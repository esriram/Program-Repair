{
    "find_first_in_sorted": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "while (hi <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:36:28.973674091 +0100\n+++ /tmp/tmpzv1mqmg6.java\t2023-03-24 20:36:29.041673785 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "while (hi <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:36:39.377627192 +0100\n+++ /tmp/tmp7fx78zrh.java\t2023-03-24 20:36:39.377627192 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "while (hi < hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:36:46.797593830 +0100\n+++ /tmp/tmpfe5v_zmq.java\t2023-03-24 20:36:46.801593813 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi < hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "while (lo <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:36:51.217573989 +0100\n+++ /tmp/tmp433car52.java\t2023-03-24 20:36:51.217573989 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (lo <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "while (hi!= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:01.281528906 +0100\n+++ /tmp/tmpp4d9xj2p.java\t2023-03-24 20:37:01.281528906 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi!= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "while (hi!= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:11.221484502 +0100\n+++ /tmp/tmpt9suelst.java\t2023-03-24 20:37:11.221484502 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi!= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "while (arr.length <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:15.173466878 +0100\n+++ /tmp/tmpgwyuih99.java\t2023-03-24 20:37:15.173466878 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (arr.length <= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "while (arr.length <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:22.089436086 +0100\n+++ /tmp/tmp1da_wf8t.java\t2023-03-24 20:37:22.089436086 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (arr.length <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "while (hi <= c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:26.189417856 +0100\n+++ /tmp/tmp1kpfyj4e.java\t2023-03-24 20:37:26.189417856 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= c) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "while (hi <= arr.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:27.973409930 +0100\n+++ /tmp/tmpk212gfze.java\t2023-03-24 20:37:27.973409930 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= arr.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "while (hi <=hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:38.057365201 +0100\n+++ /tmp/tmpud7d3o08.java\t2023-03-24 20:37:38.057365201 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "while (hi <= b) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:48.149320553 +0100\n+++ /tmp/tmpfzpv2dhw.java\t2023-03-24 20:37:48.149320553 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= b) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "while (hi <= scale) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:49.893312850 +0100\n+++ /tmp/tmpwtpee0s6.java\t2023-03-24 20:37:49.897312832 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= scale) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "while (hi <= pages.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:51.577305415 +0100\n+++ /tmp/tmpnc731r1g.java\t2023-03-24 20:37:51.577305415 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= pages.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "while (hi <= result) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:53.293297841 +0100\n+++ /tmp/tmpqrmoimk4.java\t2023-03-24 20:37:53.293297841 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= result) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "while (hi <= output) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:55.133289724 +0100\n+++ /tmp/tmphzvfn6cx.java\t2023-03-24 20:37:55.133289724 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= output) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "while (hi < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:37:56.929281803 +0100\n+++ /tmp/tmpe0dx8bl_.java\t2023-03-24 20:37:56.933281786 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi < x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "while (hi <= page) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:03.877251200 +0100\n+++ /tmp/tmpctsdz36w.java\t2023-03-24 20:38:03.881251182 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= page) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "while (hi <= Endpoint) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:05.577243719 +0100\n+++ /tmp/tmprif64rcd.java\t2023-03-24 20:38:05.581243702 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= Endpoint) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "while (hi <= 0x7F) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:07.353235909 +0100\n+++ /tmp/tmp33zxyz7d.java\t2023-03-24 20:38:07.353235909 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 0x7F) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "while ( hi <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:17.373191903 +0100\n+++ /tmp/tmp536_l075.java\t2023-03-24 20:38:17.373191903 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while ( hi <= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "while (lo < hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:24.289161591 +0100\n+++ /tmp/tmp6s0fdyqk.java\t2023-03-24 20:38:24.289161591 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (lo < hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": true
            },
            {
                "k": 23,
                "tentative_fix": "while (hi <= addressSpace.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:28.073145029 +0100\n+++ /tmp/tmpylj01ksj.java\t2023-03-24 20:38:28.073145029 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= addressSpace.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "while (hi <=27) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:29.769137610 +0100\n+++ /tmp/tmpvh8bglms.java\t2023-03-24 20:38:29.769137610 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=27) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "while (hi <=ChannelInitializer.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:39.897093368 +0100\n+++ /tmp/tmpbn8qvyws.java\t2023-03-24 20:38:39.897093368 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=ChannelInitializer.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "while (hi <= shadow) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:41.617085865 +0100\n+++ /tmp/tmp_51jd8ki.java\t2023-03-24 20:38:41.617085865 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= shadow) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "while (hi <= layer) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:43.357078278 +0100\n+++ /tmp/tmpu6ov5p98.java\t2023-03-24 20:38:43.357078278 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= layer) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "while (hi <=replaceAll) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:45.077070780 +0100\n+++ /tmp/tmpneeqfk3g.java\t2023-03-24 20:38:45.077070780 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=replaceAll) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "while (hi <= str) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:46.829063147 +0100\n+++ /tmp/tmpmjr8irp6.java\t2023-03-24 20:38:46.829063147 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= str) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "while (hi <= element) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:48.537055709 +0100\n+++ /tmp/tmpf0pciw4u.java\t2023-03-24 20:38:48.537055709 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= element) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "while (hi <= ch) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:50.361047768 +0100\n+++ /tmp/tmpf3f2vaaf.java\t2023-03-24 20:38:50.361047768 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= ch) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "while (am <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:52.041040455 +0100\n+++ /tmp/tmpudfisz6y.java\t2023-03-24 20:38:52.041040455 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (am <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "while (hi <= hi.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:53.769032938 +0100\n+++ /tmp/tmpz47_g07e.java\t2023-03-24 20:38:53.769032938 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= hi.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "while (hi <= track) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:55.445025651 +0100\n+++ /tmp/tmptfmar0ug.java\t2023-03-24 20:38:55.449025633 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= track) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "while (hi!= c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:57.165018174 +0100\n+++ /tmp/tmp4oq5syl6.java\t2023-03-24 20:38:57.165018174 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi!= c) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "while (hi <= this) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:38:58.889010683 +0100\n+++ /tmp/tmpptzpdnv8.java\t2023-03-24 20:38:58.889010683 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= this) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "while (hi <= 10) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:00.533003543 +0100\n+++ /tmp/tmp02_7iabo.java\t2023-03-24 20:39:00.533003543 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 10) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "while (hi <= 1.0f) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:10.508960269 +0100\n+++ /tmp/tmp4fwbskit.java\t2023-03-24 20:39:10.508960269 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 1.0f) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "while (hi <= X) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:14.520942892 +0100\n+++ /tmp/tmpga_qyh8i.java\t2023-03-24 20:39:14.524942877 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= X) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "while (hi <=print) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:16.288935241 +0100\n+++ /tmp/tmpc2vcsmbm.java\t2023-03-24 20:39:16.288935241 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=print) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "while (width <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:18.064927557 +0100\n+++ /tmp/tmp1uv30vy1.java\t2023-03-24 20:39:18.064927557 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (width <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "while (hi <= d) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:19.724920377 +0100\n+++ /tmp/tmperxkny7k.java\t2023-03-24 20:39:19.724920377 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= d) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "while (hi <= string) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:21.820911314 +0100\n+++ /tmp/tmpv5nhmlxo.java\t2023-03-24 20:39:21.820911314 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= string) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "while (hi <= 99) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:23.516903985 +0100\n+++ /tmp/tmpuvcllq78.java\t2023-03-24 20:39:23.516903985 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 99) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "while (zero <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:33.632860325 +0100\n+++ /tmp/tmpncvb9ms3.java\t2023-03-24 20:39:33.632860325 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (zero <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "while (hi <=range) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:35.296853152 +0100\n+++ /tmp/tmp2qydrqkh.java\t2023-03-24 20:39:35.296853152 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=range) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "while (ready <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:37.068845516 +0100\n+++ /tmp/tmpz5brru0i.java\t2023-03-24 20:39:37.068845516 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (ready <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "while ( hi!= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:38.844837866 +0100\n+++ /tmp/tmpinoovzhh.java\t2023-03-24 20:39:38.848837849 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while ( hi!= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "while (hi <=(10) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:48.828794912 +0100\n+++ /tmp/tmpk9tvdsdw.java\t2023-03-24 20:39:48.828794912 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=(10) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "while (hi <= high) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:50.400788159 +0100\n+++ /tmp/tmp7p410oh_.java\t2023-03-24 20:39:50.400788159 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= high) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "while (hi <= bits) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:52.124780752 +0100\n+++ /tmp/tmpu8hfqtjb.java\t2023-03-24 20:39:52.124780752 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= bits) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "while (hi <= lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:53.948772921 +0100\n+++ /tmp/tmpbhoz6r1t.java\t2023-03-24 20:39:53.948772921 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "while (hi <= '&') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:39:57.884756031 +0100\n+++ /tmp/tmpts9hui3_.java\t2023-03-24 20:39:57.888756013 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= '&') {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "while (hi <=Color) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:07.840713364 +0100\n+++ /tmp/tmpd4foxv9y.java\t2023-03-24 20:40:07.844713346 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=Color) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "while (hi <=lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:09.628705711 +0100\n+++ /tmp/tmp6f95mbgn.java\t2023-03-24 20:40:09.632705693 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "while (hi > hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:13.672688411 +0100\n+++ /tmp/tmpw169isu3.java\t2023-03-24 20:40:13.672688411 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi > hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "while (hi <= i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:17.756670954 +0100\n+++ /tmp/tmpj9lnq92e.java\t2023-03-24 20:40:17.760670935 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= i) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "while (acc <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:19.468663641 +0100\n+++ /tmp/tmpd2l8j4uk.java\t2023-03-24 20:40:19.468663641 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (acc <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "while (hi <=Recursive) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:21.216656175 +0100\n+++ /tmp/tmpcahq7x03.java\t2023-03-24 20:40:21.220656158 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=Recursive) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "while (binding <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:22.972648678 +0100\n+++ /tmp/tmpza4xkk31.java\t2023-03-24 20:40:22.972648678 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (binding <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "while (hi <=Handler) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:24.684641372 +0100\n+++ /tmp/tmpna0uts78.java\t2023-03-24 20:40:24.684641372 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=Handler) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "while (offset <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:26.412634000 +0100\n+++ /tmp/tmp5n_bw_dk.java\t2023-03-24 20:40:26.412634000 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (offset <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "while (hi <= types) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:28.160626545 +0100\n+++ /tmp/tmp9aezngn5.java\t2023-03-24 20:40:28.160626545 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= types) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "while (offset < hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:29.884619195 +0100\n+++ /tmp/tmps9llc8ps.java\t2023-03-24 20:40:29.884619195 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (offset < hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "while (hi <= 13) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:31.672611573 +0100\n+++ /tmp/tmp0jmjjxw8.java\t2023-03-24 20:40:31.672611573 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 13) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "while (hi <=Layer) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:41.672569001 +0100\n+++ /tmp/tmpxghhsbyj.java\t2023-03-24 20:40:41.676568986 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=Layer) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "while (hi <= predicate) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:43.368561790 +0100\n+++ /tmp/tmp_7ucm20l.java\t2023-03-24 20:40:43.368561790 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= predicate) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "while (exp <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:45.084554495 +0100\n+++ /tmp/tmpdg6j9hfp.java\t2023-03-24 20:40:45.084554495 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (exp <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "while (hi >= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:46.836547049 +0100\n+++ /tmp/tmpkbj85893.java\t2023-03-24 20:40:46.836547049 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi >= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "while (+1 < hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:50.996529380 +0100\n+++ /tmp/tmprmao3nxv.java\t2023-03-24 20:40:50.996529380 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (+1 < hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "while (x < hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:40:57.984499730 +0100\n+++ /tmp/tmpg4ui_7hu.java\t2023-03-24 20:40:57.984499730 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (x < hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "while (hi <= <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:01.948482927 +0100\n+++ /tmp/tmpk513f686.java\t2023-03-24 20:41:01.948482927 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "while (hi <=channel) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:03.644475742 +0100\n+++ /tmp/tmp2uxij_g0.java\t2023-03-24 20:41:03.644475742 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=channel) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "while (warning <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:05.260468897 +0100\n+++ /tmp/tmpl1bih10v.java\t2023-03-24 20:41:05.260468897 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (warning <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "while (hi <=flex) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:06.948461748 +0100\n+++ /tmp/tmpv38bxug5.java\t2023-03-24 20:41:06.948461748 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=flex) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "while (hi <= 0f) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:08.624454655 +0100\n+++ /tmp/tmpe6xcn5en.java\t2023-03-24 20:41:08.624454655 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 0f) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "while (hi <= offset) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:12.744437225 +0100\n+++ /tmp/tmpyk369zps.java\t2023-03-24 20:41:12.772437105 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= offset) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "while (hi <=Controls) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:14.504429783 +0100\n+++ /tmp/tmplvuaz8we.java\t2023-03-24 20:41:14.504429783 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=Controls) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "while (hi <= y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:16.312422141 +0100\n+++ /tmp/tmpcvhur3sh.java\t2023-03-24 20:41:16.312422141 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= y) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "while (hi <= serCount) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:18.088414636 +0100\n+++ /tmp/tmpd8blcb7i.java\t2023-03-24 20:41:18.088414636 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= serCount) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "while (hi <= acc) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:19.916406913 +0100\n+++ /tmp/tmplygn6q_w.java\t2023-03-24 20:41:19.916406913 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= acc) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "while (x <= hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:21.704399362 +0100\n+++ /tmp/tmpli11g5ge.java\t2023-03-24 20:41:21.704399362 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (x <= hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "while (hi instanceof hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:25.700382494 +0100\n+++ /tmp/tmptjb43je_.java\t2023-03-24 20:41:25.700382494 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi instanceof hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "while (hi <= scheme) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:27.404375307 +0100\n+++ /tmp/tmpqg8go6ey.java\t2023-03-24 20:41:27.404375307 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= scheme) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "while (hi <= 0x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:29.004368558 +0100\n+++ /tmp/tmp_1se7jl1.java\t2023-03-24 20:41:29.004368558 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 0x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "while (short i = hi.length;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:30.552362030 +0100\n+++ /tmp/tmpf8jill54.java\t2023-03-24 20:41:30.552362030 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (short i = hi.length;\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "while (hi <= repair) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:32.192355117 +0100\n+++ /tmp/tmpau_eh5n7.java\t2023-03-24 20:41:32.236354931 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= repair) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "while (hi <= full) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:33.992347531 +0100\n+++ /tmp/tmp0odkldm3.java\t2023-03-24 20:41:33.992347531 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= full) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "while (hi <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:35.736340186 +0100\n+++ /tmp/tmpjzigu0y5.java\t2023-03-24 20:41:35.736340186 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "while (hi <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:39.880322737 +0100\n+++ /tmp/tmpow162edt.java\t2023-03-24 20:41:39.880322737 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "while (hi <= memoized) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:43.872305937 +0100\n+++ /tmp/tmp4ieev8im.java\t2023-03-24 20:41:43.872305937 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= memoized) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "while (hi <= host) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:45.636298521 +0100\n+++ /tmp/tmpr35_s88h.java\t2023-03-24 20:41:45.640298503 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= host) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "while (hi <= ser) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:47.384291169 +0100\n+++ /tmp/tmpp05y6k1q.java\t2023-03-24 20:41:47.388291154 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= ser) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "while (hi <= hi) { // prefix",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:49.056284143 +0100\n+++ /tmp/tmpxjq_f1z6.java\t2023-03-24 20:41:49.056284143 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= hi) { // prefix\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "while (hi <= hi) { // add element",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:41:58.880242887 +0100\n+++ /tmp/tmpxqvd_3cb.java\t2023-03-24 20:41:58.880242887 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= hi) { // add element\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "while (hi <= hi) { // prefix byte",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:42:09.172199739 +0100\n+++ /tmp/tmpssp_unbr.java\t2023-03-24 20:42:09.172199739 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= hi) { // prefix byte\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "while (hi <=collect(lo)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:42:19.204157752 +0100\n+++ /tmp/tmprcq3j3sr.java\t2023-03-24 20:42:19.208157735 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <=collect(lo)) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "while (short i = hi.length - 3;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:42:20.892150691 +0100\n+++ /tmp/tmplm3t_3wv.java\t2023-03-24 20:42:20.892150691 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (short i = hi.length - 3;\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "while (hi <= hi) { // not supported",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:42:22.516143904 +0100\n+++ /tmp/tmp7i5oavej.java\t2023-03-24 20:42:22.520143886 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= hi) { // not supported\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "while (hi <= x) { // prefix",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 20:42:32.604101770 +0100\n+++ /tmp/tmpgut68dmm.java\t2023-03-24 20:42:32.604101770 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+while (hi <= x) { // prefix\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "while (lo < hi) {"
    },
    "to_base": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alphab.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:30.973665063 +0100\n+++ /tmp/tmp3xtrgb05.java\t2023-03-24 20:36:30.973665063 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alphab.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al speech.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:32.901656367 +0100\n+++ /tmp/tmp4baxipkd.java\t2023-03-24 20:36:32.901656367 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al speech.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alractice.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:34.561648883 +0100\n+++ /tmp/tmpuw483tnj.java\t2023-03-24 20:36:34.561648883 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alractice.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al newArray.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:36.137641782 +0100\n+++ /tmp/tmpd51ywu1m.java\t2023-03-24 20:36:36.141641764 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al newArray.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alphab.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:37.729634613 +0100\n+++ /tmp/tmpacb4yeoc.java\t2023-03-24 20:36:37.729634613 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alphab.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Article.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:39.325627427 +0100\n+++ /tmp/tmpecq49t5c.java\t2023-03-24 20:36:39.325627427 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Article.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alFox.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:41.093619470 +0100\n+++ /tmp/tmpl5o4o5sa.java\t2023-03-24 20:36:41.093619470 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alFox.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alMessageCount.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:43.053610654 +0100\n+++ /tmp/tmpj52xdwyw.java\t2023-03-24 20:36:43.053610654 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alMessageCount.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al newArray.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:44.749603031 +0100\n+++ /tmp/tmpkb2l2vvx.java\t2023-03-24 20:36:44.753603013 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al newArray.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alInventory.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:46.249596293 +0100\n+++ /tmp/tmpc_8vwmcx.java\t2023-03-24 20:36:46.253596273 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alInventory.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alrial.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:47.941588691 +0100\n+++ /tmp/tmprubzysgk.java\t2023-03-24 20:36:47.941588691 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alrial.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alphab.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:49.765580506 +0100\n+++ /tmp/tmppktzuzlq.java\t2023-03-24 20:36:49.765580506 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alphab.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alDensity.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:51.541572537 +0100\n+++ /tmp/tmp7ui1qyip.java\t2023-03-24 20:36:51.541572537 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alDensity.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al lru.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:53.273564769 +0100\n+++ /tmp/tmpfgr38qha.java\t2023-03-24 20:36:53.273564769 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al lru.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al arn.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:55.073556701 +0100\n+++ /tmp/tmpyp7oz_54.java\t2023-03-24 20:36:55.073556701 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al arn.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alractice.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:56.605549838 +0100\n+++ /tmp/tmpl295wqzo.java\t2023-03-24 20:36:56.605549838 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alractice.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alBitmap.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:57.961543766 +0100\n+++ /tmp/tmpevjopmfh.java\t2023-03-24 20:36:57.961543766 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alBitmap.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al newArray.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:36:59.473536995 +0100\n+++ /tmp/tmpggsk0g04.java\t2023-03-24 20:36:59.477536978 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al newArray.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alsecs.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:00.917530534 +0100\n+++ /tmp/tmp_jscgv6o.java\t2023-03-24 20:37:00.921530516 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alsecs.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al 900.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:02.573523128 +0100\n+++ /tmp/tmp15vr688w.java\t2023-03-24 20:37:02.573523128 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al 900.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al speech.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:04.237515688 +0100\n+++ /tmp/tmp2vs61goi.java\t2023-03-24 20:37:04.237515688 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al speech.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al collation.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:05.817508627 +0100\n+++ /tmp/tmpvmk_0dwt.java\t2023-03-24 20:37:05.821508611 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al collation.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al father.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:07.233502301 +0100\n+++ /tmp/tmpsdu_x0xv.java\t2023-03-24 20:37:07.233502301 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al father.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al conjunction.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:08.617496122 +0100\n+++ /tmp/tmpqiflruo3.java\t2023-03-24 20:37:08.617496122 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al conjunction.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alTerminated.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:10.037489783 +0100\n+++ /tmp/tmpx77pphlk.java\t2023-03-24 20:37:10.037489783 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alTerminated.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alractice.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:11.445483500 +0100\n+++ /tmp/tmpp2ta9hso.java\t2023-03-24 20:37:11.445483500 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alractice.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Formatter.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:13.205475651 +0100\n+++ /tmp/tmpfmxoyj5u.java\t2023-03-24 20:37:13.205475651 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Formatter.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alTypeCode.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:14.965467805 +0100\n+++ /tmp/tmp8n6a2jqg.java\t2023-03-24 20:37:14.965467805 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alTypeCode.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alCurve.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:16.713460017 +0100\n+++ /tmp/tmp4f_gz3qe.java\t2023-03-24 20:37:16.713460017 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alCurve.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al speech.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:18.473452178 +0100\n+++ /tmp/tmp1_jr4_9d.java\t2023-03-24 20:37:18.473452178 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al speech.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Product.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:19.929445696 +0100\n+++ /tmp/tmpo2e234_n.java\t2023-03-24 20:37:19.929445696 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Product.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alOw.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:21.353439359 +0100\n+++ /tmp/tmpou_lfx4e.java\t2023-03-24 20:37:21.353439359 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alOw.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alpeech.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:22.941432295 +0100\n+++ /tmp/tmpvhfq4d18.java\t2023-03-24 20:37:22.945432277 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alpeech.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alartist.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:24.665424630 +0100\n+++ /tmp/tmpxd2b_shs.java\t2023-03-24 20:37:24.669424612 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alartist.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alRetrieve.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:26.393416950 +0100\n+++ /tmp/tmp12dh_d3w.java\t2023-03-24 20:37:26.397416934 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alRetrieve.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alslow.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:28.069409504 +0100\n+++ /tmp/tmpslgh5th5.java\t2023-03-24 20:37:28.069409504 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alslow.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Legacy.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:29.773401940 +0100\n+++ /tmp/tmpernln2xd.java\t2023-03-24 20:37:29.773401940 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Legacy.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alPriv.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:31.469394411 +0100\n+++ /tmp/tmp9gvmck08.java\t2023-03-24 20:37:31.469394411 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alPriv.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alractice.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:33.089387224 +0100\n+++ /tmp/tmpio62wn2v.java\t2023-03-24 20:37:33.089387224 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alractice.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Styled.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:34.517380891 +0100\n+++ /tmp/tmp6byw6dur.java\t2023-03-24 20:37:34.517380891 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Styled.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alphab.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:35.901374755 +0100\n+++ /tmp/tmp9qgk__xr.java\t2023-03-24 20:37:35.901374755 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alphab.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Video.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:37.357368303 +0100\n+++ /tmp/tmpyqoecuq3.java\t2023-03-24 20:37:37.357368303 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Video.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alSearcher.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:38.889361518 +0100\n+++ /tmp/tmpxsll_uhm.java\t2023-03-24 20:37:38.889361518 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alSearcher.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al speech.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:40.533354238 +0100\n+++ /tmp/tmp66hho7dt.java\t2023-03-24 20:37:40.533354238 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al speech.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alening.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:42.213346801 +0100\n+++ /tmp/tmpxgn6pahz.java\t2023-03-24 20:37:42.217346783 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alening.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alWO.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:43.601340660 +0100\n+++ /tmp/tmpdr87tom6.java\t2023-03-24 20:37:43.605340643 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alWO.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al callee.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:45.057334220 +0100\n+++ /tmp/tmpbhc80w4r.java\t2023-03-24 20:37:45.057334220 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al callee.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al flatMap.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:46.629327272 +0100\n+++ /tmp/tmp9k98n_8i.java\t2023-03-24 20:37:46.629327272 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al flatMap.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alLC.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:48.049320998 +0100\n+++ /tmp/tmpcg41rzux.java\t2023-03-24 20:37:48.049320998 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alLC.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al shuffled.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:49.821313169 +0100\n+++ /tmp/tmpo9r3ejg1.java\t2023-03-24 20:37:49.821313169 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al shuffled.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alphabet.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:51.461305926 +0100\n+++ /tmp/tmp1qvalgb1.java\t2023-03-24 20:37:51.461305926 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alphabet.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al hole.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:55.445288348 +0100\n+++ /tmp/tmp5zhhi_80.java\t2023-03-24 20:37:55.445288348 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al hole.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alFox.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:57.041281311 +0100\n+++ /tmp/tmp8ca64_yu.java\t2023-03-24 20:37:57.041281311 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alFox.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Repeat.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:37:58.693274030 +0100\n+++ /tmp/tmp101cymam.java\t2023-03-24 20:37:58.693274030 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Repeat.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alphab.charAt(i)); } else { i = num / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:00.345266750 +0100\n+++ /tmp/tmp977mrud7.java\t2023-03-24 20:38:00.345266750 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alphab.charAt(i)); } else { i = num / b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al 900.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:01.945259704 +0100\n+++ /tmp/tmp69vvy4tx.java\t2023-03-24 20:38:01.949259687 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al 900.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al newArray.charAt(i)); } else { i = num / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:03.369253436 +0100\n+++ /tmp/tmpkp63nal0.java\t2023-03-24 20:38:03.369253436 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al newArray.charAt(i)); } else { i = num / b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al 900.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:04.901246693 +0100\n+++ /tmp/tmpxb00paw2.java\t2023-03-24 20:38:04.901246693 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al 900.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al newArray.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:06.585239286 +0100\n+++ /tmp/tmp2f2cf89_.java\t2023-03-24 20:38:06.585239286 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al newArray.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alInventory.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:08.221232092 +0100\n+++ /tmp/tmpeyygrg3p.java\t2023-03-24 20:38:08.221232092 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alInventory.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alDensity.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:10.037224111 +0100\n+++ /tmp/tmp05wmfody.java\t2023-03-24 20:38:10.037224111 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alDensity.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Article.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:11.725216695 +0100\n+++ /tmp/tmpntqexsl6.java\t2023-03-24 20:38:11.765216518 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Article.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alrial.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:13.121210563 +0100\n+++ /tmp/tmp2x0h0cmw.java\t2023-03-24 20:38:13.121210563 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alrial.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alFox.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:14.645203873 +0100\n+++ /tmp/tmpsv0yaygs.java\t2023-03-24 20:38:14.645203873 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alFox.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alMessageCount.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:16.121197395 +0100\n+++ /tmp/tmptus2cpz5.java\t2023-03-24 20:38:16.121197395 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alMessageCount.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alrial.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:17.605190885 +0100\n+++ /tmp/tmpeipuh97p.java\t2023-03-24 20:38:17.609190867 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alrial.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alDensity.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:19.293183481 +0100\n+++ /tmp/tmphlhgbd6o.java\t2023-03-24 20:38:19.297183464 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alDensity.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(alractice.charAt(i)); } else { i = num / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:21.093175592 +0100\n+++ /tmp/tmpcte_emne.java\t2023-03-24 20:38:21.093175592 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(alractice.charAt(i)); } else { i = num / b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alMessageCount.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:22.517169352 +0100\n+++ /tmp/tmpj2qy8oqp.java\t2023-03-24 20:38:22.517169352 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alMessageCount.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al speech.charAt(i)); } else { i = num / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:23.973162976 +0100\n+++ /tmp/tmpoe6gnqyp.java\t2023-03-24 20:38:23.973162976 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al speech.charAt(i)); } else { i = num / b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alInventory.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:25.517156215 +0100\n+++ /tmp/tmpz07ytqiw.java\t2023-03-24 20:38:25.517156215 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alInventory.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(al Product.charAt(i)); } else { i = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:27.293148442 +0100\n+++ /tmp/tmp8b65j11u.java\t2023-03-24 20:38:27.297148425 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(al Product.charAt(i)); } else { i = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alMessageCount.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:29.041140793 +0100\n+++ /tmp/tmp9znfbtb_.java\t2023-03-24 20:38:29.041140793 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alMessageCount.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al Article.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:30.773133220 +0100\n+++ /tmp/tmp_y6apyo2.java\t2023-03-24 20:38:30.773133220 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al Article.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alrial.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:32.389126155 +0100\n+++ /tmp/tmpjhigk0o_.java\t2023-03-24 20:38:32.421126015 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alrial.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alFox.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:34.181118324 +0100\n+++ /tmp/tmpwznc3nh7.java\t2023-03-24 20:38:34.181118324 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alFox.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alDensity.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:35.605112103 +0100\n+++ /tmp/tmpexn9r9da.java\t2023-03-24 20:38:35.605112103 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alDensity.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al lru.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:37.061105746 +0100\n+++ /tmp/tmpz1ygbydr.java\t2023-03-24 20:38:37.061105746 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al lru.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alInventory.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:38.453099669 +0100\n+++ /tmp/tmp_lgvlf2e.java\t2023-03-24 20:38:38.453099669 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alInventory.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al 900.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:40.017092844 +0100\n+++ /tmp/tmpv4m60485.java\t2023-03-24 20:38:40.021092827 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al 900.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alsecs.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:41.673085620 +0100\n+++ /tmp/tmp598kldtw.java\t2023-03-24 20:38:41.673085620 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alsecs.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alBitmap.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:43.385078155 +0100\n+++ /tmp/tmpiz6xa9hy.java\t2023-03-24 20:38:43.385078155 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alBitmap.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al arn.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:45.121070589 +0100\n+++ /tmp/tmpwyrknvcn.java\t2023-03-24 20:38:45.121070589 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al arn.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alCurve.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:46.781063356 +0100\n+++ /tmp/tmpqlifujqz.java\t2023-03-24 20:38:46.781063356 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alCurve.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alTerminated.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:48.485055935 +0100\n+++ /tmp/tmpn7aze2_q.java\t2023-03-24 20:38:48.485055935 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alTerminated.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al collation.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:50.257048220 +0100\n+++ /tmp/tmpvfoeozhq.java\t2023-03-24 20:38:50.257048220 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al collation.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alpeech.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:51.933040924 +0100\n+++ /tmp/tmp_z4_ipkz.java\t2023-03-24 20:38:51.933040924 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alpeech.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al Formatter.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:53.601033669 +0100\n+++ /tmp/tmp9n6i4khj.java\t2023-03-24 20:38:53.601033669 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al Formatter.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alTypeCode.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:55.341026103 +0100\n+++ /tmp/tmpb3qortg7.java\t2023-03-24 20:38:55.341026103 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alTypeCode.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al conjunction.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:57.049018679 +0100\n+++ /tmp/tmpg1awjlhp.java\t2023-03-24 20:38:57.049018679 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al conjunction.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al Product.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:38:58.701011500 +0100\n+++ /tmp/tmp176tlmby.java\t2023-03-24 20:38:58.705011482 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al Product.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al father.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:00.349004342 +0100\n+++ /tmp/tmp_kfrzzmk.java\t2023-03-24 20:39:00.349004342 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al father.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alOw.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:01.964997326 +0100\n+++ /tmp/tmph2_9hmuo.java\t2023-03-24 20:39:01.964997326 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alOw.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alLC.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:03.780989443 +0100\n+++ /tmp/tmp4uslp71t.java\t2023-03-24 20:39:03.780989443 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alLC.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alartist.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:05.348982641 +0100\n+++ /tmp/tmphucne4j_.java\t2023-03-24 20:39:05.348982641 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alartist.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(al Legacy.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:06.804976326 +0100\n+++ /tmp/tmpwk4dhxh3.java\t2023-03-24 20:39:06.804976326 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(al Legacy.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(alPriv.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:08.212970221 +0100\n+++ /tmp/tmpn1s6q48o.java\t2023-03-24 20:39:08.216970204 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(alPriv.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (i >= 0) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:09.648963996 +0100\n+++ /tmp/tmp08ht3k4n.java\t2023-03-24 20:39:09.648963996 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { break; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "}",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:13.484947377 +0100\n+++ /tmp/tmpg68hfdl4.java\t2023-03-24 20:39:13.484947377 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+}\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 20:39:15.140940210 +0100\n+++ /tmp/tmpbtkw3d6b.java\t2023-03-24 20:39:15.140940210 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "result = String.valueOf(alphabet.charAt(i))+result;"
    },
    "knapsack": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "else if (rows == 2 || j == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:21.636912110 +0100\n+++ /tmp/tmplfi4xcqi.java\t2023-03-24 20:39:21.676911939 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || j == 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "else if (numTypesValid == NR_UNKNOWN) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:23.500904056 +0100\n+++ /tmp/tmpokhkz5_c.java\t2023-03-24 20:39:23.504904038 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == NR_UNKNOWN) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "else if (isWeighted && j < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:25.308896244 +0100\n+++ /tmp/tmptmwhp0_3.java\t2023-03-24 20:39:25.308896244 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (isWeighted && j < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "else if (getStateChangeInformer()!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:27.128888386 +0100\n+++ /tmp/tmpawsgge_b.java\t2023-03-24 20:39:27.132888369 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (getStateChangeInformer()!= null) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "else if (j < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:28.712881549 +0100\n+++ /tmp/tmp7kjy_aar.java\t2023-03-24 20:39:28.712881549 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "else if (columns == j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:32.356865827 +0100\n+++ /tmp/tmpw5ytds4n.java\t2023-03-24 20:39:32.356865827 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (columns == j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "else if (rows == j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:33.864859325 +0100\n+++ /tmp/tmpfdfdffwz.java\t2023-03-24 20:39:33.864859325 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "else if (rows == 1 || j == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:35.608851808 +0100\n+++ /tmp/tmpjo39u945.java\t2023-03-24 20:39:35.608851808 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j == 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "else if (rows < 0 || columns < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:37.292844550 +0100\n+++ /tmp/tmp2hjjvggh.java\t2023-03-24 20:39:37.292844550 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 0 || columns < 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "else if (rows < 0 || j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:39.056836954 +0100\n+++ /tmp/tmpind4vhmc.java\t2023-03-24 20:39:39.060836936 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 0 || j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "else if (isWeighted && j < weight) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:40.808829411 +0100\n+++ /tmp/tmpdc2wl8up.java\t2023-03-24 20:39:40.808829411 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (isWeighted && j < weight) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "else if (isWeighted) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:42.528822008 +0100\n+++ /tmp/tmp7wbyc6x4.java\t2023-03-24 20:39:42.528822008 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (isWeighted) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "else if (numTypesValid == 0 || j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:44.068815381 +0100\n+++ /tmp/tmpx21qvl4w.java\t2023-03-24 20:39:44.068815381 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == 0 || j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "else if (description < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:45.632808652 +0100\n+++ /tmp/tmpl9oh2oxw.java\t2023-03-24 20:39:45.636808638 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (description < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "else if (cols.length < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:47.124802239 +0100\n+++ /tmp/tmpdah_m1hy.java\t2023-03-24 20:39:47.124802239 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cols.length < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "else if (Quote[i][j] == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:48.628795774 +0100\n+++ /tmp/tmp2ps_jcm4.java\t2023-03-24 20:39:48.628795774 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (Quote[i][j] == 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "else if (j < capacity && j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:50.340788416 +0100\n+++ /tmp/tmpbj7whvfs.java\t2023-03-24 20:39:50.340788416 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "else if (loops[i][j] == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:54.436770827 +0100\n+++ /tmp/tmpeihoe9qa.java\t2023-03-24 20:39:54.440770810 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (loops[i][j] == 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "else if (j < matrix.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:56.336762671 +0100\n+++ /tmp/tmplpr4p7ab.java\t2023-03-24 20:39:56.336762671 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < matrix.length) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "else if (Quote[i][j]!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:58.088755155 +0100\n+++ /tmp/tmpie30x4l6.java\t2023-03-24 20:39:58.088755155 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (Quote[i][j]!= 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "else if (rows < 0 || j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:39:59.764747968 +0100\n+++ /tmp/tmpj4uafumt.java\t2023-03-24 20:39:59.764747968 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 0 || j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "else if (o == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:01.524740421 +0100\n+++ /tmp/tmplfwxcck8.java\t2023-03-24 20:40:01.528740404 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (o == 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "else if (cols.length < 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:03.052733872 +0100\n+++ /tmp/tmpc_0sep6m.java\t2023-03-24 20:40:03.052733872 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cols.length < 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "else if (numTypesValid == 0 || j == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:04.520727582 +0100\n+++ /tmp/tmpos20aufq.java\t2023-03-24 20:40:04.520727582 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == 0 || j == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "else if (loops[i][j]!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:06.000721243 +0100\n+++ /tmp/tmpuvp939xw.java\t2023-03-24 20:40:06.000721243 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (loops[i][j]!= 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "else if (j < Double.MIN_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:07.544714630 +0100\n+++ /tmp/tmpnlc2zvrz.java\t2023-03-24 20:40:07.544714630 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < Double.MIN_VALUE) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "else if (rows < 1 || j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:11.904695973 +0100\n+++ /tmp/tmpjzc5wyak.java\t2023-03-24 20:40:11.904695973 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 1 || j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "else if (j < capacity && j % 2 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:13.664688443 +0100\n+++ /tmp/tmpg2t1t_nz.java\t2023-03-24 20:40:13.664688443 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j % 2 == 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "else if (partial[j] == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:17.920670253 +0100\n+++ /tmp/tmp90ennu0o.java\t2023-03-24 20:40:17.920670253 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (partial[j] == 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "else if (columns < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:19.596663094 +0100\n+++ /tmp/tmplfcrml1s.java\t2023-03-24 20:40:19.600663076 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (columns < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "else if (rows < 0 || columns > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:21.376655492 +0100\n+++ /tmp/tmp2y4vrm0r.java\t2023-03-24 20:40:21.376655492 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 0 || columns > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "else if (rows == 1 || j == 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:23.132647994 +0100\n+++ /tmp/tmp0hjict33.java\t2023-03-24 20:40:23.132647994 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j == 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "else if (numTypesValid == 0 && j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:24.744641116 +0100\n+++ /tmp/tmpe10dammn.java\t2023-03-24 20:40:24.744641116 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == 0 && j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "else if (rows == 2 ||rows == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:26.508633589 +0100\n+++ /tmp/tmp61efwj6q.java\t2023-03-24 20:40:26.508633589 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 ||rows == 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "else if (rows < 0 || columns - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:28.228626256 +0100\n+++ /tmp/tmpm29g1ezb.java\t2023-03-24 20:40:28.228626256 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 0 || columns - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "else if (rows == 1 || j == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:29.892619159 +0100\n+++ /tmp/tmp00sk_ui7.java\t2023-03-24 20:40:29.892619159 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "else if (rows == 2 || j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:31.604611865 +0100\n+++ /tmp/tmp06qwdhz_.java\t2023-03-24 20:40:31.604611865 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "else if (rows == 2 || columns == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:33.392604247 +0100\n+++ /tmp/tmpd8jejmcv.java\t2023-03-24 20:40:33.392604247 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || columns == 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "else if (j < 0 || j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:35.148596767 +0100\n+++ /tmp/tmpoqk_t4y1.java\t2023-03-24 20:40:35.148596767 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < 0 || j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "else if (rows == 2 || type == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:38.872580912 +0100\n+++ /tmp/tmpnstaxzik.java\t2023-03-24 20:40:38.872580912 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || type == 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "else if (numTypesValid == 0 && j == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:40.428574294 +0100\n+++ /tmp/tmpt433zfch.java\t2023-03-24 20:40:40.428574294 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == 0 && j == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "else if (cardinality - j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:41.924567931 +0100\n+++ /tmp/tmpvavwt5xl.java\t2023-03-24 20:40:41.924567931 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cardinality - j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "else if (rows == 2 || i == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:43.664560530 +0100\n+++ /tmp/tmpt679ndro.java\t2023-03-24 20:40:43.668560515 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || i == 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "else if (j < n - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:45.412553099 +0100\n+++ /tmp/tmpdad8ipl2.java\t2023-03-24 20:40:45.412553099 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < n - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "else if (weight < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:49.568535444 +0100\n+++ /tmp/tmp2b0smbg_.java\t2023-03-24 20:40:49.568535444 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (weight < 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "else if (partial[i - 1][j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:54.028516510 +0100\n+++ /tmp/tmp5sa020sc.java\t2023-03-24 20:40:54.028516510 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (partial[i - 1][j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "else if (rows == 1 || i == j - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:55.608509807 +0100\n+++ /tmp/tmptgmk97hs.java\t2023-03-24 20:40:55.608509807 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || i == j - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "else if (numTypesValid == 0 && j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:57.064503631 +0100\n+++ /tmp/tmptmy2pqkx.java\t2023-03-24 20:40:57.064503631 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == 0 && j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "else if (rows == 1 || j == 5) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:40:58.616497049 +0100\n+++ /tmp/tmpfq0vnk9u.java\t2023-03-24 20:40:58.620497031 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j == 5) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "else if (weight < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:00.372489604 +0100\n+++ /tmp/tmp5_o8501w.java\t2023-03-24 20:41:00.372489604 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (weight < j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "else if (cardinality - 1 < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:04.876470523 +0100\n+++ /tmp/tmpa5jo35qh.java\t2023-03-24 20:41:04.876470523 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cardinality - 1 < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "else if (false) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:06.628463105 +0100\n+++ /tmp/tmp9bf9lof_.java\t2023-03-24 20:41:06.632463087 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (false) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "else if (Quote[i - 1][j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:11.068444313 +0100\n+++ /tmp/tmpgm2snbuk.java\t2023-03-24 20:41:11.068444313 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (Quote[i - 1][j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "else if (o < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:12.800436989 +0100\n+++ /tmp/tmp7wn_6bhv.java\t2023-03-24 20:41:12.804436971 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (o < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "else if (comparator == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:14.516429732 +0100\n+++ /tmp/tmp3sy_5lo8.java\t2023-03-24 20:41:14.516429732 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (comparator == null) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "else if (numTypesValid == 0 || j == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:16.352421970 +0100\n+++ /tmp/tmpue7xg61q.java\t2023-03-24 20:41:16.356421955 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == 0 || j == 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "else if (rows == 2 ||columns == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:18.088414636 +0100\n+++ /tmp/tmpc2vayn1d.java\t2023-03-24 20:41:18.088414636 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 ||columns == 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "else if (rows == 0 || j == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:19.880407066 +0100\n+++ /tmp/tmpv54sm150.java\t2023-03-24 20:41:19.880407066 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 0 || j == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "else if (j < 0 || j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:21.672399496 +0100\n+++ /tmp/tmp9zzsjj83.java\t2023-03-24 20:41:21.672399496 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < 0 || j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "else if (rows < 0 || columns == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:23.384392271 +0100\n+++ /tmp/tmpqbds2ftw.java\t2023-03-24 20:41:23.388392253 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 0 || columns == 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "else if (rows == 2 || j == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:25.104385011 +0100\n+++ /tmp/tmpm6y21b0h.java\t2023-03-24 20:41:25.104385011 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || j == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "else if (extending - 1][j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:26.828377737 +0100\n+++ /tmp/tmpgyyjyb7f.java\t2023-03-24 20:41:26.828377737 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (extending - 1][j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "else if (rows == 1 || j == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:28.588370311 +0100\n+++ /tmp/tmp8lsjcksy.java\t2023-03-24 20:41:28.592370296 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j == i) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "else if (rows == 2 || capacity == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:30.352362875 +0100\n+++ /tmp/tmp5y7mux_g.java\t2023-03-24 20:41:30.352362875 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || capacity == 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "else if (size > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:32.156355270 +0100\n+++ /tmp/tmpypooqmtn.java\t2023-03-24 20:41:32.168355219 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (size > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "else if (columns < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:33.928347801 +0100\n+++ /tmp/tmpwkfntwj6.java\t2023-03-24 20:41:33.928347801 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (columns < j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "else if (rows == 1 || j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:35.720340252 +0100\n+++ /tmp/tmpskjsudnj.java\t2023-03-24 20:41:35.720340252 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "else if (weight <= j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:37.408333143 +0100\n+++ /tmp/tmp1gu7h9tq.java\t2023-03-24 20:41:37.412333128 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (weight <= j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": true
            },
            {
                "k": 69,
                "tentative_fix": "else if (degree[i - 1][j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:42.184313041 +0100\n+++ /tmp/tmpifhrkob7.java\t2023-03-24 20:41:42.184313041 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (degree[i - 1][j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "else if (j < capacity && j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:43.976305502 +0100\n+++ /tmp/tmp04nef5ib.java\t2023-03-24 20:41:43.980305485 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "else if (pdz == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:48.220287655 +0100\n+++ /tmp/tmplo6dvqvw.java\t2023-03-24 20:41:48.220287655 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (pdz == 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "else if (rows == 2 || j > 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:49.920280511 +0100\n+++ /tmp/tmpdgfrlak3.java\t2023-03-24 20:41:49.920280511 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || j > 3) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "else if (cols.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:51.760272780 +0100\n+++ /tmp/tmpg2snr06n.java\t2023-03-24 20:41:51.760272780 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cols.length < 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "else if (weight > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:53.592265086 +0100\n+++ /tmp/tmpa7c55mvn.java\t2023-03-24 20:41:53.592265086 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (weight > j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "else if (j < capacity && j % 2 == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:41:57.324249417 +0100\n+++ /tmp/tmpsuft_h0z.java\t2023-03-24 20:41:57.328249402 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j % 2 == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "else if (capacity < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:01.380232402 +0100\n+++ /tmp/tmperf74nzc.java\t2023-03-24 20:42:01.380232402 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (capacity < j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "else if (height < 0 || j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:05.508215094 +0100\n+++ /tmp/tmp885ua0jx.java\t2023-03-24 20:42:05.512215075 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (height < 0 || j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "else if (height < 0 || j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:07.024208738 +0100\n+++ /tmp/tmpd9hf9ehu.java\t2023-03-24 20:42:07.024208738 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (height < 0 || j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "else if (rows < 0 || columns > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:08.496202573 +0100\n+++ /tmp/tmp39ac56w_.java\t2023-03-24 20:42:08.496202573 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < 0 || columns > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "else if (rows == 1 || j == -1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:10.084195921 +0100\n+++ /tmp/tmp81_r5pum.java\t2023-03-24 20:42:10.084195921 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j == -1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "else if (description < capacity && j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:11.988187946 +0100\n+++ /tmp/tmp50qp9jdf.java\t2023-03-24 20:42:11.988187946 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (description < capacity && j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "else if (rows == 1 || columns == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:13.668180915 +0100\n+++ /tmp/tmpq60oaj7_.java\t2023-03-24 20:42:13.668180915 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || columns == 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "else if (it.hasNext()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:15.132174787 +0100\n+++ /tmp/tmpqodcbyks.java\t2023-03-24 20:42:15.132174787 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (it.hasNext()) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "else if (rows == columns) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:16.680168308 +0100\n+++ /tmp/tmpzzr47f1e.java\t2023-03-24 20:42:16.680168308 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == columns) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "else if (rows == 2 || j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:18.212161901 +0100\n+++ /tmp/tmpsmoy3qw1.java\t2023-03-24 20:42:18.212161901 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 2 || j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "else if (cols.length > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:19.684155745 +0100\n+++ /tmp/tmpm6dt9ema.java\t2023-03-24 20:42:19.684155745 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cols.length > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "else if (rows == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:21.448148367 +0100\n+++ /tmp/tmps9i8urek.java\t2023-03-24 20:42:21.448148367 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == i) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "else if (len < 1 || j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:23.244140861 +0100\n+++ /tmp/tmp4udwj1ee.java\t2023-03-24 20:42:23.248140843 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (len < 1 || j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "else if (rows == 1 || j == 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:24.964133674 +0100\n+++ /tmp/tmp9bg8d5jb.java\t2023-03-24 20:42:24.968133655 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1 || j == 2) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "else if (numTypesValid == 0 && j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:26.752126204 +0100\n+++ /tmp/tmplfevgjzj.java\t2023-03-24 20:42:26.752126204 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (numTypesValid == 0 && j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "else if (partial[j] == 0x0020) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:28.196120172 +0100\n+++ /tmp/tmppt3c2dok.java\t2023-03-24 20:42:28.200120154 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (partial[j] == 0x0020) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "else if (partial[i - 1][j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:29.676113992 +0100\n+++ /tmp/tmp18at_ocp.java\t2023-03-24 20:42:29.676113992 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (partial[i - 1][j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "else if (double == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:31.112107994 +0100\n+++ /tmp/tmp416m_dba.java\t2023-03-24 20:42:31.112107994 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (double == 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "else if (cardinality - 1 < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:32.556101969 +0100\n+++ /tmp/tmpiotzsfxa.java\t2023-03-24 20:42:32.560101951 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cardinality - 1 < 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "else if (rows == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:34.352094475 +0100\n+++ /tmp/tmps4a137d4.java\t2023-03-24 20:42:34.352094475 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "else if (--j >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:36.128087064 +0100\n+++ /tmp/tmpo4k7ynxq.java\t2023-03-24 20:42:36.128087064 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (--j >= 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "else if (Restrictions.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:39.820071670 +0100\n+++ /tmp/tmpybt_3mu4.java\t2023-03-24 20:42:39.824071652 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (Restrictions.isEmpty()) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "else if (i == j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:41.928062882 +0100\n+++ /tmp/tmp3nqlqzoc.java\t2023-03-24 20:42:41.928062882 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i == j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "else if (task == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:47.348040303 +0100\n+++ /tmp/tmpm3806mjl.java\t2023-03-24 20:42:47.348040303 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (task == 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "else if (columns.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 20:42:49.072033128 +0100\n+++ /tmp/tmpszn_mikb.java\t2023-03-24 20:42:49.072033128 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (columns.size() == 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "else if (weight <= j) {"
    },
    "topological_ordering": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:46.620043337 +0100\n+++ /tmp/tmp08g7621n.java\t2023-03-24 20:42:46.632043285 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:48.520035423 +0100\n+++ /tmp/tmpvmyj9jzs.java\t2023-03-24 20:42:48.520035423 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (listSize > 0) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:50.252028216 +0100\n+++ /tmp/tmpf8s6h_wd.java\t2023-03-24 20:42:50.256028197 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (listSize > 0) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (node.getNode().is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:52.176020208 +0100\n+++ /tmp/tmp0bnu6wk2.java\t2023-03-24 20:42:52.176020208 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (node.getNode().is(Node.Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:54.468010670 +0100\n+++ /tmp/tmpwbr4lh5q.java\t2023-03-24 20:42:54.468010670 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().is(Node.Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (node.is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:56.192003500 +0100\n+++ /tmp/tmpqcprn7bx.java\t2023-03-24 20:42:56.192003500 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (node.getNodeType() == Node.COMMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:57.959996148 +0100\n+++ /tmp/tmp7g4uolgt.java\t2023-03-24 20:42:57.959996148 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.COMMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (node.getNode().isTextual()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:42:59.715988849 +0100\n+++ /tmp/tmpocb8vdn8.java\t2023-03-24 20:42:59.715988849 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().isTextual()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (node.getToken().isGeneratedCode()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:01.383981917 +0100\n+++ /tmp/tmpfbzfntjb.java\t2023-03-24 20:43:01.383981917 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getToken().isGeneratedCode()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (node.getName().equals(name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:03.119974706 +0100\n+++ /tmp/tmpiql9uthz.java\t2023-03-24 20:43:03.123974687 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getName().equals(name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (node.is(CxxGrammarImpl.selectionStatement)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:04.839967560 +0100\n+++ /tmp/tmpah2n8uco.java\t2023-03-24 20:43:04.839967560 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(CxxGrammarImpl.selectionStatement)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (o.equals(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:06.527960549 +0100\n+++ /tmp/tmpngy35sst.java\t2023-03-24 20:43:06.531960535 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (o.equals(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (node.getRole() == node) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:08.211953558 +0100\n+++ /tmp/tmp81niplah.java\t2023-03-24 20:43:08.211953558 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getRole() == node) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (!(node instanceof Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:09.871946669 +0100\n+++ /tmp/tmp9oqhm0hc.java\t2023-03-24 20:43:09.871946669 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(node instanceof Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (map.get(i).is(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:11.603939482 +0100\n+++ /tmp/tmp1lmoxoll.java\t2023-03-24 20:43:11.603939482 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (map.get(i).is(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (node.getNodeType()!= Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:13.347932244 +0100\n+++ /tmp/tmpzjf7v6dx.java\t2023-03-24 20:43:13.347932244 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType()!= Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (Objects.equals(listSize, node.getNode())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:15.035925243 +0100\n+++ /tmp/tmpwhyt4sdy.java\t2023-03-24 20:43:15.035925243 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(listSize, node.getNode())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (node.is(CxxGrammarImpl.node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:16.747918146 +0100\n+++ /tmp/tmp16zr0ee1.java\t2023-03-24 20:43:16.747918146 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(CxxGrammarImpl.node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (node.is(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:18.431911162 +0100\n+++ /tmp/tmpwx_5lv6t.java\t2023-03-24 20:43:18.431911162 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (Objects.equals(prefix, nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:20.127904132 +0100\n+++ /tmp/tmpqy3gex6m.java\t2023-03-24 20:43:20.127904132 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(prefix, nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (node.is(CxxGrammarImpl.expression)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:21.775897305 +0100\n+++ /tmp/tmp4grhrbaz.java\t2023-03-24 20:43:21.775897305 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(CxxGrammarImpl.expression)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (StringUtils.isBlank(nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:23.495890178 +0100\n+++ /tmp/tmpmh70wm30.java\t2023-03-24 20:43:23.495890178 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (StringUtils.isBlank(nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (node.getNodes().isEmpty()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:25.219883038 +0100\n+++ /tmp/tmpm9pdpw8q.java\t2023-03-24 20:43:25.219883038 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodes().isEmpty()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (node.is(CxxGrammarImpl.functionDefinition)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:26.931875949 +0100\n+++ /tmp/tmpusu8fsgr.java\t2023-03-24 20:43:26.935875934 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(CxxGrammarImpl.functionDefinition)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (!(node instanceof List)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:28.683868698 +0100\n+++ /tmp/tmp01r3wz99.java\t2023-03-24 20:43:28.683868698 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(node instanceof List)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (node.getCardinality() == node.getCardinality()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:30.359861761 +0100\n+++ /tmp/tmpars8gf0o.java\t2023-03-24 20:43:30.359861761 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getCardinality() == node.getCardinality()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (!StringUtils.isBlank(nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:32.043854793 +0100\n+++ /tmp/tmpm2g77fn6.java\t2023-03-24 20:43:32.043854793 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!StringUtils.isBlank(nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (node.equals(listSize)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:33.775847628 +0100\n+++ /tmp/tmpsll86c6j.java\t2023-03-24 20:43:33.775847628 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.equals(listSize)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (node.getNodeName().equals(name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:35.527840380 +0100\n+++ /tmp/tmp2i1bflmu.java\t2023-03-24 20:43:35.527840380 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeName().equals(name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (Objects.equals(name, nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:37.247833268 +0100\n+++ /tmp/tmpfxsrh0go.java\t2023-03-24 20:43:37.255833235 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(name, nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (iterator.hasNext()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:38.911826389 +0100\n+++ /tmp/tmp6tuttuyy.java\t2023-03-24 20:43:38.915826375 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (iterator.hasNext()) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:40.559819580 +0100\n+++ /tmp/tmphw0am0nn.java\t2023-03-24 20:43:40.559819580 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (node.getNextNode() == node) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:42.211812754 +0100\n+++ /tmp/tmp31pa779a.java\t2023-03-24 20:43:42.211812754 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNextNode() == node) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (node.getNodeType() == Node.IDENT) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:43.919805698 +0100\n+++ /tmp/tmp317cn__o.java\t2023-03-24 20:43:43.919805698 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.IDENT) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (node.getNodeType() == Node.COMMENT) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:45.635798611 +0100\n+++ /tmp/tmpz4s7xjzz.java\t2023-03-24 20:43:45.635798611 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.COMMENT) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (node.is(FirstNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:47.327791622 +0100\n+++ /tmp/tmpp_6d2dxf.java\t2023-03-24 20:43:47.327791622 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(FirstNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (!(node instanceof ModuleNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:49.007784687 +0100\n+++ /tmp/tmpsjoxxez8.java\t2023-03-24 20:43:49.007784687 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(node instanceof ModuleNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (Objects.equals(name, node.name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:50.639777953 +0100\n+++ /tmp/tmpyfja8py3.java\t2023-03-24 20:43:50.643777934 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(name, node.name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (o.is(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:52.299771101 +0100\n+++ /tmp/tmp0692ahld.java\t2023-03-24 20:43:52.299771101 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (o.is(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (name.equals(nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:53.979764172 +0100\n+++ /tmp/tmpnroexcmt.java\t2023-03-24 20:43:53.979764172 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (name.equals(nextNode.getName())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (name.equals(nextNode.name())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:55.647757290 +0100\n+++ /tmp/tmpe_urjpao.java\t2023-03-24 20:43:55.651757276 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (name.equals(nextNode.name())) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (counter == null) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:57.343750299 +0100\n+++ /tmp/tmpomiomd4j.java\t2023-03-24 20:43:57.343750299 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (counter == null) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (node.getNodeName().equals(name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:43:59.023743370 +0100\n+++ /tmp/tmpjpwpzth5.java\t2023-03-24 20:43:59.027743354 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeName().equals(name)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (nextNode.is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:00.691736498 +0100\n+++ /tmp/tmph3a6q5z0.java\t2023-03-24 20:44:00.695736479 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (nextNode.is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (node.is( listNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:02.359729621 +0100\n+++ /tmp/tmpy91jre77.java\t2023-03-24 20:44:02.359729621 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is( listNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (node.is(ID)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:04.039722700 +0100\n+++ /tmp/tmpltsp1jsc.java\t2023-03-24 20:44:04.039722700 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.is(ID)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:05.711715813 +0100\n+++ /tmp/tmp2tk44ncp.java\t2023-03-24 20:44:05.711715813 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (!(node instanceof Map.Entry)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:07.391708894 +0100\n+++ /tmp/tmp77w6ny2q.java\t2023-03-24 20:44:07.391708894 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(node instanceof Map.Entry)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:09.083701927 +0100\n+++ /tmp/tmpf_fhtb_7.java\t2023-03-24 20:44:09.083701927 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:10.767694996 +0100\n+++ /tmp/tmpwg8nbwhr.java\t2023-03-24 20:44:10.771694982 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getNodeValue()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:12.479687952 +0100\n+++ /tmp/tmp792rjetu.java\t2023-03-24 20:44:12.483687933 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getNodeValue()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors())) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:14.167681007 +0100\n+++ /tmp/tmpbgj1n3fx.java\t2023-03-24 20:44:14.167681007 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors())) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:15.855674060 +0100\n+++ /tmp/tmpiynejipe.java\t2023-03-24 20:44:15.855674060 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (node.getNode().is(Node.Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:17.519667216 +0100\n+++ /tmp/tmp9x66gu11.java\t2023-03-24 20:44:17.519667216 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().is(Node.Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors())) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:19.231660177 +0100\n+++ /tmp/tmp29nuazmf.java\t2023-03-24 20:44:19.255660078 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors())) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (node.getNode().is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:20.879653404 +0100\n+++ /tmp/tmpjaq8qyvh.java\t2023-03-24 20:44:20.879653404 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) ||!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:22.575646433 +0100\n+++ /tmp/tmpl3wa_bcq.java\t2023-03-24 20:44:22.575646433 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) ||!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) && (!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:24.375639034 +0100\n+++ /tmp/tmpahc_b811.java\t2023-03-24 20:44:24.375639034 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) && (!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (Objects.equals(listSize, node.getNode) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:26.091631984 +0100\n+++ /tmp/tmpxekab7br.java\t2023-03-24 20:44:26.091631984 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (Objects.equals(listSize, node.getNode) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) && (!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:27.767625100 +0100\n+++ /tmp/tmpsu3wk9vg.java\t2023-03-24 20:44:27.767625100 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) && (!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getNodeValue()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:29.471618102 +0100\n+++ /tmp/tmpom9qdil4.java\t2023-03-24 20:44:29.475618088 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getNodeValue()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) ||!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:31.159611174 +0100\n+++ /tmp/tmptq0u18io.java\t2023-03-24 20:44:31.159611174 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) ||!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.get(\"value\") &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:32.827604327 +0100\n+++ /tmp/tmpi5qn4p1k.java\t2023-03-24 20:44:32.827604327 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.get(\"value\") &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:34.599597054 +0100\n+++ /tmp/tmpt7egvxxn.java\t2023-03-24 20:44:34.603597035 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); } }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } } else { orderedNodes.add(node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:36.267590211 +0100\n+++ /tmp/tmp290zth3n.java\t2023-03-24 20:44:36.267590211 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } } else { orderedNodes.add(node); }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:37.935583366 +0100\n+++ /tmp/tmpsm4vqg7w.java\t2023-03-24 20:44:37.935583366 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:39.779575802 +0100\n+++ /tmp/tmp6ec_a47q.java\t2023-03-24 20:44:39.779575802 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (Objects.equals(prefix, nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:41.523568653 +0100\n+++ /tmp/tmpjv2lg0il.java\t2023-03-24 20:44:41.527568635 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(prefix, nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:43.199561782 +0100\n+++ /tmp/tmpyb933br8.java\t2023-03-24 20:44:43.223561684 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); } }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:44.911554765 +0100\n+++ /tmp/tmpkjqygkij.java\t2023-03-24 20:44:44.911554765 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:46.615547780 +0100\n+++ /tmp/tmpa45whbob.java\t2023-03-24 20:44:46.615547780 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } } else { orderedNodes.add(node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:48.363540617 +0100\n+++ /tmp/tmp3he9gqm1.java\t2023-03-24 20:44:48.363540617 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } } else { orderedNodes.add(node); }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!(node.getNodeType() == Node.ELEMENT_NODE) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:50.099533509 +0100\n+++ /tmp/tmpieg_uk33.java\t2023-03-24 20:44:50.099533509 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(node.getNodeType() == Node.ELEMENT_NODE) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (o.equals(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:51.843526365 +0100\n+++ /tmp/tmpkak2c_86.java\t2023-03-24 20:44:51.843526365 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (o.equals(nextNode)) { if (orderedNodes.containsAll(nextNode.getSuccessors() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(previousNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:53.551519370 +0100\n+++ /tmp/tmp0gk4_1t6.java\t2023-03-24 20:44:53.551519370 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(previousNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (listSize > 0) { if (listSize < 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(nextNode); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:55.319512133 +0100\n+++ /tmp/tmpiws7ie_d.java\t2023-03-24 20:44:55.319512133 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (listSize > 0) { if (listSize < 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(nextNode); } }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:57.043505079 +0100\n+++ /tmp/tmp8mg52zi_.java\t2023-03-24 20:44:57.043505079 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(nextNode); }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(previousNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:44:58.871497596 +0100\n+++ /tmp/tmpk7jflkuz.java\t2023-03-24 20:44:58.871497596 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(previousNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (node.getNode().is(CxxGrammarImpl.namedNodes) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:00.627490415 +0100\n+++ /tmp/tmpfenm6b9t.java\t2023-03-24 20:45:00.627490415 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().is(CxxGrammarImpl.namedNodes) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (normalizeNodes.contains(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:02.411483117 +0100\n+++ /tmp/tmppn0m95dh.java\t2023-03-24 20:45:02.411483117 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (normalizeNodes.contains(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (node.getName().equals(listSize) && node.getNode().equals(listSize) && node.getNode().equals(listSize)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:04.151475999 +0100\n+++ /tmp/tmpn1lx7d__.java\t2023-03-24 20:45:04.151475999 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getName().equals(listSize) && node.getNode().equals(listSize) && node.getNode().equals(listSize)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:05.983468509 +0100\n+++ /tmp/tmpsdaidc8u.java\t2023-03-24 20:45:05.983468509 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (Objects.equals(listNode.get(i), nextNode.get(i + 1).equals(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:07.815461023 +0100\n+++ /tmp/tmppa1evmd0.java\t2023-03-24 20:45:07.815461023 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(listNode.get(i), nextNode.get(i + 1).equals(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains( nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:09.603453714 +0100\n+++ /tmp/tmpd5l3a4b4.java\t2023-03-24 20:45:09.603453714 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains( nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:11.347446590 +0100\n+++ /tmp/tmp_3f82s6s.java\t2023-03-24 20:45:11.347446590 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(nextNode); }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains( nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:13.151439218 +0100\n+++ /tmp/tmp4p_ie8s0.java\t2023-03-24 20:45:13.151439218 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains( nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.isEmpty(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:14.911432029 +0100\n+++ /tmp/tmpaoyf8fst.java\t2023-03-24 20:45:14.911432029 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.isEmpty(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:16.631425005 +0100\n+++ /tmp/tmpir5224kh.java\t2023-03-24 20:45:16.635424991 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(node); }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:18.335418048 +0100\n+++ /tmp/tmp_sh420p0.java\t2023-03-24 20:45:18.335418048 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (Objects.equals(listSize, node.getNode.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:20.059411014 +0100\n+++ /tmp/tmp39a16rqd.java\t2023-03-24 20:45:20.059411014 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (Objects.equals(listSize, node.getNode.getNodeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.addAll(listSize); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:21.775404008 +0100\n+++ /tmp/tmpjb5raulo.java\t2023-03-24 20:45:21.775404008 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.addAll(listSize); }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:23.567396698 +0100\n+++ /tmp/tmppw1xutgu.java\t2023-03-24 20:45:23.567396698 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(name); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:25.295389647 +0100\n+++ /tmp/tmpe67czd2p.java\t2023-03-24 20:45:25.295389647 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (listSize > 0) { orderedNodes.add(nextNode); } else { orderedNodes.add(name); } }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:27.027382582 +0100\n+++ /tmp/tmpi88hnc81.java\t2023-03-24 20:45:27.027382582 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (node.getNode().is(Node.Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:28.811375307 +0100\n+++ /tmp/tmpu_hk3jit.java\t2023-03-24 20:45:28.811375307 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().is(Node.Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode))",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:30.607367985 +0100\n+++ /tmp/tmpn49e6o5o.java\t2023-03-24 20:45:30.607367985 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode))\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (node.getNode().is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:32.387360728 +0100\n+++ /tmp/tmpytal6kbz.java\t2023-03-24 20:45:32.387360728 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNode().is(Node)) { if (orderedNodes.containsAll(nextNode.getSuccessors()) &&!orderedNodes.contains(nextNode)) { }\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (node.getNodeName().equals(listSize) && node.getNode().equals(listSize)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:34.139353589 +0100\n+++ /tmp/tmp99f626us.java\t2023-03-24 20:45:34.139353589 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeName().equals(listSize) && node.getNode().equals(listSize)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (node.getName().equals(listSize) && node.getNode().equals(listSize)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:35.867346548 +0100\n+++ /tmp/tmpvqx5ucn_.java\t2023-03-24 20:45:35.867346548 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getName().equals(listSize) && node.getNode().equals(listSize)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 20:45:37.611339445 +0100\n+++ /tmp/tmpymr78z65.java\t2023-03-24 20:45:37.611339445 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (orderedNodes.containsAll(nextNode.getPredecessors()) && !orderedNodes.contains(nextNode)) {"
    },
    "next_palindrome": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:42:54.584010190 +0100\n+++ /tmp/tmplz8lsvna.java\t2023-03-24 20:42:54.596010138 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:42:56.276003153 +0100\n+++ /tmp/tmpqfykm29l.java\t2023-03-24 20:42:56.276003153 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (when_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:42:57.979996067 +0100\n+++ /tmp/tmpth7eoiu0.java\t2023-03-24 20:42:57.979996067 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (when_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (nCopies.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:42:59.703988901 +0100\n+++ /tmp/tmp4x2rboi9.java\t2023-03-24 20:42:59.703988901 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (nCopies.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (iterator.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:01.359982017 +0100\n+++ /tmp/tmppb79j_fe.java\t2023-03-24 20:43:01.359982017 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iterator.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (otherwise.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:03.047975003 +0100\n+++ /tmp/tmp4wtrtaoe.java\t2023-03-24 20:43:03.051974988 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:04.771967842 +0100\n+++ /tmp/tmpitom_rcg.java\t2023-03-24 20:43:04.771967842 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:06.471960782 +0100\n+++ /tmp/tmpuohu93qn.java\t2023-03-24 20:43:06.471960782 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:08.135953873 +0100\n+++ /tmp/tmpjhbqy_hr.java\t2023-03-24 20:43:08.135953873 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if ( otherwise.isPresent()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:09.851946750 +0100\n+++ /tmp/tmpc0h38ea3.java\t2023-03-24 20:43:09.851946750 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.isPresent()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (elem.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:11.591939530 +0100\n+++ /tmp/tmpumsmvgem.java\t2023-03-24 20:43:11.591939530 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (elem.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:13.275932545 +0100\n+++ /tmp/tmpr5lr1t4u.java\t2023-03-24 20:43:13.275932545 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if ( otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:14.987925444 +0100\n+++ /tmp/tmp2zu9_a5s.java\t2023-03-24 20:43:14.987925444 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (prepend) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:16.655918525 +0100\n+++ /tmp/tmpnmhtc679.java\t2023-03-24 20:43:16.655918525 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (prepend) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (otherwise.length.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:18.335911560 +0100\n+++ /tmp/tmp18k453ab.java\t2023-03-24 20:43:18.339911545 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (otherwise.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:20.051904448 +0100\n+++ /tmp/tmpvnlbhrpr.java\t2023-03-24 20:43:20.051904448 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (pe.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:21.747897420 +0100\n+++ /tmp/tmp0ybxk6ca.java\t2023-03-24 20:43:21.747897420 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (pe.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (connection!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:23.459890327 +0100\n+++ /tmp/tmpq_qd_lc7.java\t2023-03-24 20:43:23.459890327 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (connection!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:25.203883106 +0100\n+++ /tmp/tmpn398sas5.java\t2023-03-24 20:43:25.203883106 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (value.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:26.903876065 +0100\n+++ /tmp/tmpttn4kr7e.java\t2023-03-24 20:43:26.903876065 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (value.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (i.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:28.619868963 +0100\n+++ /tmp/tmp25f6a2fr.java\t2023-03-24 20:43:28.619868963 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (i.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (value!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:30.339861842 +0100\n+++ /tmp/tmpddp7b_5h.java\t2023-03-24 20:43:30.343861828 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (value!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (origin!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:32.015854907 +0100\n+++ /tmp/tmpkxstgk4g.java\t2023-03-24 20:43:32.015854907 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (origin!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (selected.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:33.695847956 +0100\n+++ /tmp/tmpf0zctwev.java\t2023-03-24 20:43:33.695847956 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (selected.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if ( otherwise.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:35.327841207 +0100\n+++ /tmp/tmpfl5snk8n.java\t2023-03-24 20:43:35.327841207 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (cardinality.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:36.979834379 +0100\n+++ /tmp/tmpis17toc5.java\t2023-03-24 20:43:36.979834379 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (cardinality.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if ( otherwise.length!= 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:38.643827497 +0100\n+++ /tmp/tmp3cnb5r4k.java\t2023-03-24 20:43:38.643827497 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.length!= 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:40.279820735 +0100\n+++ /tmp/tmp6y1_7cja.java\t2023-03-24 20:43:40.279820735 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (commit.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:42.087813264 +0100\n+++ /tmp/tmp406d934x.java\t2023-03-24 20:43:42.087813264 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (commit.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (value.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:43.755806376 +0100\n+++ /tmp/tmpu8apt6ax.java\t2023-03-24 20:43:43.759806357 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (value.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (25_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:45.435799434 +0100\n+++ /tmp/tmpza82znvx.java\t2023-03-24 20:43:45.435799434 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (25_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (plural.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:47.143792382 +0100\n+++ /tmp/tmpscdtugmo.java\t2023-03-24 20:43:47.143792382 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (plural.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (iteration.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:48.779785628 +0100\n+++ /tmp/tmpx0k4f32q.java\t2023-03-24 20:43:48.779785628 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iteration.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if ( otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:50.515778463 +0100\n+++ /tmp/tmpuoqb43uu.java\t2023-03-24 20:43:50.515778463 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (plural.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:52.255771283 +0100\n+++ /tmp/tmpix0qgoy_.java\t2023-03-24 20:43:52.255771283 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (plural.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (reference.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:53.959764255 +0100\n+++ /tmp/tmpuwma_7mo.java\t2023-03-24 20:43:53.959764255 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (reference.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:55.635757340 +0100\n+++ /tmp/tmp5mcp15s6.java\t2023-03-24 20:43:55.635757340 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (Unknown.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:57.291750512 +0100\n+++ /tmp/tmp48crw90t.java\t2023-03-24 20:43:57.295750497 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Unknown.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (o.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:43:58.967743601 +0100\n+++ /tmp/tmpd7d8sbv3.java\t2023-03-24 20:43:58.971743587 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (o.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (space.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:00.603736860 +0100\n+++ /tmp/tmpgpizdhe8.java\t2023-03-24 20:44:00.603736860 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (space.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (renamed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:02.255730050 +0100\n+++ /tmp/tmp0nafr292.java\t2023-03-24 20:44:02.259730036 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (renamed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (throwable!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:03.931723145 +0100\n+++ /tmp/tmpf2mn3f73.java\t2023-03-24 20:44:03.931723145 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (throwable!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:05.623716175 +0100\n+++ /tmp/tmp9oy8g8dg.java\t2023-03-24 20:44:05.627716161 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if ( otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:07.331709144 +0100\n+++ /tmp/tmpdzf1zwn5.java\t2023-03-24 20:44:07.331709144 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (renamed!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:08.987702323 +0100\n+++ /tmp/tmpqj2l6lri.java\t2023-03-24 20:44:08.987702323 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (renamed!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (space_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:10.687695325 +0100\n+++ /tmp/tmp_40kvpkp.java\t2023-03-24 20:44:10.687695325 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (space_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (Implemented.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:12.399688281 +0100\n+++ /tmp/tmp6m4btznh.java\t2023-03-24 20:44:12.399688281 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Implemented.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (comment!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:14.091681317 +0100\n+++ /tmp/tmpjd8ot474.java\t2023-03-24 20:44:14.091681317 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (comment!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (override) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:15.779674375 +0100\n+++ /tmp/tmpzboql7_k.java\t2023-03-24 20:44:15.779674375 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (override) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (href.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:17.443667531 +0100\n+++ /tmp/tmp2ezc7fuv.java\t2023-03-24 20:44:17.443667531 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (href.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (cols.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:19.151660506 +0100\n+++ /tmp/tmpwx6p_l7e.java\t2023-03-24 20:44:19.151660506 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (cols.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if ( once.length.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:20.847653536 +0100\n+++ /tmp/tmp9i_a5yxn.java\t2023-03-24 20:44:20.847653536 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( once.length.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (iter.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:22.543646563 +0100\n+++ /tmp/tmpp4h2ahk5.java\t2023-03-24 20:44:22.543646563 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iter.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (property!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:24.191639792 +0100\n+++ /tmp/tmpr6a3c3rx.java\t2023-03-24 20:44:24.191639792 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (property!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (when_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:25.863632921 +0100\n+++ /tmp/tmp9345uipl.java\t2023-03-24 20:44:25.867632907 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (when_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (dynamic.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:27.591625825 +0100\n+++ /tmp/tmp4o8ehxt1.java\t2023-03-24 20:44:27.591625825 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (dynamic.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (space_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:29.267618939 +0100\n+++ /tmp/tmpq41jw50l.java\t2023-03-24 20:44:29.267618939 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (space_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if ( once.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:30.959611992 +0100\n+++ /tmp/tmp50mvj2py.java\t2023-03-24 20:44:30.959611992 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( once.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (dynamic.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:32.631605130 +0100\n+++ /tmp/tmpgy2lleqt.java\t2023-03-24 20:44:32.635605115 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (dynamic.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (digit_list.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:34.303598267 +0100\n+++ /tmp/tmpp7e4vc9l.java\t2023-03-24 20:44:34.303598267 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (but.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:35.967591439 +0100\n+++ /tmp/tmpexpocm61.java\t2023-03-24 20:44:35.967591439 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (but.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (iteration.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:37.659584497 +0100\n+++ /tmp/tmpcwhnw7di.java\t2023-03-24 20:44:37.659584497 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iteration.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (f!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:39.287577820 +0100\n+++ /tmp/tmps08vp0yw.java\t2023-03-24 20:44:39.287577820 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (f!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if ( -1!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:40.987570849 +0100\n+++ /tmp/tmpa60bh6tc.java\t2023-03-24 20:44:40.987570849 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( -1!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if ( completed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:42.683563895 +0100\n+++ /tmp/tmp3__ynri7.java\t2023-03-24 20:44:42.683563895 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( completed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (selected.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:44.371556976 +0100\n+++ /tmp/tmpqdq5go2d.java\t2023-03-24 20:44:44.371556976 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (selected.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (columns.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:46.043550123 +0100\n+++ /tmp/tmpou0o8vhd.java\t2023-03-24 20:44:46.043550123 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (columns.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if ( objects.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:47.687543387 +0100\n+++ /tmp/tmp2zszxx8z.java\t2023-03-24 20:44:47.691543371 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( objects.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (Menu.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:49.347536587 +0100\n+++ /tmp/tmprqiinvkx.java\t2023-03-24 20:44:49.347536587 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Menu.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if ( & 0!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:51.099529411 +0100\n+++ /tmp/tmpcrf81qft.java\t2023-03-24 20:44:51.103529395 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( & 0!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if ( prop.isPresent()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:52.767522583 +0100\n+++ /tmp/tmp5fftdjvv.java\t2023-03-24 20:44:52.767522583 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( prop.isPresent()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (processed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:54.467515620 +0100\n+++ /tmp/tmp4bv6l6g6.java\t2023-03-24 20:44:54.467515620 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (processed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:56.243508351 +0100\n+++ /tmp/tmpuv3bnpd8.java\t2023-03-24 20:44:56.243508351 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (cardinality.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:57.887501623 +0100\n+++ /tmp/tmpju54gs2a.java\t2023-03-24 20:44:57.887501623 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (cardinality.length > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (Schedule.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:44:59.519494948 +0100\n+++ /tmp/tmpsamcs8i4.java\t2023-03-24 20:44:59.519494948 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Schedule.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (completed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:01.235487926 +0100\n+++ /tmp/tmp2wkqe_b0.java\t2023-03-24 20:45:01.239487912 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (completed.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (logged.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:02.895481138 +0100\n+++ /tmp/tmp6vnbbdg3.java\t2023-03-24 20:45:02.895481138 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (logged.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (otherwise!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:04.515474514 +0100\n+++ /tmp/tmpt35j3fbt.java\t2023-03-24 20:45:04.515474514 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (cols.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:06.167467759 +0100\n+++ /tmp/tmpo5y0e9bt.java\t2023-03-24 20:45:06.167467759 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (cols.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (columns.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:07.851460876 +0100\n+++ /tmp/tmpsmbxbr6a.java\t2023-03-24 20:45:07.851460876 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (columns.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (AsInt.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:09.591453763 +0100\n+++ /tmp/tmp_rff96vc.java\t2023-03-24 20:45:09.591453763 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (AsInt.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (i == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:11.279446865 +0100\n+++ /tmp/tmpzgx1jbcz.java\t2023-03-24 20:45:11.279446865 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (i == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (iterator.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:12.999439841 +0100\n+++ /tmp/tmplpzm0ppw.java\t2023-03-24 20:45:12.999439841 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iterator.hasNext()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (size > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:14.787432535 +0100\n+++ /tmp/tmpdab3ksux.java\t2023-03-24 20:45:14.791432520 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (size > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (origin.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:16.431425822 +0100\n+++ /tmp/tmpu4q582ez.java\t2023-03-24 20:45:16.431425822 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (origin.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (when_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:18.151418800 +0100\n+++ /tmp/tmp81gcu0h9.java\t2023-03-24 20:45:18.151418800 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (when_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:19.935411517 +0100\n+++ /tmp/tmp_qbn0j49.java\t2023-03-24 20:45:19.935411517 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (nCopies.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:21.731404190 +0100\n+++ /tmp/tmpg3s0ntww.java\t2023-03-24 20:45:21.735404170 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (nCopies.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (capacity > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:23.539396810 +0100\n+++ /tmp/tmp4h74rkx_.java\t2023-03-24 20:45:23.539396810 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (capacity > 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (outer) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:25.235389892 +0100\n+++ /tmp/tmpvb_tef66.java\t2023-03-24 20:45:25.239389878 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (outer) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (logged.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:26.923383006 +0100\n+++ /tmp/tmpk0sp_c8e.java\t2023-03-24 20:45:26.923383006 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (logged.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if ( started) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:28.583376237 +0100\n+++ /tmp/tmp4m6h_iki.java\t2023-03-24 20:45:28.583376237 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( started) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (literal) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:30.287369291 +0100\n+++ /tmp/tmpk4t_s2pf.java\t2023-03-24 20:45:30.287369291 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (literal) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:31.939362555 +0100\n+++ /tmp/tmpoag5nj7h.java\t2023-03-24 20:45:31.939362555 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if ( otherwise.isPresent()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:33.759355137 +0100\n+++ /tmp/tmp6fyd423x.java\t2023-03-24 20:45:33.759355137 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.isPresent()) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (INTER) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:35.639347476 +0100\n+++ /tmp/tmpw7woz58_.java\t2023-03-24 20:45:35.639347476 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (INTER) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (otherwise.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:37.355340486 +0100\n+++ /tmp/tmpf3tkod10.java\t2023-03-24 20:45:37.355340486 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (nCopies.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:39.083333446 +0100\n+++ /tmp/tmpxp4gl1ry.java\t2023-03-24 20:45:39.083333446 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (nCopies.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:41.055325415 +0100\n+++ /tmp/tmpjg50slkt.java\t2023-03-24 20:45:41.055325415 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if ( as) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 20:45:45.335307994 +0100\n+++ /tmp/tmpyumgxxc0.java\t2023-03-24 20:45:45.339307975 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( as) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "otherwise.addAll(Collections.nCopies(digit_list.length-1, 0));"
    },
    "get_factors": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "return new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:41.727322679 +0100\n+++ /tmp/tmpsi8xr7_k.java\t2023-03-24 20:45:41.791322418 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:45.843305924 +0100\n+++ /tmp/tmpy0y7ffst.java\t2023-03-24 20:45:45.843305924 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (!prepend) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:47.551298976 +0100\n+++ /tmp/tmp_9rkofme.java\t2023-03-24 20:45:47.555298957 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (! prepend.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:49.739290071 +0100\n+++ /tmp/tmp8k_k877f.java\t2023-03-24 20:45:49.743290055 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (! prepend.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (addNewLine) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:51.863281434 +0100\n+++ /tmp/tmpyu92fb56.java\t2023-03-24 20:45:51.863281434 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (addNewLine) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (trimLine) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:53.511274729 +0100\n+++ /tmp/tmpe_xnzj6u.java\t2023-03-24 20:45:53.511274729 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trimLine) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (prepend) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:55.179267949 +0100\n+++ /tmp/tmp790vzzz4.java\t2023-03-24 20:45:55.179267949 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (n % 2 == 0) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:56.863261101 +0100\n+++ /tmp/tmptgzjj_w9.java\t2023-03-24 20:45:56.863261101 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (n % 2 == 0) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if ( prepend.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:45:58.659253800 +0100\n+++ /tmp/tmp6z9t54jz.java\t2023-03-24 20:45:58.659253800 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if ( prepend.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (!selections.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:00.423246631 +0100\n+++ /tmp/tmpphkvf2eh.java\t2023-03-24 20:46:00.455246502 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!selections.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (!prepend) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:02.311238963 +0100\n+++ /tmp/tmpstacg9j4.java\t2023-03-24 20:46:02.315238944 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (iterator.hasNext()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:04.087231745 +0100\n+++ /tmp/tmp_n9mwth_.java\t2023-03-24 20:46:04.087231745 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (iterator.hasNext()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (trim) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:05.847224597 +0100\n+++ /tmp/tmpev9q6x2h.java\t2023-03-24 20:46:05.847224597 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trim) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (n % 2!= 0) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:07.499217889 +0100\n+++ /tmp/tmptugrjvna.java\t2023-03-24 20:46:07.499217889 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (n % 2!= 0) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (selections.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:09.307210548 +0100\n+++ /tmp/tmp3sbssugp.java\t2023-03-24 20:46:09.307210548 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (selections.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (trim().isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:11.011203633 +0100\n+++ /tmp/tmpz9tvmpmw.java\t2023-03-24 20:46:11.011203633 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trim().isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (selections!= null) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:12.715196715 +0100\n+++ /tmp/tmpz_mdj9pf.java\t2023-03-24 20:46:12.715196715 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (selections!= null) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (!add(prepend)) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:14.483189541 +0100\n+++ /tmp/tmpj_ftz6eq.java\t2023-03-24 20:46:14.483189541 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!add(prepend)) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (!prevNodes.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:16.323182078 +0100\n+++ /tmp/tmpaeun155m.java\t2023-03-24 20:46:16.323182078 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prevNodes.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (params.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:18.019175198 +0100\n+++ /tmp/tmpnb8axsix.java\t2023-03-24 20:46:18.023175179 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (params.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (!prepend.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:19.731168251 +0100\n+++ /tmp/tmpjhro1o1e.java\t2023-03-24 20:46:19.731168251 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (!schema.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:21.479161163 +0100\n+++ /tmp/tmpx8r2t0td.java\t2023-03-24 20:46:21.479161163 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!schema.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (!children.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:23.199154190 +0100\n+++ /tmp/tmp3onmagsm.java\t2023-03-24 20:46:23.203154176 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!children.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!columns.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:25.099146491 +0100\n+++ /tmp/tmpme8pjqur.java\t2023-03-24 20:46:25.099146491 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!columns.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (trimmed) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:26.875139290 +0100\n+++ /tmp/tmpf_10lmaz.java\t2023-03-24 20:46:26.875139290 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trimmed) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (!addNewLine) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:28.599132307 +0100\n+++ /tmp/tmp4qckzpjc.java\t2023-03-24 20:46:28.603132288 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!addNewLine) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (Nodes.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:30.343125242 +0100\n+++ /tmp/tmp2qndguvg.java\t2023-03-24 20:46:30.343125242 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (Nodes.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if ( params.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:32.083118190 +0100\n+++ /tmp/tmp9__ri79t.java\t2023-03-24 20:46:32.083118190 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if ( params.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "} else if (prepend) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:33.811111195 +0100\n+++ /tmp/tmphcrlzaw9.java\t2023-03-24 20:46:33.811111195 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+} else if (prepend) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (trimSpaces) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:35.475104457 +0100\n+++ /tmp/tmp46gzdghc.java\t2023-03-24 20:46:35.475104457 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trimSpaces) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (! prepend.isEmpty()) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:37.207097442 +0100\n+++ /tmp/tmp3pf3xc0i.java\t2023-03-24 20:46:37.207097442 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (! prepend.isEmpty()) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!LITERAL.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:38.831090871 +0100\n+++ /tmp/tmpm0uhrxju.java\t2023-03-24 20:46:38.831090871 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!LITERAL.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (prev!= null) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:40.503084101 +0100\n+++ /tmp/tmp_0s98knb.java\t2023-03-24 20:46:40.507084087 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prev!= null) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (!points.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:42.335076687 +0100\n+++ /tmp/tmpy1_j4ppj.java\t2023-03-24 20:46:42.335076687 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!points.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (prepend.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:44.027069844 +0100\n+++ /tmp/tmp_d5p1pw2.java\t2023-03-24 20:46:44.027069844 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (columns.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:45.811062625 +0100\n+++ /tmp/tmp411d526h.java\t2023-03-24 20:46:45.811062625 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (columns.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (!statement.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:47.607055361 +0100\n+++ /tmp/tmphr501gjr.java\t2023-03-24 20:46:47.607055361 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!statement.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (n % 2 == 0) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:49.379048198 +0100\n+++ /tmp/tmpyqiyc3tz.java\t2023-03-24 20:46:49.379048198 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (n % 2 == 0) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (LITERAL.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:51.047041451 +0100\n+++ /tmp/tmpehwecg3u.java\t2023-03-24 20:46:51.047041451 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (LITERAL.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (n % 10 == 0) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:52.787034417 +0100\n+++ /tmp/tmpw83rxluz.java\t2023-03-24 20:46:52.787034417 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (n % 10 == 0) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (emit) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:54.635026947 +0100\n+++ /tmp/tmpt73id4xx.java\t2023-03-24 20:46:54.635026947 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (emit) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (trim.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:56.423019723 +0100\n+++ /tmp/tmpq_b256fh.java\t2023-03-24 20:46:56.423019723 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trim.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (filter.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:46:58.211012498 +0100\n+++ /tmp/tmpmd_0vgwy.java\t2023-03-24 20:46:58.211012498 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (filter.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (s.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:00.015005210 +0100\n+++ /tmp/tmpdwpqe630.java\t2023-03-24 20:47:00.019005194 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (s.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "return new ArrayList<Integer>(); return new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:01.774998101 +0100\n+++ /tmp/tmpd73n1g_z.java\t2023-03-24 20:47:01.778998085 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>(); return new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if ( prepend.isEmpty()) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:03.546990948 +0100\n+++ /tmp/tmpvrziigpo.java\t2023-03-24 20:47:03.546990948 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if ( prepend.isEmpty()) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:05.178984355 +0100\n+++ /tmp/tmpn5yzn5pa.java\t2023-03-24 20:47:05.182984340 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (addNewLine) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:06.866977540 +0100\n+++ /tmp/tmpv2gjny8i.java\t2023-03-24 20:47:06.866977540 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (addNewLine) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (Invalid) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:08.578970633 +0100\n+++ /tmp/tmpwbo8xy78.java\t2023-03-24 20:47:08.578970633 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (Invalid) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (ret == null) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:10.310963643 +0100\n+++ /tmp/tmp1o82m4f0.java\t2023-03-24 20:47:10.310963643 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (ret == null) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "else if (prepend) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:12.010956781 +0100\n+++ /tmp/tmpzrbb7vkd.java\t2023-03-24 20:47:12.010956781 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+else if (prepend) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (trimLine()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:13.690950002 +0100\n+++ /tmp/tmptnvlbtf9.java\t2023-03-24 20:47:13.690950002 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trimLine()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (!commit) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:15.394943128 +0100\n+++ /tmp/tmpqlte9ptz.java\t2023-03-24 20:47:15.394943128 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!commit) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (prepend) { // prepend return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:17.122936159 +0100\n+++ /tmp/tmpuy43vrms.java\t2023-03-24 20:47:17.122936159 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { // prepend return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (hasDot) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:18.802929386 +0100\n+++ /tmp/tmp4j8eh5on.java\t2023-03-24 20:47:18.802929386 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (hasDot) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (selections.isEmpty()) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:20.582922209 +0100\n+++ /tmp/tmp0n0uzps2.java\t2023-03-24 20:47:20.582922209 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (selections.isEmpty()) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (iterator.hasNext()) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:22.202915678 +0100\n+++ /tmp/tmp9sj1g16d.java\t2023-03-24 20:47:22.206915662 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (iterator.hasNext()) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (trimName) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:24.022908341 +0100\n+++ /tmp/tmpg8ahcyh1.java\t2023-03-24 20:47:24.022908341 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trimName) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (commit) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:25.906900749 +0100\n+++ /tmp/tmpa26_46ii.java\t2023-03-24 20:47:25.906900749 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (commit) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (enabled) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:27.630893802 +0100\n+++ /tmp/tmpsay2ustm.java\t2023-03-24 20:47:27.630893802 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (enabled) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (selected) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:29.354886856 +0100\n+++ /tmp/tmp7k24liwo.java\t2023-03-24 20:47:29.354886856 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (selected) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (prepend)) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:31.142879654 +0100\n+++ /tmp/tmp_szugiwg.java\t2023-03-24 20:47:31.154879605 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend)) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if ( prepend) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:32.894872598 +0100\n+++ /tmp/tmps3wgmgvf.java\t2023-03-24 20:47:32.894872598 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if ( prepend) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (params.isEmpty()) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:34.702865312 +0100\n+++ /tmp/tmpawq7cl88.java\t2023-03-24 20:47:34.702865312 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (params.isEmpty()) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (!add) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:36.326858770 +0100\n+++ /tmp/tmp90lrp8kx.java\t2023-03-24 20:47:36.326858770 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!add) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if ( rename) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:38.038851879 +0100\n+++ /tmp/tmpbq3kjth6.java\t2023-03-24 20:47:38.042851863 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if ( rename) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (ret == null) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:39.862844537 +0100\n+++ /tmp/tmp8qgbqgkr.java\t2023-03-24 20:47:39.862844537 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (ret == null) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (trimLine) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:41.578837631 +0100\n+++ /tmp/tmpul_v878m.java\t2023-03-24 20:47:41.582837615 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trimLine) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (s.isEmpty()) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:43.162831257 +0100\n+++ /tmp/tmpykwsjc8s.java\t2023-03-24 20:47:43.162831257 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (s.isEmpty()) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (trimmed = new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:44.734824933 +0100\n+++ /tmp/tmpp4ovxpny.java\t2023-03-24 20:47:44.734824933 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trimmed = new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (prepend) return new ArrayList<Integer>();>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:46.418818159 +0100\n+++ /tmp/tmpxl0sp13q.java\t2023-03-24 20:47:46.418818159 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) return new ArrayList<Integer>();>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:48.122811304 +0100\n+++ /tmp/tmp8b8yyj35.java\t2023-03-24 20:47:48.122811304 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (prepend) return new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:49.846804371 +0100\n+++ /tmp/tmpaoub7yvp.java\t2023-03-24 20:47:49.846804371 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) return new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "return new ArrayList<String>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:51.582797390 +0100\n+++ /tmp/tmpj6wz831v.java\t2023-03-24 20:47:51.582797390 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<String>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "return new LinkedHashSet<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:53.274790588 +0100\n+++ /tmp/tmpqmuhykcu.java\t2023-03-24 20:47:53.274790588 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new LinkedHashSet<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "return new HashSet<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:55.026783546 +0100\n+++ /tmp/tmpuar6ev23.java\t2023-03-24 20:47:55.026783546 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new HashSet<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "return new ArrayList<Integer>(); });",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:56.754776599 +0100\n+++ /tmp/tmpghwknq8u.java\t2023-03-24 20:47:56.754776599 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>(); });\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "return return new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:47:58.294770412 +0100\n+++ /tmp/tmpbh36ljuk.java\t2023-03-24 20:47:58.294770412 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return return new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "throw new IllegalArgumentException(\"Only simple parameters\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:00.302762343 +0100\n+++ /tmp/tmpqi40n8t5.java\t2023-03-24 20:48:00.302762343 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+throw new IllegalArgumentException(\"Only simple parameters\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "{ return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:06.582737118 +0100\n+++ /tmp/tmp8wv3p8gl.java\t2023-03-24 20:48:06.586737102 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+{ return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "try { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:11.974715471 +0100\n+++ /tmp/tmpwvrvzaeu.java\t2023-03-24 20:48:12.410713721 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+try { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "return new LinkedList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:14.434705598 +0100\n+++ /tmp/tmpck08s777.java\t2023-03-24 20:48:14.434705598 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new LinkedList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "return new ArrayList<Integer>(); // prepend",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:16.514697253 +0100\n+++ /tmp/tmp40hry087.java\t2023-03-24 20:48:16.514697253 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>(); // prepend\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "return new List<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:21.874675751 +0100\n+++ /tmp/tmp60jwh94o.java\t2023-03-24 20:48:21.874675751 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new List<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "return new ArrayList<Integer>(prepend);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:24.202666414 +0100\n+++ /tmp/tmp3ci5f2yx.java\t2023-03-24 20:48:24.202666414 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>(prepend);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "return new ArrayList<Int>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:25.922659519 +0100\n+++ /tmp/tmpramd4b_e.java\t2023-03-24 20:48:25.922659519 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Int>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "return new ArrayList<Boolean>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:27.886651645 +0100\n+++ /tmp/tmp0x09whv9.java\t2023-03-24 20:48:27.886651645 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Boolean>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "return new ArrayList<Integer>();>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:30.362641720 +0100\n+++ /tmp/tmplbxqc1vb.java\t2023-03-24 20:48:30.362641720 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>();>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "return new Set<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:32.522633065 +0100\n+++ /tmp/tmpvqmpnvsq.java\t2023-03-24 20:48:32.522633065 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new Set<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "{ return new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:34.882623609 +0100\n+++ /tmp/tmp0c5x2kgl.java\t2023-03-24 20:48:34.882623609 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+{ return new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "return newArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:36.958615292 +0100\n+++ /tmp/tmp9d0ol5tx.java\t2023-03-24 20:48:36.962615276 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return newArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "continue new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:39.286605968 +0100\n+++ /tmp/tmpg8axfdzu.java\t2023-03-24 20:48:39.446605327 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+continue new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return new ArrayList<Long>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:41.566596838 +0100\n+++ /tmp/tmpsggiyi55.java\t2023-03-24 20:48:41.566596838 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Long>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "break new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:44.134586556 +0100\n+++ /tmp/tmp91te4pty.java\t2023-03-24 20:48:44.138586540 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+break new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "return new TreeSet<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:46.074578788 +0100\n+++ /tmp/tmpz3siu_14.java\t2023-03-24 20:48:46.074578788 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new TreeSet<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "return add(prepend);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:48.346569695 +0100\n+++ /tmp/tmp46k3vnep.java\t2023-03-24 20:48:48.346569695 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return add(prepend);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "throw new IllegalStateException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:51.358557642 +0100\n+++ /tmp/tmptcts59ts.java\t2023-03-24 20:48:51.358557642 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+throw new IllegalStateException();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:48:57.262534024 +0100\n+++ /tmp/tmpnsabhx4r.java\t2023-03-24 20:48:57.262534024 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "return this;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:49:01.638516526 +0100\n+++ /tmp/tmp469qka5g.java\t2023-03-24 20:49:01.638516526 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return this;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return prepend;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 20:49:03.434509346 +0100\n+++ /tmp/tmpp4mub3h_.java\t2023-03-24 20:49:03.434509346 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return prepend;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return new ArrayList<Integer>(Arrays.asList(n));"
    },
    "find_in_sorted": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (!arr[mid]) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:45:51.595282522 +0100\n+++ /tmp/tmp9kfslhsy.java\t2023-03-24 20:45:51.607282473 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid]) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:45:53.415275120 +0100\n+++ /tmp/tmput0ao2ft.java\t2023-03-24 20:45:53.415275120 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (!arr.isEmpty()) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:45:55.115268207 +0100\n+++ /tmp/tmp7zymipbv.java\t2023-03-24 20:45:55.115268207 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr.isEmpty()) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (arr.length > 1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:45:56.907260922 +0100\n+++ /tmp/tmprgwk84rh.java\t2023-03-24 20:45:56.907260922 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:45:58.619253963 +0100\n+++ /tmp/tmpx0gnekva.java\t2023-03-24 20:45:58.619253963 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (Util.check(arr, x, start, mid)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:02.667237515 +0100\n+++ /tmp/tmp8zbmm3o3.java\t2023-03-24 20:46:02.671237501 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (Util.check(arr, x, start, mid)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (Util.check(arr, x, mid)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:04.331230757 +0100\n+++ /tmp/tmp8lg1erjs.java\t2023-03-24 20:46:04.331230757 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (Util.check(arr, x, mid)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:06.023223883 +0100\n+++ /tmp/tmpockhlqsc.java\t2023-03-24 20:46:06.023223883 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (!arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:10.039207576 +0100\n+++ /tmp/tmphhmdeqzn.java\t2023-03-24 20:46:10.039207576 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (arr[mid] > mid) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:11.823200335 +0100\n+++ /tmp/tmp786nwpxd.java\t2023-03-24 20:46:11.823200335 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] > mid) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (arr[mid] == c) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:15.759184363 +0100\n+++ /tmp/tmphmx0_tu8.java\t2023-03-24 20:46:15.759184363 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == c) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (arr[mid] == index) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:17.443177534 +0100\n+++ /tmp/tmp94mtqfx5.java\t2023-03-24 20:46:17.443177534 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == index) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (arr[mid] > mid) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:19.227170295 +0100\n+++ /tmp/tmp1xojpckd.java\t2023-03-24 20:46:19.227170295 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] > mid) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (arr[mid] == mid) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:21.035162964 +0100\n+++ /tmp/tmpnmkrvn2i.java\t2023-03-24 20:46:21.035162964 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == mid) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (!arr.isEmpty()) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:25.151146277 +0100\n+++ /tmp/tmpbmr8m7ut.java\t2023-03-24 20:46:25.151146277 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr.isEmpty()) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:26.883139261 +0100\n+++ /tmp/tmpcjguh6t9.java\t2023-03-24 20:46:26.883139261 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "return binsearch(arr, x, mid, end);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:28.607132272 +0100\n+++ /tmp/tmpx_8o8lpt.java\t2023-03-24 20:46:28.607132272 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+return binsearch(arr, x, mid, end);\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (arr.length == 1) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:32.667115826 +0100\n+++ /tmp/tmp96prdmmk.java\t2023-03-24 20:46:32.667115826 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length == 1) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:36.851098885 +0100\n+++ /tmp/tmpty77ofwh.java\t2023-03-24 20:46:36.851098885 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (arr[mid] == x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:38.567091939 +0100\n+++ /tmp/tmpnn99igs7.java\t2023-03-24 20:46:38.567091939 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:42.611075573 +0100\n+++ /tmp/tmp44_2rf6o.java\t2023-03-24 20:46:42.611075573 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { return true; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (!arr[mid] || mid > end) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:44.267068870 +0100\n+++ /tmp/tmpc5ysde82.java\t2023-03-24 20:46:44.267068870 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] || mid > end) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (!arr[mid] || mid == -1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:45.983061929 +0100\n+++ /tmp/tmpw65a6hfq.java\t2023-03-24 20:46:45.983061929 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] || mid == -1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!arr[mid].isEmpty()) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:47.711054943 +0100\n+++ /tmp/tmpjdfrp2qt.java\t2023-03-24 20:46:47.711054943 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid].isEmpty()) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (arr.length >= start) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:49.431047984 +0100\n+++ /tmp/tmpx4m_n_3w.java\t2023-03-24 20:46:49.435047968 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length >= start) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (!arr[mid] && (mid > end)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:51.143041062 +0100\n+++ /tmp/tmp1onwbnsw.java\t2023-03-24 20:46:51.143041062 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] && (mid > end)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (arr[mid]!= null) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:52.887034013 +0100\n+++ /tmp/tmp6sna3i1n.java\t2023-03-24 20:46:52.891033997 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]!= null) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (LOG.isDebugEnabled()) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:54.643026916 +0100\n+++ /tmp/tmpcsgyrzjs.java\t2023-03-24 20:46:54.647026902 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (LOG.isDebugEnabled()) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { return mid - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:46:56.387019868 +0100\n+++ /tmp/tmp_4u0ve2s.java\t2023-03-24 20:46:56.387019868 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { return mid - 1; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (arr[mid] =='' || mid == '\\r') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:00.467003387 +0100\n+++ /tmp/tmpjb2zn8p7.java\t2023-03-24 20:47:00.467003387 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] =='' || mid == '\\r') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (arr.length >= start) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:02.094996808 +0100\n+++ /tmp/tmp4y6s8f14.java\t2023-03-24 20:47:02.094996808 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length >= start) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (Util.check(mid, x, mid)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:06.050980835 +0100\n+++ /tmp/tmpssi3w_1x.java\t2023-03-24 20:47:06.050980835 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (Util.check(mid, x, mid)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (!arr[mid] & 0xFF) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:07.722974085 +0100\n+++ /tmp/tmp4epg7g8b.java\t2023-03-24 20:47:07.722974085 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] & 0xFF) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (arr[mid] == '+' || mid == '-') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:09.426967210 +0100\n+++ /tmp/tmpt1x0j7ly.java\t2023-03-24 20:47:09.426967210 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == '+' || mid == '-') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (mid >= x && mid < arr.length) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:11.130960331 +0100\n+++ /tmp/tmpev4hbz_8.java\t2023-03-24 20:47:11.130960331 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= x && mid < arr.length) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end); else { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:12.858953358 +0100\n+++ /tmp/tmpxa22_jxj.java\t2023-03-24 20:47:12.882953262 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end); else { return true; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (arr[mid]!= x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:14.590946372 +0100\n+++ /tmp/tmpfyz0w5pc.java\t2023-03-24 20:47:14.590946372 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]!= x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (arr.length == 1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:18.658929964 +0100\n+++ /tmp/tmpi96n3wp3.java\t2023-03-24 20:47:18.658929964 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length == 1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (start > mid) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:20.398922948 +0100\n+++ /tmp/tmp3yha6t3c.java\t2023-03-24 20:47:20.398922948 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (start > mid) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (Util.checkAndFixAccess(arr, x, mid)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:24.278907309 +0100\n+++ /tmp/tmpjvzehzt_.java\t2023-03-24 20:47:24.278907309 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (Util.checkAndFixAccess(arr, x, mid)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (arr[mid] == index) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:26.014900316 +0100\n+++ /tmp/tmp_vopzhg_.java\t2023-03-24 20:47:26.014900316 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == index) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:27.782893189 +0100\n+++ /tmp/tmpruaekvqu.java\t2023-03-24 20:47:27.782893189 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid; } }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (arr.length <= end) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:29.506886243 +0100\n+++ /tmp/tmpy4pqm8em.java\t2023-03-24 20:47:29.506886243 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length <= end) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (arr[mid]!= c) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:33.490870197 +0100\n+++ /tmp/tmp_ed8awh9.java\t2023-03-24 20:47:33.490870197 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]!= c) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (arr[mid]!= null) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:35.130863587 +0100\n+++ /tmp/tmpd8vch49o.java\t2023-03-24 20:47:35.130863587 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]!= null) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (arr[mid] == 11) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:36.986856113 +0100\n+++ /tmp/tmpxvnc_utz.java\t2023-03-24 20:47:36.990856098 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == 11) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (!arr.substring(start, mid)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:41.006839932 +0100\n+++ /tmp/tmpv2gqq28c.java\t2023-03-24 20:47:41.006839932 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr.substring(start, mid)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:42.746832932 +0100\n+++ /tmp/tmp_vvz7qjh.java\t2023-03-24 20:47:42.750832914 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid - 1; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid += 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:46.698817032 +0100\n+++ /tmp/tmp628u2pw7.java\t2023-03-24 20:47:46.698817032 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end); else { return mid += 1; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (end > mid) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:50.618801266 +0100\n+++ /tmp/tmp3x_ydl55.java\t2023-03-24 20:47:50.618801266 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (end > mid) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (arr[mid] == c) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:52.318794432 +0100\n+++ /tmp/tmpzxo8rwa_.java\t2023-03-24 20:47:52.322794415 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == c) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (arr.length > end) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:54.038787516 +0100\n+++ /tmp/tmprm__tld5.java\t2023-03-24 20:47:54.038787516 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > end) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (end > mid) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:47:58.742768611 +0100\n+++ /tmp/tmp4myk34gf.java\t2023-03-24 20:47:58.742768611 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (end > mid) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (arr[mid] > startIndex) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:03.134750966 +0100\n+++ /tmp/tmpws5wzegk.java\t2023-03-24 20:48:03.134750966 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] > startIndex) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (arr.length == 1) return binsearch(arr, x, mid, end); else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:04.854744059 +0100\n+++ /tmp/tmppvcfnzln.java\t2023-03-24 20:48:04.854744059 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length == 1) return binsearch(arr, x, mid, end); else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { throw x = mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:09.350726005 +0100\n+++ /tmp/tmple8go5r4.java\t2023-03-24 20:48:09.350726005 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) { return binsearch(arr, x, mid, end); } else { throw x = mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (y < arr.length) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:10.974719485 +0100\n+++ /tmp/tmpmwkn3sq0.java\t2023-03-24 20:48:10.974719485 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (y < arr.length) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (mid >= start) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:12.458713528 +0100\n+++ /tmp/tmphe8brhka.java\t2023-03-24 20:48:12.458713528 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= start) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (!arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:14.438705582 +0100\n+++ /tmp/tmpycczp62t.java\t2023-03-24 20:48:14.438705582 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid - 1; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (arr[mid] > end) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:16.478697396 +0100\n+++ /tmp/tmp5a1_7pt8.java\t2023-03-24 20:48:16.478697396 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] > end) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (!(_arr[mid] & 0xFF)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:21.870675767 +0100\n+++ /tmp/tmp21v31hfy.java\t2023-03-24 20:48:21.870675767 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!(_arr[mid] & 0xFF)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (arr[mid] == c) { return binsearch(arr, x, mid, end); } else { return c; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:23.630668709 +0100\n+++ /tmp/tmpp3q4narf.java\t2023-03-24 20:48:23.730668308 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == c) { return binsearch(arr, x, mid, end); } else { return c; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!arr[mid] || mid == 0) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:25.654660593 +0100\n+++ /tmp/tmpj1r4l2pa.java\t2023-03-24 20:48:25.654660593 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] || mid == 0) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (mid >= len) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:27.782652062 +0100\n+++ /tmp/tmpfauiowsp.java\t2023-03-24 20:48:27.786652046 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= len) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (!arr[mid] || mid == x) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:30.366641704 +0100\n+++ /tmp/tmpnud805j9.java\t2023-03-24 20:48:30.366641704 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] || mid == x) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (!arr[mid] || mid == c) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:32.526633049 +0100\n+++ /tmp/tmpfsndmlg7.java\t2023-03-24 20:48:32.526633049 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] || mid == c) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (arr[mid]!= x) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:34.694624362 +0100\n+++ /tmp/tmprsqrtkhh.java\t2023-03-24 20:48:34.694624362 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]!= x) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (arr[mid]!= c) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:36.954615308 +0100\n+++ /tmp/tmp3yigcpzp.java\t2023-03-24 20:48:36.954615308 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]!= c) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (arr[mid] =='' || mid == -1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:39.306605887 +0100\n+++ /tmp/tmp4zi4kbfk.java\t2023-03-24 20:48:39.446605327 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] =='' || mid == -1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (arr[mid] == index) { return binsearch(arr, x, mid, end); } else { return index; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:41.578596789 +0100\n+++ /tmp/tmpl5jr3tsz.java\t2023-03-24 20:48:41.578596789 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == index) { return binsearch(arr, x, mid, end); } else { return index; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (arr[mid] == '+' || c == '-') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:43.630588573 +0100\n+++ /tmp/tmp1t834fyn.java\t2023-03-24 20:48:43.762588044 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == '+' || c == '-') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (arr.length > end) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:46.074578788 +0100\n+++ /tmp/tmp4oz7ly18.java\t2023-03-24 20:48:46.074578788 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > end) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (arr[mid] == '>') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:48.310569839 +0100\n+++ /tmp/tmpgmi04cq4.java\t2023-03-24 20:48:48.310569839 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == '>') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (arr[mid] =='' || mid == '-') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:51.130558555 +0100\n+++ /tmp/tmpwyf6hixi.java\t2023-03-24 20:48:51.130558555 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] =='' || mid == '-') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (arr[mid]!= index) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:53.378549560 +0100\n+++ /tmp/tmpvrlgqzaa.java\t2023-03-24 20:48:53.542548905 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]!= index) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (!arr.trim().isEmpty()) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:56.062538824 +0100\n+++ /tmp/tmpsv6ma45t.java\t2023-03-24 20:48:56.062538824 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr.trim().isEmpty()) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (arr[mid] == mid) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:57.710532232 +0100\n+++ /tmp/tmp23s8eb6t.java\t2023-03-24 20:48:57.710532232 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == mid) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (mid >= arr.length) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:48:59.378525561 +0100\n+++ /tmp/tmpib1ka5fh.java\t2023-03-24 20:48:59.378525561 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= arr.length) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (separatorChar >= arr.length) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:01.242518109 +0100\n+++ /tmp/tmpow4uhoqk.java\t2023-03-24 20:49:01.242518109 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (separatorChar >= arr.length) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (!arr[mid] & 0xFF00) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:03.398509489 +0100\n+++ /tmp/tmprmy1uqlm.java\t2023-03-24 20:49:03.398509489 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr[mid] & 0xFF00) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (mid >= x) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:05.978499177 +0100\n+++ /tmp/tmp1dh3a30h.java\t2023-03-24 20:49:06.114498633 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= x) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (start > mid) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:08.606488675 +0100\n+++ /tmp/tmpnuzxgwi3.java\t2023-03-24 20:49:08.614488641 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (start > mid) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (arr.length <= end) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:10.650480506 +0100\n+++ /tmp/tmpz4z15fwm.java\t2023-03-24 20:49:10.650480506 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length <= end) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (arr.length == 1) return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:12.578472804 +0100\n+++ /tmp/tmp157b4x9n.java\t2023-03-24 20:49:12.578472804 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length == 1) return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (arr.length >= end) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:14.694464352 +0100\n+++ /tmp/tmpvmg0fn0j.java\t2023-03-24 20:49:14.806463904 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length >= end) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (y >= arr.length) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:16.774456044 +0100\n+++ /tmp/tmp53l9x6p9.java\t2023-03-24 20:49:16.906455517 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (y >= arr.length) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (arr[mid] == ':' || mid == '-') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:19.550444959 +0100\n+++ /tmp/tmpyqg05hml.java\t2023-03-24 20:49:19.550444959 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == ':' || mid == '-') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (mid > x) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:21.266438108 +0100\n+++ /tmp/tmp6esuvsl1.java\t2023-03-24 20:49:21.266438108 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid > x) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (arr.length < end) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:22.862431737 +0100\n+++ /tmp/tmpxp3_qqw_.java\t2023-03-24 20:49:22.866431721 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length < end) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (! arr[mid]) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:24.650424599 +0100\n+++ /tmp/tmpdx7w955g.java\t2023-03-24 20:49:24.650424599 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (! arr[mid]) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (mid >= end) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:27.158414590 +0100\n+++ /tmp/tmpezebx7zo.java\t2023-03-24 20:49:27.398413632 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= end) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (y < arr.length) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:28.918407567 +0100\n+++ /tmp/tmp63cnsf17.java\t2023-03-24 20:49:28.918407567 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (y < arr.length) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (arr.length >= 3) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:31.022399173 +0100\n+++ /tmp/tmp8kqhu6ja.java\t2023-03-24 20:49:31.142398693 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length >= 3) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (arr.length < 1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:32.910391640 +0100\n+++ /tmp/tmp8n77z793.java\t2023-03-24 20:49:32.970391400 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length < 1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (arr.length >= 1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:34.642384731 +0100\n+++ /tmp/tmpd567c7rl.java\t2023-03-24 20:49:34.666384637 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length >= 1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (!arr.isEmpty()) return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:36.934375591 +0100\n+++ /tmp/tmpzva7qey1.java\t2023-03-24 20:49:36.934375591 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!arr.isEmpty()) return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (arr[mid]) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:38.690368590 +0100\n+++ /tmp/tmpci0djc4q.java\t2023-03-24 20:49:38.690368590 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid]) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (arr.length >= start) return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:40.446361588 +0100\n+++ /tmp/tmpberd8ziy.java\t2023-03-24 20:49:40.446361588 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length >= start) return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (arr.length > 1) return binsearch(arr, x, mid, end);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:42.094355017 +0100\n+++ /tmp/tmp6ru08qnt.java\t2023-03-24 20:49:42.094355017 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr.length > 1) return binsearch(arr, x, mid, end);\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (mid >= 0) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 20:49:43.834348082 +0100\n+++ /tmp/tmpoh5y2vxq.java\t2023-03-24 20:49:43.834348082 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= 0) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return binsearch(arr, x, mid+1, end);"
    },
    "mergesort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (arr.size() <= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:09.310485860 +0100\n+++ /tmp/tmpdlis0t5h.java\t2023-03-24 20:49:10.282481977 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:16.938455389 +0100\n+++ /tmp/tmpx6pe_wdp.java\t2023-03-24 20:49:16.938455389 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:22.538433029 +0100\n+++ /tmp/tmprdx0q4i_.java\t2023-03-24 20:49:22.538433029 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (arr.size() <= 1) { // The range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:28.930407520 +0100\n+++ /tmp/tmppdxdj4an.java\t2023-03-24 20:49:28.930407520 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // The range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (arr.size() == 1 || arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:35.402381702 +0100\n+++ /tmp/tmprk86caiq.java\t2023-03-24 20:49:35.402381702 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (arr.size() <= 1) { // / 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:39.346365973 +0100\n+++ /tmp/tmpjzsp1lx2.java\t2023-03-24 20:49:39.346365973 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // / 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (arr.size() == 1 || arr.size() == 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:43.526349309 +0100\n+++ /tmp/tmpoh6sss99.java\t2023-03-24 20:49:43.526349309 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() == 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (arr.size() <= 1) { // > 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:48.286330339 +0100\n+++ /tmp/tmpshp8ap9n.java\t2023-03-24 20:49:48.286330339 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // > 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (arr.size() == 1 || arr.size() == 5) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:52.806312331 +0100\n+++ /tmp/tmpvg5d5ieb.java\t2023-03-24 20:49:52.806312331 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() == 5) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (arr.size() == 0 || arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:49:57.178294917 +0100\n+++ /tmp/tmp3zywf190.java\t2023-03-24 20:49:57.182294902 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 0 || arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (arr.size() <= 1 in correct version {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:01.406278084 +0100\n+++ /tmp/tmp56yfysnn.java\t2023-03-24 20:50:01.406278084 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (arr.size() <= 1 in correct version(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:03.150271140 +0100\n+++ /tmp/tmpv2_qm9vs.java\t2023-03-24 20:50:03.150271140 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (arr.size() == 1) { // The range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:04.826264469 +0100\n+++ /tmp/tmprz99pl11.java\t2023-03-24 20:50:04.826264469 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { // The range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (arr.size() <= 1 in correct version) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:09.030247739 +0100\n+++ /tmp/tmp4w8n2673.java\t2023-03-24 20:50:09.030247739 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if ((arr.size() == 1) && (arr.size() <= 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:10.742240927 +0100\n+++ /tmp/tmpwjp0_u1l.java\t2023-03-24 20:50:10.742240927 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if ((arr.size() == 1) && (arr.size() <= 1)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (arr.size() <= 1) { // this is not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:14.886224442 +0100\n+++ /tmp/tmpu9i4vrue.java\t2023-03-24 20:50:14.890224426 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // this is not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (arr.size() <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:19.226207181 +0100\n+++ /tmp/tmpcp_g31zm.java\t2023-03-24 20:50:19.226207181 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (arr.size() > 1) { // The range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:20.930200405 +0100\n+++ /tmp/tmpuegt8tnc.java\t2023-03-24 20:50:20.930200405 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1) { // The range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (arr.size() > 1 || arr.contains(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:25.094183852 +0100\n+++ /tmp/tmpr7ji_ogr.java\t2023-03-24 20:50:25.094183852 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1 || arr.contains(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (arr.size() >= arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:29.218167462 +0100\n+++ /tmp/tmpd2ywtg_a.java\t2023-03-24 20:50:29.222167445 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() >= arr.size()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (arr.size() > 1) { // / 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:33.494150471 +0100\n+++ /tmp/tmpqu6fb5ih.java\t2023-03-24 20:50:33.494150471 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1) { // / 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (arr.size() == 1 && arr.contains(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:37.622134074 +0100\n+++ /tmp/tmpr9dhyoh0.java\t2023-03-24 20:50:37.622134074 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 && arr.contains(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (arr.size() == 1 || arr.contains(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:42.054116474 +0100\n+++ /tmp/tmpg98j52g8.java\t2023-03-24 20:50:42.058116456 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.contains(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (arr.size() == 1 || arr.iterator().hasNext()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:46.186100068 +0100\n+++ /tmp/tmpix8ag2ch.java\t2023-03-24 20:50:46.186100068 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.iterator().hasNext()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (arr.size() <= 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:50.414083287 +0100\n+++ /tmp/tmp9n_2xmje.java\t2023-03-24 20:50:50.414083287 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (arr.size() > 1 && arr.contains(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:52.166076333 +0100\n+++ /tmp/tmp40v8p9le.java\t2023-03-24 20:50:52.170076317 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1 && arr.contains(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (arr.size() <= 1) { // && c > 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:50:56.402059526 +0100\n+++ /tmp/tmp56bf1zx1.java\t2023-03-24 20:50:56.406059510 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // && c > 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (arr.size() <= 1) { // <= 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:00.362043819 +0100\n+++ /tmp/tmp9xx2dqlx.java\t2023-03-24 20:51:00.362043819 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // <= 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (arr.size() % 2 || arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:04.582027082 +0100\n+++ /tmp/tmpvmps08o3.java\t2023-03-24 20:51:04.582027082 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() % 2 || arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (arr.size() == 1) { // / 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:06.422019787 +0100\n+++ /tmp/tmp0g93jlxd.java\t2023-03-24 20:51:06.422019787 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { // / 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if ((arr.size() == 1) && (arr.size() == 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:10.430003898 +0100\n+++ /tmp/tmpt1hqkww1.java\t2023-03-24 20:51:10.430003898 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if ((arr.size() == 1) && (arr.size() == 1)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (arr.size()!= arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:14.525987664 +0100\n+++ /tmp/tmpnscvoerj.java\t2023-03-24 20:51:14.525987664 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size()!= arr.size()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (arr.size() > 1) { // this is not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:19.681967235 +0100\n+++ /tmp/tmpypw3mxk3.java\t2023-03-24 20:51:19.681967235 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1) { // this is not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (arr.size() <= 1 || arr.contains(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:25.601943787 +0100\n+++ /tmp/tmphf0ecnfg.java\t2023-03-24 20:51:25.601943787 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 || arr.contains(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (arr.size() == 1 || arr.size() == 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:30.757923369 +0100\n+++ /tmp/tmpafp72s2d.java\t2023-03-24 20:51:30.757923369 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() == 1)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (arr.size() == 1 || arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:32.369916987 +0100\n+++ /tmp/tmp71pw6sad.java\t2023-03-24 20:51:32.369916987 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (arr.size() == 1 || arr.equals(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:37.477896767 +0100\n+++ /tmp/tmpjqcamje7.java\t2023-03-24 20:51:37.481896752 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.equals(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (arr.size() == 1) { // > 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:41.773879768 +0100\n+++ /tmp/tmpwl78nnbn.java\t2023-03-24 20:51:41.773879768 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { // > 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (arr.size() > 1 || arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:46.045862867 +0100\n+++ /tmp/tmpnpwy3g3i.java\t2023-03-24 20:51:46.049862851 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1 || arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (arr.size() <= 1) { // for 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:51.809840070 +0100\n+++ /tmp/tmpxh8d4sye.java\t2023-03-24 20:51:51.821840021 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // for 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (arr.size() <= 1) { // not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:51:55.869824014 +0100\n+++ /tmp/tmpy3byt33z.java\t2023-03-24 20:51:55.873823999 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (arr.size() == 1 && correct version.contains(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:00.801804518 +0100\n+++ /tmp/tmpieul4ie9.java\t2023-03-24 20:52:00.801804518 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 && correct version.contains(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (arr.size() == 2 || arr.size() == 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:03.629793340 +0100\n+++ /tmp/tmph07mgfjc.java\t2023-03-24 20:52:03.629793340 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 2 || arr.size() == 3) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (arr.size() == 0 || arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:10.097767783 +0100\n+++ /tmp/tmpxkugiaeh.java\t2023-03-24 20:52:10.097767783 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 0 || arr.size() > 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (arr.size() == 1 && arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:14.801749201 +0100\n+++ /tmp/tmpocowfr67.java\t2023-03-24 20:52:14.805749185 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 && arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (arr.size() <= 2 || arr.size() > 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:18.341735221 +0100\n+++ /tmp/tmpiowg0ys2.java\t2023-03-24 20:52:18.341735221 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 2 || arr.size() > 3) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (arr.size() <= 1) { // at correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:22.997716837 +0100\n+++ /tmp/tmpl3yolz7a.java\t2023-03-24 20:52:23.025716726 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // at correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (arr.size() <= 1) { // The range range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:27.805697857 +0100\n+++ /tmp/tmpevcwsw1q.java\t2023-03-24 20:52:27.809697841 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // The range range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (arr.size() == 1 || arr.size() == 4) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:52:51.833603074 +0100\n+++ /tmp/tmptsz2qmix.java\t2023-03-24 20:52:51.833603074 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() == 4) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (arr.size() <= 1) { // && len > 2 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:53:14.241514783 +0100\n+++ /tmp/tmphz__ic1f.java\t2023-03-24 20:53:14.241514783 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // && len > 2 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (arr.size() == 1) { // this is not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:53:35.689430359 +0100\n+++ /tmp/tmpz1o1d39m.java\t2023-03-24 20:53:35.689430359 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { // this is not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (arr.size() <= 1) { // {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:53:55.897350891 +0100\n+++ /tmp/tmpn_vby60o.java\t2023-03-24 20:53:55.897350891 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if ((arr.size() == 1) && (arr.size() > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:54:15.997271916 +0100\n+++ /tmp/tmpwu4g90oq.java\t2023-03-24 20:54:15.997271916 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if ((arr.size() == 1) && (arr.size() > 1)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (arr.size() == 1) { // The range range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:54:34.321199975 +0100\n+++ /tmp/tmpc6ks6amh.java\t2023-03-24 20:54:34.321199975 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { // The range range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (arr.size() <= 1 in correct version && arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:54:50.133137940 +0100\n+++ /tmp/tmpzkpd9am6.java\t2023-03-24 20:54:50.133137940 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version && arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (arr.size() <= 1 || arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:54:55.885115384 +0100\n+++ /tmp/tmp3z3ft6vz.java\t2023-03-24 20:54:55.889115368 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 || arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (arr.size() <= 1) { // len len correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:55:10.501058087 +0100\n+++ /tmp/tmp224pengf.java\t2023-03-24 20:55:10.501058087 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // len len correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (arr.size() == 2 || arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:55:24.821001981 +0100\n+++ /tmp/tmpxr5gx__3.java\t2023-03-24 20:55:24.821001981 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 2 || arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (arr.size() > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:55:38.520948330 +0100\n+++ /tmp/tmp9knp3qf8.java\t2023-03-24 20:55:38.520948330 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (arr.size() <= 1) { // && p.getValue() > 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:55:43.912927222 +0100\n+++ /tmp/tmp4v83ncoc.java\t2023-03-24 20:55:43.912927222 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // && p.getValue() > 1);\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (arr.size() > 1) { // The range range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:55:57.336874689 +0100\n+++ /tmp/tmpjlaqrzx2.java\t2023-03-24 20:55:57.336874689 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1) { // The range range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (arr.size() < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:56:08.984829126 +0100\n+++ /tmp/tmpg9brdwhc.java\t2023-03-24 20:56:08.988829110 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() < 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (arr.size() <= 1) { // this is at correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:56:20.104785644 +0100\n+++ /tmp/tmpzj_w8uif.java\t2023-03-24 20:56:20.104785644 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // this is at correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (arr.size() > 1 || arr.size() > 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:56:30.116746507 +0100\n+++ /tmp/tmpml04xbws.java\t2023-03-24 20:56:30.116746507 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1 || arr.size() > 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (arr.size() <= 1 in correct version;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:56:39.648709260 +0100\n+++ /tmp/tmpa6dh9f8g.java\t2023-03-24 20:56:39.648709260 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version;\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (arr.size() == 1 || arr.size() > 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:56:42.992696195 +0100\n+++ /tmp/tmp_3_35mv7.java\t2023-03-24 20:56:42.996696179 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() > 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (arr.size() <= 1) { // candidates",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:56:50.724665992 +0100\n+++ /tmp/tmpbmyxsbj2.java\t2023-03-24 20:56:50.728665976 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // candidates\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (arr.size() == 0 || arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:56:56.776642356 +0100\n+++ /tmp/tmpegl1fun_.java\t2023-03-24 20:56:56.776642356 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 0 || arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (arr.size() <= 2 || arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:04.460612355 +0100\n+++ /tmp/tmpwoocv8gn.java\t2023-03-24 20:57:04.464612339 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 2 || arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (arr.size() <= 1)) { // The range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:10.312589507 +0100\n+++ /tmp/tmppklvd9gh.java\t2023-03-24 20:57:10.312589507 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1)) { // The range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (arr.size() > 1 || arr.size() == 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:12.224582044 +0100\n+++ /tmp/tmpgui2cdod.java\t2023-03-24 20:57:12.224582044 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1 || arr.size() == 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (arr.size() <= 1) { // this is not the right range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:16.948563608 +0100\n+++ /tmp/tmp652ykdfw.java\t2023-03-24 20:57:16.948563608 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // this is not the right range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (arr.size() <= 1 in correct version = arr.iterator();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:21.556545626 +0100\n+++ /tmp/tmpadm_n9jw.java\t2023-03-24 20:57:21.556545626 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version = arr.iterator();\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (arr.size() % 2 || arr.size() == 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:23.628537542 +0100\n+++ /tmp/tmpcmh5itho.java\t2023-03-24 20:57:23.628537542 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() % 2 || arr.size() == 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (arr.size() <= 1) { // && c.size() > 2",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:25.736529317 +0100\n+++ /tmp/tmpkfy4ifrz.java\t2023-03-24 20:57:25.736529317 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // && c.size() > 2\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (arr.size() <= 1 in correct version(arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:30.796509575 +0100\n+++ /tmp/tmp37uso12k.java\t2023-03-24 20:57:30.800509560 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1 in correct version(arr) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (arr.size() == 1) { // {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:32.820501680 +0100\n+++ /tmp/tmpbkdzoz8a.java\t2023-03-24 20:57:32.824501664 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { // {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (arr.size() == 1 || arr.isEmpty()) { // The range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:37.272484314 +0100\n+++ /tmp/tmpocc_2y8n.java\t2023-03-24 20:57:37.272484314 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.isEmpty()) { // The range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (arr.size() == 2) { // The range",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:41.820466576 +0100\n+++ /tmp/tmp25x08356.java\t2023-03-24 20:57:41.820466576 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 2) { // The range\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (arr.size() <= 1) { // x at least",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:46.436448575 +0100\n+++ /tmp/tmpf5r8f_5i.java\t2023-03-24 20:57:46.436448575 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // x at least\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (arr.size() <= 1) { // at least",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:51.000430778 +0100\n+++ /tmp/tmp4t5j4qm9.java\t2023-03-24 20:57:51.000430778 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // at least\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (arr.size()!= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:55.468413361 +0100\n+++ /tmp/tmpbvieketm.java\t2023-03-24 20:57:55.468413361 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size()!= 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (arr.size() <= 1) { // the correct version number",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:57:59.940395928 +0100\n+++ /tmp/tmppvjpo9sr.java\t2023-03-24 20:57:59.944395912 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // the correct version number\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (arr.size() == 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:04.128379604 +0100\n+++ /tmp/tmpnphdu_v_.java\t2023-03-24 20:58:04.128379604 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (arr.size() <= 1) { // && c == 2",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:08.284363407 +0100\n+++ /tmp/tmp4a3in63y.java\t2023-03-24 20:58:08.284363407 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // && c == 2\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (arr.size() == len - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:12.532346852 +0100\n+++ /tmp/tmphq5ak9x2.java\t2023-03-24 20:58:12.536346836 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == len - 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (arr.size() % 2!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:14.348339776 +0100\n+++ /tmp/tmp3mz6mpi5.java\t2023-03-24 20:58:14.348339776 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() % 2!= 0) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (arr.size() <= 1) { // && correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:18.660322977 +0100\n+++ /tmp/tmp04i8kveo.java\t2023-03-24 20:58:18.660322977 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { // && correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (arr.size() <= 1) { //",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:22.660307392 +0100\n+++ /tmp/tmpc7k9j17h.java\t2023-03-24 20:58:22.664307376 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { //\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (arr.size() == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:26.920290799 +0100\n+++ /tmp/tmpow201dbb.java\t2023-03-24 20:58:26.920290799 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 0) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (arr.size() == 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:31.212274082 +0100\n+++ /tmp/tmpkjah9jf9.java\t2023-03-24 20:58:31.212274082 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (\"arr\".equals(arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:32.952267303 +0100\n+++ /tmp/tmpyieawgt7.java\t2023-03-24 20:58:32.956267290 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (\"arr\".equals(arr)) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (arr.size()!= 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:37.260250527 +0100\n+++ /tmp/tmp551h46c_.java\t2023-03-24 20:58:37.260250527 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size()!= 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:41.548233831 +0100\n+++ /tmp/tmpg8znhz8f.java\t2023-03-24 20:58:41.548233831 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.isEmpty()) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (arr.size() == 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:45.644217882 +0100\n+++ /tmp/tmpcb3s713x.java\t2023-03-24 20:58:45.644217882 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1;\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (arr.length <= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:47.480210734 +0100\n+++ /tmp/tmpmi_lxrk7.java\t2023-03-24 20:58:47.480210734 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.length <= 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (arr.size() <= 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:49.340203494 +0100\n+++ /tmp/tmp0292f951.java\t2023-03-24 20:58:49.340203494 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1;\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (arr == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:51.116196579 +0100\n+++ /tmp/tmppcy41n71.java\t2023-03-24 20:58:51.116196579 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr == null) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:55.332180168 +0100\n+++ /tmp/tmpyqscb119.java\t2023-03-24 20:58:55.332180168 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (arr.size();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 20:58:57.096173302 +0100\n+++ /tmp/tmpoxzf0auj.java\t2023-03-24 20:58:57.096173302 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size();\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (arr.size() <= 1) { // <= 1 in correct version"
    },
    "longest_common_subsequence": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "return a.substring(1) + longest_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:49:49.306326274 +0100\n+++ /tmp/tmpfh6vs_z_.java\t2023-03-24 20:49:49.362326052 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + longest_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "return a.charAt(0) + longest_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:49:53.498309574 +0100\n+++ /tmp/tmphentd6sr.java\t2023-03-24 20:49:53.498309574 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "return a.charAt(1) + longest_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:49:57.514293579 +0100\n+++ /tmp/tmpqis8aoqq.java\t2023-03-24 20:49:57.514293579 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(1) + longest_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "return a.substring(1 + longest_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:01.458277876 +0100\n+++ /tmp/tmps4qhag08.java\t2023-03-24 20:50:01.458277876 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1 + longest_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:03.122271252 +0100\n+++ /tmp/tmp468rzg2p.java\t2023-03-24 20:50:03.122271252 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "return a.substring(0) + longest_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:04.786264629 +0100\n+++ /tmp/tmp9liw8b1p.java\t2023-03-24 20:50:04.786264629 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0) + longest_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "return a.substring(1) + verifier_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:09.038247708 +0100\n+++ /tmp/tmpn2p5jbl9.java\t2023-03-24 20:50:09.038247708 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + verifier_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "return a.substring(1) +AttributeSet_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:10.758240864 +0100\n+++ /tmp/tmpd2c0w24h.java\t2023-03-24 20:50:10.758240864 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +AttributeSet_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "return a.charAt(0) +ham_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:12.522233844 +0100\n+++ /tmp/tmpenrv6g4u.java\t2023-03-24 20:50:12.522233844 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) +ham_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "return a.charAt(0) + verifier_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:14.326226669 +0100\n+++ /tmp/tmpjfjeqdvl.java\t2023-03-24 20:50:14.326226669 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + verifier_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "return a.substring(1) +ham_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:15.982220083 +0100\n+++ /tmp/tmp3ipq4is2.java\t2023-03-24 20:50:15.982220083 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +ham_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "return a.substring(1) +irection_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:17.706213227 +0100\n+++ /tmp/tmpqeloyna6.java\t2023-03-24 20:50:17.706213227 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +irection_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "return a.substring(1) + composed_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:19.454206274 +0100\n+++ /tmp/tmpo03w0ms4.java\t2023-03-24 20:50:19.454206274 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + composed_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "return a.substring(1) +286_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:21.138199579 +0100\n+++ /tmp/tmpzpjcorf4.java\t2023-03-24 20:50:21.138199579 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +286_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "return a.substring(1) + missed_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:22.806192947 +0100\n+++ /tmp/tmplvt1g07t.java\t2023-03-24 20:50:22.810192931 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + missed_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "return a.substring(1) + LineString_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:24.558185982 +0100\n+++ /tmp/tmpe3nj_9da.java\t2023-03-24 20:50:24.562185966 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + LineString_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "return a.substring(1) +\u56fd_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:26.262179210 +0100\n+++ /tmp/tmpavl8kdph.java\t2023-03-24 20:50:26.262179210 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +\u56fd_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "return a.charAt(0) +AttributeSet_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:28.046172119 +0100\n+++ /tmp/tmp4_tvfhvt.java\t2023-03-24 20:50:28.046172119 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) +AttributeSet_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "return a.substring(1) + remains_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:29.826165045 +0100\n+++ /tmp/tmpgxmszo7u.java\t2023-03-24 20:50:29.830165030 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + remains_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "return a.substring(1) +channels_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:31.558158163 +0100\n+++ /tmp/tmp114tribp.java\t2023-03-24 20:50:31.558158163 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +channels_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "return a.substring(1) + [];_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:33.410150806 +0100\n+++ /tmp/tmp41ymhucm.java\t2023-03-24 20:50:33.410150806 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + [];_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "return a.charAt(0) + [];_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:35.070144210 +0100\n+++ /tmp/tmpd6j7azcl.java\t2023-03-24 20:50:35.070144210 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + [];_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "return a.substring(1) +Substitution_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:36.754137521 +0100\n+++ /tmp/tmpzsmdzviv.java\t2023-03-24 20:50:36.758137505 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +Substitution_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "return a.charAt(0) + LineString_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:38.570130309 +0100\n+++ /tmp/tmp8t6n3zka.java\t2023-03-24 20:50:38.574130293 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + LineString_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "return a.substring(1) +tilEST_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:40.246123652 +0100\n+++ /tmp/tmpvo2yu6cr.java\t2023-03-24 20:50:40.246123652 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +tilEST_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "return a.charAt(0) +Substitution_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:42.042116521 +0100\n+++ /tmp/tmp8mvy416l.java\t2023-03-24 20:50:42.042116521 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) +Substitution_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "return a.charAt(0) +irection_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:43.838109390 +0100\n+++ /tmp/tmppi9o6pgd.java\t2023-03-24 20:50:43.842109374 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) +irection_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "return a.substring(1) +friend_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:45.634102259 +0100\n+++ /tmp/tmplkau953q.java\t2023-03-24 20:50:45.638102243 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +friend_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "return a.substring(1) +CONN_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:47.374095352 +0100\n+++ /tmp/tmp73cu_sum.java\t2023-03-24 20:50:47.374095352 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +CONN_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "return a.charAt(0) + missed_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:49.234087970 +0100\n+++ /tmp/tmp5zjxisij.java\t2023-03-24 20:50:49.234087970 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + missed_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "return a.substring(1) + JTextArea_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:50.922081270 +0100\n+++ /tmp/tmp90vg8h0y.java\t2023-03-24 20:50:50.922081270 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + JTextArea_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "return a.substring(1) +ToDate_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:52.614074556 +0100\n+++ /tmp/tmpoo2omjas.java\t2023-03-24 20:50:52.638074461 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +ToDate_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "return a.substring(1) + exiting_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:54.326067762 +0100\n+++ /tmp/tmp_doz8726.java\t2023-03-24 20:50:54.326067762 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + exiting_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "return a.substring(1) + selectedItem_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:56.142060558 +0100\n+++ /tmp/tmpeq9yybl2.java\t2023-03-24 20:50:56.146060542 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + selectedItem_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "return a.charAt(0) + passwords_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:57.838053829 +0100\n+++ /tmp/tmpz377obln.java\t2023-03-24 20:50:57.838053829 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + passwords_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "return a.substring(1) + ksession_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:50:59.654046626 +0100\n+++ /tmp/tmpdch32qod.java\t2023-03-24 20:50:59.658046611 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + ksession_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "return a.substring(1) +tbl_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:01.386039758 +0100\n+++ /tmp/tmp7qp9dchg.java\t2023-03-24 20:51:01.386039758 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +tbl_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "return a.substring(1) + Hopefully_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:03.070033079 +0100\n+++ /tmp/tmp8srtj8sf.java\t2023-03-24 20:51:03.070033079 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + Hopefully_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "return a.substring(1) + Fragment_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:04.718026543 +0100\n+++ /tmp/tmp64h4bb8y.java\t2023-03-24 20:51:04.722026527 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + Fragment_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "return a.substring(1) +ForUser_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:06.510019438 +0100\n+++ /tmp/tmpia679y3v.java\t2023-03-24 20:51:06.514019423 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +ForUser_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "return a.charAt(0) + asynchronous_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:08.258012509 +0100\n+++ /tmp/tmp5vzv6jay.java\t2023-03-24 20:51:08.258012509 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + asynchronous_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "return a.substring(1) +rolling_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:10.010005563 +0100\n+++ /tmp/tmpxjeqmz_g.java\t2023-03-24 20:51:10.010005563 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +rolling_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "return a.substring(1) + shorthand_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:11.793998492 +0100\n+++ /tmp/tmpe3mj3ugt.java\t2023-03-24 20:51:11.825998365 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + shorthand_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "return a.substring(1) +mc_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:13.601991325 +0100\n+++ /tmp/tmpogz3hk3_.java\t2023-03-24 20:51:13.605991310 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +mc_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "return a.charAt(0 + longest_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:15.385984256 +0100\n+++ /tmp/tmpue3pjxrm.java\t2023-03-24 20:51:15.385984256 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0 + longest_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "return a.substring(1) + asynchronous_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:16.853978440 +0100\n+++ /tmp/tmp80grpcr8.java\t2023-03-24 20:51:16.857978424 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + asynchronous_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "return a.substring(1) +criptive_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:19.133969405 +0100\n+++ /tmp/tmp01u3zo2v.java\t2023-03-24 20:51:19.229969025 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +criptive_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "return a.substring(1) + validated_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:21.153961404 +0100\n+++ /tmp/tmp3b0nai6_.java\t2023-03-24 20:51:21.153961404 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + validated_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(3), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:23.873950630 +0100\n+++ /tmp/tmphz0uqhb1.java\t2023-03-24 20:51:23.993950154 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(3), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "return a.substring(1) + longest_common_subsequence(a.substring(2), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:25.513944135 +0100\n+++ /tmp/tmp83e9ev6x.java\t2023-03-24 20:51:25.513944135 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + longest_common_subsequence(a.substring(2), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "return a.substring(1) +Compaction_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:30.189925617 +0100\n+++ /tmp/tmpjsnyynsd.java\t2023-03-24 20:51:30.321925095 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +Compaction_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "return a.substring(0, b.length() - 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:32.273917367 +0100\n+++ /tmp/tmp_16v0lz_.java\t2023-03-24 20:51:32.333917129 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - 2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "return a.substring(1) +=0_common_subsequence(a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:36.525900536 +0100\n+++ /tmp/tmp55746h5x.java\t2023-03-24 20:51:36.525900536 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +=0_common_subsequence(a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(2), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:39.173890057 +0100\n+++ /tmp/tmpmuzj5a86.java\t2023-03-24 20:51:39.265889692 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(2), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "return a.substring(1) + longest_common_subsequence(a.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:41.213881983 +0100\n+++ /tmp/tmpgdy55lko.java\t2023-03-24 20:51:41.217881968 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + longest_common_subsequence(a.substring(1));\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "return a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:43.349873532 +0100\n+++ /tmp/tmpp5eucu9e.java\t2023-03-24 20:51:43.349873532 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "return a.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:45.969863166 +0100\n+++ /tmp/tmpymtlz1f1.java\t2023-03-24 20:51:45.969863166 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a, b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:51.101842868 +0100\n+++ /tmp/tmpucsysrui.java\t2023-03-24 20:51:51.101842868 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a, b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(3));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:53.353833963 +0100\n+++ /tmp/tmptlbs_j1u.java\t2023-03-24 20:51:53.353833963 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(3));\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:55.345826086 +0100\n+++ /tmp/tmpplh9mmhc.java\t2023-03-24 20:51:55.481825548 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(1));\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "return a.substring(0, b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:51:57.653816962 +0100\n+++ /tmp/tmpc3wf693o.java\t2023-03-24 20:51:57.773816488 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "return a.substring(0, b.length() - b.length());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:01.633801229 +0100\n+++ /tmp/tmpyyhw5_5a.java\t2023-03-24 20:52:01.653801151 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - b.length());\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "return a.charAt(0) + longest_common_subsequence(a.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:06.469782118 +0100\n+++ /tmp/tmpnd187qel.java\t2023-03-24 20:52:06.469782118 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + longest_common_subsequence(a.substring(1));\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "return a.substring(0, b.length() - a.length());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:08.321774800 +0100\n+++ /tmp/tmpo4xjil5j.java\t2023-03-24 20:52:08.377774579 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - a.length());\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "return a.substring(0, a.length() - b.length());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:12.305759060 +0100\n+++ /tmp/tmpxi6zghda.java\t2023-03-24 20:52:12.305759060 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, a.length() - b.length());\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "return a.charAt(a.length() - 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:17.577738238 +0100\n+++ /tmp/tmpsog4_7k1.java\t2023-03-24 20:52:17.577738238 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(a.length() - 2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "return a.substring(1).toLowerCase();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:20.033728540 +0100\n+++ /tmp/tmpc4x15nl1.java\t2023-03-24 20:52:20.033728540 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1).toLowerCase();\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "return a.substring(1) + longest_common_subsequence(a.substring(1) + b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:23.989712921 +0100\n+++ /tmp/tmp2igx62je.java\t2023-03-24 20:52:23.989712921 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + longest_common_subsequence(a.substring(1) + b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "return a.substring(1, b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:25.601706557 +0100\n+++ /tmp/tmp5jplkmga.java\t2023-03-24 20:52:25.601706557 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1, b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "return a.subsequence(b.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:39.361652258 +0100\n+++ /tmp/tmppg78sy92.java\t2023-03-24 20:52:39.361652258 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.subsequence(b.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(1) + \"0\";",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:51.045606180 +0100\n+++ /tmp/tmpihkdprem.java\t2023-03-24 20:52:51.045606180 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(1) + \"0\";\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(1) + \"0\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:52:59.705572046 +0100\n+++ /tmp/tmpk9lscdmo.java\t2023-03-24 20:52:59.705572046 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(1) + \"0\");\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "return a.substring(1) + longest_common_subsequence(a.substring(1), b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:53:08.717536539 +0100\n+++ /tmp/tmpu0t2zl7e.java\t2023-03-24 20:53:08.717536539 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + longest_common_subsequence(a.substring(1), b); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "return a.charAt(0) + longest_common_subsequence(a.substring(1), b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:53:16.777504796 +0100\n+++ /tmp/tmpqry1h_au.java\t2023-03-24 20:53:16.777504796 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + longest_common_subsequence(a.substring(1), b); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "return a.substring(2 + longest_common_subsequence(a.substring(3)) - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:53:24.617473931 +0100\n+++ /tmp/tmpc0hecz70.java\t2023-03-24 20:53:24.617473931 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + longest_common_subsequence(a.substring(3)) - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "return a.substring(1) +20, b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:53:33.677438276 +0100\n+++ /tmp/tmpzvfvxajy.java\t2023-03-24 20:53:33.681438260 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +20, b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "return a.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:53:41.693406741 +0100\n+++ /tmp/tmpke6al8d8.java\t2023-03-24 20:53:41.745406536 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "return a.toLowerCase(Locale.US);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:54:00.841331458 +0100\n+++ /tmp/tmpfe5j392e.java\t2023-03-24 20:54:00.841331458 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.toLowerCase(Locale.US);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "return a.charAt(0) +zoneId;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:54:19.665257511 +0100\n+++ /tmp/tmpf55c03m4.java\t2023-03-24 20:54:19.665257511 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) +zoneId;\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "return a.substring(1) +zoneId;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:54:27.349227341 +0100\n+++ /tmp/tmprvuxsxm4.java\t2023-03-24 20:54:27.349227341 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) +zoneId;\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "return a.substring(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:54:34.917197636 +0100\n+++ /tmp/tmphwknup6i.java\t2023-03-24 20:54:34.917197636 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(3);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "return a.charAt(0.0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:54:50.509136465 +0100\n+++ /tmp/tmps2af7j05.java\t2023-03-24 20:54:50.517136434 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0.0);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "return a.substring(4);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:54:56.549112780 +0100\n+++ /tmp/tmpkybpzmkf.java\t2023-03-24 20:54:56.549112780 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(4);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "return a.charAt(0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:10.661057460 +0100\n+++ /tmp/tmpin_quxls.java\t2023-03-24 20:55:10.661057460 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "return a.substring(1) + baseline;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:16.269035483 +0100\n+++ /tmp/tmpdy9k8kzt.java\t2023-03-24 20:55:16.269035483 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + baseline;\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "return a.charAt(offset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:22.441011304 +0100\n+++ /tmp/tmptny_hx65.java\t2023-03-24 20:55:22.453011257 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(offset);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "return a.charAt(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:28.464987708 +0100\n+++ /tmp/tmp3s62n7cx.java\t2023-03-24 20:55:28.464987708 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(3);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "return a.substring(1) + tagName;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:34.424964369 +0100\n+++ /tmp/tmp1y9u612x.java\t2023-03-24 20:55:34.424964369 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + tagName;\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "return a.charAt(13);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:40.172941863 +0100\n+++ /tmp/tmp2q1fgbfw.java\t2023-03-24 20:55:40.172941863 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(13);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "return a.substring(offset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:46.012919003 +0100\n+++ /tmp/tmpf6wdg3a0.java\t2023-03-24 20:55:46.012919003 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(offset);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "return a.charAt(0.0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:51.652896930 +0100\n+++ /tmp/tmpl3j5la3l.java\t2023-03-24 20:55:51.652896930 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0.0;\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "return a.substring(13);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:55:56.816876724 +0100\n+++ /tmp/tmpizdns35w.java\t2023-03-24 20:55:56.816876724 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(13);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return a.charAt(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:07.944833193 +0100\n+++ /tmp/tmpv7jmafj8.java\t2023-03-24 20:56:07.944833193 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "return a.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:12.028817222 +0100\n+++ /tmp/tmpurav9h88.java\t2023-03-24 20:56:12.028817222 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "return a.substring(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:22.672775603 +0100\n+++ /tmp/tmp9zfplrkt.java\t2023-03-24 20:56:22.672775603 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(3);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "return a.substring(0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:31.600740708 +0100\n+++ /tmp/tmpk35p9dyv.java\t2023-03-24 20:56:31.600740708 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "return a.charAt(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:39.968708009 +0100\n+++ /tmp/tmpkl9iz46y.java\t2023-03-24 20:56:39.968708009 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:43.460694367 +0100\n+++ /tmp/tmptlktp8t3.java\t2023-03-24 20:56:43.464694351 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a;\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "return a);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:51.040664758 +0100\n+++ /tmp/tmpn9s2d6hu.java\t2023-03-24 20:56:51.040664758 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return a",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 20:56:53.732654244 +0100\n+++ /tmp/tmpagao69th.java\t2023-03-24 20:56:53.732654244 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));"
    },
    "lcs_length": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:07.888598971 +0100\n+++ /tmp/tmpxjuaxtoj.java\t2023-03-24 20:57:07.924598831 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:09.968590852 +0100\n+++ /tmp/tmp97au1g6e.java\t2023-03-24 20:57:09.968590852 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:11.796583715 +0100\n+++ /tmp/tmpy2j8k9uh.java\t2023-03-24 20:57:11.796583715 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:13.660576442 +0100\n+++ /tmp/tmp013vvome.java\t2023-03-24 20:57:13.660576442 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:15.524569166 +0100\n+++ /tmp/tmpobylrol8.java\t2023-03-24 20:57:15.524569166 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:17.616561000 +0100\n+++ /tmp/tmp4zw9m0aj.java\t2023-03-24 20:57:17.616561000 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:19.708552837 +0100\n+++ /tmp/tmpbirmy20r.java\t2023-03-24 20:57:19.708552837 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:21.624545360 +0100\n+++ /tmp/tmpbn2l7csb.java\t2023-03-24 20:57:21.624545360 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:26.172527615 +0100\n+++ /tmp/tmpksbaod3n.java\t2023-03-24 20:57:26.172527615 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:28.056520263 +0100\n+++ /tmp/tmpl5ruvc_n.java\t2023-03-24 20:57:28.056520263 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1);\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:32.872501477 +0100\n+++ /tmp/tmp75cwkg7s.java\t2023-03-24 20:57:32.872501477 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:34.728494238 +0100\n+++ /tmp/tmpcuisrl26.java\t2023-03-24 20:57:34.732494222 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:36.548487136 +0100\n+++ /tmp/tmpqywq8ru9.java\t2023-03-24 20:57:36.548487136 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:38.528479415 +0100\n+++ /tmp/tmpxiurmreh.java\t2023-03-24 20:57:38.532479399 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (dp.containsKey(i1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:40.428472004 +0100\n+++ /tmp/tmpvdcy69j9.java\t2023-03-24 20:57:40.432471988 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:42.168465219 +0100\n+++ /tmp/tmpx1ewg5n7.java\t2023-03-24 20:57:42.172465203 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j - 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:43.968458199 +0100\n+++ /tmp/tmp63ie3tne.java\t2023-03-24 20:57:43.968458199 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (dp.get(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:45.796451069 +0100\n+++ /tmp/tmpwadhc8fj.java\t2023-03-24 20:57:45.800451056 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.get(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (dp.containsKey(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:47.592444068 +0100\n+++ /tmp/tmpiovh8xg5.java\t2023-03-24 20:57:47.592444068 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:49.508436598 +0100\n+++ /tmp/tmpdb5b86ay.java\t2023-03-24 20:57:49.508436598 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:51.368429345 +0100\n+++ /tmp/tmp4iuund7h.java\t2023-03-24 20:57:51.372429329 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (dp.containsKey(i-1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:53.168422327 +0100\n+++ /tmp/tmpuz5vclpo.java\t2023-03-24 20:57:53.168422327 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i-1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:55.072414904 +0100\n+++ /tmp/tmpe5fpr44j.java\t2023-03-24 20:57:55.072414904 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:56.896407792 +0100\n+++ /tmp/tmppw0n08sm.java\t2023-03-24 20:57:56.896407792 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+ 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:57:58.632401027 +0100\n+++ /tmp/tmp0_mjy5ip.java\t2023-03-24 20:57:58.632401027 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+ 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:00.540393587 +0100\n+++ /tmp/tmpw9c2q3l0.java\t2023-03-24 20:58:00.540393587 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (dp.containsKey(i[0]) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:02.316386666 +0100\n+++ /tmp/tmp7eesjk90.java\t2023-03-24 20:58:02.316386666 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i[0]) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (dp.containsKey(i])) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:04.100379713 +0100\n+++ /tmp/tmp3zelj41w.java\t2023-03-24 20:58:04.100379713 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i])) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1); int insert_value = dp.get(j).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:05.832372963 +0100\n+++ /tmp/tmpxwty7wts.java\t2023-03-24 20:58:05.836372947 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1); int insert_value = dp.get(j).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1); i = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:07.520366384 +0100\n+++ /tmp/tmpkfcx1e7k.java\t2023-03-24 20:58:07.520366384 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1); i = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:09.236359696 +0100\n+++ /tmp/tmpssysgm1v.java\t2023-03-24 20:58:09.236359696 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:10.904353197 +0100\n+++ /tmp/tmpd8yan7hw.java\t2023-03-24 20:58:10.904353197 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:12.664346339 +0100\n+++ /tmp/tmpp1qym8_0.java\t2023-03-24 20:58:12.664346339 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:14.360339731 +0100\n+++ /tmp/tmpjnl7egqw.java\t2023-03-24 20:58:14.360339731 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j);\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:18.532323476 +0100\n+++ /tmp/tmppa2eob8o.java\t2023-03-24 20:58:18.532323476 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (dp.containsKey(i -1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:20.240316820 +0100\n+++ /tmp/tmpfa5flyt4.java\t2023-03-24 20:58:20.244316803 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i -1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j - 1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:22.000309965 +0100\n+++ /tmp/tmpbz2c6w7r.java\t2023-03-24 20:58:22.004309949 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j - 1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:23.672303451 +0100\n+++ /tmp/tmptgzc8mru.java\t2023-03-24 20:58:23.672303451 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:25.420296641 +0100\n+++ /tmp/tmpsaaj84nc.java\t2023-03-24 20:58:25.420296641 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } int insert_value = dp.get(i-1).get(j + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:27.172289817 +0100\n+++ /tmp/tmp1owbrdfm.java\t2023-03-24 20:58:27.176289801 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } int insert_value = dp.get(i-1).get(j + 1);\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (dp.containsKey(i1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:28.896283102 +0100\n+++ /tmp/tmpokq1kk86.java\t2023-03-24 20:58:28.896283102 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); if ( insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:30.552276653 +0100\n+++ /tmp/tmp792apuw6.java\t2023-03-24 20:58:30.552276653 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); if ( insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:32.240270077 +0100\n+++ /tmp/tmpc4ttgku6.java\t2023-03-24 20:58:32.240270077 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; } else {\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); String insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:33.908263581 +0100\n+++ /tmp/tmpvjw29h1x.java\t2023-03-24 20:58:33.908263581 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); String insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:35.600256992 +0100\n+++ /tmp/tmpdtdaxris.java\t2023-03-24 20:58:35.600256992 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:37.348250186 +0100\n+++ /tmp/tmpkkqcjmqc.java\t2023-03-24 20:58:37.348250186 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:41.524233924 +0100\n+++ /tmp/tmpgyui65h2.java\t2023-03-24 20:58:41.524233924 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j - 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (dp.get(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:43.256227180 +0100\n+++ /tmp/tmp4se227eo.java\t2023-03-24 20:58:43.256227180 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.get(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); } int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:44.980220466 +0100\n+++ /tmp/tmpehx9fixi.java\t2023-03-24 20:58:44.980220466 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); } int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:46.668213895 +0100\n+++ /tmp/tmpudfgl7ws.java\t2023-03-24 20:58:46.668213895 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (dp.containsKey(i\")) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:48.404207138 +0100\n+++ /tmp/tmprjxked11.java\t2023-03-24 20:58:48.408207122 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i\")) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:50.084200595 +0100\n+++ /tmp/tmpmaeznrot.java\t2023-03-24 20:58:50.084200595 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else if (dp.get(i - 1).equals(j) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:51.716194243 +0100\n+++ /tmp/tmpblwh73iv.java\t2023-03-24 20:58:51.716194243 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else if (dp.get(i - 1).equals(j) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:53.416187626 +0100\n+++ /tmp/tmprcd7ifty.java\t2023-03-24 20:58:53.416187626 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); last = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:55.184180744 +0100\n+++ /tmp/tmprsru8bsw.java\t2023-03-24 20:58:55.184180744 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); last = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:56.860174220 +0100\n+++ /tmp/tmp0lqh1e12.java\t2023-03-24 20:58:56.860174220 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:58:58.568167573 +0100\n+++ /tmp/tmp82uo4yz5.java\t2023-03-24 20:58:58.568167573 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j - 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:00.340160676 +0100\n+++ /tmp/tmp5ccwe1za.java\t2023-03-24 20:59:00.344160660 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j - 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:02.512152223 +0100\n+++ /tmp/tmphf73_vso.java\t2023-03-24 20:59:02.512152223 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:04.392144906 +0100\n+++ /tmp/tmpvdzg31v9.java\t2023-03-24 20:59:04.392144906 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j)).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:06.024138555 +0100\n+++ /tmp/tmpsufs45wj.java\t2023-03-24 20:59:06.024138555 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j)).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); final int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:07.700132034 +0100\n+++ /tmp/tmpdi2ov2ew.java\t2023-03-24 20:59:07.700132034 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); final int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:09.416125354 +0100\n+++ /tmp/tmp9e_d4kl0.java\t2023-03-24 20:59:09.420125341 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (dp.contains(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:11.112118757 +0100\n+++ /tmp/tmplvk3iqwv.java\t2023-03-24 20:59:11.112118757 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.contains(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:12.836112049 +0100\n+++ /tmp/tmp3d50l86r.java\t2023-03-24 20:59:12.836112049 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (dp.containsKey(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:17.084095521 +0100\n+++ /tmp/tmppbyzaljd.java\t2023-03-24 20:59:17.084095521 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (dp.containsKey(i-1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:18.812088799 +0100\n+++ /tmp/tmp6mtee03g.java\t2023-03-24 20:59:18.816088783 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i-1) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (dp.containsKey(i)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:20.508082201 +0100\n+++ /tmp/tmpuaj69xbr.java\t2023-03-24 20:59:20.508082201 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:22.172075726 +0100\n+++ /tmp/tmp1utfx3pu.java\t2023-03-24 20:59:22.172075726 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i -1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:23.832069271 +0100\n+++ /tmp/tmp8ye39sje.java\t2023-03-24 20:59:23.832069271 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i -1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (dp.get(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:25.512062736 +0100\n+++ /tmp/tmpy3lsz31s.java\t2023-03-24 20:59:25.516062721 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.get(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:27.188056217 +0100\n+++ /tmp/tmpb12deyo7.java\t2023-03-24 20:59:27.188056217 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:31.332040098 +0100\n+++ /tmp/tmpnu7rfbsn.java\t2023-03-24 20:59:31.332040098 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:33.016033550 +0100\n+++ /tmp/tmpdyl6z9pv.java\t2023-03-24 20:59:33.016033550 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j - 1).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:34.632027266 +0100\n+++ /tmp/tmpizah5jfl.java\t2023-03-24 20:59:34.632027266 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j - 1).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i);int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:36.272020888 +0100\n+++ /tmp/tmprjdarlvm.java\t2023-03-24 20:59:36.272020888 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i);int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:37.948014371 +0100\n+++ /tmp/tmpkg1xbbyk.java\t2023-03-24 20:59:37.948014371 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j)); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).toString(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:39.636007805 +0100\n+++ /tmp/tmpzd4ql4_p.java\t2023-03-24 20:59:39.636007805 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).toString(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:41.360001103 +0100\n+++ /tmp/tmp4t7qj902.java\t2023-03-24 20:59:41.360001103 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); current = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:42.995994742 +0100\n+++ /tmp/tmp6e61si5i.java\t2023-03-24 20:59:42.995994742 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); current = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (dp.containsKey(i')) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:44.731987993 +0100\n+++ /tmp/tmpn3dcft2c.java\t2023-03-24 20:59:44.731987993 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i')) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:46.411981459 +0100\n+++ /tmp/tmp_lqrvnc8.java\t2023-03-24 20:59:46.415981446 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map; int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:48.283974183 +0100\n+++ /tmp/tmp8dve2qlq.java\t2023-03-24 20:59:48.283974183 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map; int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(j); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:49.987967559 +0100\n+++ /tmp/tmpjvxobpfa.java\t2023-03-24 20:59:49.987967559 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(j); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (dp.containsKey(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:51.775960607 +0100\n+++ /tmp/tmpgommg_at.java\t2023-03-24 20:59:51.775960607 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i-1)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:53.367954419 +0100\n+++ /tmp/tmporhhd8yt.java\t2023-03-24 20:59:53.367954419 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:55.055947858 +0100\n+++ /tmp/tmprr_hsdun.java\t2023-03-24 20:59:55.055947858 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 20:59:56.811941032 +0100\n+++ /tmp/tmpwj3gmqog.java\t2023-03-24 20:59:56.811941032 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j).get(j + 1);\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:00.935925000 +0100\n+++ /tmp/tmprhwz6wrd.java\t2023-03-24 21:00:00.939924988 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:03.107916562 +0100\n+++ /tmp/tmp4pnp2rle.java\t2023-03-24 21:00:03.107916562 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i - 1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:05.655906658 +0100\n+++ /tmp/tmphdzaoz2g.java\t2023-03-24 21:00:05.655906658 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i - 1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:07.075901141 +0100\n+++ /tmp/tmpilo8p7c0.java\t2023-03-24 21:00:07.075901141 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j)).get(j + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:08.563895356 +0100\n+++ /tmp/tmp2sejafvt.java\t2023-03-24 21:00:08.563895356 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(j)).get(j + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:10.011889731 +0100\n+++ /tmp/tmpb2f05o0g.java\t2023-03-24 21:00:10.011889731 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:11.455884121 +0100\n+++ /tmp/tmptl4xvpqh.java\t2023-03-24 21:00:11.455884121 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else { if (dp.containsKey(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:12.851878696 +0100\n+++ /tmp/tmpu26gkwb7.java\t2023-03-24 21:00:12.851878696 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else { if (dp.containsKey(i)) {\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:14.239873303 +0100\n+++ /tmp/tmpd6vo6h9n.java\t2023-03-24 21:00:14.239873303 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)) + 1;\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:15.639867862 +0100\n+++ /tmp/tmp8gt93qft.java\t2023-03-24 21:00:15.639867862 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); i = dp.get(i-1).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else { dp.put(i, j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:17.047862392 +0100\n+++ /tmp/tmptb35u7w6.java\t2023-03-24 21:00:17.047862392 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else { dp.put(i, j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 21:00:18.495856766 +0100\n+++ /tmp/tmp9pl9kukr.java\t2023-03-24 21:00:18.499856750 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); } else {\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "// dp.get(i-1).containsKey(j-1) if (dp.containsKey(i-1)&&dp.get(i-1).containsKey(j-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j-1) + 1;"
    },
    "wrap": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:03.856146993 +0100\n+++ /tmp/tmpyr1ylyq9.java\t2023-03-24 20:59:03.916146758 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:05.828139318 +0100\n+++ /tmp/tmpbpjq8aji.java\t2023-03-24 20:59:05.828139318 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (line.isEmpty()) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:07.640132267 +0100\n+++ /tmp/tmp_5qk42f6.java\t2023-03-24 20:59:07.640132267 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:09.400125418 +0100\n+++ /tmp/tmpol7g4aow.java\t2023-03-24 20:59:09.400125418 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:11.188118461 +0100\n+++ /tmp/tmptq75lhih.java\t2023-03-24 20:59:11.192118446 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == quoteChar) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:12.936111660 +0100\n+++ /tmp/tmpdi_4xf7d.java\t2023-03-24 20:59:12.936111660 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == quoteChar) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (!Character.isLetterOrDigit(text.charAt(i))) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:14.700104796 +0100\n+++ /tmp/tmpzjayujpd.java\t2023-03-24 20:59:14.700104796 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (!Character.isLetterOrDigit(text.charAt(i))) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:16.488097838 +0100\n+++ /tmp/tmpua354ilc.java\t2023-03-24 20:59:16.488097838 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:18.156091352 +0100\n+++ /tmp/tmpaysqsb3b.java\t2023-03-24 20:59:18.156091352 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:19.988084222 +0100\n+++ /tmp/tmpr858ny34.java\t2023-03-24 20:59:19.988084222 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { line = text.substring(i); break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:21.688077611 +0100\n+++ /tmp/tmptzc47dxm.java\t2023-03-24 20:59:21.692077596 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { line = text.substring(i); break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (!Character.isLetterOrDigit(text.charAt(i))) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:23.408070921 +0100\n+++ /tmp/tmpx4khv6yf.java\t2023-03-24 20:59:23.408070921 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (!Character.isLetterOrDigit(text.charAt(i))) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:25.236063810 +0100\n+++ /tmp/tmp6d_9kl16.java\t2023-03-24 20:59:25.236063810 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "for (int i = offset, end = offset+length; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:27.136056417 +0100\n+++ /tmp/tmpjzbxkix3.java\t2023-03-24 20:59:27.136056417 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = offset, end = offset+length; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:28.940049402 +0100\n+++ /tmp/tmpyhnk7_ek.java\t2023-03-24 20:59:28.940049402 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); } else { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:30.752042356 +0100\n+++ /tmp/tmpcivxvll5.java\t2023-03-24 20:59:30.756042340 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); } else { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:32.572035277 +0100\n+++ /tmp/tmp0c4kltnx.java\t2023-03-24 20:59:32.572035277 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == quoteChar) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:34.196028962 +0100\n+++ /tmp/tmpnjbjyb55.java\t2023-03-24 20:59:34.196028962 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == quoteChar) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:35.976022039 +0100\n+++ /tmp/tmpz_v3xwiy.java\t2023-03-24 20:59:35.980022022 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { break; } lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { return line; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:37.836014807 +0100\n+++ /tmp/tmp5q2f3ljv.java\t2023-03-24 20:59:37.840014791 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { return line; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (!Character.isLetterOrDigit(text.charAt(i))) { break; } lines.add(text); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:39.632007822 +0100\n+++ /tmp/tmpkw6czxc4.java\t2023-03-24 20:59:39.632007822 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (!Character.isLetterOrDigit(text.charAt(i))) { break; } lines.add(text); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "for (int i = offset; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:41.428000839 +0100\n+++ /tmp/tmpzzh7dkbf.java\t2023-03-24 20:59:41.428000839 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = offset; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:43.163994089 +0100\n+++ /tmp/tmpd_dte7z6.java\t2023-03-24 20:59:43.167994073 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { line = text.substring(i); break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:44.855987510 +0100\n+++ /tmp/tmpqtmrv5hx.java\t2023-03-24 20:59:44.855987510 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { line = text.substring(i); break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { line = text.substring(start, end); break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:46.595980746 +0100\n+++ /tmp/tmpmioewg8r.java\t2023-03-24 20:59:46.595980746 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { line = text.substring(start, end); break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { line = text.substring(start, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:48.379973810 +0100\n+++ /tmp/tmppaoyu6la.java\t2023-03-24 20:59:48.379973810 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length()) { line = text.substring(start, end); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (Character.isLetterOrDigit(text.charAt(i))) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:50.115967062 +0100\n+++ /tmp/tmp8aois6tc.java\t2023-03-24 20:59:50.115967062 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (Character.isLetterOrDigit(text.charAt(i))) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\r') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:51.915960061 +0100\n+++ /tmp/tmpugc6hwpv.java\t2023-03-24 20:59:51.919960049 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\r') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "for (int i = offset, end = offset + 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:53.635953377 +0100\n+++ /tmp/tmptdqn3jhr.java\t2023-03-24 20:59:53.635953377 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = offset, end = offset + 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { lines.add(lines.get(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 20:59:55.347946720 +0100\n+++ /tmp/tmpddipml_b.java\t2023-03-24 20:59:55.347946720 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { lines.add(lines.get(i)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (Character.isLetterOrDigit(text.charAt(i))) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:36.811320082 +0100\n+++ /tmp/tmpk9lc21j4.java\t2023-03-24 21:02:36.811320082 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (Character.isLetterOrDigit(text.charAt(i))) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (line.charAt(i) == quoteChar) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:38.615313090 +0100\n+++ /tmp/tmpzs441exh.java\t2023-03-24 21:02:38.615313090 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (line.charAt(i) == quoteChar) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "for (int i = 0, end = offset + 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:40.403306161 +0100\n+++ /tmp/tmpusfjzmbw.java\t2023-03-24 21:02:40.403306161 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0, end = offset + 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:42.187299248 +0100\n+++ /tmp/tmpby5dxbzo.java\t2023-03-24 21:02:42.187299248 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; } } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (!Character.isWhitespace(text.charAt(i))) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:43.883292675 +0100\n+++ /tmp/tmp9gee6jau.java\t2023-03-24 21:02:43.883292675 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (!Character.isWhitespace(text.charAt(i))) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:45.675285730 +0100\n+++ /tmp/tmp4n1gg7jg.java\t2023-03-24 21:02:45.675285730 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\n') { break; } } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "for (int i = 0; i < text.length(); i++) { if (line.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:47.331279315 +0100\n+++ /tmp/tmp2uimqtj4.java\t2023-03-24 21:02:47.331279315 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < text.length(); i++) { if (line.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == quoteChar) { break; } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:49.115272402 +0100\n+++ /tmp/tmpg64tm9h6.java\t2023-03-24 21:02:49.115272402 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == quoteChar) { break; } } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (text.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:50.831265753 +0100\n+++ /tmp/tmpnghxeb65.java\t2023-03-24 21:02:50.831265753 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (text.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '_') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:52.675258608 +0100\n+++ /tmp/tmp1l7c_gu9.java\t2023-03-24 21:02:52.675258608 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '_') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\r') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:54.407251898 +0100\n+++ /tmp/tmp8usp82dj.java\t2023-03-24 21:02:54.407251898 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '\\r') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:56.163245093 +0100\n+++ /tmp/tmpkd3yy95t.java\t2023-03-24 21:02:56.163245093 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (line.charAt(i) == '\\n') { lines.add(line); } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "for (int i = 0; i < text.length(); i++) { if (text.charAt(i) == '\\n') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:02:57.903238352 +0100\n+++ /tmp/tmpe2zh4f6a.java\t2023-03-24 21:02:57.903238352 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < text.length(); i++) { if (text.charAt(i) == '\\n') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "for (int i = 0; i < end; i++) { if (!Character.isWhitespace(text.charAt(i))) { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:01.843223089 +0100\n+++ /tmp/tmpdl3_0cxe.java\t2023-03-24 21:03:01.847223073 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { if (!Character.isWhitespace(text.charAt(i))) { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (line!= null) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:03.611216239 +0100\n+++ /tmp/tmpm7mo4295.java\t2023-03-24 21:03:03.611216239 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line!= null) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:05.443209142 +0100\n+++ /tmp/tmpm0v4kbya.java\t2023-03-24 21:03:05.443209142 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { if (line.charAt(i) == '\\n') { break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length() - 1) { return line; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:07.175202431 +0100\n+++ /tmp/tmp31dj7bmj.java\t2023-03-24 21:03:07.175202431 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.indexOf('.') > 0 && line.indexOf('\\r') < line.length() - 1) { return line; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (line.isEmpty()) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:09.015195306 +0100\n+++ /tmp/tmpa7sqbg9p.java\t2023-03-24 21:03:09.015195306 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '&') { break; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:10.755188566 +0100\n+++ /tmp/tmpetbzqmpe.java\t2023-03-24 21:03:10.755188566 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { if (line.charAt(i) == '&') { break; } }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (line.indexOf('.') > 0 && line.indexOf('\\n') < line.length()) { return line; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:12.563181562 +0100\n+++ /tmp/tmp7n8s6kz4.java\t2023-03-24 21:03:12.567181546 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.indexOf('.') > 0 && line.indexOf('\\n') < line.length()) { return line; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (text.length() > 0 && text.charAt(0) == '#') { lines.add(text); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:14.411174404 +0100\n+++ /tmp/tmp8d58do4e.java\t2023-03-24 21:03:14.411174404 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.length() > 0 && text.charAt(0) == '#') { lines.add(text); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (text.length() > 0 && text.charAt(0) == '#') { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:18.431158834 +0100\n+++ /tmp/tmp6phn8vu2.java\t2023-03-24 21:03:18.431158834 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.length() > 0 && text.charAt(0) == '#') { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (lineCount > 0 && lineCount < lines.size()) { lines.add(lineCount); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:22.467143203 +0100\n+++ /tmp/tmp_k405f8g.java\t2023-03-24 21:03:22.467143203 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lineCount > 0 && lineCount < lines.size()) { lines.add(lineCount); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (line == null) { return EMPTY_STRING; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:24.219136418 +0100\n+++ /tmp/tmpjv0xjau9.java\t2023-03-24 21:03:24.219136418 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { return EMPTY_STRING; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "for (int i = 1; i < end; i++) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:26.007129491 +0100\n+++ /tmp/tmpse1tk9q9.java\t2023-03-24 21:03:26.011129479 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (lineCount > 0 && lineCount < lines.size()) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:27.767122678 +0100\n+++ /tmp/tmp3qlnfgz0.java\t2023-03-24 21:03:27.771122663 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lineCount > 0 && lineCount < lines.size()) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (line.length() > end) { return lines.get(end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:29.511115925 +0100\n+++ /tmp/tmplp6uef9z.java\t2023-03-24 21:03:29.511115925 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.length() > end) { return lines.get(end); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (text.length() > 0 && text.charAt(0) == '#') { return line; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:31.255109171 +0100\n+++ /tmp/tmp0_sj54t8.java\t2023-03-24 21:03:31.255109171 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.length() > 0 && text.charAt(0) == '#') { return line; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (c =='' || c == '\\n' || c == '\\r') { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:33.015102356 +0100\n+++ /tmp/tmpxt_nevjo.java\t2023-03-24 21:03:33.015102356 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (c =='' || c == '\\n' || c == '\\r') { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (lineCount > 0 && lineCount < lines.size()) { return lineCount; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:34.723095743 +0100\n+++ /tmp/tmpcygktr1q.java\t2023-03-24 21:03:34.723095743 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lineCount > 0 && lineCount < lines.size()) { return lineCount; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (lines.isEmpty()) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:36.491088896 +0100\n+++ /tmp/tmpj_n1mw54.java\t2023-03-24 21:03:36.491088896 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.isEmpty()) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "for (int i = 0; i < end; i++) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:40.503073362 +0100\n+++ /tmp/tmprfz0ne7o.java\t2023-03-24 21:03:40.503073362 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < end; i++) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "for (int i = 1; i < end; i++) { lines.add(text); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:42.179066873 +0100\n+++ /tmp/tmpb99_yzfl.java\t2023-03-24 21:03:42.179066873 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 1; i < end; i++) { lines.add(text); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (lineCount == 0 && lineCount == 1) { lines.add(lineCount); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:43.875060306 +0100\n+++ /tmp/tmpsyhbjh9b.java\t2023-03-24 21:03:43.875060306 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lineCount == 0 && lineCount == 1) { lines.add(lineCount); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (line.isEmpty()) { return lines.get(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:45.619053555 +0100\n+++ /tmp/tmp6j9tq49y.java\t2023-03-24 21:03:45.619053555 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { return lines.get(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (line.isEmpty()) { lines.add(line); return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:47.339046896 +0100\n+++ /tmp/tmpbh12holb.java\t2023-03-24 21:03:47.343046880 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { lines.add(line); return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (line.isEmpty()) { return line; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:49.023040373 +0100\n+++ /tmp/tmpcz1e4j91.java\t2023-03-24 21:03:49.023040373 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { return line; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (lineCount > 1) { lines.add(lineCount); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:50.819033424 +0100\n+++ /tmp/tmp844y87m_.java\t2023-03-24 21:03:50.819033424 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lineCount > 1) { lines.add(lineCount); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (line.isEmpty()) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:52.567026656 +0100\n+++ /tmp/tmpancee7c0.java\t2023-03-24 21:03:52.567026656 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (line.isEmpty()) { return -1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:54.287019997 +0100\n+++ /tmp/tmp5nuwv0x9.java\t2023-03-24 21:03:54.287019997 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { return -1; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (line.trim().isEmpty()) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:56.423011729 +0100\n+++ /tmp/tmpvxzwwor9.java\t2023-03-24 21:03:56.427011713 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.trim().isEmpty()) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (text!= null) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:03:58.383004142 +0100\n+++ /tmp/tmpx6guinal.java\t2023-03-24 21:03:58.383004142 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (c == '\\r' || c == '\\n') { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:00.090997530 +0100\n+++ /tmp/tmplpt5aeaa.java\t2023-03-24 21:04:00.090997530 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (c == '\\r' || c == '\\n') { break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (c == '\\r' || c == '\\n') { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:01.930990409 +0100\n+++ /tmp/tmpz27su00t.java\t2023-03-24 21:04:01.930990409 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (c == '\\r' || c == '\\n') { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (lineCount == 0 && lineCount == 1) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:03.618983874 +0100\n+++ /tmp/tmpf28_hech.java\t2023-03-24 21:04:03.618983874 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lineCount == 0 && lineCount == 1) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (c == '\\r' || c == '\\n') { return -1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:05.418976907 +0100\n+++ /tmp/tmp58dk1hdl.java\t2023-03-24 21:04:05.422976890 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (c == '\\r' || c == '\\n') { return -1; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (line == null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:07.246969833 +0100\n+++ /tmp/tmpejfm2v__.java\t2023-03-24 21:04:07.246969833 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (line == null) { lines.add(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:08.950963237 +0100\n+++ /tmp/tmpi62zh9f8.java\t2023-03-24 21:04:08.954963221 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { lines.add(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (line.isEmpty()) { return Collections.emptySet(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:10.762956224 +0100\n+++ /tmp/tmp92f4rcuy.java\t2023-03-24 21:04:10.766956209 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { return Collections.emptySet(); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (text!= null) { lines.add(text); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:12.518949429 +0100\n+++ /tmp/tmpktno__gr.java\t2023-03-24 21:04:12.518949429 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { lines.add(text); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (line.length() > end) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:16.410934364 +0100\n+++ /tmp/tmp2b5ctkdo.java\t2023-03-24 21:04:16.410934364 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.length() > end) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (line.isEmpty()) { return EMPTY_STRING; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:18.266927183 +0100\n+++ /tmp/tmpuhjub4iw.java\t2023-03-24 21:04:18.270927165 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { return EMPTY_STRING; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (line == null) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:20.002920466 +0100\n+++ /tmp/tmpevvg21nq.java\t2023-03-24 21:04:20.002920466 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (line.length() > end) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:21.802913501 +0100\n+++ /tmp/tmp0vr4zokx.java\t2023-03-24 21:04:21.806913485 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.length() > end) { break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (line.equals(\"#\")) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:23.610906504 +0100\n+++ /tmp/tmp_1wudeto.java\t2023-03-24 21:04:23.610906504 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.equals(\"#\")) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (line == null) { line = new Line(line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:25.394899600 +0100\n+++ /tmp/tmpxdnq4bd4.java\t2023-03-24 21:04:25.394899600 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { line = new Line(line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (line!= null) { line = line.trim(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:27.258892387 +0100\n+++ /tmp/tmpwfc0duig.java\t2023-03-24 21:04:27.258892387 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line!= null) { line = line.trim(); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (line == null) { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:29.014885593 +0100\n+++ /tmp/tmpuwsd2opi.java\t2023-03-24 21:04:29.014885593 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { return null; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (line == null) { lines = new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:30.790878721 +0100\n+++ /tmp/tmpl2smp_eg.java\t2023-03-24 21:04:30.790878721 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { lines = new ArrayList<>(); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (line.equals(line)) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:33.370868740 +0100\n+++ /tmp/tmpmin3phla.java\t2023-03-24 21:04:33.370868740 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.equals(line)) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (c == '\\r') { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:35.002862426 +0100\n+++ /tmp/tmpzk0ci8yl.java\t2023-03-24 21:04:35.002862426 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (c == '\\r') { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (line!= null) { return line; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:36.830855354 +0100\n+++ /tmp/tmp2vxah8nn.java\t2023-03-24 21:04:36.830855354 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line!= null) { return line; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (line == null) { line = null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:39.042846795 +0100\n+++ /tmp/tmp7rhs9k0y.java\t2023-03-24 21:04:39.042846795 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) { line = null; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (line.isEmpty()) { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:41.054839010 +0100\n+++ /tmp/tmphcyi7gtk.java\t2023-03-24 21:04:41.054839010 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.isEmpty()) { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (null!= text) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:43.222830623 +0100\n+++ /tmp/tmp80boy2gk.java\t2023-03-24 21:04:43.222830623 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (null!= text) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (text!= null) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:49.078807969 +0100\n+++ /tmp/tmpdxlm2drm.java\t2023-03-24 21:04:49.078807969 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "return lines.get(line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:53.910789277 +0100\n+++ /tmp/tmpdoh9elu4.java\t2023-03-24 21:04:53.910789277 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+return lines.get(line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (line == null) break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:56.322779948 +0100\n+++ /tmp/tmpwntoww45.java\t2023-03-24 21:04:56.322779948 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line == null) break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "lines.add(line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:57.946773668 +0100\n+++ /tmp/tmpjm0wxfuc.java\t2023-03-24 21:04:57.950773652 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+lines.add(line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "}",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 21:04:59.798766504 +0100\n+++ /tmp/tmpnp8f2gyr.java\t2023-03-24 21:04:59.798766504 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+}\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "lines.add(text);"
    },
    "powerset": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:00:56.063710862 +0100\n+++ /tmp/tmpmmm5fbi0.java\t2023-03-24 21:00:56.123710629 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:00:57.643704728 +0100\n+++ /tmp/tmpcvfqh0ii.java\t2023-03-24 21:00:57.643704728 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:00:59.395697926 +0100\n+++ /tmp/tmp9lr91awj.java\t2023-03-24 21:00:59.395697926 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:02.059687584 +0100\n+++ /tmp/tmpd4j1m0nj.java\t2023-03-24 21:01:02.059687584 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:04.579677803 +0100\n+++ /tmp/tmp968d2ye_.java\t2023-03-24 21:01:04.579677803 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:07.027668300 +0100\n+++ /tmp/tmpeo8vhdki.java\t2023-03-24 21:01:07.027668300 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:09.535658566 +0100\n+++ /tmp/tmpyhnka86p.java\t2023-03-24 21:01:09.535658566 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:12.075648708 +0100\n+++ /tmp/tmpgfnmad_a.java\t2023-03-24 21:01:12.075648708 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:14.603638894 +0100\n+++ /tmp/tmp7zunab9q.java\t2023-03-24 21:01:14.603638894 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:17.031629473 +0100\n+++ /tmp/tmpd7oq3r5d.java\t2023-03-24 21:01:17.035629458 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:19.367620408 +0100\n+++ /tmp/tmpz9rpj8e6.java\t2023-03-24 21:01:19.367620408 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:21.979610272 +0100\n+++ /tmp/tmp2jban8zp.java\t2023-03-24 21:01:21.979610272 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:24.459600647 +0100\n+++ /tmp/tmpec5nx6kd.java\t2023-03-24 21:01:24.459600647 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:26.959590949 +0100\n+++ /tmp/tmp0dt9ibb2.java\t2023-03-24 21:01:26.959590949 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } else { to_add.add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:29.323581776 +0100\n+++ /tmp/tmp505sogks.java\t2023-03-24 21:01:29.323581776 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } else { to_add.add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:31.847571984 +0100\n+++ /tmp/tmpmg9_cq5m.java\t2023-03-24 21:01:31.847571984 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:33.587565231 +0100\n+++ /tmp/tmpybes2j6z.java\t2023-03-24 21:01:33.587565231 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:35.111559321 +0100\n+++ /tmp/tmpagnlw5kd.java\t2023-03-24 21:01:35.111559321 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:36.567553672 +0100\n+++ /tmp/tmp5hpqs_5a.java\t2023-03-24 21:01:36.567553672 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:37.979548195 +0100\n+++ /tmp/tmpqhis5ade.java\t2023-03-24 21:01:37.979548195 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:39.363542823 +0100\n+++ /tmp/tmpbt585rmf.java\t2023-03-24 21:01:39.363542823 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:41.547534353 +0100\n+++ /tmp/tmprhwlj3qd.java\t2023-03-24 21:01:41.551534338 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:44.531522779 +0100\n+++ /tmp/tmp15d35q6e.java\t2023-03-24 21:01:44.531522779 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:46.475515236 +0100\n+++ /tmp/tmp4rnpouhc.java\t2023-03-24 21:01:46.475515236 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:47.931509591 +0100\n+++ /tmp/tmpg5w4ckn0.java\t2023-03-24 21:01:47.931509591 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:49.307504253 +0100\n+++ /tmp/tmph7z4e1z0.java\t2023-03-24 21:01:49.311504236 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:50.687498902 +0100\n+++ /tmp/tmppydcvku1.java\t2023-03-24 21:01:50.687498902 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:52.131493301 +0100\n+++ /tmp/tmpnu6q6qwx.java\t2023-03-24 21:01:52.135493285 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:53.587487654 +0100\n+++ /tmp/tmpk8nz2ay4.java\t2023-03-24 21:01:53.587487654 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:55.039482023 +0100\n+++ /tmp/tmp_aopl51b.java\t2023-03-24 21:01:55.043482005 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:57.231473523 +0100\n+++ /tmp/tmpppft_peb.java\t2023-03-24 21:01:57.231473523 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:01:59.271465612 +0100\n+++ /tmp/tmp1u0_0sn6.java\t2023-03-24 21:01:59.271465612 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:00.703460058 +0100\n+++ /tmp/tmpho01uhq5.java\t2023-03-24 21:02:00.703460058 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:02.143454474 +0100\n+++ /tmp/tmp9nwwh_c8.java\t2023-03-24 21:02:02.147454458 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:03.567448953 +0100\n+++ /tmp/tmpdazstat0.java\t2023-03-24 21:02:03.567448953 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:05.019443322 +0100\n+++ /tmp/tmpw19a0ztx.java\t2023-03-24 21:02:05.019443322 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:06.411437925 +0100\n+++ /tmp/tmpwx620nu2.java\t2023-03-24 21:02:06.415437910 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:07.783432606 +0100\n+++ /tmp/tmp0741ouu_.java\t2023-03-24 21:02:07.783432606 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:09.243426945 +0100\n+++ /tmp/tmpiq_jzj2j.java\t2023-03-24 21:02:09.243426945 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:10.663421437 +0100\n+++ /tmp/tmptthew1v5.java\t2023-03-24 21:02:10.663421437 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:12.055416041 +0100\n+++ /tmp/tmpf94tptsb.java\t2023-03-24 21:02:12.055416041 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:13.419410753 +0100\n+++ /tmp/tmpsz88krs_.java\t2023-03-24 21:02:13.423410738 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:14.879405094 +0100\n+++ /tmp/tmpfpfyj0at.java\t2023-03-24 21:02:14.879405094 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:16.311399542 +0100\n+++ /tmp/tmpev2i09gg.java\t2023-03-24 21:02:16.311399542 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:17.719394084 +0100\n+++ /tmp/tmpb7h4k38q.java\t2023-03-24 21:02:17.719394084 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:19.123388640 +0100\n+++ /tmp/tmpw6etd2cs.java\t2023-03-24 21:02:19.123388640 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:22.555375336 +0100\n+++ /tmp/tmp_xz91wb6.java\t2023-03-24 21:02:22.555375336 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:24.031369615 +0100\n+++ /tmp/tmprnu_bdxp.java\t2023-03-24 21:02:24.031369615 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:25.479364002 +0100\n+++ /tmp/tmpbcpn31fa.java\t2023-03-24 21:02:25.479364002 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:26.975358204 +0100\n+++ /tmp/tmpboo6__ef.java\t2023-03-24 21:02:26.975358204 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:28.323352979 +0100\n+++ /tmp/tmphm315_k4.java\t2023-03-24 21:02:28.327352963 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:29.755347429 +0100\n+++ /tmp/tmpm3xrcoe_.java\t2023-03-24 21:02:29.755347429 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:31.187341878 +0100\n+++ /tmp/tmp1h649i3z.java\t2023-03-24 21:02:31.187341878 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:32.595336418 +0100\n+++ /tmp/tmp6dpsduad.java\t2023-03-24 21:02:32.595336418 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:34.035330840 +0100\n+++ /tmp/tmp0bo562h5.java\t2023-03-24 21:02:34.035330840 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:35.467325287 +0100\n+++ /tmp/tmpmjdzn5sz.java\t2023-03-24 21:02:35.467325287 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:36.955319523 +0100\n+++ /tmp/tmpyl5ys5i0.java\t2023-03-24 21:02:36.955319523 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:38.631313029 +0100\n+++ /tmp/tmpv8luoab7.java\t2023-03-24 21:02:38.631313029 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:40.351306362 +0100\n+++ /tmp/tmpf58glmum.java\t2023-03-24 21:02:40.355306347 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:44.351290859 +0100\n+++ /tmp/tmp1h7vhsap.java\t2023-03-24 21:02:44.351290859 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:46.039284321 +0100\n+++ /tmp/tmporqk3q5t.java\t2023-03-24 21:02:46.043284305 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:47.747277702 +0100\n+++ /tmp/tmp8au33d4y.java\t2023-03-24 21:02:47.747277702 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:49.367271425 +0100\n+++ /tmp/tmpryrlhb7l.java\t2023-03-24 21:02:49.371271409 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:51.011265055 +0100\n+++ /tmp/tmp69tgolec.java\t2023-03-24 21:02:51.015265037 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:52.671258623 +0100\n+++ /tmp/tmpztv83nfd.java\t2023-03-24 21:02:52.671258623 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:54.351252115 +0100\n+++ /tmp/tmpsnx9993e.java\t2023-03-24 21:02:54.351252115 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:56.047245543 +0100\n+++ /tmp/tmpf3qqnm6_.java\t2023-03-24 21:02:56.047245543 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:57.763238895 +0100\n+++ /tmp/tmpftyigmsz.java\t2023-03-24 21:02:57.763238895 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } else { to_add(to_add); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:02:59.519232092 +0100\n+++ /tmp/tmpwx7esem9.java\t2023-03-24 21:02:59.519232092 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:01.215225521 +0100\n+++ /tmp/tmpk1mhg8_i.java\t2023-03-24 21:03:01.215225521 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); } } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:02.955218781 +0100\n+++ /tmp/tmpyv7obp_s.java\t2023-03-24 21:03:02.955218781 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.addAll(subset); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } for (ArrayList subset : rest_ractice) { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:04.631212289 +0100\n+++ /tmp/tmpdepzy7mt.java\t2023-03-24 21:03:04.631212289 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } for (ArrayList subset : rest_ractice) { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:06.239206059 +0100\n+++ /tmp/tmpomcmi5wm.java\t2023-03-24 21:03:06.243206043 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:07.891199657 +0100\n+++ /tmp/tmpgwc8cck9.java\t2023-03-24 21:03:07.891199657 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } for (ArrayList subset : rest_ractice) { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:09.539193276 +0100\n+++ /tmp/tmpvzqp5oy1.java\t2023-03-24 21:03:09.543193261 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } for (ArrayList subset : rest_ractice) { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.addAll(subset); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:11.211186799 +0100\n+++ /tmp/tmpc6uauc2k.java\t2023-03-24 21:03:11.211186799 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.TRUE.equals(subset)) { to_add.add(first); } else { to_add.addAll(subset); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:12.851180447 +0100\n+++ /tmp/tmpberzel5x.java\t2023-03-24 21:03:12.851180447 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add(first); } } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:14.511174017 +0100\n+++ /tmp/tmp0v1etgiy.java\t2023-03-24 21:03:14.511174017 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add(first); } } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:16.211167434 +0100\n+++ /tmp/tmp6h8wfivp.java\t2023-03-24 21:03:16.211167434 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:17.911160848 +0100\n+++ /tmp/tmpn5u2m3wa.java\t2023-03-24 21:03:17.911160848 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } return output; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:19.739153769 +0100\n+++ /tmp/tmpw77bco2i.java\t2023-03-24 21:03:19.739153769 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } return output; }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:21.451147138 +0100\n+++ /tmp/tmpixyv04h1.java\t2023-03-24 21:03:21.451147138 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:23.207140337 +0100\n+++ /tmp/tmpnt4x38yz.java\t2023-03-24 21:03:23.207140337 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.add(first); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:24.887133829 +0100\n+++ /tmp/tmpv2rqtc8w.java\t2023-03-24 21:03:24.887133829 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!Boolean.parseBoolean(subset)) { to_add.add(first); } else { to_add.add(first); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:26.575127294 +0100\n+++ /tmp/tmp2vwvwy3t.java\t2023-03-24 21:03:26.611127156 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:28.371120339 +0100\n+++ /tmp/tmpnq41y08q.java\t2023-03-24 21:03:28.371120339 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.addAll(subset); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:30.031113911 +0100\n+++ /tmp/tmpgr9p_38y.java\t2023-03-24 21:03:30.031113911 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.addAll(subset); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:31.615107777 +0100\n+++ /tmp/tmpd81avwcw.java\t2023-03-24 21:03:31.615107777 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!rest.isEmpty()) { to_add.add(first); } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:33.307101225 +0100\n+++ /tmp/tmpdz33niv8.java\t2023-03-24 21:03:33.307101225 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:35.015094612 +0100\n+++ /tmp/tmpkuslkztq.java\t2023-03-24 21:03:35.015094612 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first); } } else { to_add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); } return output;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:36.663088228 +0100\n+++ /tmp/tmppx9ugivd.java\t2023-03-24 21:03:36.663088228 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); } return output;\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:38.451081308 +0100\n+++ /tmp/tmpbvhnm6r5.java\t2023-03-24 21:03:38.451081308 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.addAll(subset); } } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first); } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:40.175074630 +0100\n+++ /tmp/tmp652k6f8r.java\t2023-03-24 21:03:40.179074617 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first); } } else {\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (100) { to_add.add(first); } else { to_add.add(first); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:41.847068158 +0100\n+++ /tmp/tmp19jl28py.java\t2023-03-24 21:03:41.847068158 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (100) { to_add.add(first); } else { to_add.add(first); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (subset!= null) { to_add.add(first); } else { to_add(first); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:43.607061345 +0100\n+++ /tmp/tmpn7ukrzz8.java\t2023-03-24 21:03:43.607061345 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset!= null) { to_add.add(first); } else { to_add(first); } }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (subset) { to_add.add(first); } else { to_add.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:45.363054546 +0100\n+++ /tmp/tmphx5jz0r_.java\t2023-03-24 21:03:45.363054546 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); } else { to_add.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (!subset) { to_add.add(first); } else { to_add.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:47.067047948 +0100\n+++ /tmp/tmpf9l8wd9w.java\t2023-03-24 21:03:47.071047931 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); } else { to_add.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "for (first); first_add.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:48.799041243 +0100\n+++ /tmp/tmpza206zq4.java\t2023-03-24 21:03:48.803041228 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+for (first); first_add.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "for (first); first.add(first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:50.507034628 +0100\n+++ /tmp/tmpi7_t85h9.java\t2023-03-24 21:03:50.507034628 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+for (first); first.add(first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "for (first);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 21:03:52.247027892 +0100\n+++ /tmp/tmpedop3m1x.java\t2023-03-24 21:03:52.247027892 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+for (first);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (ArrayList subset : rest_subsets) { ArrayList r = new ArrayList(); r.add(first); r.addAll(subset); to_add.add(r); } output.addAll(to_add); rest_subsets.addAll(output); return rest_subsets;"
    },
    "shortest_path_length": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:03:57.607007147 +0100\n+++ /tmp/tmpyh5_o3nb.java\t2023-03-24 21:03:57.679006865 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:01.922990437 +0100\n+++ /tmp/tmpeh68xorh.java\t2023-03-24 21:04:01.922990437 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "new HashSet<>(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:03.630983829 +0100\n+++ /tmp/tmpjc7rqsf9.java\t2023-03-24 21:04:03.630983829 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:05.446976797 +0100\n+++ /tmp/tmp0s8g7zhy.java\t2023-03-24 21:04:05.446976797 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "new HashSet<>()); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:07.194970034 +0100\n+++ /tmp/tmp1htlqzcb.java\t2023-03-24 21:04:07.194970034 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>()); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "new ArrayList<>(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:08.870963547 +0100\n+++ /tmp/tmpn6sjm0kx.java\t2023-03-24 21:04:08.874963531 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:10.682956534 +0100\n+++ /tmp/tmpuu134v7r.java\t2023-03-24 21:04:10.682956534 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "new HashSet<>(), unvisitedNodes.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:12.270950388 +0100\n+++ /tmp/tmp2fw_9mjq.java\t2023-03-24 21:04:12.270950388 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), unvisitedNodes.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "new HashSet<>(), unvisitedNodes.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:13.930943964 +0100\n+++ /tmp/tmp0ob43cb6.java\t2023-03-24 21:04:13.930943964 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), unvisitedNodes.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:15.778936811 +0100\n+++ /tmp/tmpe8nodntf.java\t2023-03-24 21:04:15.778936811 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:17.450930341 +0100\n+++ /tmp/tmp52z7zycs.java\t2023-03-24 21:04:17.450930341 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "new Integer(length_by_edge.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:19.114923901 +0100\n+++ /tmp/tmplc9g7eqv.java\t2023-03-24 21:04:19.118923886 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(length_by_edge.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "new HashSet<>(), new HashSet<>()); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:20.834917246 +0100\n+++ /tmp/tmp2ua76rwg.java\t2023-03-24 21:04:20.834917246 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), new HashSet<>()); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "new Integer(nextnode), unvisitedNodes.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:22.458910962 +0100\n+++ /tmp/tmpva07tche.java\t2023-03-24 21:04:22.462910946 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(nextnode), unvisitedNodes.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "new Integer(length_by_edge.get(Arrays.asList(node)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:24.094904630 +0100\n+++ /tmp/tmppa__hkhv.java\t2023-03-24 21:04:24.094904630 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(length_by_edge.get(Arrays.asList(node)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:25.718898346 +0100\n+++ /tmp/tmp7wylw8do.java\t2023-03-24 21:04:25.718898346 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode)))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:27.350892032 +0100\n+++ /tmp/tmpm8i1dyus.java\t2023-03-24 21:04:27.354892016 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode)))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:29.058885420 +0100\n+++ /tmp/tmpzalzo_i8.java\t2023-03-24 21:04:29.058885420 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "new Integer(nextnode) ); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:34.822863121 +0100\n+++ /tmp/tmpvnk6pdw4.java\t2023-03-24 21:04:34.822863121 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(nextnode) ); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "new Integer(length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:36.786855524 +0100\n+++ /tmp/tmpod5kpu_e.java\t2023-03-24 21:04:36.786855524 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "new Integer(length_by_edge.get(Arrays.asList(node))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:38.806847708 +0100\n+++ /tmp/tmprfkoj8qa.java\t2023-03-24 21:04:38.938847198 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(length_by_edge.get(Arrays.asList(node))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "new HashSet<>(length_by_edge.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:40.990839259 +0100\n+++ /tmp/tmpw8w5r1fc.java\t2023-03-24 21:04:40.990839259 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(length_by_edge.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "new HashSet<>(), length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:42.982831553 +0100\n+++ /tmp/tmph8j7nno7.java\t2023-03-24 21:04:43.066831227 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "new HashSet<>(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:45.606821401 +0100\n+++ /tmp/tmphndlxajg.java\t2023-03-24 21:04:45.686821091 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "new LinkedHashMap<>(length_by_edge.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:47.590813726 +0100\n+++ /tmp/tmpfo_6q5dw.java\t2023-03-24 21:04:47.590813726 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new LinkedHashMap<>(length_by_edge.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:49.078807969 +0100\n+++ /tmp/tmpgsedwhk4.java\t2023-03-24 21:04:49.078807969 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "new Integer(nextnode), unvisitedNodes.get(Arrays.asList(node, nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:51.154799939 +0100\n+++ /tmp/tmp12we7jgs.java\t2023-03-24 21:04:51.154799939 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(nextnode), unvisitedNodes.get(Arrays.asList(node, nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "new ArrayList<>(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:52.962792946 +0100\n+++ /tmp/tmpfwsqabyh.java\t2023-03-24 21:04:52.966792930 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode)))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:55.270784018 +0100\n+++ /tmp/tmplbbjhx8e.java\t2023-03-24 21:04:55.382783585 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode)))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode))) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:04:57.786774286 +0100\n+++ /tmp/tmpu72xamqv.java\t2023-03-24 21:04:57.786774286 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode))) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode))) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:03.174753446 +0100\n+++ /tmp/tmpp7r8xe8a.java\t2023-03-24 21:05:03.174753446 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node, nextnode))) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "new HashSet<>(length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:05.930742787 +0100\n+++ /tmp/tmpxvxcrmgm.java\t2023-03-24 21:05:05.930742787 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "new ArrayDeque<>()); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:08.426733132 +0100\n+++ /tmp/tmpqfp2wtxk.java\t2023-03-24 21:05:08.446733056 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayDeque<>()); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "new HashSet<>(Arrays.asList(node, nextnode)) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:11.214722350 +0100\n+++ /tmp/tmps4wu89l8.java\t2023-03-24 21:05:11.282722087 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(Arrays.asList(node, nextnode)) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "new Integer(length_by_edge.get(Arrays.asList(node)), unvisitedNodes);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:14.078711275 +0100\n+++ /tmp/tmpzi6jiml1.java\t2023-03-24 21:05:14.078711275 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(length_by_edge.get(Arrays.asList(node)), unvisitedNodes);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "new HashSet<>(), unvisitedNodes.get(Arrays.asList(node, nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:16.130703340 +0100\n+++ /tmp/tmpb4m8pu7w.java\t2023-03-24 21:05:16.318702613 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), unvisitedNodes.get(Arrays.asList(node, nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "new Integer(nextnode)); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:18.370694678 +0100\n+++ /tmp/tmpvk6kmjup.java\t2023-03-24 21:05:18.370694678 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(nextnode)); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "new ArrayList<>(length_by_edge.get(Arrays.asList(node)), unvisitedNodes);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:20.450686634 +0100\n+++ /tmp/tmpd4_3pdmu.java\t2023-03-24 21:05:20.450686634 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(length_by_edge.get(Arrays.asList(node)), unvisitedNodes);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "new ArrayList<>(Arrays.asList(node, nextnode)) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:22.734677802 +0100\n+++ /tmp/tmp2v_rxmi9.java\t2023-03-24 21:05:22.734677802 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(Arrays.asList(node, nextnode)) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "new LinkedHashMap<>(length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:24.330671630 +0100\n+++ /tmp/tmps0qlv163.java\t2023-03-24 21:05:24.330671630 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new LinkedHashMap<>(length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:26.182664470 +0100\n+++ /tmp/tmpjjgo4bbw.java\t2023-03-24 21:05:26.206664377 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "unvisitedNodes.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:31.642643359 +0100\n+++ /tmp/tmpokfktlp0.java\t2023-03-24 21:05:31.642643359 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "(int) unvisitedNodes.get(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:37.042622480 +0100\n+++ /tmp/tmpsr8qx_vn.java\t2023-03-24 21:05:37.042622480 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.get(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "new ArrayList<>()); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:42.218602468 +0100\n+++ /tmp/tmpt33_nevf.java\t2023-03-24 21:05:42.266602282 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>()); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "unvisitedNodes.get(node) + length_by_edge.getId());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:43.982595650 +0100\n+++ /tmp/tmpkxvr0ve8.java\t2023-03-24 21:05:43.982595650 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(node) + length_by_edge.getId());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:46.030587732 +0100\n+++ /tmp/tmps3q52sgt.java\t2023-03-24 21:05:46.030587732 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "new HashSet<>(length_by_edge.get(Arrays.asList(node))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:48.186579397 +0100\n+++ /tmp/tmpvk8u53j0.java\t2023-03-24 21:05:48.186579397 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(length_by_edge.get(Arrays.asList(node))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode))) ;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:50.458570615 +0100\n+++ /tmp/tmp1u5ru2y6.java\t2023-03-24 21:05:50.462570599 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode))) ;\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "new HashSet<>(length_by_edge.get(Arrays.asList(node)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:52.450562914 +0100\n+++ /tmp/tmpu0a2t7q4.java\t2023-03-24 21:05:52.450562914 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(length_by_edge.get(Arrays.asList(node)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "new HashSet<>(); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:54.934553311 +0100\n+++ /tmp/tmpvjtpg_0q.java\t2023-03-24 21:05:55.066552802 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "new HashSet<>(), new HashSet<>(Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:57.222544467 +0100\n+++ /tmp/tmpxe11wrwe.java\t2023-03-24 21:05:57.222544467 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), new HashSet<>(Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "new Integer() ); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:05:59.442535888 +0100\n+++ /tmp/tmp0u9ql6a7.java\t2023-03-24 21:05:59.442535888 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer() ); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "new Integer()); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:01.550527738 +0100\n+++ /tmp/tmpbaz7tg8e.java\t2023-03-24 21:06:01.550527738 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer()); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "new HashSet<>())); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:03.542520040 +0100\n+++ /tmp/tmpz6qemefd.java\t2023-03-24 21:06:03.542520040 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>())); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "new HashSet<>(), new HashSet<>(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:06.246509588 +0100\n+++ /tmp/tmphi_i8dbt.java\t2023-03-24 21:06:06.250509574 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), new HashSet<>(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "Integer.MAX_VALUE, Integer.MAX_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:07.830503467 +0100\n+++ /tmp/tmpw83tu83n.java\t2023-03-24 21:06:07.830503467 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE, Integer.MAX_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:10.086494747 +0100\n+++ /tmp/tmp3ejto94l.java\t2023-03-24 21:06:10.254494099 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "true); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:11.882487806 +0100\n+++ /tmp/tmptok0msx6.java\t2023-03-24 21:06:11.882487806 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+true); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "unvisitedNodes.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:13.534481422 +0100\n+++ /tmp/tmpsy344waf.java\t2023-03-24 21:06:13.534481422 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "new HashSet<>(), new HashSet<>(), unvisitedNodes);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:15.162475131 +0100\n+++ /tmp/tmpbz5q69_r.java\t2023-03-24 21:06:15.162475131 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), new HashSet<>(), unvisitedNodes);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "false); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:16.838468652 +0100\n+++ /tmp/tmpglu2r5bv.java\t2023-03-24 21:06:16.838468652 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+false); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "-1); unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:18.494462252 +0100\n+++ /tmp/tmp1az_0mj7.java\t2023-03-24 21:06:18.494462252 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+-1); unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "new HashSet<>()); unvisitedNodes.put(node, nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:20.234455529 +0100\n+++ /tmp/tmprq0c5fme.java\t2023-03-24 21:06:20.238455513 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>()); unvisitedNodes.put(node, nextNode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "unvisitedNodes.get(index + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:21.878449176 +0100\n+++ /tmp/tmp1puag01o.java\t2023-03-24 21:06:21.878449176 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(index + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "new HashSet<>(), new HashSet<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:23.582442591 +0100\n+++ /tmp/tmpnac_idt_.java\t2023-03-24 21:06:23.582442591 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), new HashSet<>());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "(int) unvisitedNodes.get(index + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:25.298435960 +0100\n+++ /tmp/tmpchirmea5.java\t2023-03-24 21:06:25.298435960 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.get(index + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "new HashSet<>(), new HashSet<>(), new HashSet<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:27.030429268 +0100\n+++ /tmp/tmp7_llcbyf.java\t2023-03-24 21:06:27.030429268 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), new HashSet<>(), new HashSet<>());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "new ArrayList<>(Arrays.asList(node, nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:28.738422667 +0100\n+++ /tmp/tmpdcaue7a5.java\t2023-03-24 21:06:28.742422653 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(Arrays.asList(node, nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "new HashSet<>(Arrays.asList(node, nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:30.462416006 +0100\n+++ /tmp/tmpi8dla6lg.java\t2023-03-24 21:06:30.462416006 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(Arrays.asList(node, nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "new HashSet<>(Arrays.asList(node))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:32.198409298 +0100\n+++ /tmp/tmpeqr8jvvj.java\t2023-03-24 21:06:32.202409282 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(Arrays.asList(node))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "new HashSet<>(Arrays.asList(node)) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:34.006402312 +0100\n+++ /tmp/tmpi_mbqjzs.java\t2023-03-24 21:06:34.006402312 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(Arrays.asList(node)) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "new Integer(unvisitedNodes.get(nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:35.698395774 +0100\n+++ /tmp/tmp3e5_44_3.java\t2023-03-24 21:06:35.702395758 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(unvisitedNodes.get(nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "-1; unvisitedNodes.put(node, nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:39.774380026 +0100\n+++ /tmp/tmpyirwb72_.java\t2023-03-24 21:06:39.774380026 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+-1; unvisitedNodes.put(node, nextnode);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "Integer.MAX_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:41.510373317 +0100\n+++ /tmp/tmpy96005cl.java\t2023-03-24 21:06:41.510373317 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "new Integer(MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:43.226366689 +0100\n+++ /tmp/tmppct4zzri.java\t2023-03-24 21:06:43.226366689 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "Arrays.asList(node, nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:44.918360152 +0100\n+++ /tmp/tmpfad5x3nx.java\t2023-03-24 21:06:44.918360152 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Arrays.asList(node, nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "new Integer(nextnode) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:46.622353569 +0100\n+++ /tmp/tmp1qn712l_.java\t2023-03-24 21:06:46.622353569 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(nextnode) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "new ArrayList<>(Arrays.asList(node))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:48.318347016 +0100\n+++ /tmp/tmpa9ne6jtz.java\t2023-03-24 21:06:48.318347016 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(Arrays.asList(node))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "new ArrayList<>(Arrays.asList(node)) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:50.110340093 +0100\n+++ /tmp/tmp9crhkkmq.java\t2023-03-24 21:06:50.110340093 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(Arrays.asList(node)) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "new Integer(nextnode), unvisitedNodes);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:51.830333448 +0100\n+++ /tmp/tmpoo26jefx.java\t2023-03-24 21:06:51.830333448 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(nextnode), unvisitedNodes);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "new HashSet<>(), unvisitedNodes);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:53.570326726 +0100\n+++ /tmp/tmp_r2ba3m9.java\t2023-03-24 21:06:53.570326726 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(), unvisitedNodes);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "new HashSet<>(unvisitedNodes.values()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:55.278320127 +0100\n+++ /tmp/tmpfwvb2p64.java\t2023-03-24 21:06:55.278320127 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(unvisitedNodes.values()));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "new ArrayList<>(unvisitedNodes.values()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:57.058313251 +0100\n+++ /tmp/tmp86ccdons.java\t2023-03-24 21:06:57.058313251 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(unvisitedNodes.values()));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "new Integer(nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:06:58.770306638 +0100\n+++ /tmp/tmphgvj1fr0.java\t2023-03-24 21:06:58.770306638 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "Arrays.asList(node, nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:00.482300024 +0100\n+++ /tmp/tmp_bskfjq3.java\t2023-03-24 21:07:00.486300008 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Arrays.asList(node, nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "new ArrayList<>(unvisitedNodes.values());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:02.174293488 +0100\n+++ /tmp/tmpof8s4a66.java\t2023-03-24 21:07:02.178293474 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(unvisitedNodes.values());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "unvisitedNodes.get(node)) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:03.878286906 +0100\n+++ /tmp/tmp_3b47w6e.java\t2023-03-24 21:07:03.878286906 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(node)) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "new HashSet<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:07.978271068 +0100\n+++ /tmp/tmptdfv91dt.java\t2023-03-24 21:07:07.978271068 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "unvisitedNodes.get(node));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:09.690264457 +0100\n+++ /tmp/tmp_3a970jn.java\t2023-03-24 21:07:09.690264457 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(node));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "new HashSet<>(graph.vertexSet()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:11.342258074 +0100\n+++ /tmp/tmpwmzipa3s.java\t2023-03-24 21:07:11.342258074 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(graph.vertexSet()));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "new Integer.MAX_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:12.994251694 +0100\n+++ /tmp/tmp084gex5l.java\t2023-03-24 21:07:12.994251694 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer.MAX_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:14.642245330 +0100\n+++ /tmp/tmpcmfdq6n9.java\t2023-03-24 21:07:14.642245330 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "Integer.MIN_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:18.794229292 +0100\n+++ /tmp/tmp1apf7eah.java\t2023-03-24 21:07:18.794229292 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MIN_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "new HashSet<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:20.510222665 +0100\n+++ /tmp/tmpnua0v3y0.java\t2023-03-24 21:07:20.510222665 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<Integer>();\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "Collections.emptySet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:22.178216223 +0100\n+++ /tmp/tmp54le9z9c.java\t2023-03-24 21:07:22.178216223 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Collections.emptySet());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "new ArrayDeque<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:23.838209813 +0100\n+++ /tmp/tmprpza_sdb.java\t2023-03-24 21:07:23.838209813 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayDeque<>());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "new HashSet<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:25.554203186 +0100\n+++ /tmp/tmpxbzewpvl.java\t2023-03-24 21:07:25.554203186 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>();\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "graph.vertexSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:27.274196543 +0100\n+++ /tmp/tmp5gkzsib8.java\t2023-03-24 21:07:27.274196543 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+graph.vertexSet());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "new HashSet<>()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:28.982189947 +0100\n+++ /tmp/tmp83z8gphh.java\t2023-03-24 21:07:28.986189931 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>()));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "Boolean.FALSE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 21:07:30.818182855 +0100\n+++ /tmp/tmpo28g_5rh.java\t2023-03-24 21:07:30.818182855 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Boolean.FALSE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "distance + length_by_edge.get(Arrays.asList(node, nextnode))));"
    },
    "shortest_paths": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:14.126711090 +0100\n+++ /tmp/tmph40rmiuw.java\t2023-03-24 21:05:14.494709666 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:16.130703340 +0100\n+++ /tmp/tmp7c56rwo9.java\t2023-03-24 21:05:16.318702613 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (weight_by_node.get(edge.toString() - 1) == weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:18.390694601 +0100\n+++ /tmp/tmptu8zx1zx.java\t2023-03-24 21:05:18.390694601 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString() - 1) == weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:20.446686649 +0100\n+++ /tmp/tmp4kom7ia4.java\t2023-03-24 21:05:20.446686649 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:22.270679597 +0100\n+++ /tmp/tmppel4vpvb.java\t2023-03-24 21:05:22.270679597 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:24.210672094 +0100\n+++ /tmp/tmprpcxhuh8.java\t2023-03-24 21:05:24.210672094 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.put(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:26.162664547 +0100\n+++ /tmp/tmpaqj3v23f.java\t2023-03-24 21:05:26.202664391 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.put(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:28.226656566 +0100\n+++ /tmp/tmp0st0ksod.java\t2023-03-24 21:05:28.226656566 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.put(edge, weight_by_node); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:31.582643590 +0100\n+++ /tmp/tmp9iu5_ufc.java\t2023-03-24 21:05:31.582643590 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.put(edge, weight_by_node); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (weight_by_node.size() > 0) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:33.418636491 +0100\n+++ /tmp/tmphgcfjhjr.java\t2023-03-24 21:05:33.582635857 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.size() > 0) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (weight_by_node.equals(vertex)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:35.630627939 +0100\n+++ /tmp/tmpnmtiqw8g.java\t2023-03-24 21:05:35.630627939 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(vertex)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (weight_by_node.equals(1)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:37.234621738 +0100\n+++ /tmp/tmp1w2hqtrc.java\t2023-03-24 21:05:37.234621738 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(1)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:39.314613695 +0100\n+++ /tmp/tmp9n2vpk9j.java\t2023-03-24 21:05:39.314613695 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:41.218606334 +0100\n+++ /tmp/tmpb1c7wlhu.java\t2023-03-24 21:05:41.350605825 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (weight_by_node.equals(v)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:43.822596268 +0100\n+++ /tmp/tmpn0d_56sq.java\t2023-03-24 21:05:43.950595772 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(v)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (edge.get(1)!= null) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:46.026587748 +0100\n+++ /tmp/tmp_e4c_w0u.java\t2023-03-24 21:05:46.026587748 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(1)!= null) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (weight_by_node.equals(null)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:48.198579350 +0100\n+++ /tmp/tmp1_ixtn5p.java\t2023-03-24 21:05:48.198579350 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(null)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (Math.max(weight_by_node.get(edge.toString()), weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:50.250571418 +0100\n+++ /tmp/tmpk8gb1z39.java\t2023-03-24 21:05:50.250571418 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (Math.max(weight_by_node.get(edge.toString()), weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (Objects.equals(weight_by_node.get(edge.toString()), weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:52.446562930 +0100\n+++ /tmp/tmpwdc1ubdc.java\t2023-03-24 21:05:52.446562930 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (Objects.equals(weight_by_node.get(edge.toString()), weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:54.934553311 +0100\n+++ /tmp/tmpcgqxebj3.java\t2023-03-24 21:05:55.066552802 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (weight_by_node.get(edge.toString())!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:57.234544422 +0100\n+++ /tmp/tmpv3th7ksi.java\t2023-03-24 21:05:57.234544422 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString())!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (weight_by_node.get(edge.toString() - 1) <= weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:05:59.810534464 +0100\n+++ /tmp/tmp2y3jxmmz.java\t2023-03-24 21:05:59.810534464 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString() - 1) <= weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (weight_by_node.get(edge.toString() - 1) > weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:01.542527770 +0100\n+++ /tmp/tmp5z9ld8y6.java\t2023-03-24 21:06:01.546527754 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString() - 1) > weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge, weight_by_node.get(2)); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:03.538520055 +0100\n+++ /tmp/tmp_mt9rqcg.java\t2023-03-24 21:06:03.538520055 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge, weight_by_node.get(2)); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:05.578512171 +0100\n+++ /tmp/tmp3_qjlf40.java\t2023-03-24 21:06:05.578512171 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:07.806503560 +0100\n+++ /tmp/tmp0lb6fhlq.java\t2023-03-24 21:06:07.806503560 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (weight_by_node.get(edge.toString() - 1) < weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:09.898495474 +0100\n+++ /tmp/tmprj_alc6q.java\t2023-03-24 21:06:10.026494980 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString() - 1) < weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:11.766488254 +0100\n+++ /tmp/tmpdjd_wuuf.java\t2023-03-24 21:06:11.766488254 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "for (Map.Entry<String, Integer> entry : weight_by_node.entrySet()) { weight_by_node.add(entry); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:13.430481823 +0100\n+++ /tmp/tmpy1uk5imx.java\t2023-03-24 21:06:13.430481823 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+for (Map.Entry<String, Integer> entry : weight_by_node.entrySet()) { weight_by_node.add(entry); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:15.102475362 +0100\n+++ /tmp/tmpjwudc96p.java\t2023-03-24 21:06:15.102475362 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "for (Map.Entry<String, Integer> entry : weight_by_node.entrySet()) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:16.834468668 +0100\n+++ /tmp/tmp9xhhjgmd.java\t2023-03-24 21:06:16.838468652 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+for (Map.Entry<String, Integer> entry : weight_by_node.entrySet()) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (weight_by_node.get(edge.toString()) == null) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:18.482462300 +0100\n+++ /tmp/tmpsdvui2mi.java\t2023-03-24 21:06:18.482462300 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString()) == null) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge.toString()); } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:20.162455807 +0100\n+++ /tmp/tmppolz2o14.java\t2023-03-24 21:06:20.162455807 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge.toString()); } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:21.850449285 +0100\n+++ /tmp/tmpnaotpf4r.java\t2023-03-24 21:06:21.850449285 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:23.566442652 +0100\n+++ /tmp/tmpd7havoq1.java\t2023-03-24 21:06:23.570442638 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (size > 0) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:25.310435915 +0100\n+++ /tmp/tmpcryitg0z.java\t2023-03-24 21:06:25.310435915 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (size > 0) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.get(edge)); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:27.010429345 +0100\n+++ /tmp/tmp2apyc6g7.java\t2023-03-24 21:06:27.010429345 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.get(edge)); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:28.746422637 +0100\n+++ /tmp/tmpkzsffjsz.java\t2023-03-24 21:06:28.750422621 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (weight_by_node.get(edge.toString()) > weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:30.490415898 +0100\n+++ /tmp/tmp37bitdat.java\t2023-03-24 21:06:30.490415898 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString()) > weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString()))) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:32.178409375 +0100\n+++ /tmp/tmp42r185iz.java\t2023-03-24 21:06:32.178409375 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString()))) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:33.886402776 +0100\n+++ /tmp/tmpuyfdbfk9.java\t2023-03-24 21:06:33.886402776 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.put(edge, weight_by_node); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:35.530396423 +0100\n+++ /tmp/tmptn7swedd.java\t2023-03-24 21:06:35.530396423 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.put(edge, weight_by_node); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:37.178390055 +0100\n+++ /tmp/tmpx1nc9_wv.java\t2023-03-24 21:06:37.182390041 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:38.902383394 +0100\n+++ /tmp/tmppmh2dlr9.java\t2023-03-24 21:06:38.902383394 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(2))) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:40.518377150 +0100\n+++ /tmp/tmpwu2j9pom.java\t2023-03-24 21:06:40.522377135 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:42.138370893 +0100\n+++ /tmp/tmprvecm314.java\t2023-03-24 21:06:42.138370893 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (weight_by_node.get(edge.toString()) == weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:43.822364386 +0100\n+++ /tmp/tmp8gghjwdd.java\t2023-03-24 21:06:43.822364386 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString()) == weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (weight_by_node.get(edge.toString())!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:45.506357879 +0100\n+++ /tmp/tmppjedk493.java\t2023-03-24 21:06:45.506357879 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString())!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (weight_by_node.size() > weight_by_node.get(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:47.098351728 +0100\n+++ /tmp/tmpjr68hr8n.java\t2023-03-24 21:06:47.098351728 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.size() > weight_by_node.get(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString() - 1)) { return weight_by_node; } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:48.742345378 +0100\n+++ /tmp/tmpdw6r2ptq.java\t2023-03-24 21:06:48.746345362 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString() - 1)) { return weight_by_node; } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString()))) { return weight_by_node; } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:50.406338950 +0100\n+++ /tmp/tmpf96h68cf.java\t2023-03-24 21:06:50.406338950 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString()))) { return weight_by_node; } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (weight_by_node.get(edge.toString()) == null) { weight_by_node.set(edge.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:52.086332459 +0100\n+++ /tmp/tmp4m7yj87q.java\t2023-03-24 21:06:52.086332459 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString()) == null) { weight_by_node.set(edge.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString()))) { weight_by_node.set(edge.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:53.782325907 +0100\n+++ /tmp/tmp6novcejg.java\t2023-03-24 21:06:53.782325907 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString()))) { weight_by_node.set(edge.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (weight_by_node.equals(1)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:55.462319416 +0100\n+++ /tmp/tmpbb400b44.java\t2023-03-24 21:06:55.466319402 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(1)) { weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(1))) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:57.182312773 +0100\n+++ /tmp/tmpqmsmjak3.java\t2023-03-24 21:06:57.182312773 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(1))) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:06:58.846306345 +0100\n+++ /tmp/tmp5zx6_s6y.java\t2023-03-24 21:06:58.850306329 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (weight_by_node.get(edge.toString())!= null) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:00.482300024 +0100\n+++ /tmp/tmpolv3p5i_.java\t2023-03-24 21:07:00.482300024 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString())!= null) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(2))) { return weight_by_node; } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:02.174293488 +0100\n+++ /tmp/tmpbwsck00x.java\t2023-03-24 21:07:02.174293488 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(2))) { return weight_by_node; } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:03.870286938 +0100\n+++ /tmp/tmpm4gjatz_.java\t2023-03-24 21:07:03.874286922 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:05.614280200 +0100\n+++ /tmp/tmpe3qwa64e.java\t2023-03-24 21:07:05.618280186 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.get(edge)); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:07.334273557 +0100\n+++ /tmp/tmp42can0tr.java\t2023-03-24 21:07:07.334273557 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.get(edge)); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:08.998267129 +0100\n+++ /tmp/tmpnnbl2n3r.java\t2023-03-24 21:07:09.002267113 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (weight_by_node.get(edge.toString() - 1).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:10.650260748 +0100\n+++ /tmp/tmpq69cdq6b.java\t2023-03-24 21:07:10.650260748 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString() - 1).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:12.374254090 +0100\n+++ /tmp/tmpcimqic37.java\t2023-03-24 21:07:12.374254090 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:14.006247786 +0100\n+++ /tmp/tmpsdi0eknn.java\t2023-03-24 21:07:14.026247709 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { return weight_by_node; } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:15.738241095 +0100\n+++ /tmp/tmpwrnzx3kp.java\t2023-03-24 21:07:15.742241082 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { return weight_by_node; } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:17.446234500 +0100\n+++ /tmp/tmpvim7u2wu.java\t2023-03-24 21:07:17.446234500 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { weight_by_node.set(edge, weight_by_node.toString()); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:19.146227934 +0100\n+++ /tmp/tmprtyrdp4l.java\t2023-03-24 21:07:19.146227934 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:20.798221553 +0100\n+++ /tmp/tmpd5cznc3r.java\t2023-03-24 21:07:20.798221553 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:22.446215189 +0100\n+++ /tmp/tmp04__giq0.java\t2023-03-24 21:07:22.446215189 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (weight_by_node.equals(edge)) { return weight_by_node; } else { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:24.062208946 +0100\n+++ /tmp/tmplw7484ep.java\t2023-03-24 21:07:24.066208932 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { return weight_by_node; } else { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:25.682202690 +0100\n+++ /tmp/tmplw8rok25.java\t2023-03-24 21:07:25.682202690 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(edge.toString())) { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:27.338196296 +0100\n+++ /tmp/tmpf99pvfq0.java\t2023-03-24 21:07:27.338196296 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node)) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:29.050189684 +0100\n+++ /tmp/tmpkvej_svq.java\t2023-03-24 21:07:29.050189684 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.set(edge, weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (weight_by_node.get(edge.toString() - 1) == weight_by_node.get(edge.toString())); } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:30.750183118 +0100\n+++ /tmp/tmp3o22ueok.java\t2023-03-24 21:07:30.750183118 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString() - 1) == weight_by_node.get(edge.toString())); } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (weight_by_node.equals(edge)) { return weight_by_node; } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:32.494176384 +0100\n+++ /tmp/tmpgsu_0yd3.java\t2023-03-24 21:07:32.494176384 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { return weight_by_node; } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.get(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:34.526168536 +0100\n+++ /tmp/tmprsxvjii4.java\t2023-03-24 21:07:34.526168536 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.get(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (edge.get(1)!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:36.626160427 +0100\n+++ /tmp/tmpb8s1cd81.java\t2023-03-24 21:07:36.626160427 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(1)!= null) { weight_by_node.set(edge.toString()); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:38.254154139 +0100\n+++ /tmp/tmp8f_9vux3.java\t2023-03-24 21:07:38.254154139 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (weight_by_node!= null) { weight_by_node.set(edge); } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:39.926147684 +0100\n+++ /tmp/tmppdg26njz.java\t2023-03-24 21:07:39.926147684 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { weight_by_node.set(edge); } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (weight_by_node.equals(edge)) return weight_by_node; } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:41.654141011 +0100\n+++ /tmp/tmp5uyyavj_.java\t2023-03-24 21:07:41.654141011 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) return weight_by_node; } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (weight_by_node.equals(v)) { weight_by_node.set(edge); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:43.326134555 +0100\n+++ /tmp/tmpa7ti8n_a.java\t2023-03-24 21:07:43.326134555 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(v)) { weight_by_node.set(edge); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (weight_by_node.equals(\"\")); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:45.026127991 +0100\n+++ /tmp/tmpfnokg6rp.java\t2023-03-24 21:07:45.026127991 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(\"\")); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString() - 1)) { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:46.710121488 +0100\n+++ /tmp/tmpue44pmym.java\t2023-03-24 21:07:46.710121488 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString() - 1)) { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (weight_by_node.equals(edge.get(edge.toString()))) { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:48.406114939 +0100\n+++ /tmp/tmpgc2xyleb.java\t2023-03-24 21:07:48.410114924 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.get(edge.toString()))) { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (weight_by_node.equals(v)) { weight_by_node.set(edge); } return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:50.106108375 +0100\n+++ /tmp/tmpqpwqdn3j.java\t2023-03-24 21:07:50.106108375 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(v)) { weight_by_node.set(edge); } return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "weight_by_node.put(edge, weight_by_node); } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:51.770101951 +0100\n+++ /tmp/tmptju4pma5.java\t2023-03-24 21:07:51.774101935 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.put(edge, weight_by_node); } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "weight_by_node.set(edge, weight_by_node); } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:53.422095572 +0100\n+++ /tmp/tmpvmhrqs1c.java\t2023-03-24 21:07:53.426095556 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.set(edge, weight_by_node); } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:55.050089286 +0100\n+++ /tmp/tmp5w4iqrp0.java\t2023-03-24 21:07:55.050089286 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (weight_by_node.equals(edge)) { return weight_by_node; } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:56.690082955 +0100\n+++ /tmp/tmpfrtoafuh.java\t2023-03-24 21:07:56.690082955 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { return weight_by_node; } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (weight_by_node!= null) { return weight_by_node; } } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:07:58.350076544 +0100\n+++ /tmp/tmpu6krg_sf.java\t2023-03-24 21:07:58.350076544 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node!= null) { return weight_by_node; } } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (edge.get(2).equals(weight_by_node.get(2))) { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:00.002070167 +0100\n+++ /tmp/tmpya5t59az.java\t2023-03-24 21:08:00.006070152 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(2).equals(weight_by_node.get(2))) { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (weight_by_node.get(edge.toString())); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:01.666063741 +0100\n+++ /tmp/tmpuv3myhs9.java\t2023-03-24 21:08:01.666063741 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.get(edge.toString())); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "weight_by_node.put(edge, weight_by_node); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:03.386057102 +0100\n+++ /tmp/tmppe908res.java\t2023-03-24 21:08:03.386057102 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.put(edge, weight_by_node); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "weight_by_node.get(edge.toString()); } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:05.010050832 +0100\n+++ /tmp/tmpo5eme5s3.java\t2023-03-24 21:08:05.010050832 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.get(edge.toString()); } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "weight_by_node.set(edge, weight_by_node); } return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:06.698044315 +0100\n+++ /tmp/tmpnl0fv5sc.java\t2023-03-24 21:08:06.698044315 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.set(edge, weight_by_node); } return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (weight_by_node.equals(edge.toString())) { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:08.358037906 +0100\n+++ /tmp/tmp0t711m_f.java\t2023-03-24 21:08:08.358037906 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge.toString())) { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (weight_by_node.equals(edge)) { return weight_by_node; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:10.066031312 +0100\n+++ /tmp/tmpyr3f7s_8.java\t2023-03-24 21:08:10.066031312 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (weight_by_node.equals(edge)) { return weight_by_node; } }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "weight_by_node.get(edge.toString()).add(edge); } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:11.722024919 +0100\n+++ /tmp/tmpg0lnrp6u.java\t2023-03-24 21:08:11.722024919 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.get(edge.toString()).add(edge); } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "weight_by_node.add(edge); } return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 21:08:13.418018373 +0100\n+++ /tmp/tmpypjcj91y.java\t2023-03-24 21:08:13.418018373 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.add(edge); } return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "weight_by_node.put(edge.get(1), update_weight); } } return weight_by_node; }"
    },
    "hanoi": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:36.474161014 +0100\n+++ /tmp/tmpfhe2mf_0.java\t2023-03-24 21:07:36.474161014 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:38.302153954 +0100\n+++ /tmp/tmp8r2rot5g.java\t2023-03-24 21:07:38.302153954 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:40.038147251 +0100\n+++ /tmp/tmpebilddar.java\t2023-03-24 21:07:40.038147251 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (start!= -1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:41.870140178 +0100\n+++ /tmp/tmp_v2mgrs8.java\t2023-03-24 21:07:41.870140178 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (start!= -1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if ( started) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:45.838124855 +0100\n+++ /tmp/tmp5pqe6z62.java\t2023-03-24 21:07:45.838124855 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( started) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, false)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:47.558118214 +0100\n+++ /tmp/tmpm0jmpreq.java\t2023-03-24 21:07:47.558118214 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, false)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (traces > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:49.294111511 +0100\n+++ /tmp/tmpdjkz0lax.java\t2023-03-24 21:07:49.294111511 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (traces > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, false)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:51.074104638 +0100\n+++ /tmp/tmp4lpkzrht.java\t2023-03-24 21:07:51.074104638 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, false)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if ((':') { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:52.866097719 +0100\n+++ /tmp/tmp7w0zmxsr.java\t2023-03-24 21:07:52.866097719 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ((':') { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (general.isPresent()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:54.554091202 +0100\n+++ /tmp/tmpp4x350b4.java\t2023-03-24 21:07:54.554091202 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (general.isPresent()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (trackUndo) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:56.334084329 +0100\n+++ /tmp/tmpqhqifs0r.java\t2023-03-24 21:07:56.338084313 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (trackUndo) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (style.isAuto()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:58.174077224 +0100\n+++ /tmp/tmpikk73qd5.java\t2023-03-24 21:07:58.174077224 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (style.isAuto()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if ( steps.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:07:59.966070306 +0100\n+++ /tmp/tmpl4fvsy84.java\t2023-03-24 21:07:59.966070306 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( steps.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(start, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:03.990054770 +0100\n+++ /tmp/tmpfwnv_p58.java\t2023-03-24 21:08:03.990054770 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(start, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(width, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:08.002039281 +0100\n+++ /tmp/tmpqa7vhb4c.java\t2023-03-24 21:08:08.002039281 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(width, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (general.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:09.822032254 +0100\n+++ /tmp/tmpnctpkikf.java\t2023-03-24 21:08:09.822032254 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (general.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (pushQueue) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:11.606025368 +0100\n+++ /tmp/tmp1ksfda9w.java\t2023-03-24 21:08:11.606025368 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(end, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:13.442018280 +0100\n+++ /tmp/tmpl7d5xigk.java\t2023-03-24 21:08:13.442018280 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(end, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (ascending) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:15.214011439 +0100\n+++ /tmp/tmpcdu7ahar.java\t2023-03-24 21:08:15.218011423 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (ascending) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (overflow!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:17.334003255 +0100\n+++ /tmp/tmpcr_xk9_b.java\t2023-03-24 21:08:17.334003255 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (overflow!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (ms.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:19.381995349 +0100\n+++ /tmp/tmpp6x32s05.java\t2023-03-24 21:08:19.385995334 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (ms.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if ( helper!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:21.173988431 +0100\n+++ /tmp/tmp9wm_xvm9.java\t2023-03-24 21:08:21.173988431 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( helper!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (slice!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:23.085981051 +0100\n+++ /tmp/tmptct7tkwc.java\t2023-03-24 21:08:23.085981051 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (slice!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(2))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:24.857974212 +0100\n+++ /tmp/tmphtiapk6g.java\t2023-03-24 21:08:24.857974212 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(2))); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:26.689967140 +0100\n+++ /tmp/tmpppvvpccp.java\t2023-03-24 21:08:26.689967140 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(1)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (true) { steps.add(new Pair<Integer,Integer>(true, true)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:28.429960423 +0100\n+++ /tmp/tmpdtu6yny5.java\t2023-03-24 21:08:28.429960423 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (true) { steps.add(new Pair<Integer,Integer>(true, true)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (traces > 0) { steps.add(new Pair<Integer,Integer>(traces)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:30.245953414 +0100\n+++ /tmp/tmp8d1om7u9.java\t2023-03-24 21:08:30.245953414 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (traces > 0) { steps.add(new Pair<Integer,Integer>(traces)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, null)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:32.029946528 +0100\n+++ /tmp/tmphmrqp02x.java\t2023-03-24 21:08:32.029946528 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, null)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( end, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:33.809939657 +0100\n+++ /tmp/tmp7oc6okiv.java\t2023-03-24 21:08:33.809939657 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( end, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(block)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:35.629932632 +0100\n+++ /tmp/tmp_2vnfh0r.java\t2023-03-24 21:08:35.629932632 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(block)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:37.433925670 +0100\n+++ /tmp/tmpv4_uztk2.java\t2023-03-24 21:08:37.433925670 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(2)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(1))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:39.153919031 +0100\n+++ /tmp/tmpmlbdgmxw.java\t2023-03-24 21:08:39.153919031 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group(1))); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (MS.isPresent()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:40.933912159 +0100\n+++ /tmp/tmpqz5d3fn9.java\t2023-03-24 21:08:40.937912146 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (MS.isPresent()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:42.841904797 +0100\n+++ /tmp/tmploa29zp9.java\t2023-03-24 21:08:42.841904797 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, true)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:44.589898051 +0100\n+++ /tmp/tmpt4stazhx.java\t2023-03-24 21:08:44.589898051 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, true)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (projectId!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:46.365891196 +0100\n+++ /tmp/tmpl6pybosx.java\t2023-03-24 21:08:46.365891196 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (projectId!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (channels!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:48.157884280 +0100\n+++ /tmp/tmpqoouy6y5.java\t2023-03-24 21:08:48.157884280 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channels!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( stop, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:49.885877610 +0100\n+++ /tmp/tmpt331tfp_.java\t2023-03-24 21:08:49.885877610 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( stop, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(clear, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:51.609870958 +0100\n+++ /tmp/tmpod6aypgl.java\t2023-03-24 21:08:51.609870958 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(clear, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(stop, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:53.373864151 +0100\n+++ /tmp/tmpr6o6lx8u.java\t2023-03-24 21:08:53.373864151 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(stop, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (general.isNumber()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:55.177857187 +0100\n+++ /tmp/tmprgu9565h.java\t2023-03-24 21:08:55.177857187 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (general.isNumber()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (width!= -1) { steps.add(new Pair<Integer,Integer>(width, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:56.997850164 +0100\n+++ /tmp/tmp9wtnge5s.java\t2023-03-24 21:08:56.997850164 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (width!= -1) { steps.add(new Pair<Integer,Integer>(width, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, null)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:08:58.773843311 +0100\n+++ /tmp/tmprvrx2aul.java\t2023-03-24 21:08:58.777843295 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, null)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, true)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:00.525836548 +0100\n+++ /tmp/tmpdcdpxkbg.java\t2023-03-24 21:09:00.525836548 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, true)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( 2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:02.257829865 +0100\n+++ /tmp/tmp7f2niwa3.java\t2023-03-24 21:09:02.257829865 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( 2)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (true) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:04.061822903 +0100\n+++ /tmp/tmpnwx_olre.java\t2023-03-24 21:09:04.061822903 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (true) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (secondary!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:08.169807052 +0100\n+++ /tmp/tmp2o2qwrqb.java\t2023-03-24 21:09:08.169807052 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (secondary!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:09.925800276 +0100\n+++ /tmp/tmps9c117fv.java\t2023-03-24 21:09:09.925800276 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.group())); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(buffer, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:11.749793237 +0100\n+++ /tmp/tmpl23f5ql6.java\t2023-03-24 21:09:11.749793237 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(buffer, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.getKey())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:13.533786354 +0100\n+++ /tmp/tmp9oh65n0c.java\t2023-03-24 21:09:13.533786354 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( matcher.find()) { steps.add(new Pair<Integer,Integer>( matcher.getKey())); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(true, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:15.349779347 +0100\n+++ /tmp/tmp58phf844.java\t2023-03-24 21:09:15.349779347 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(true, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (aliases!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:17.149772401 +0100\n+++ /tmp/tmp2quh9iod.java\t2023-03-24 21:09:17.149772401 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (aliases!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:18.973765364 +0100\n+++ /tmp/tmpxlq6xh4b.java\t2023-03-24 21:09:18.973765364 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if ( matcher.find()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:20.765758449 +0100\n+++ /tmp/tmp8xb1lmks.java\t2023-03-24 21:09:20.765758449 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( matcher.find()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(module, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:22.609751333 +0100\n+++ /tmp/tmpw6gr72_0.java\t2023-03-24 21:09:22.613751320 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(module, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (true) { steps.add(new Pair<Integer,Integer>(width, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:24.493744065 +0100\n+++ /tmp/tmprznx8h1x.java\t2023-03-24 21:09:24.509744004 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (true) { steps.add(new Pair<Integer,Integer>(width, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(new, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:26.261737244 +0100\n+++ /tmp/tmp91lo61lc.java\t2023-03-24 21:09:26.261737244 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(new, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:27.917730854 +0100\n+++ /tmp/tmp38nqg91n.java\t2023-03-24 21:09:27.917730854 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(true, true)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:29.753723770 +0100\n+++ /tmp/tmpblwy2tlu.java\t2023-03-24 21:09:29.753723770 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(true, true)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( \"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:31.601716640 +0100\n+++ /tmp/tmpjk3qdxvj.java\t2023-03-24 21:09:31.601716640 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>( \"); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(block, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:33.289710129 +0100\n+++ /tmp/tmph6fbt4q7.java\t2023-03-24 21:09:33.289710129 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(block, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(Queue)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:35.025703431 +0100\n+++ /tmp/tmphwheome5.java\t2023-03-24 21:09:35.025703431 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(Queue)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(limit, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:36.753696764 +0100\n+++ /tmp/tmp33sf69z7.java\t2023-03-24 21:09:36.753696764 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(limit, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if ( started) { steps.add(new Pair<Integer,Integer>(end, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:38.521689944 +0100\n+++ /tmp/tmpnymtj9pa.java\t2023-03-24 21:09:38.525689928 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( started) { steps.add(new Pair<Integer,Integer>(end, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, pattern)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:40.249683276 +0100\n+++ /tmp/tmpvk35efrs.java\t2023-03-24 21:09:40.253683262 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, pattern)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(width, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:42.025676424 +0100\n+++ /tmp/tmpfk0a7wen.java\t2023-03-24 21:09:42.025676424 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(width, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(with, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:43.757669743 +0100\n+++ /tmp/tmpn9_yc7ez.java\t2023-03-24 21:09:43.757669743 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(with, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, remoteAddress)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:45.469663138 +0100\n+++ /tmp/tmpuuu9c0pl.java\t2023-03-24 21:09:45.469663138 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, remoteAddress)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (true) { steps.add(new Pair<Integer,Integer>(true, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:47.201656457 +0100\n+++ /tmp/tmpm_80jwm6.java\t2023-03-24 21:09:47.201656457 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (true) { steps.add(new Pair<Integer,Integer>(true, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if ((':') { steps.add(new Pair<Integer,Integer>(width, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:48.941649745 +0100\n+++ /tmp/tmpm4ztw4cd.java\t2023-03-24 21:09:48.941649745 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ((':') { steps.add(new Pair<Integer,Integer>(width, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (true) { steps.add(new Pair<Integer,Integer>(end, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:50.665643093 +0100\n+++ /tmp/tmpcs9uxc2t.java\t2023-03-24 21:09:50.665643093 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (true) { steps.add(new Pair<Integer,Integer>(end, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(end, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:54.797627155 +0100\n+++ /tmp/tmpcldd6fzd.java\t2023-03-24 21:09:54.801627139 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(end, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (true) { steps.add(new Pair<Integer,Integer>(true)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:09:58.961611091 +0100\n+++ /tmp/tmpjqf560jr.java\t2023-03-24 21:09:58.961611091 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (true) { steps.add(new Pair<Integer,Integer>(true)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(key, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:00.705604364 +0100\n+++ /tmp/tmpqr9b89_a.java\t2023-03-24 21:10:00.705604364 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(key, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(module, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:02.481597515 +0100\n+++ /tmp/tmpj3ijtx96.java\t2023-03-24 21:10:02.481597515 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(module, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(new, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:04.245590711 +0100\n+++ /tmp/tmpt1gllhbm.java\t2023-03-24 21:10:04.245590711 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(new, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(true, true));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:05.945584153 +0100\n+++ /tmp/tmp9_f127c6.java\t2023-03-24 21:10:05.945584153 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(true, true));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( start, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:07.745577209 +0100\n+++ /tmp/tmplmeesprl.java\t2023-03-24 21:10:07.745577209 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( start, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( end, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:11.849561381 +0100\n+++ /tmp/tmpi53i0mu_.java\t2023-03-24 21:10:11.849561381 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( end, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(padding, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:15.977546484 +0100\n+++ /tmp/tmp7et5gg6e.java\t2023-03-24 21:10:15.977546484 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(padding, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(true, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:17.809540357 +0100\n+++ /tmp/tmphnprs9lg.java\t2023-03-24 21:10:17.809540357 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(true, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(block));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:19.593534389 +0100\n+++ /tmp/tmpt0ckmnqe.java\t2023-03-24 21:10:19.597534375 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(block));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( stop, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:21.345528524 +0100\n+++ /tmp/tmpv0n2xyyf.java\t2023-03-24 21:10:21.345528524 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( stop, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(buffer, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:23.121522574 +0100\n+++ /tmp/tmpjrbiw7b9.java\t2023-03-24 21:10:23.125522562 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(buffer, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:24.929516516 +0100\n+++ /tmp/tmpom2bo1h4.java\t2023-03-24 21:10:24.929516516 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(startDate, null));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:26.653510737 +0100\n+++ /tmp/tmpfapdmlfy.java\t2023-03-24 21:10:26.653510737 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(startDate, null));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(height, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:28.461504675 +0100\n+++ /tmp/tmp20r6fhnc.java\t2023-03-24 21:10:28.461504675 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(height, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(stop, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:32.481491182 +0100\n+++ /tmp/tmp8yhuah8e.java\t2023-03-24 21:10:32.481491182 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(stop, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(clear, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:34.201485407 +0100\n+++ /tmp/tmpi12ya1b_.java\t2023-03-24 21:10:34.201485407 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(clear, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(width), helper);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:35.993479386 +0100\n+++ /tmp/tmpyafimnrc.java\t2023-03-24 21:10:35.997479371 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(width), helper);\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( matcher.group(1)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:37.873473065 +0100\n+++ /tmp/tmp14_uxq9j.java\t2023-03-24 21:10:37.873473065 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( matcher.group(1)));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(index, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:39.661467053 +0100\n+++ /tmp/tmpoj4jsebw.java\t2023-03-24 21:10:39.661467053 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(index, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( \");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:41.397461213 +0100\n+++ /tmp/tmp2e20qy7l.java\t2023-03-24 21:10:41.397461213 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( \");\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(limit, helper));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:43.133455370 +0100\n+++ /tmp/tmpth_50hyz.java\t2023-03-24 21:10:43.133455370 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(limit, helper));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( matcher, pattern));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:44.957449226 +0100\n+++ /tmp/tmpbfpjy178.java\t2023-03-24 21:10:44.961449214 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( matcher, pattern));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(pattern, null));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:46.785443069 +0100\n+++ /tmp/tmp7wywewmp.java\t2023-03-24 21:10:46.789443055 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(pattern, null));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(module));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:48.569437057 +0100\n+++ /tmp/tmp5iq3_aom.java\t2023-03-24 21:10:48.569437057 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(module));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( crap);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:50.405430866 +0100\n+++ /tmp/tmpn42pgfgu.java\t2023-03-24 21:10:50.405430866 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( crap);\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>( crap));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:52.125425063 +0100\n+++ /tmp/tmp8huarqvq.java\t2023-03-24 21:10:52.125425063 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>( crap));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "steps.add(new Pair<Integer,Integer>(Borders));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 21:10:53.909419042 +0100\n+++ /tmp/tmp_0f4gzev.java\t2023-03-24 21:10:53.909419042 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+steps.add(new Pair<Integer,Integer>(Borders));\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "steps.add(new Pair<Integer,Integer>(start, end));"
    },
    "gcd": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (a % b) return a; else { a = b / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:18.477998839 +0100\n+++ /tmp/tmptksa1r7f.java\t2023-03-24 21:08:18.537998608 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (a % b) return a; else { a = b % a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:20.229992075 +0100\n+++ /tmp/tmpcpaxqmms.java\t2023-03-24 21:08:20.233992061 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (a % b) return a; else { a = b % a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:21.981985313 +0100\n+++ /tmp/tmpwk4ampkt.java\t2023-03-24 21:08:21.981985313 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (a % b) return a; else { a = a % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:23.701978673 +0100\n+++ /tmp/tmp4tqotej6.java\t2023-03-24 21:08:23.705978657 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (a % b) return a; else { return a % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:25.433971988 +0100\n+++ /tmp/tmpli71d_l6.java\t2023-03-24 21:08:25.433971988 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { return a % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (a % b) return a; else { return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:27.121965473 +0100\n+++ /tmp/tmpqkdb4h97.java\t2023-03-24 21:08:27.121965473 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (a % b) return a; else return a % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:28.801958987 +0100\n+++ /tmp/tmpljfv3894.java\t2023-03-24 21:08:28.801958987 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else return a % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (a % b) return a; else { throw new IllegalArgumentException(a % b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:30.461952581 +0100\n+++ /tmp/tmpbdikyuz6.java\t2023-03-24 21:08:30.465952565 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { throw new IllegalArgumentException(a % b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (a % b) return a; else { a = b / b; } return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:32.173945972 +0100\n+++ /tmp/tmp8em6vohb.java\t2023-03-24 21:08:32.173945972 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / b; } return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (a % b) return a; else { a = a % b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:33.837939548 +0100\n+++ /tmp/tmp_3hw7grg.java\t2023-03-24 21:08:33.837939548 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (a % b) return a; else { a = a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:35.665932494 +0100\n+++ /tmp/tmpjxinnpd4.java\t2023-03-24 21:08:35.665932494 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (a % b) return a; else { a = b % (a % b) * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:37.489925453 +0100\n+++ /tmp/tmpkbngh7lj.java\t2023-03-24 21:08:37.505925392 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % (a % b) * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (a % b) return a; else { a = b / a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:39.233918722 +0100\n+++ /tmp/tmp545qm5bc.java\t2023-03-24 21:08:39.233918722 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (a % b) return a; else { throw new IllegalArgumentException(a % b - b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:41.021911820 +0100\n+++ /tmp/tmp20ezmin2.java\t2023-03-24 21:08:41.025911806 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { throw new IllegalArgumentException(a % b - b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (a % b) returnreplaceAll(a % b, b); else { return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:42.733905214 +0100\n+++ /tmp/tmpirvr1n24.java\t2023-03-24 21:08:42.733905214 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) returnreplaceAll(a % b, b); else { return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (a % b) return a; else { a = b % a; } return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:44.537898250 +0100\n+++ /tmp/tmphkhgruat.java\t2023-03-24 21:08:44.541898236 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % a; } return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (a % b) return a; else return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:46.257891612 +0100\n+++ /tmp/tmpoy_58f5u.java\t2023-03-24 21:08:46.257891612 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (a % b) return a; else { a = b / b; } return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:47.941885113 +0100\n+++ /tmp/tmp_jsphoyf.java\t2023-03-24 21:08:47.941885113 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / b; } return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (a % b) return a; else { a = b / b; } return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:49.649878522 +0100\n+++ /tmp/tmp5rdii8mm.java\t2023-03-24 21:08:49.649878522 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / b; } return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (a % b) return a; else { a = b % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:51.369871885 +0100\n+++ /tmp/tmpd0u7blok.java\t2023-03-24 21:08:51.369871885 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (a % b) return a; else { a = -a - b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:53.153864998 +0100\n+++ /tmp/tmpbw5f79j9.java\t2023-03-24 21:08:53.157864984 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = -a - b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (a % b) { returnractice(a % b, b); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:54.941858099 +0100\n+++ /tmp/tmpvd55kjmj.java\t2023-03-24 21:08:54.941858099 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) { returnractice(a % b, b); } else { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (a % b) return a; else { throw new IllegalArgumentException(a % b, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:56.749851122 +0100\n+++ /tmp/tmpjxjl222x.java\t2023-03-24 21:08:56.749851122 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { throw new IllegalArgumentException(a % b, b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (a % b) return a; else { a = a % b; } return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:08:58.637843836 +0100\n+++ /tmp/tmpb9s1gvbx.java\t2023-03-24 21:08:58.637843836 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b; } return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (a % b) return a; else { a = b / (b - b) * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:00.365837167 +0100\n+++ /tmp/tmpo8wkebnq.java\t2023-03-24 21:09:00.365837167 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / (b - b) * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (a % b) return a; else { a = b / b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:02.077830560 +0100\n+++ /tmp/tmpj9pln3fa.java\t2023-03-24 21:09:02.081830545 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (a % b) returnreplaceAll(a % b, b); else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:03.893823553 +0100\n+++ /tmp/tmpc4np4d_b.java\t2023-03-24 21:09:03.893823553 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) returnreplaceAll(a % b, b); else { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (a % b) return a; else { a = b / (a % b) - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:05.569817085 +0100\n+++ /tmp/tmp0s0bvo_8.java\t2023-03-24 21:09:05.573817069 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / (a % b) - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (a % b) returnreplaceAll(a % b, b); else { return a - b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:07.357810184 +0100\n+++ /tmp/tmpjmjbpuze.java\t2023-03-24 21:09:07.361810171 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) returnreplaceAll(a % b, b); else { return a - b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (a % b) return a; else { a = b % b; } return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:09.081803533 +0100\n+++ /tmp/tmp34czyh3a.java\t2023-03-24 21:09:09.081803533 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % b; } return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (a % b) return a; else { a = b / (b - b) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:10.725797189 +0100\n+++ /tmp/tmpxvqo2mzp.java\t2023-03-24 21:09:10.725797189 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / (b - b) - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (a % b) returnreplaceAll(a % b, b); else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:12.437790583 +0100\n+++ /tmp/tmpz106oqw_.java\t2023-03-24 21:09:12.437790583 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) returnreplaceAll(a % b, b); else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (a % b) return a; else { a = b % (a % b) - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:14.109784132 +0100\n+++ /tmp/tmpu14pxi5j.java\t2023-03-24 21:09:14.109784132 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % (a % b) - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (a % b) return b; else { return a % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:15.801777603 +0100\n+++ /tmp/tmpi6z2zpnl.java\t2023-03-24 21:09:15.801777603 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else { return a % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (a % b) return a; else { a = a % b - 1; } return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:17.593770688 +0100\n+++ /tmp/tmpko1_chq8.java\t2023-03-24 21:09:17.593770688 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b - 1; } return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (a % b) return a; else { a = -a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:19.229764376 +0100\n+++ /tmp/tmp9y86rhye.java\t2023-03-24 21:09:19.229764376 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = -a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (a % b) return a; else { a = b / b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:20.921757847 +0100\n+++ /tmp/tmp_9zzlz3z.java\t2023-03-24 21:09:20.921757847 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (a % b) return a; else { a = b % d; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:22.641751211 +0100\n+++ /tmp/tmposy09d8r.java\t2023-03-24 21:09:22.641751211 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % d; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (a % b) return a; else { a = b / (b % b) - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:24.457744204 +0100\n+++ /tmp/tmphlyji9ru.java\t2023-03-24 21:09:24.457744204 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / (b % b) - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (a % b) return a; else { a = b / a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:26.181737552 +0100\n+++ /tmp/tmp_uh7vo4a.java\t2023-03-24 21:09:26.181737552 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (a % b!= 0) { returnractice(a % b, b); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:27.909730886 +0100\n+++ /tmp/tmpij1nqv_x.java\t2023-03-24 21:09:27.909730886 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b!= 0) { returnractice(a % b, b); } else { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (a % b) return b; else { return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:29.653724157 +0100\n+++ /tmp/tmpv49by_uk.java\t2023-03-24 21:09:29.653724157 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else { return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (a % b) return a; else { throw new IllegalStateException(a % b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:31.421717335 +0100\n+++ /tmp/tmpyqnipbv1.java\t2023-03-24 21:09:31.421717335 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { throw new IllegalStateException(a % b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (a % b) return a % b; else return a % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:33.193710497 +0100\n+++ /tmp/tmpjyuqf7v3.java\t2023-03-24 21:09:33.193710497 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a % b; else return a % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (a % b) return a % b; else { return a % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:34.813704249 +0100\n+++ /tmp/tmplwh30f1r.java\t2023-03-24 21:09:34.841704140 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a % b; else { return a % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (a % b) returnreplaceAll(a % b, b); else return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:36.657697135 +0100\n+++ /tmp/tmp4s2yq97e.java\t2023-03-24 21:09:36.657697135 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) returnreplaceAll(a % b, b); else return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (a % b) return a; else { a = b / (b - b) - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:38.297690807 +0100\n+++ /tmp/tmp14c3dk5b.java\t2023-03-24 21:09:38.297690807 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / (b - b) - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (a % b) return a; else { a = a - b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:40.081683926 +0100\n+++ /tmp/tmp62p4k46k.java\t2023-03-24 21:09:40.081683926 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a - b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (a % b) return a; else { a = a % b; } return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:41.837677151 +0100\n+++ /tmp/tmp9z8mnrrj.java\t2023-03-24 21:09:41.841677135 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b; } return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (a % b) return b; else return a % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:43.585670407 +0100\n+++ /tmp/tmp935kw28n.java\t2023-03-24 21:09:43.585670407 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else return a % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (a % b) return b; else { throw new IllegalArgumentException(a % b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:45.305663772 +0100\n+++ /tmp/tmphw3nusny.java\t2023-03-24 21:09:45.305663772 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else { throw new IllegalArgumentException(a % b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (a % b) return a - b; else { return a - b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:47.065656982 +0100\n+++ /tmp/tmph1msdimk.java\t2023-03-24 21:09:47.065656982 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a - b; else { return a - b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (a % b) return a; else { a = b % a + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:48.809650253 +0100\n+++ /tmp/tmpb0jka452.java\t2023-03-24 21:09:48.809650253 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % a + b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (a % b) return a; else if (a % b!= 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:50.625643249 +0100\n+++ /tmp/tmpmglbrtk6.java\t2023-03-24 21:09:50.625643249 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else if (a % b!= 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (a % b) return a; else { a = a % b - b; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:52.381636475 +0100\n+++ /tmp/tmpn0f0u195.java\t2023-03-24 21:09:52.381636475 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b - b; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (a % b) return a; else { a = b / (b % b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:54.081629915 +0100\n+++ /tmp/tmpth642gdf.java\t2023-03-24 21:09:54.081629915 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / (b % b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (a % b) return a; else { a = b % a; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:55.797623297 +0100\n+++ /tmp/tmpemqk7cx1.java\t2023-03-24 21:09:55.797623297 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % a; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (a % b) return a; else { a = b / b; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:57.517616663 +0100\n+++ /tmp/tmp56j3bt5a.java\t2023-03-24 21:09:57.517616663 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / b; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (a % b) return a; else { a = b % a - b; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:09:59.225610074 +0100\n+++ /tmp/tmpe7ch1hzf.java\t2023-03-24 21:09:59.225610074 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % a - b; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (a % b) return b; else { a = b % a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:00.869603732 +0100\n+++ /tmp/tmp0hxbp5q4.java\t2023-03-24 21:10:00.873603717 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else { a = b % a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (a % b) return a; else { a = b % (a % b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:02.617596990 +0100\n+++ /tmp/tmp85qqtaq2.java\t2023-03-24 21:10:02.617596990 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % (a % b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (a % b) returnreplaceAll(a % b, b); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:04.321590416 +0100\n+++ /tmp/tmpwh4inkcq.java\t2023-03-24 21:10:04.321590416 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) returnreplaceAll(a % b, b); else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (a % b) return a % b; else return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:06.029583829 +0100\n+++ /tmp/tmpmiaiasxs.java\t2023-03-24 21:10:06.029583829 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a % b; else return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (a % b) return a; else { a = b % 1 - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:07.721577301 +0100\n+++ /tmp/tmpctlesxl7.java\t2023-03-24 21:10:07.721577301 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % 1 - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (a % b) return a; else { a = b % b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:09.457570606 +0100\n+++ /tmp/tmp5gxfgf6h.java\t2023-03-24 21:10:09.457570606 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (a % b) return a; else { a = a / b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:11.245563709 +0100\n+++ /tmp/tmpdstbl73t.java\t2023-03-24 21:10:11.245563709 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a / b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (a % b) returnreplaceAll(a % b, b); else { return a; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:12.933557199 +0100\n+++ /tmp/tmpm2wyx82r.java\t2023-03-24 21:10:12.933557199 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) returnreplaceAll(a % b, b); else { return a; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (a % b) return b; else { a = b % a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:14.697550762 +0100\n+++ /tmp/tmpcc3omew9.java\t2023-03-24 21:10:14.701550751 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else { a = b % a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (a % b) return a; else { a = b % b - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:16.473544826 +0100\n+++ /tmp/tmpr2bglki7.java\t2023-03-24 21:10:16.473544826 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % b - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (a % b) return a; else { return a - b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:18.157539194 +0100\n+++ /tmp/tmp0y6r2rxq.java\t2023-03-24 21:10:18.161539180 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { return a - b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (a % b) return b; else return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:19.913533316 +0100\n+++ /tmp/tmpawty9t4r.java\t2023-03-24 21:10:19.913533316 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (a % b) return a % b; else { return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:21.541527865 +0100\n+++ /tmp/tmp9w613vv6.java\t2023-03-24 21:10:21.545527854 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a % b; else { return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (a % b) return a; else { a = b % a - b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:23.217522254 +0100\n+++ /tmp/tmp0s_h8t1n.java\t2023-03-24 21:10:23.217522254 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % a - b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (a % b) return a; else { a = a % b - 1; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:24.929516516 +0100\n+++ /tmp/tmpa1s1dff6.java\t2023-03-24 21:10:24.929516516 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b - 1; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (a % b) return a; else { a = b %2.length(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:26.629510817 +0100\n+++ /tmp/tmp2xjnm6j1.java\t2023-03-24 21:10:26.629510817 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b %2.length(); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (a % b) return a; else { a = a % b; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:28.337505091 +0100\n+++ /tmp/tmpr25dlvmz.java\t2023-03-24 21:10:28.337505091 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a % b; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (a % b) return b; else { a = b / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:30.073499265 +0100\n+++ /tmp/tmpj8bletz2.java\t2023-03-24 21:10:30.073499265 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; else { a = b / b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (a % b) return a; else { a = b / (a % b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:31.837493347 +0100\n+++ /tmp/tmpgifie31e.java\t2023-03-24 21:10:31.837493347 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / (a % b); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (a % b) return a; else { return a % b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:33.637487301 +0100\n+++ /tmp/tmpayfxh9fr.java\t2023-03-24 21:10:33.637487301 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { return a % b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (a % b) return a; else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:35.393481403 +0100\n+++ /tmp/tmpy6xy934t.java\t2023-03-24 21:10:35.393481403 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (a % b) return a - b; else return a - b - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:37.057475810 +0100\n+++ /tmp/tmpyqgs18hf.java\t2023-03-24 21:10:37.057475810 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a - b; else return a - b - 1; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (a % b) return a; else { a = a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:38.717470228 +0100\n+++ /tmp/tmpirqceu0m.java\t2023-03-24 21:10:38.717470228 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (a % b) return a; else { return a % b; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:40.429464470 +0100\n+++ /tmp/tmp63barg1d.java\t2023-03-24 21:10:40.429464470 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { return a % b; } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (a % b) return a; else { a = b % 0d; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:42.045459031 +0100\n+++ /tmp/tmptpmqea2y.java\t2023-03-24 21:10:42.045459031 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % 0d; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (a % b) return a; else { a = b % 10; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:43.837452997 +0100\n+++ /tmp/tmple81yuih.java\t2023-03-24 21:10:43.837452997 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % 10; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (b % a) return b; else { return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:45.561447191 +0100\n+++ /tmp/tmpjvtqksv4.java\t2023-03-24 21:10:45.561447191 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (b % a) return b; else { return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (a % b) return a; else { a = b % 10); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:47.293441356 +0100\n+++ /tmp/tmpmuihscaj.java\t2023-03-24 21:10:47.293441356 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b % 10); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (a % b) return a; else { a = b / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:48.909435908 +0100\n+++ /tmp/tmp2dhaktz1.java\t2023-03-24 21:10:48.909435908 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = b / 2; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (a % b) return a; else { a = 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:50.609430176 +0100\n+++ /tmp/tmpm_a14bsd.java\t2023-03-24 21:10:50.609430176 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else { a = 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (a % b) return a % b; else return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:52.305424456 +0100\n+++ /tmp/tmp1ey_d_dj.java\t2023-03-24 21:10:52.305424456 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a % b; else return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (a % b) return a; return a % b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:53.957418881 +0100\n+++ /tmp/tmpzm7njsl_.java\t2023-03-24 21:10:53.957418881 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; return a % b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (a % b) return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:55.621413262 +0100\n+++ /tmp/tmpn46n1c1u.java\t2023-03-24 21:10:55.625413248 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (a % b) return a; else return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:57.573406669 +0100\n+++ /tmp/tmptah8n9j4.java\t2023-03-24 21:10:57.573406669 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return a; else return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "throw new IllegalArgumentException(a % b, b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:10:59.537400031 +0100\n+++ /tmp/tmpwwrj8dcx.java\t2023-03-24 21:10:59.537400031 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+throw new IllegalArgumentException(a % b, b);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "throw new IllegalArgumentException(a % b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:11:01.225394326 +0100\n+++ /tmp/tmpk26eq9i9.java\t2023-03-24 21:11:01.229394311 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+throw new IllegalArgumentException(a % b);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (a % b) return b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:11:03.049388157 +0100\n+++ /tmp/tmpadrwph0z.java\t2023-03-24 21:11:03.049388157 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b) return b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (b % (a % b)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:11:04.513383203 +0100\n+++ /tmp/tmpxvjt5ttk.java\t2023-03-24 21:11:04.513383203 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (b % (a % b)\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (a % b)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:11:05.889378546 +0100\n+++ /tmp/tmp61m47oyy.java\t2023-03-24 21:11:05.893378534 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b)\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (a % b",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:11:07.357373577 +0100\n+++ /tmp/tmpvz4upni2.java\t2023-03-24 21:11:07.357373577 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a % b\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (a %",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 21:11:08.813368644 +0100\n+++ /tmp/tmprkwehye3.java\t2023-03-24 21:11:08.813368644 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a %\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return gcd(b, a%b);"
    },
    "bitcount": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:10:58.981401913 +0100\n+++ /tmp/tmpyiuw_605.java\t2023-03-24 21:10:59.033401736 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:11:30.157296171 +0100\n+++ /tmp/tmpryvnlaug.java\t2023-03-24 21:11:30.157296171 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:12:01.069190602 +0100\n+++ /tmp/tmpsblj6opk.java\t2023-03-24 21:12:01.069190602 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:12:02.693185037 +0100\n+++ /tmp/tmphyshadcl.java\t2023-03-24 21:12:02.693185037 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:12:04.369179291 +0100\n+++ /tmp/tmpt3f8jpgx.java\t2023-03-24 21:12:04.369179291 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) >> 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:12:06.005173683 +0100\n+++ /tmp/tmp75sccl77.java\t2023-03-24 21:12:06.005173683 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) >> 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:12:37.065066823 +0100\n+++ /tmp/tmp12quk7l0.java\t2023-03-24 21:12:37.065066823 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) >> 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:12:38.673061273 +0100\n+++ /tmp/tmpmwzpbuoo.java\t2023-03-24 21:12:38.677061259 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) >> 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) % 10; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:09.676953940 +0100\n+++ /tmp/tmpis68abvt.java\t2023-03-24 21:13:09.676953940 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) % 10; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:11.272948398 +0100\n+++ /tmp/tmp3l2fgpd_.java\t2023-03-24 21:13:11.272948398 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:12.776943174 +0100\n+++ /tmp/tmpmwxd523z.java\t2023-03-24 21:13:12.776943174 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) / 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:14.460937322 +0100\n+++ /tmp/tmpafqnuyjy.java\t2023-03-24 21:13:14.460937322 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) / 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) / 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:16.080931694 +0100\n+++ /tmp/tmpgv8rv_ec.java\t2023-03-24 21:13:16.080931694 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) / 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (count <= 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:17.640926272 +0100\n+++ /tmp/tmp1ourg06p.java\t2023-03-24 21:13:17.640926272 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count <= 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:19.292920528 +0100\n+++ /tmp/tmpleifjqc_.java\t2023-03-24 21:13:19.304920486 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (count == 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:20.908914906 +0100\n+++ /tmp/tmp3qa_78op.java\t2023-03-24 21:13:20.908914906 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count == 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:22.476909452 +0100\n+++ /tmp/tmpkayuiaqg.java\t2023-03-24 21:13:22.476909452 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) % 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:13:54.184798824 +0100\n+++ /tmp/tmpch6qx9tu.java\t2023-03-24 21:13:54.184798824 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) % 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (count >= 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:14:02.896768326 +0100\n+++ /tmp/tmp51scwvdh.java\t2023-03-24 21:14:02.896768326 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count >= 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (count > 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:14:11.760737253 +0100\n+++ /tmp/tmpc51dg5pt.java\t2023-03-24 21:14:11.760737253 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count > 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) % 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:14:20.312707233 +0100\n+++ /tmp/tmphspycyhm.java\t2023-03-24 21:14:20.312707233 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) % 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (count < 1) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:14:29.284675695 +0100\n+++ /tmp/tmp2uhnbjr4.java\t2023-03-24 21:14:29.284675695 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 1) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) >> 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:14:37.808645694 +0100\n+++ /tmp/tmpxwe73084.java\t2023-03-24 21:14:37.808645694 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) >> 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) % 10; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:15:24.860479424 +0100\n+++ /tmp/tmpb1labchb.java\t2023-03-24 21:15:24.860479424 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) % 10; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) >> 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:15:32.268453149 +0100\n+++ /tmp/tmp3wcgqgya.java\t2023-03-24 21:15:32.268453149 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) >> 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:16:17.392292548 +0100\n+++ /tmp/tmplxtnq5dk.java\t2023-03-24 21:16:17.392292548 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:16:59.428142152 +0100\n+++ /tmp/tmpxcj68ptc.java\t2023-03-24 21:16:59.428142152 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:17:38.968000046 +0100\n+++ /tmp/tmp_q1i8oln.java\t2023-03-24 21:17:38.972000032 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1); } else { return 0; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) << 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:17:43.655983159 +0100\n+++ /tmp/tmph8accahx.java\t2023-03-24 21:17:43.655983159 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) << 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) & 0xFF); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:18:17.359861520 +0100\n+++ /tmp/tmp06tucdv4.java\t2023-03-24 21:18:17.359861520 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) & 0xFF); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) * 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:18:51.359738421 +0100\n+++ /tmp/tmpmidhcpff.java\t2023-03-24 21:18:51.359738421 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) * 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) & 0xFF); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:18:53.991728875 +0100\n+++ /tmp/tmp2p0v6zut.java\t2023-03-24 21:18:53.991728875 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) & 0xFF); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) / 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:19:25.795613372 +0100\n+++ /tmp/tmp0lpxod21.java\t2023-03-24 21:19:25.795613372 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) / 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) >> (count / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:19:27.611606765 +0100\n+++ /tmp/tmpois95ujm.java\t2023-03-24 21:19:27.611606765 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) >> (count / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (count == 0) { n = (n ^ (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:19:29.407600234 +0100\n+++ /tmp/tmplzscmzm1.java\t2023-03-24 21:19:29.407600234 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count == 0) { n = (n ^ (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) / 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:19:31.339593204 +0100\n+++ /tmp/tmp6lsxh5sv.java\t2023-03-24 21:19:31.339593204 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) / 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:20:02.407480033 +0100\n+++ /tmp/tmpilr_5amx.java\t2023-03-24 21:20:02.407480033 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) + 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) * 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:20:06.387465513 +0100\n+++ /tmp/tmpxtmvi72l.java\t2023-03-24 21:20:06.387465513 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) * 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (count % 10!= 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:20:08.015459575 +0100\n+++ /tmp/tmpyicztxky.java\t2023-03-24 21:20:08.015459575 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10!= 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) >> 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:20:39.019346320 +0100\n+++ /tmp/tmpoj0esa6v.java\t2023-03-24 21:20:39.019346320 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) >> 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) >> 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:20:40.687340220 +0100\n+++ /tmp/tmpyvp5l7g5.java\t2023-03-24 21:20:40.687340220 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) >> 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) << 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:11.767226429 +0100\n+++ /tmp/tmp6y7yesa6.java\t2023-03-24 21:21:11.767226429 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) << 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:39.755123762 +0100\n+++ /tmp/tmp_htlocmo.java\t2023-03-24 21:21:39.759123744 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (count > 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:41.411117681 +0100\n+++ /tmp/tmprdcau3xb.java\t2023-03-24 21:21:41.411117681 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count > 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) % 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:43.167111233 +0100\n+++ /tmp/tmpeczk0iyo.java\t2023-03-24 21:21:43.167111233 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) % 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) >> (count / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:44.891104898 +0100\n+++ /tmp/tmp80leide3.java\t2023-03-24 21:21:44.891104898 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) >> (count / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:46.667098378 +0100\n+++ /tmp/tmp60oqv99a.java\t2023-03-24 21:21:46.667098378 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) / 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:48.419091942 +0100\n+++ /tmp/tmp5x4ewro6.java\t2023-03-24 21:21:48.423091924 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) / 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:50.179085474 +0100\n+++ /tmp/tmpi1tnrzyg.java\t2023-03-24 21:21:50.179085474 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:51.815079465 +0100\n+++ /tmp/tmpipdd68ue.java\t2023-03-24 21:21:51.815079465 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) + 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:21:55.731065072 +0100\n+++ /tmp/tmpxmce1mvo.java\t2023-03-24 21:21:55.731065072 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (count % 1000 == 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:22:26.774950875 +0100\n+++ /tmp/tmpm6l0hrly.java\t2023-03-24 21:22:26.774950875 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 1000 == 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) * 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:22:28.442944733 +0100\n+++ /tmp/tmp9vx1la6p.java\t2023-03-24 21:22:28.442944733 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) * 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) * 1 + n; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:22:59.494830282 +0100\n+++ /tmp/tmpo480ltt4.java\t2023-03-24 21:22:59.494830282 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) * 1 + n; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:23:01.226823893 +0100\n+++ /tmp/tmpb0giluze.java\t2023-03-24 21:23:01.226823893 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) % 1000); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:23:02.910817680 +0100\n+++ /tmp/tmprxa3rfzy.java\t2023-03-24 21:23:02.910817680 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) % 1000); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (count <= 0) { n = (n ^ (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:23:34.146702353 +0100\n+++ /tmp/tmpwy60ydoz.java\t2023-03-24 21:23:34.146702353 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count <= 0) { n = (n ^ (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) / 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:23:35.822696160 +0100\n+++ /tmp/tmp9jt6wrkx.java\t2023-03-24 21:23:35.826696146 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) / 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (count % 10!= 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:24:07.078580570 +0100\n+++ /tmp/tmp8r6cc84t.java\t2023-03-24 21:24:07.078580570 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10!= 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (count >= 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:24:08.802574190 +0100\n+++ /tmp/tmpcm1tpwc2.java\t2023-03-24 21:24:08.802574190 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count >= 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) % 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:24:10.398568284 +0100\n+++ /tmp/tmpkd36vaxd.java\t2023-03-24 21:24:10.398568284 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) % 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (count % 10!= 0) { n = (n ^ (n - 1) >> 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:24:12.070562094 +0100\n+++ /tmp/tmptxe6ar14.java\t2023-03-24 21:24:12.070562094 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10!= 0) { n = (n ^ (n - 1) >> 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) / 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:24:43.070447262 +0100\n+++ /tmp/tmp35t_up2d.java\t2023-03-24 21:24:43.074447246 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) / 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (count % 1000!= 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:24:44.710441182 +0100\n+++ /tmp/tmpdlvik6fv.java\t2023-03-24 21:24:44.710441182 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 1000!= 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) * 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:24:46.334435162 +0100\n+++ /tmp/tmpx2h4qwl7.java\t2023-03-24 21:24:46.334435162 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) * 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (count % 1!= 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:25:17.406319892 +0100\n+++ /tmp/tmpi6y46m0c.java\t2023-03-24 21:25:17.406319892 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 1!= 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) % 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:25:48.634203899 +0100\n+++ /tmp/tmpfpm2ft77.java\t2023-03-24 21:25:48.638203883 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) % 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (count % 10!= 0) { n = (n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:25:50.270197817 +0100\n+++ /tmp/tmpfpelw61h.java\t2023-03-24 21:25:50.270197817 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10!= 0) { n = (n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) % 10); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:25:51.958191543 +0100\n+++ /tmp/tmp8wqp_rrk.java\t2023-03-24 21:25:51.962191530 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) % 10); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) >> 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:26:23.086075771 +0100\n+++ /tmp/tmp4u1yysv6.java\t2023-03-24 21:26:23.086075771 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) >> 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) >> 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:26:24.750069580 +0100\n+++ /tmp/tmp_jaazzgu.java\t2023-03-24 21:26:24.750069580 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) >> 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) >> 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:26:26.434063311 +0100\n+++ /tmp/tmp31xq38or.java\t2023-03-24 21:26:26.434063311 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) >> 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) % 10; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:26:28.130056998 +0100\n+++ /tmp/tmp81qu1uyo.java\t2023-03-24 21:26:28.130056998 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) % 10; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (count < 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:26:29.798050791 +0100\n+++ /tmp/tmpct1toe2_.java\t2023-03-24 21:26:29.798050791 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (count % 1000 == 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:26:31.534044328 +0100\n+++ /tmp/tmp5fwtmqaw.java\t2023-03-24 21:26:31.534044328 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 1000 == 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (count == 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:27:02.549928814 +0100\n+++ /tmp/tmpsxdazcsc.java\t2023-03-24 21:27:02.549928814 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count == 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:27:04.225922567 +0100\n+++ /tmp/tmpiata4au1.java\t2023-03-24 21:27:04.229922554 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) % 1000); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:27:05.929916219 +0100\n+++ /tmp/tmp1859_h_d.java\t2023-03-24 21:27:05.933916202 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) % 1000); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (count % 1!= 0) { n = (n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:27:36.953800544 +0100\n+++ /tmp/tmpz_1nboph.java\t2023-03-24 21:27:36.953800544 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 1!= 0) { n = (n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (count % 10 == 0) { n = (n ^ (n - 1) >> 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:27:38.633794275 +0100\n+++ /tmp/tmpr9_tmkov.java\t2023-03-24 21:27:38.633794275 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10 == 0) { n = (n ^ (n - 1) >> 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) * 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:09.613678651 +0100\n+++ /tmp/tmpqkrz4n62.java\t2023-03-24 21:28:09.613678651 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) * 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (count % 10!= 0) { n = (n ^ (n - 1) / 100; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:11.241672571 +0100\n+++ /tmp/tmpnimm3yf6.java\t2023-03-24 21:28:11.241672571 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10!= 0) { n = (n ^ (n - 1) / 100; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (count > 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:12.909666342 +0100\n+++ /tmp/tmpbzfdln1c.java\t2023-03-24 21:28:12.909666342 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count > 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1)\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:44.117549753 +0100\n+++ /tmp/tmpbxjdk5j6.java\t2023-03-24 21:28:44.117549753 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1)\"); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^ (n - 1) >> 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:45.805543443 +0100\n+++ /tmp/tmpr0puztoa.java\t2023-03-24 21:28:45.805543443 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^ (n - 1) >> 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (count % 1)) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:47.473537210 +0100\n+++ /tmp/tmpq8e9jcyj.java\t2023-03-24 21:28:47.473537210 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 1)) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (count <= 0) { n = (n ^ (n - 1) - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:49.177530839 +0100\n+++ /tmp/tmp0gep9487.java\t2023-03-24 21:28:49.177530839 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count <= 0) { n = (n ^ (n - 1) - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (count == 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:28:50.853524573 +0100\n+++ /tmp/tmp7uer35vt.java\t2023-03-24 21:28:50.857524560 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count == 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (count >= 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:29:22.033407970 +0100\n+++ /tmp/tmpxbu_8zbc.java\t2023-03-24 21:29:22.033407970 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count >= 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^ (n - 1) >> 2); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:29:53.561289976 +0100\n+++ /tmp/tmp_ilfunbd.java\t2023-03-24 21:29:53.561289976 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^ (n - 1) >> 2); } }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (count == 0) { n = (n ^ (n - 1) - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:29:55.209283804 +0100\n+++ /tmp/tmp33titqa7.java\t2023-03-24 21:29:55.209283804 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count == 0) { n = (n ^ (n - 1) - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (count % 2!= 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:30:26.429166873 +0100\n+++ /tmp/tmpz0kozknf.java\t2023-03-24 21:30:26.429166873 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2!= 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (count > 0) { n = (n ^ (n - 1) - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:30:28.117160548 +0100\n+++ /tmp/tmpwq7u84kx.java\t2023-03-24 21:30:28.121160532 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count > 0) { n = (n ^ (n - 1) - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (count % 1) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:30:59.201044042 +0100\n+++ /tmp/tmple9tnuj4.java\t2023-03-24 21:30:59.201044042 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 1) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (count > 1) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:31:00.821037966 +0100\n+++ /tmp/tmpdbuuv8cy.java\t2023-03-24 21:31:00.825037953 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count > 1) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (count - 1) { n = (n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:31:02.409032012 +0100\n+++ /tmp/tmp7ebo4eyj.java\t2023-03-24 21:31:02.409032012 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count - 1) { n = (n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (count >= 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:31:04.097025685 +0100\n+++ /tmp/tmp0e4wo12u.java\t2023-03-24 21:31:04.097025685 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count >= 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (count % 10); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:31:05.737019535 +0100\n+++ /tmp/tmpozh18d6j.java\t2023-03-24 21:31:05.737019535 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (count % 10);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:31:07.317013608 +0100\n+++ /tmp/tmp3hlwz3v4.java\t2023-03-24 21:31:07.317013608 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10);\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (count % 10;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 21:31:09.097006933 +0100\n+++ /tmp/tmpm85f9nwx.java\t2023-03-24 21:31:09.097006933 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 10;\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "n = (n & (n - 1));"
    },
    "is_valid_parenthesization": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:12.241357029 +0100\n+++ /tmp/tmp8n_a6qct.java\t2023-03-24 21:11:12.285356881 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "} else if (depth > depth) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:16.177343679 +0100\n+++ /tmp/tmphq6jdz6i.java\t2023-03-24 21:11:16.177343679 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth > depth) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (depth > 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:17.857337978 +0100\n+++ /tmp/tmpfx52ivjs.java\t2023-03-24 21:11:17.857337978 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "} else if (depth > depth - 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:19.721331651 +0100\n+++ /tmp/tmphegsylu6.java\t2023-03-24 21:11:19.725331637 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth > depth - 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "} else if (depth > 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:21.653325089 +0100\n+++ /tmp/tmpynol1_1w.java\t2023-03-24 21:11:21.653325089 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth > 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "try { return true; } catch (final NumberFormatException e) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:23.641318332 +0100\n+++ /tmp/tmpfa9rvyxh.java\t2023-03-24 21:11:23.645318320 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+try { return true; } catch (final NumberFormatException e) { }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "} else if (depth == 0) { return true; } else { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:25.713311290 +0100\n+++ /tmp/tmp71zr9pe9.java\t2023-03-24 21:11:25.713311290 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth == 0) { return true; } else { }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "} else if (depth == 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:27.689304568 +0100\n+++ /tmp/tmpbiqt_fpa.java\t2023-03-24 21:11:27.689304568 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth == 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (depth > depth) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:29.745297572 +0100\n+++ /tmp/tmp7s2uxfwl.java\t2023-03-24 21:11:29.745297572 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > depth) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (depth > 1) return false; else { return true; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:31.525291514 +0100\n+++ /tmp/tmp8gphk_rp.java\t2023-03-24 21:11:31.529291500 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 1) return false; else { return true; } }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "try { return true; } catch (final Throwable e) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:33.217285751 +0100\n+++ /tmp/tmp6uckv5yz.java\t2023-03-24 21:11:33.217285751 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+try { return true; } catch (final Throwable e) { }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (depth > 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:34.861280151 +0100\n+++ /tmp/tmpfgf363nl.java\t2023-03-24 21:11:34.861280151 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "try { return true; } catch (final Exception e) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:36.401274903 +0100\n+++ /tmp/tmpf2l_rw4p.java\t2023-03-24 21:11:36.401274903 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+try { return true; } catch (final Exception e) { }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "} else if (depth == 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:37.905269777 +0100\n+++ /tmp/tmpio7x3yp_.java\t2023-03-24 21:11:37.909269763 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth == 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "else if (depth > depth) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:39.373264770 +0100\n+++ /tmp/tmpe2srk94i.java\t2023-03-24 21:11:39.373264770 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth > depth) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (Math.abs(depth) > 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:40.905259545 +0100\n+++ /tmp/tmpu_4wjya2.java\t2023-03-24 21:11:40.909259531 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (Math.abs(depth) > 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "try { return true; } catch (final Throwable e) { } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:42.533253990 +0100\n+++ /tmp/tmpih_730pq.java\t2023-03-24 21:11:42.533253990 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+try { return true; } catch (final Throwable e) { } }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (depth > 1) return false; else { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:44.109248611 +0100\n+++ /tmp/tmpva2ku6wb.java\t2023-03-24 21:11:44.113248597 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 1) return false; else { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "else if (depth > 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:48.217234577 +0100\n+++ /tmp/tmpo9m13xs1.java\t2023-03-24 21:11:48.217234577 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth > 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "throw new IllegalArgumentException(\"Unexpected end of input: \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:49.965228605 +0100\n+++ /tmp/tmphj7845uv.java\t2023-03-24 21:11:49.965228605 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Unexpected end of input: \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (get(depth - 1) == 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:54.577212832 +0100\n+++ /tmp/tmpl1eor2c3.java\t2023-03-24 21:11:54.577212832 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (get(depth - 1) == 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (depth > 0 && depth == 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:56.681205631 +0100\n+++ /tmp/tmpzkh4jv7u.java\t2023-03-24 21:11:56.681205631 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0 && depth == 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "return false; else if (depth > 0) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:11:58.757198523 +0100\n+++ /tmp/tmpr0uma2e7.java\t2023-03-24 21:11:58.757198523 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; else if (depth > 0) { return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (depth > 0) { return true; } return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:00.813191481 +0100\n+++ /tmp/tmppr0qrnvk.java\t2023-03-24 21:12:00.813191481 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) { return true; } return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "else if (depth > depth - 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:02.569185463 +0100\n+++ /tmp/tmpq8rpu8iz.java\t2023-03-24 21:12:02.569185463 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth > depth - 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (depth > 0) { return true; } else { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:04.253179691 +0100\n+++ /tmp/tmpjnvqe6__.java\t2023-03-24 21:12:04.253179691 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) { return true; } else { }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (depth > depth - 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:06.085173408 +0100\n+++ /tmp/tmpk41ah3f0.java\t2023-03-24 21:12:06.085173408 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > depth - 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "} else if (depth > 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:07.881167246 +0100\n+++ /tmp/tmp7tr6ii61.java\t2023-03-24 21:12:07.881167246 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth > 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "return false; // Colons must not appear after dots.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:09.573161442 +0100\n+++ /tmp/tmprynovsix.java\t2023-03-24 21:12:09.577161428 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // Colons must not appear after dots.\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (c == '\\n') { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:13.157149135 +0100\n+++ /tmp/tmpyr53ibd2.java\t2023-03-24 21:12:13.157149135 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (c == '\\n') { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "} else if (depth >= 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:14.745143680 +0100\n+++ /tmp/tmp85xrsh5z.java\t2023-03-24 21:12:14.745143680 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth >= 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "else if (depth == 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:16.285138388 +0100\n+++ /tmp/tmpscwbg311.java\t2023-03-24 21:12:16.289138374 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth == 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "} else if (depth <= 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:17.733133410 +0100\n+++ /tmp/tmpjes5du2i.java\t2023-03-24 21:12:17.737133396 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth <= 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (depth > 0) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:19.205128349 +0100\n+++ /tmp/tmpuyq6eng1.java\t2023-03-24 21:12:19.205128349 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "else if (depth > depth - 1) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:20.753123025 +0100\n+++ /tmp/tmpwbdxuzul.java\t2023-03-24 21:12:20.753123025 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth > depth - 1) return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "return null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:22.305117685 +0100\n+++ /tmp/tmpsognb89a.java\t2023-03-24 21:12:22.305117685 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return null;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (depth > 1) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:26.261104068 +0100\n+++ /tmp/tmpols36u0n.java\t2023-03-24 21:12:26.261104068 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 1) return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "else if (depth > 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:28.001098074 +0100\n+++ /tmp/tmpq0qtdcfo.java\t2023-03-24 21:12:28.005098060 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth > 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (c == '.') { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:29.957091335 +0100\n+++ /tmp/tmpnf41z37y.java\t2023-03-24 21:12:29.957091335 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (c == '.') { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (depth > depth - 1) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:31.973084387 +0100\n+++ /tmp/tmp7c0gaskh.java\t2023-03-24 21:12:31.973084387 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > depth - 1) return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (stack.isEmpty()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:33.821078015 +0100\n+++ /tmp/tmpdq5i1o32.java\t2023-03-24 21:12:33.825078001 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (stack.isEmpty()) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "else if (depth == 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:35.925070755 +0100\n+++ /tmp/tmpoao29cfr.java\t2023-03-24 21:12:35.925070755 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth == 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (depth > depth) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:37.709064601 +0100\n+++ /tmp/tmp4voxfl0g.java\t2023-03-24 21:12:37.709064601 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > depth) return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "while (true) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:39.309059078 +0100\n+++ /tmp/tmpr072fnji.java\t2023-03-24 21:12:39.309059078 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+while (true) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (depth > 0) { return true; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:43.205045623 +0100\n+++ /tmp/tmpx52mvak6.java\t2023-03-24 21:12:43.205045623 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) { return true; } }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (c == '_') { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:44.629040701 +0100\n+++ /tmp/tmpvz2oyrb4.java\t2023-03-24 21:12:44.629040701 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (c == '_') { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (depth == 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:46.129035517 +0100\n+++ /tmp/tmptasy1i5_.java\t2023-03-24 21:12:46.129035517 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth == 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (depth > 1) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:47.573030526 +0100\n+++ /tmp/tmpa8iv1o76.java\t2023-03-24 21:12:47.573030526 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 1) return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "return false; // get the end of input return true",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:48.977025670 +0100\n+++ /tmp/tmpf0t958lz.java\t2023-03-24 21:12:48.977025670 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // get the end of input return true\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "else if (depth > 0) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:52.453013643 +0100\n+++ /tmp/tmp70ts9xs7.java\t2023-03-24 21:12:52.453013643 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth > 0) return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "else if (depth == 0) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:53.881008701 +0100\n+++ /tmp/tmpc5xziqsj.java\t2023-03-24 21:12:53.881008701 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth == 0) return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "switch (depth - 1) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:55.277003868 +0100\n+++ /tmp/tmprmqj6zmf.java\t2023-03-24 21:12:55.277003868 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+switch (depth - 1) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "throw new IllegalArgumentException(\"Unexpected end of input\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:12:56.812998549 +0100\n+++ /tmp/tmpb0npy01o.java\t2023-03-24 21:12:56.816998535 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Unexpected end of input\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "throw new IllegalStateException(\"Expected a previous key\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:00.664985201 +0100\n+++ /tmp/tmps7f5f7w_.java\t2023-03-24 21:13:00.664985201 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected a previous key\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "else if (depth == 0) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:04.708971179 +0100\n+++ /tmp/tmpp4zzo3re.java\t2023-03-24 21:13:04.708971179 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth == 0) return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "throw new ParseException(\"Unexpected end of input\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:06.380965379 +0100\n+++ /tmp/tmpx0wamwmb.java\t2023-03-24 21:13:06.380965379 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new ParseException(\"Unexpected end of input\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "return false; // get the end of input",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:08.424958286 +0100\n+++ /tmp/tmp7cepsx5x.java\t2023-03-24 21:13:08.424958286 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // get the end of input\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "throw new IllegalArgumentException(\"Expected a previous key\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:12.280944897 +0100\n+++ /tmp/tmpz4we51s0.java\t2023-03-24 21:13:12.284944883 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Expected a previous key\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "return false; // End of input return true",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:16.084931680 +0100\n+++ /tmp/tmpmtg0qo7m.java\t2023-03-24 21:13:16.084931680 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // End of input return true\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "return false; else { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:19.816918704 +0100\n+++ /tmp/tmpei4no_by.java\t2023-03-24 21:13:19.816918704 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; else { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "throw new NoSuchElementException(\"No more data\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:21.320913473 +0100\n+++ /tmp/tmpiu25o_og.java\t2023-03-24 21:13:21.320913473 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException(\"No more data\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "return false; return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:25.020900597 +0100\n+++ /tmp/tmppcjgy2pb.java\t2023-03-24 21:13:25.024900583 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; return true;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "return false; // End of input",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:26.644894943 +0100\n+++ /tmp/tmpz7munf0r.java\t2023-03-24 21:13:26.644894943 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // End of input\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (depth > 1) return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:29.864883728 +0100\n+++ /tmp/tmp9wbkxscg.java\t2023-03-24 21:13:29.864883728 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 1) return false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "return false; // We'll fail",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:31.292878751 +0100\n+++ /tmp/tmpa59lmh5j.java\t2023-03-24 21:13:31.292878751 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We'll fail\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "return false; // skip-only",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:34.632867109 +0100\n+++ /tmp/tmpto4kcb29.java\t2023-03-24 21:13:34.632867109 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // skip-only\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "return false; // START_ARRAY",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:38.028855265 +0100\n+++ /tmp/tmpdxv01_9s.java\t2023-03-24 21:13:38.028855265 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // START_ARRAY\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "else { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:41.524843064 +0100\n+++ /tmp/tmpu4oo1cgn.java\t2023-03-24 21:13:41.524843064 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "this.depth = false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:43.004837897 +0100\n+++ /tmp/tmplx_lh1oq.java\t2023-03-24 21:13:43.004837897 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+this.depth = false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:44.588832366 +0100\n+++ /tmp/tmp5_r8huwe.java\t2023-03-24 21:13:44.588832366 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return true;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "return false; // current order",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:13:59.600779867 +0100\n+++ /tmp/tmpr0thlxil.java\t2023-03-24 21:13:59.604779853 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // current order\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "return false; });",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:14:20.656706024 +0100\n+++ /tmp/tmp1o_k1t3h.java\t2023-03-24 21:14:20.656706024 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; });\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "do { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:14:29.012676653 +0100\n+++ /tmp/tmpqj2ly2ns.java\t2023-03-24 21:14:29.012676653 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+do { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "return false; // Not found",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:14:37.476646863 +0100\n+++ /tmp/tmpo4ppssq3.java\t2023-03-24 21:14:37.476646863 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // Not found\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "return false; // EOF",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:14:57.396576609 +0100\n+++ /tmp/tmp9sd9shww.java\t2023-03-24 21:14:57.396576609 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // EOF\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "return false; // current index",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:15:16.212510065 +0100\n+++ /tmp/tmpl5mq8d7n.java\t2023-03-24 21:15:16.212510065 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // current index\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "{ return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:15:35.552441490 +0100\n+++ /tmp/tmps8r2t3_8.java\t2023-03-24 21:15:35.556441476 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+{ return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:15:52.524381168 +0100\n+++ /tmp/tmpzavblf87.java\t2023-03-24 21:15:52.524381168 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "return false; };",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:15:59.144357606 +0100\n+++ /tmp/tmpo950jjcg.java\t2023-03-24 21:15:59.144357606 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; };\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "throw new NoSuchElementException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:16:05.672334347 +0100\n+++ /tmp/tmpjlqgz27k.java\t2023-03-24 21:16:05.672334347 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "return false; // Ignore",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:16:20.256282324 +0100\n+++ /tmp/tmp9gsor_mi.java\t2023-03-24 21:16:20.256282324 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // Ignore\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:16:34.124232772 +0100\n+++ /tmp/tmp1u6te8_e.java\t2023-03-24 21:16:34.124232772 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "throw new AssertionError();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:16:47.344185462 +0100\n+++ /tmp/tmpgrm5nt4d.java\t2023-03-24 21:16:47.344185462 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new AssertionError();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "final return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:02.312131807 +0100\n+++ /tmp/tmpgqw42690.java\t2023-03-24 21:17:02.312131807 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+final return false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "current = false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:07.576112917 +0100\n+++ /tmp/tmpy_vuq4cs.java\t2023-03-24 21:17:07.576112917 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+current = false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "return return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:13.404091991 +0100\n+++ /tmp/tmp1nlbrnr4.java\t2023-03-24 21:17:13.404091991 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return return false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "current = null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:18.864072374 +0100\n+++ /tmp/tmp_v10p8kr.java\t2023-03-24 21:17:18.864072374 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+current = null;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "continue;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:24.548051939 +0100\n+++ /tmp/tmp3dxzip64.java\t2023-03-24 21:17:24.548051939 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+continue;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "= false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:30.244031451 +0100\n+++ /tmp/tmpvp6xm05f.java\t2023-03-24 21:17:30.244031451 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+= false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "throw e;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:35.800011454 +0100\n+++ /tmp/tmpqwe9w_be.java\t2023-03-24 21:17:35.800011454 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw e;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "final false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:40.811993405 +0100\n+++ /tmp/tmp0kr502b2.java\t2023-03-24 21:17:40.815993391 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+final false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "break;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:44.799979038 +0100\n+++ /tmp/tmpuk1n9z3y.java\t2023-03-24 21:17:44.799979038 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+break;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": ": false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:48.783964678 +0100\n+++ /tmp/tmp2jvrzj3j.java\t2023-03-24 21:17:48.783964678 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+: false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "returnNULL;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:52.855949996 +0100\n+++ /tmp/tmpz79vj_85.java\t2023-03-24 21:17:52.855949996 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+returnNULL;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "returnnull;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:55.939938872 +0100\n+++ /tmp/tmpxd7brbsy.java\t2023-03-24 21:17:55.939938872 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+returnnull;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "throw selection;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:17:59.319926677 +0100\n+++ /tmp/tmp1pstmicp.java\t2023-03-24 21:17:59.319926677 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw selection;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": ", null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:18:03.815910451 +0100\n+++ /tmp/tmp7e06dc1y.java\t2023-03-24 21:18:03.815910451 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+, null;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": ": null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:18:08.963891860 +0100\n+++ /tmp/tmpm_2q36p2.java\t2023-03-24 21:18:08.963891860 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+: null;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:18:14.031873549 +0100\n+++ /tmp/tmpwzd45mgj.java\t2023-03-24 21:18:14.031873549 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 21:18:18.263858252 +0100\n+++ /tmp/tmpk4n7i1vm.java\t2023-03-24 21:18:18.263858252 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return 0;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return depth==0;"
    },
    "shortest_path_lengths": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:18:54.147728310 +0100\n+++ /tmp/tmpmsjqy4ca.java\t2023-03-24 21:18:54.147728310 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:18:56.159721012 +0100\n+++ /tmp/tmphrwwdglh.java\t2023-03-24 21:18:56.159721012 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:18:58.319713176 +0100\n+++ /tmp/tmp65gm2r5s.java\t2023-03-24 21:18:58.319713176 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:00.131706600 +0100\n+++ /tmp/tmpo77vspe2.java\t2023-03-24 21:19:00.131706600 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:01.839700403 +0100\n+++ /tmp/tmpvun0lr4w.java\t2023-03-24 21:19:01.843700390 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (count > 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:03.515694319 +0100\n+++ /tmp/tmpfs939kgc.java\t2023-03-24 21:19:03.515694319 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (count > 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (update_length > 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:05.243688046 +0100\n+++ /tmp/tmpgohllvzc.java\t2023-03-24 21:19:05.243688046 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length > 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (required) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:07.047681497 +0100\n+++ /tmp/tmp420mxdlt.java\t2023-03-24 21:19:07.079681383 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (required) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (update_length > 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:08.943674611 +0100\n+++ /tmp/tmpn6ib9n3p.java\t2023-03-24 21:19:08.943674611 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length > 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (count > 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:11.035667014 +0100\n+++ /tmp/tmphl7wxi0p.java\t2023-03-24 21:19:11.035667014 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (count > 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (update_length - k > 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:13.139659370 +0100\n+++ /tmp/tmpqxao_w_j.java\t2023-03-24 21:19:13.139659370 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length - k > 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "new ArrayList<>(length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:15.259651671 +0100\n+++ /tmp/tmpoi6msyf0.java\t2023-03-24 21:19:15.259651671 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (required) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:17.439643749 +0100\n+++ /tmp/tmpl_wkp87_.java\t2023-03-24 21:19:17.439643749 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (required) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (index > 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:19.607635869 +0100\n+++ /tmp/tmpiuz1jz6v.java\t2023-03-24 21:19:19.611635852 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (index > 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (query_length > 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:21.863627666 +0100\n+++ /tmp/tmpjsfv5j9d.java\t2023-03-24 21:19:21.863627666 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (query_length > 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (allowMultipleEdges) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:24.227619071 +0100\n+++ /tmp/tmpermmbjwu.java\t2023-03-24 21:19:24.227619071 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (allowMultipleEdges) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:26.219611830 +0100\n+++ /tmp/tmplu2ypou6.java\t2023-03-24 21:19:26.219611830 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (maxNodes == null) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:28.011605310 +0100\n+++ /tmp/tmp6no2lgd1.java\t2023-03-24 21:19:28.011605310 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (maxNodes == null) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (maxNodes == null) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:29.895598456 +0100\n+++ /tmp/tmp6kr53ciq.java\t2023-03-24 21:19:29.895598456 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (maxNodes == null) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (maxNodes[j].isEmpty()) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:31.659592041 +0100\n+++ /tmp/tmpqg7273q5.java\t2023-03-24 21:19:31.659592041 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (maxNodes[j].isEmpty()) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (query_length > 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:33.355585870 +0100\n+++ /tmp/tmpx39h12hc.java\t2023-03-24 21:19:33.355585870 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (query_length > 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(i, k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:35.131579405 +0100\n+++ /tmp/tmpctq9o2zk.java\t2023-03-24 21:19:35.131579405 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(i, k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (update_length == 0) { length_by_path.get(Arrays.asList(k,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:36.687573744 +0100\n+++ /tmp/tmp6hpqpld2.java\t2023-03-24 21:19:36.691573727 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == 0) { length_by_path.get(Arrays.asList(k,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if ( update_length == 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:38.167568357 +0100\n+++ /tmp/tmp615cljfy.java\t2023-03-24 21:19:38.167568357 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if ( update_length == 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j, k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:39.771562515 +0100\n+++ /tmp/tmpa75ufjh1.java\t2023-03-24 21:19:39.771562515 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j, k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (update_length == 0) { length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:41.331556835 +0100\n+++ /tmp/tmpig10pdr8.java\t2023-03-24 21:19:41.331556835 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == 0) { length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "false) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:42.959550907 +0100\n+++ /tmp/tmp4dwyhw0l.java\t2023-03-24 21:19:42.959550907 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+false) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if ( update_length == 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:44.575545024 +0100\n+++ /tmp/tmps2a5x1uk.java\t2023-03-24 21:19:44.575545024 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if ( update_length == 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:46.255538902 +0100\n+++ /tmp/tmpb1do2pt9.java\t2023-03-24 21:19:46.255538902 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "Math.max(length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:47.975532639 +0100\n+++ /tmp/tmp00726mw8.java\t2023-03-24 21:19:47.979532622 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Math.max(length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (update_length == i) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:49.735526225 +0100\n+++ /tmp/tmpjwu1orrw.java\t2023-03-24 21:19:49.735526225 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == i) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "} else if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:51.579519505 +0100\n+++ /tmp/tmp8c7gvs4r.java\t2023-03-24 21:19:51.583519493 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+} else if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (update_length == 0) { length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:53.615512087 +0100\n+++ /tmp/tmpf4zqn3gp.java\t2023-03-24 21:19:53.615512087 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == 0) { length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (index > 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:55.727504386 +0100\n+++ /tmp/tmpmhziykb9.java\t2023-03-24 21:19:55.727504386 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (index > 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (update_length >= numNodes) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:57.839496690 +0100\n+++ /tmp/tmp50d8z2fl.java\t2023-03-24 21:19:57.839496690 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length >= numNodes) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (get(j, k)!= 0.0) { length_by_path.get(Arrays.asList(k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:19:59.903489162 +0100\n+++ /tmp/tmp8hsc7qnu.java\t2023-03-24 21:19:59.907489150 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (get(j, k)!= 0.0) { length_by_path.get(Arrays.asList(k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (update_length == i) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:01.995481533 +0100\n+++ /tmp/tmpn4_6ape6.java\t2023-03-24 21:20:01.995481533 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == i) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "&& (update_length > 0)) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:03.851474766 +0100\n+++ /tmp/tmp0ri6lyom.java\t2023-03-24 21:20:03.855474749 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+&& (update_length > 0)) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:05.575468477 +0100\n+++ /tmp/tmprbredqon.java\t2023-03-24 21:20:05.575468477 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (hasDot) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:07.363461954 +0100\n+++ /tmp/tmpwr1s707h.java\t2023-03-24 21:20:07.363461954 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (hasDot) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (maxNodes) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:09.147455445 +0100\n+++ /tmp/tmppl_56i82.java\t2023-03-24 21:20:09.151455427 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (maxNodes) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (allowNonce) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:10.875449137 +0100\n+++ /tmp/tmpytlq1xgv.java\t2023-03-24 21:20:10.875449137 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (allowNonce) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (hasDot(update_length)) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:12.547443037 +0100\n+++ /tmp/tmp7s95b1iv.java\t2023-03-24 21:20:12.551443019 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (hasDot(update_length)) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (update_length >= 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:14.011437693 +0100\n+++ /tmp/tmpo1bkymks.java\t2023-03-24 21:20:14.011437693 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length >= 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (deviceSession == null) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:15.511432215 +0100\n+++ /tmp/tmply0ur21c.java\t2023-03-24 21:20:15.511432215 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (deviceSession == null) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))), true); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:17.035426651 +0100\n+++ /tmp/tmpt08jwlg1.java\t2023-03-24 21:20:17.035426651 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))), true); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (update_length > i) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:18.559421086 +0100\n+++ /tmp/tmpva_vyeap.java\t2023-03-24 21:20:18.559421086 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length > i) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (update_length > i) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:20.135415331 +0100\n+++ /tmp/tmpoxeaq58h.java\t2023-03-24 21:20:20.135415331 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length > i) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:21.775409342 +0100\n+++ /tmp/tmp8jhy3khm.java\t2023-03-24 21:20:21.775409342 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (size > 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:23.411403366 +0100\n+++ /tmp/tmpgtu6s4r2.java\t2023-03-24 21:20:23.411403366 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (size > 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (deviceSession == null) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:25.139397053 +0100\n+++ /tmp/tmpj9t2f4m9.java\t2023-03-24 21:20:25.139397053 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (deviceSession == null) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if ( update_length > 0) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:26.931390508 +0100\n+++ /tmp/tmpfamc3npr.java\t2023-03-24 21:20:26.935390491 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if ( update_length > 0) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (update_length >= 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:28.775383768 +0100\n+++ /tmp/tmpsvaydfcp.java\t2023-03-24 21:20:28.775383768 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length >= 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (allowMultipleEdges) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:30.747376562 +0100\n+++ /tmp/tmpop3ovb3s.java\t2023-03-24 21:20:30.747376562 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (allowMultipleEdges) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:32.767369181 +0100\n+++ /tmp/tmpbn2ecb1i.java\t2023-03-24 21:20:32.767369181 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length!= 0) { length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (count > 0) { length_by_path.get(Arrays.asList(k,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:34.827361648 +0100\n+++ /tmp/tmprbe7qi3p.java\t2023-03-24 21:20:34.827361648 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (count > 0) { length_by_path.get(Arrays.asList(k,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (isCollection) { length_by_path.get(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:36.967353824 +0100\n+++ /tmp/tmpy76ity0k.java\t2023-03-24 21:20:36.971353810 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (isCollection) { length_by_path.get(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "} else if (update_length > 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:38.975346481 +0100\n+++ /tmp/tmp_urh_bh5.java\t2023-03-24 21:20:38.979346467 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+} else if (update_length > 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (length_by_path.contains(Arrays.asList(j,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:40.707340150 +0100\n+++ /tmp/tmpo6o1boko.java\t2023-03-24 21:20:40.707340150 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.contains(Arrays.asList(j,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)) ); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:42.423333873 +0100\n+++ /tmp/tmpbz7tamwn.java\t2023-03-24 21:20:42.423333873 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == 0) { length_by_path.get(Arrays.asList(j,k)) ); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (update_length > 0) { length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:44.171327479 +0100\n+++ /tmp/tmphvxioesc.java\t2023-03-24 21:20:44.171327479 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length > 0) { length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "false); length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:45.719321814 +0100\n+++ /tmp/tmph8lpj8m6.java\t2023-03-24 21:20:45.719321814 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+false); length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k)))); return i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:47.195316416 +0100\n+++ /tmp/tmp6hih6wny.java\t2023-03-24 21:20:47.195316416 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k)))); return i; }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if ( update_length > 0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:48.695310925 +0100\n+++ /tmp/tmpx8zxlwey.java\t2023-03-24 21:20:48.695310925 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if ( update_length > 0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (maxNodes) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:50.279305128 +0100\n+++ /tmp/tmptgytbwq8.java\t2023-03-24 21:20:50.279305128 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (maxNodes) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (get(j, k)!= null) { length_by_path.get(Arrays.asList(k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:51.875299289 +0100\n+++ /tmp/tmpz9z_qule.java\t2023-03-24 21:20:51.875299289 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (get(j, k)!= null) { length_by_path.get(Arrays.asList(k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (update_length == 0) { length_by_path.get(Arrays.asList(k,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:53.459293488 +0100\n+++ /tmp/tmpwyiz0iym.java\t2023-03-24 21:20:53.459293488 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length == 0) { length_by_path.get(Arrays.asList(k,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k)))); return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:55.159287267 +0100\n+++ /tmp/tmp057vw4bi.java\t2023-03-24 21:20:55.159287267 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k)))); return true; }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k)) ;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:56.875280982 +0100\n+++ /tmp/tmp4qd5nnmf.java\t2023-03-24 21:20:56.875280982 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k)) ;\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k)) - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:20:58.623274584 +0100\n+++ /tmp/tmptncs8bh1.java\t2023-03-24 21:20:58.623274584 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k)) - 1); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "false); length_by_path.get(Arrays.asList(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:00.351268254 +0100\n+++ /tmp/tmp03pqbm0e.java\t2023-03-24 21:21:00.351268254 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+false); length_by_path.get(Arrays.asList(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))), update_length); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:02.331261002 +0100\n+++ /tmp/tmpwsln6wzq.java\t2023-03-24 21:21:02.355260914 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))), update_length); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "false, true); length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:04.339253647 +0100\n+++ /tmp/tmp9kntzojz.java\t2023-03-24 21:21:04.339253647 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+false, true); length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (update_length - k > 0) { length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:06.407246073 +0100\n+++ /tmp/tmpq8b8v63s.java\t2023-03-24 21:21:06.411246056 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (update_length - k > 0) { length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:08.531238291 +0100\n+++ /tmp/tmpnz_sj7xu.java\t2023-03-24 21:21:08.531238291 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k)))); return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:13.215221122 +0100\n+++ /tmp/tmpbfl2f6mm.java\t2023-03-24 21:21:13.215221122 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k)))); return; }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "false, true); length_by_path.get(Arrays.asList(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:15.043214422 +0100\n+++ /tmp/tmpu8elfnm5.java\t2023-03-24 21:21:15.047214409 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+false, true); length_by_path.get(Arrays.asList(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(k,k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:16.675208441 +0100\n+++ /tmp/tmpyb3q_7ng.java\t2023-03-24 21:21:16.675208441 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(k,k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "Math.min(length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:18.131203100 +0100\n+++ /tmp/tmpqu9km6ou.java\t2023-03-24 21:21:18.135203088 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Math.min(length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(k, k)))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:19.691197380 +0100\n+++ /tmp/tmpyzdmpsmv.java\t2023-03-24 21:21:19.691197380 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(k, k)))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "true) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:21.191191879 +0100\n+++ /tmp/tmp8e7ej5ml.java\t2023-03-24 21:21:21.191191879 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+true) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))),",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:22.731186234 +0100\n+++ /tmp/tmprv7hi3m7.java\t2023-03-24 21:21:22.735186217 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))),\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:24.295180495 +0100\n+++ /tmp/tmp7hrp9d7e.java\t2023-03-24 21:21:24.295180495 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))())); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "new ArrayList<>(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:25.875174699 +0100\n+++ /tmp/tmpf8ha15oz.java\t2023-03-24 21:21:25.875174699 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))!= -1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:27.579168450 +0100\n+++ /tmp/tmpn3u96pi4.java\t2023-03-24 21:21:27.579168450 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))!= -1;\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "new ArrayList<>(Arrays.asList(j,k)) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:29.411161729 +0100\n+++ /tmp/tmp9lz6cvr5.java\t2023-03-24 21:21:29.411161729 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(Arrays.asList(j,k)) );\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "result.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:31.215155109 +0100\n+++ /tmp/tmpamxziceg.java\t2023-03-24 21:21:31.215155109 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+result.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "new HashSet<String>(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:33.307147429 +0100\n+++ /tmp/tmp2dai92uw.java\t2023-03-24 21:21:33.307147429 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new HashSet<String>(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "new ArrayList<>(Arrays.asList(update_length, k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:35.351139927 +0100\n+++ /tmp/tmpnn3fidv0.java\t2023-03-24 21:21:35.351139927 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(Arrays.asList(update_length, k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": ".get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:37.507132015 +0100\n+++ /tmp/tmp03mv44ny.java\t2023-03-24 21:21:37.507132015 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": ".get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:39.563124464 +0100\n+++ /tmp/tmpglzvjrw5.java\t2023-03-24 21:21:39.563124464 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "new HashSet<>(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:41.379117798 +0100\n+++ /tmp/tmpqnc8pxen.java\t2023-03-24 21:21:41.379117798 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new HashSet<>(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "new HashSet<>(Arrays.asList(j,k)) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:43.187111159 +0100\n+++ /tmp/tmppm_7so5c.java\t2023-03-24 21:21:43.187111159 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new HashSet<>(Arrays.asList(j,k)) );\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "new ArrayList<>(length_by_path.size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:44.907104840 +0100\n+++ /tmp/tmpa2zm7eec.java\t2023-03-24 21:21:44.907104840 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.size()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "new ArrayList<>(Arrays.asList(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:46.659098404 +0100\n+++ /tmp/tmporisi_ii.java\t2023-03-24 21:21:46.659098404 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(Arrays.asList(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "new ArrayList<>(update_length);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:48.423091924 +0100\n+++ /tmp/tmpttcn2hdl.java\t2023-03-24 21:21:48.423091924 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(update_length);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "new ArrayList<>(update_length));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:50.187085445 +0100\n+++ /tmp/tmp4tjy2vrk.java\t2023-03-24 21:21:50.187085445 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(update_length));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "new ArrayList<>(update_length) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:51.883079213 +0100\n+++ /tmp/tmpr64sa6kr.java\t2023-03-24 21:21:51.883079213 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(update_length) );\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:53.611072863 +0100\n+++ /tmp/tmpr219v256.java\t2023-03-24 21:21:53.615072849 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+false);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "-1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 21:21:55.407066266 +0100\n+++ /tmp/tmp9w6670qp.java\t2023-03-24 21:21:55.407066266 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+-1;\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "length_by_path.get(Arrays.asList(k,j))));"
    },
    "max_sublist_sum": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "max_ending_here = x + x;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:01.995042049 +0100\n+++ /tmp/tmp4mm08cxp.java\t2023-03-24 21:22:02.071041767 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + x;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "max_ending_here = x + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:05.555028956 +0100\n+++ /tmp/tmp0sgf46hw.java\t2023-03-24 21:22:05.555028956 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "max_ending_here = x + y;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:07.123023190 +0100\n+++ /tmp/tmpmlavawq6.java\t2023-03-24 21:22:07.123023190 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + y;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "max_ending_here = x + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:08.751017202 +0100\n+++ /tmp/tmphrxi4nrk.java\t2023-03-24 21:22:08.755017190 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 1;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "max_ending_here = x + width;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:12.711002636 +0100\n+++ /tmp/tmpcj9dftx7.java\t2023-03-24 21:22:12.731002562 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + width;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "max_ending_here = x + segment;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:14.514995998 +0100\n+++ /tmp/tmpzbp2x6kk.java\t2023-03-24 21:22:14.514995998 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + segment;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "max_ending_here = x + w;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:16.402989054 +0100\n+++ /tmp/tmpfwenw1lz.java\t2023-03-24 21:22:16.402989054 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + w;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "max_ending_here = x / x;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:18.374981797 +0100\n+++ /tmp/tmpeh7fj_g6.java\t2023-03-24 21:22:18.378981780 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x / x;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "max_ending_here = x + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:23.018964705 +0100\n+++ /tmp/tmp8esezd_x.java\t2023-03-24 21:22:23.022964687 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 2;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "max_ending_here = x + 10;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:27.450948386 +0100\n+++ /tmp/tmptlwnrx45.java\t2023-03-24 21:22:27.450948386 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 10;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "max_ending_here = x / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:31.478933553 +0100\n+++ /tmp/tmpj_3m38_z.java\t2023-03-24 21:22:31.478933553 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x / 2;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "max_ending_here = x + total;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:35.122920131 +0100\n+++ /tmp/tmpz_dxafll.java\t2023-03-24 21:22:35.126920118 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + total;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "max_ending_here = x / arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:36.618914620 +0100\n+++ /tmp/tmpjdlze241.java\t2023-03-24 21:22:36.618914620 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x / arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "max_ending_here = x + line;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:38.142909005 +0100\n+++ /tmp/tmpdevj5u6l.java\t2023-03-24 21:22:38.142909005 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + line;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "max_ending_here = x + height;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:39.782902963 +0100\n+++ /tmp/tmppnzprcjt.java\t2023-03-24 21:22:39.786902949 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + height;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "max_ending_here = x + i;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:41.450896817 +0100\n+++ /tmp/tmpohn4u6ux.java\t2023-03-24 21:22:41.454896805 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + i;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "max_ending_here = x + separator;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:43.186890419 +0100\n+++ /tmp/tmpzwuilt3c.java\t2023-03-24 21:22:43.186890419 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + separator;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "max_ending_here = x + result;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:44.938883965 +0100\n+++ /tmp/tmp91bfbmqy.java\t2023-03-24 21:22:44.938883965 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + result;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "max_ending_here = x + start;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:46.742877314 +0100\n+++ /tmp/tmpksclcquq.java\t2023-03-24 21:22:46.742877314 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + start;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "max_ending_here = x + 1.0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:48.634870342 +0100\n+++ /tmp/tmp570myovg.java\t2023-03-24 21:22:48.634870342 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 1.0;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "max_ending_here = x + 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:50.726862615 +0100\n+++ /tmp/tmp7ex_zm78.java\t2023-03-24 21:22:50.726862615 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 0;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "max_ending_here = x + v;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:55.350845565 +0100\n+++ /tmp/tmpon1me1wx.java\t2023-03-24 21:22:55.350845565 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + v;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "max_ending_here = x + tag;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:57.462837777 +0100\n+++ /tmp/tmp9ady_91i.java\t2023-03-24 21:22:57.462837777 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + tag;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "max_ending_here = x + out;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:22:59.538830119 +0100\n+++ /tmp/tmp4d2g6jkl.java\t2023-03-24 21:22:59.538830119 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + out;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "max_ending_here = x + right;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:01.266823746 +0100\n+++ /tmp/tmpjczqss1g.java\t2023-03-24 21:23:01.270823730 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + right;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "max_ending_here = x + curr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:02.962817490 +0100\n+++ /tmp/tmpbjj0ef8w.java\t2023-03-24 21:23:02.962817490 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + curr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "max_ending_here = x + arr.length;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:04.726810981 +0100\n+++ /tmp/tmp6ourdjz2.java\t2023-03-24 21:23:04.730810966 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + arr.length;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "max_ending_here = x + cursor;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:08.618796619 +0100\n+++ /tmp/tmp0prqaexk.java\t2023-03-24 21:23:08.618796619 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + cursor;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "max_ending_here = x + range;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:10.126791055 +0100\n+++ /tmp/tmpjcvykrjb.java\t2023-03-24 21:23:10.126791055 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + range;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "max_ending_here = x + other;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:11.686785297 +0100\n+++ /tmp/tmprypofny_.java\t2023-03-24 21:23:11.686785297 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + other;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "max_ending_here = x +Mismatched;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:13.258779495 +0100\n+++ /tmp/tmp3hbu4_4u.java\t2023-03-24 21:23:13.258779495 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +Mismatched;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "max_ending_here = x + 7;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:14.910773396 +0100\n+++ /tmp/tmpcwv4bw3m.java\t2023-03-24 21:23:14.910773396 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 7;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "max_ending_here = x + DOUBLE;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:18.702759398 +0100\n+++ /tmp/tmp196oom7q.java\t2023-03-24 21:23:18.702759398 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + DOUBLE;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "max_ending_here = x + horizontal;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:20.566752515 +0100\n+++ /tmp/tmptwvcm8f3.java\t2023-03-24 21:23:20.566752515 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + horizontal;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "max_ending_here = x + o;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:22.314746060 +0100\n+++ /tmp/tmpfz9bulg7.java\t2023-03-24 21:23:22.318746046 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + o;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "max_ending_here = x + c;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:24.366738482 +0100\n+++ /tmp/tmp82ua9vbw.java\t2023-03-24 21:23:24.370738468 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + c;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "max_ending_here = x + len;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:26.414730918 +0100\n+++ /tmp/tmp9p7ifyab.java\t2023-03-24 21:23:26.418730903 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + len;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "max_ending_here = x + this;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:28.418723516 +0100\n+++ /tmp/tmpprcuzp85.java\t2023-03-24 21:23:28.418723516 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + this;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "max_ending_here = x + 5;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:30.474715921 +0100\n+++ /tmp/tmpxhb2uvxb.java\t2023-03-24 21:23:30.474715921 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 5;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "max_ending_here = x + pad;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:34.882699635 +0100\n+++ /tmp/tmp7eijxuwn.java\t2023-03-24 21:23:34.882699635 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + pad;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "max_ending_here = x + vertical;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:36.550693469 +0100\n+++ /tmp/tmpm30v7vsd.java\t2023-03-24 21:23:36.554693455 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + vertical;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "max_ending_here = x + mask;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:38.298687010 +0100\n+++ /tmp/tmpjb17pf_v.java\t2023-03-24 21:23:38.298687010 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + mask;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "max_ending_here = x + amount;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:40.066680476 +0100\n+++ /tmp/tmp32m1zeyw.java\t2023-03-24 21:23:40.070680460 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + amount;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "max_ending_here = x + 9;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:41.554674976 +0100\n+++ /tmp/tmp23su_41_.java\t2023-03-24 21:23:41.554674976 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 9;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "max_ending_here = x + input;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:45.002662229 +0100\n+++ /tmp/tmpppuuyj4c.java\t2023-03-24 21:23:45.002662229 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + input;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "max_ending_here = x + p;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:46.614656269 +0100\n+++ /tmp/tmpwnhdfbdo.java\t2023-03-24 21:23:46.614656269 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + p;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "max_ending_here = x + n;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:48.282650102 +0100\n+++ /tmp/tmpd9y0crv1.java\t2023-03-24 21:23:48.282650102 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + n;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "max_ending_here = x + zoom;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:49.938643979 +0100\n+++ /tmp/tmpqa3cqaej.java\t2023-03-24 21:23:49.938643979 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + zoom;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "max_ending_here = x + r;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:51.670637574 +0100\n+++ /tmp/tmpg3xhm31i.java\t2023-03-24 21:23:51.674637558 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + r;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "max_ending_here = x + suffix;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:53.366631300 +0100\n+++ /tmp/tmps2pkf4kx.java\t2023-03-24 21:23:53.366631300 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + suffix;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "max_ending_here = x + 10;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:55.138624747 +0100\n+++ /tmp/tmp25jwof5x.java\t2023-03-24 21:23:55.138624747 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 10;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "max_ending_here = x + total_here;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:23:59.846607331 +0100\n+++ /tmp/tmpmxu111qx.java\t2023-03-24 21:23:59.846607331 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + total_here;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "max_ending_here = x + value;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:01.914599680 +0100\n+++ /tmp/tmp80dnk70i.java\t2023-03-24 21:24:01.914599680 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + value;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "max_ending_here = x + 10 + x;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:03.906592309 +0100\n+++ /tmp/tmpvm263ksw.java\t2023-03-24 21:24:03.906592309 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 10 + x;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "max_ending_here = x + elements;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:08.386575730 +0100\n+++ /tmp/tmpravwutfi.java\t2023-03-24 21:24:08.386575730 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + elements;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "max_ending_here = x +argin;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:10.226568919 +0100\n+++ /tmp/tmp1pkcyhap.java\t2023-03-24 21:24:10.226568919 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +argin;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "max_ending_here = x + node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:12.034562227 +0100\n+++ /tmp/tmph1ewqn9l.java\t2023-03-24 21:24:12.034562227 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + node;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "max_ending_here = x + avail;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:13.842555535 +0100\n+++ /tmp/tmpvacmr7xy.java\t2023-03-24 21:24:13.842555535 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + avail;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "max_ending_here = x + unit;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:15.610548989 +0100\n+++ /tmp/tmpdobqctou.java\t2023-03-24 21:24:15.610548989 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + unit;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "max_ending_here = x + h;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:17.234542976 +0100\n+++ /tmp/tmpyhp73a11.java\t2023-03-24 21:24:17.234542976 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + h;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "max_ending_here = x + port;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:18.794537201 +0100\n+++ /tmp/tmpupowyznf.java\t2023-03-24 21:24:18.798537185 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + port;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "max_ending_here = x + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:20.358531409 +0100\n+++ /tmp/tmp9po8dnys.java\t2023-03-24 21:24:20.362531395 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 2;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "max_ending_here = x + remaining;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:23.970518031 +0100\n+++ /tmp/tmpzalszqf4.java\t2023-03-24 21:24:23.970518031 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + remaining;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "max_ending_here = x + q;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:25.630511884 +0100\n+++ /tmp/tmpx3qqoqwh.java\t2023-03-24 21:24:25.630511884 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + q;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "max_ending_here = x + command;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:27.230505957 +0100\n+++ /tmp/tmpvy3tbpvn.java\t2023-03-24 21:24:27.230505957 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + command;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "max_ending_here = x + scale;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:28.974499496 +0100\n+++ /tmp/tmppikqzuv1.java\t2023-03-24 21:24:28.974499496 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + scale;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "max_ending_here = x + parsed;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:30.762492872 +0100\n+++ /tmp/tmpzp0og2oz.java\t2023-03-24 21:24:30.762492872 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + parsed;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "max_ending_here = x + X;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:32.662485833 +0100\n+++ /tmp/tmpeds13kr9.java\t2023-03-24 21:24:32.662485833 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + X;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "max_ending_here = x + target;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:34.726478186 +0100\n+++ /tmp/tmps9ftneis.java\t2023-03-24 21:24:34.730478170 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + target;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "max_ending_here = x + nodes;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:36.770470611 +0100\n+++ /tmp/tmpyun1tjk1.java\t2023-03-24 21:24:36.770470611 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + nodes;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "max_ending_here = x + ch;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:38.822463007 +0100\n+++ /tmp/tmpot1_w4vd.java\t2023-03-24 21:24:38.826462991 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + ch;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "max_ending_here = x + replacement;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:40.834455550 +0100\n+++ /tmp/tmpxfm9v7c4.java\t2023-03-24 21:24:40.834455550 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + replacement;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "max_ending_here = x + index;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:42.898447899 +0100\n+++ /tmp/tmp9v66antq.java\t2023-03-24 21:24:42.898447899 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + index;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "max_ending_here = x + defaultValue;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:44.718441152 +0100\n+++ /tmp/tmpwsxgj41k.java\t2023-03-24 21:24:44.718441152 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + defaultValue;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "max_ending_here = x +Part;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:46.510434509 +0100\n+++ /tmp/tmpezp118m4.java\t2023-03-24 21:24:46.510434509 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +Part;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "max_ending_here = x + reverse;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:48.198428251 +0100\n+++ /tmp/tmp9zmpkbw2.java\t2023-03-24 21:24:48.198428251 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + reverse;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "max_ending_here = x +$;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:50.094421221 +0100\n+++ /tmp/tmphfh0bgl7.java\t2023-03-24 21:24:50.098421205 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +$;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "max_ending_here = x + z;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:51.634415509 +0100\n+++ /tmp/tmppegdk3gg.java\t2023-03-24 21:24:51.634415509 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + z;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "max_ending_here = x + length;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:53.170409815 +0100\n+++ /tmp/tmpa5iraanl.java\t2023-03-24 21:24:53.174409799 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + length;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "max_ending_here = x + m;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:54.794403792 +0100\n+++ /tmp/tmpeg88ca8r.java\t2023-03-24 21:24:54.794403792 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + m;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "max_ending_here = x + prev;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:56.378397917 +0100\n+++ /tmp/tmpu1w9cd9p.java\t2023-03-24 21:24:56.378397917 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + prev;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "max_ending_here = x + bit;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:57.998391908 +0100\n+++ /tmp/tmp07ive50e.java\t2023-03-24 21:24:57.998391908 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + bit;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "max_ending_here = x + byte;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:24:59.618385900 +0100\n+++ /tmp/tmpatjix1rt.java\t2023-03-24 21:24:59.618385900 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "max_ending_here = x + System;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:01.282379726 +0100\n+++ /tmp/tmpqvww3ji4.java\t2023-03-24 21:25:01.282379726 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + System;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "max_ending_here = x + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:02.990373391 +0100\n+++ /tmp/tmphhumqk0r.java\t2023-03-24 21:25:02.994373375 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 1);\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "max_ending_here = x + 10 + y;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:04.718366979 +0100\n+++ /tmp/tmpw37tnxhq.java\t2023-03-24 21:25:04.718366979 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 10 + y;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "max_ending_here = x + 3;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:06.698359632 +0100\n+++ /tmp/tmpdsn8f1_0.java\t2023-03-24 21:25:06.698359632 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 3;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "max_ending_here = x + LATABLE;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:11.342342400 +0100\n+++ /tmp/tmp6qp22lwt.java\t2023-03-24 21:25:11.346342384 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + LATABLE;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "max_ending_here = x + initial_ending;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:13.426334665 +0100\n+++ /tmp/tmpkdfd0pub.java\t2023-03-24 21:25:13.426334665 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + initial_ending;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "max_ending_here = x + System.err;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:15.570326707 +0100\n+++ /tmp/tmpmesa7z1k.java\t2023-03-24 21:25:15.570326707 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + System.err;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "max_ending_here = x + 10 + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:17.582319240 +0100\n+++ /tmp/tmpc7fiqx6c.java\t2023-03-24 21:25:17.582319240 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 10 + arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "max_ending_here = x + x; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:19.330312750 +0100\n+++ /tmp/tmp6x4wdy76.java\t2023-03-24 21:25:19.334312734 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + x; }\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "max_ending_here = x + delayending;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:21.162305948 +0100\n+++ /tmp/tmp41vp9aib.java\t2023-03-24 21:25:21.162305948 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + delayending;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "max_ending_here = x + bitending;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:22.702300231 +0100\n+++ /tmp/tmpk661vmyg.java\t2023-03-24 21:25:22.702300231 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + bitending;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "max_ending_here = x + arr; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:24.222294587 +0100\n+++ /tmp/tmp42m4lpau.java\t2023-03-24 21:25:24.222294587 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + arr; }\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "max_ending_here = x + LATFactor;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:25.702289090 +0100\n+++ /tmp/tmpd2g50tc1.java\t2023-03-24 21:25:25.706289077 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + LATFactor;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "max_ending_here = x + y; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:27.250283342 +0100\n+++ /tmp/tmpywkvcz8w.java\t2023-03-24 21:25:27.250283342 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + y; }\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "max_ending_here = x + 10 + segment;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:28.758277742 +0100\n+++ /tmp/tmpo5h2qrhg.java\t2023-03-24 21:25:28.758277742 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 10 + segment;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "max_ending_here = x + arr.here;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:30.310271977 +0100\n+++ /tmp/tmpk67txodx.java\t2023-03-24 21:25:30.310271977 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + arr.here;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "max_ending_here = x + LATWS;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 21:25:31.902266066 +0100\n+++ /tmp/tmpde7xocaq.java\t2023-03-24 21:25:31.902266066 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + LATWS;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "max_ending_here = Math.max(0,max_ending_here + x);"
    },
    "pascal": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (int c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:36.318249662 +0100\n+++ /tmp/tmpf_1mk9ld.java\t2023-03-24 21:25:36.374249454 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "for (int c=0; c<r; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:40.910232602 +0100\n+++ /tmp/tmpyf9bu46d.java\t2023-03-24 21:25:40.910232602 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "for (int c = 0; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:42.806225556 +0100\n+++ /tmp/tmpq5nx36jb.java\t2023-03-24 21:25:42.806225556 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "for (int c = 0; c < r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:47.666207496 +0100\n+++ /tmp/tmp_1brnxi6.java\t2023-03-24 21:25:47.666207496 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "for(int c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:51.874191855 +0100\n+++ /tmp/tmpfi5p8i1d.java\t2023-03-24 21:25:51.882191825 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for(int c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "for (int c=0; c<r; c <= 12; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:56.094176169 +0100\n+++ /tmp/tmpu7f6_cxs.java\t2023-03-24 21:25:56.094176169 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 12; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "for (int c=0; c<r; c <= ch; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:57.570170681 +0100\n+++ /tmp/tmpzwoxusq7.java\t2023-03-24 21:25:57.570170681 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= ch; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "for (int c=0; c<r; c < r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:25:58.986165417 +0100\n+++ /tmp/tmply72iq7l.java\t2023-03-24 21:25:58.986165417 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "for (int c=0; c<r; c!= null; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:00.482159854 +0100\n+++ /tmp/tmps2mldao0.java\t2023-03-24 21:26:00.482159854 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c!= null; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "for (int c=0; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:01.978154291 +0100\n+++ /tmp/tmpn1prpndo.java\t2023-03-24 21:26:01.978154291 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "for (int c=0; c<r; c < 12; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:05.750140264 +0100\n+++ /tmp/tmp7lgtv0dj.java\t2023-03-24 21:26:05.750140264 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < 12; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "for (int c=0; c<r; c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:07.382134195 +0100\n+++ /tmp/tmp02gwgitl.java\t2023-03-24 21:26:07.382134195 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "for (int c=0; c<r; c <= q; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:09.058127961 +0100\n+++ /tmp/tmp39mo0oko.java\t2023-03-24 21:26:09.058127961 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= q; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "for (int c=0; c< r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:10.790121519 +0100\n+++ /tmp/tmpcq2qvh9w.java\t2023-03-24 21:26:10.790121519 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c< r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "for (int c=0; c<r; c <= 'n') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:15.254104912 +0100\n+++ /tmp/tmpizselqxb.java\t2023-03-24 21:26:15.254104912 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 'n') {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "for (int c=0; c<r, c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:17.134097919 +0100\n+++ /tmp/tmplzu2er12.java\t2023-03-24 21:26:17.134097919 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r, c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "for (int c=0; c<r; c <= 8; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:19.102090596 +0100\n+++ /tmp/tmpey8h71bv.java\t2023-03-24 21:26:19.102090596 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 8; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "for (int c=0; c<r; c < q; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:21.082083228 +0100\n+++ /tmp/tmp5i6op2w0.java\t2023-03-24 21:26:21.082083228 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < q; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "for (int c=0; c<r; c <= 9; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:23.034075966 +0100\n+++ /tmp/tmpxzujp813.java\t2023-03-24 21:26:23.034075966 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 9; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "for (int c=0; c<r; c <= '9') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:24.730069653 +0100\n+++ /tmp/tmp51704umj.java\t2023-03-24 21:26:24.730069653 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= '9') {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "for (int c = 0; c < q; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:26.434063311 +0100\n+++ /tmp/tmp55kp0xdk.java\t2023-03-24 21:26:26.434063311 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < q; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "for (int c=0; c<r; c = r;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:28.150056925 +0100\n+++ /tmp/tmpkv8p58jv.java\t2023-03-24 21:26:28.150056925 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c = r;\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "for (int c=0; c<r; c <= high; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:29.794050805 +0100\n+++ /tmp/tmptfesy_4q.java\t2023-03-24 21:26:29.798050791 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= high; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "for (int c=0; c<r; c=r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:31.478044538 +0100\n+++ /tmp/tmpkp83ke98.java\t2023-03-24 21:26:31.478044538 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c=r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "for (int c=0; c2 = 0; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:33.166038254 +0100\n+++ /tmp/tmpxsewck6i.java\t2023-03-24 21:26:33.166038254 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c2 = 0; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "for (int c = 1; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:34.850031985 +0100\n+++ /tmp/tmp8n3_d5pc.java\t2023-03-24 21:26:34.850031985 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 1; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "for (int c=0; c<r; c < p; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:38.606018000 +0100\n+++ /tmp/tmprly5ytc8.java\t2023-03-24 21:26:38.606018000 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < p; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "for (int c=0; c<r; c<n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:40.034012684 +0100\n+++ /tmp/tmp4851sb4t.java\t2023-03-24 21:26:40.034012684 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c<n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "for (int c=0; c<r; c -= c; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:41.458007381 +0100\n+++ /tmp/tmpbvauqzq1.java\t2023-03-24 21:26:41.458007381 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c -= c; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "for (int c=0; c<r; c <= n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:43.026001541 +0100\n+++ /tmp/tmp97acowm1.java\t2023-03-24 21:26:43.026001541 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "for (int i=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:44.557995836 +0100\n+++ /tmp/tmpzwu0gna0.java\t2023-03-24 21:26:44.557995836 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int i=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "for (int c=0; c<r; c < 0; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:46.313989298 +0100\n+++ /tmp/tmpp9n4n_vs.java\t2023-03-24 21:26:46.313989298 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < 0; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "for (int c = 0; c < d; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:47.937983248 +0100\n+++ /tmp/tmpgodgcvrx.java\t2023-03-24 21:26:47.937983248 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < d; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "for (int c=0; c<r; c = r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:49.773976411 +0100\n+++ /tmp/tmpirw_v297.java\t2023-03-24 21:26:49.773976411 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c = r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "for (int c=0; c<r; j++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:51.557969766 +0100\n+++ /tmp/tmpo69tcklw.java\t2023-03-24 21:26:51.557969766 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; j++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "for (int c=0; c = c; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:53.569962270 +0100\n+++ /tmp/tmpszhhgcoy.java\t2023-03-24 21:26:53.593962180 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c = c; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "for (int c=0; c<r; c < 6; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:55.525954984 +0100\n+++ /tmp/tmpj0s0m2ft.java\t2023-03-24 21:26:55.525954984 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < 6; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "for (int c=0; c<r; c < rows; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:57.449947816 +0100\n+++ /tmp/tmpuilairx2.java\t2023-03-24 21:26:57.449947816 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < rows; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "for (int c=0; c<r; c <= r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:26:59.461940320 +0100\n+++ /tmp/tmpvnl9g_nt.java\t2023-03-24 21:26:59.461940320 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "for (int c=0; c<r; c = c;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:01.505932703 +0100\n+++ /tmp/tmpeo7xy_rk.java\t2023-03-24 21:27:01.505932703 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c = c;\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "for (int c=0; c<r; c <= 0; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:03.241926235 +0100\n+++ /tmp/tmpwinp3t1j.java\t2023-03-24 21:27:03.245926219 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 0; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "for (int i=0; i<r; i++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:04.909920019 +0100\n+++ /tmp/tmpnl7ui8xq.java\t2023-03-24 21:27:04.909920019 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int i=0; i<r; i++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "for (int c=0; c<r; c = c; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:06.609913684 +0100\n+++ /tmp/tmpkrmdgkuv.java\t2023-03-24 21:27:06.613913668 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c = c; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "for (int c=0; c<r; c <= p; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:08.333907259 +0100\n+++ /tmp/tmprpt0z777.java\t2023-03-24 21:27:08.333907259 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= p; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "for (int c=0; c<r; c <= c; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:10.153900476 +0100\n+++ /tmp/tmpw_ulb8sp.java\t2023-03-24 21:27:10.157900460 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= c; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "for (int c=0; c<r; c += c; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:11.557895241 +0100\n+++ /tmp/tmpxn8gw4yj.java\t2023-03-24 21:27:11.557895241 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c += c; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "for (int c = 0; c < m; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:12.957890023 +0100\n+++ /tmp/tmpe2c3ke5z.java\t2023-03-24 21:27:12.957890023 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < m; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "for (int c=0; c<r; c+=r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:14.425884551 +0100\n+++ /tmp/tmpw9pjwted.java\t2023-03-24 21:27:14.425884551 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c+=r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "for (int c=0; c<r; c <= 'z') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:15.805879406 +0100\n+++ /tmp/tmp76pegvvk.java\t2023-03-24 21:27:15.917878990 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 'z') {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "for (int c = i=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:17.425873367 +0100\n+++ /tmp/tmpeb5mmof2.java\t2023-03-24 21:27:17.425873367 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = i=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "for (int c=0; c<r; c c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:19.045867327 +0100\n+++ /tmp/tmp9yjeul8d.java\t2023-03-24 21:27:19.045867327 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "for (int c=0; c<r; c=0; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:20.661861302 +0100\n+++ /tmp/tmp6vdwexfv.java\t2023-03-24 21:27:20.661861302 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c=0; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "for (int c=0; c<r; c = r.next()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:22.205855546 +0100\n+++ /tmp/tmp38iybzic.java\t2023-03-24 21:27:22.205855546 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c = r.next()) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "for (int c = 0; c < c; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:24.013848805 +0100\n+++ /tmp/tmphd19lmbv.java\t2023-03-24 21:27:24.013848805 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < c; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "for (int c=0; c<r; c++, c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:28.517832008 +0100\n+++ /tmp/tmpwxzphurr.java\t2023-03-24 21:27:28.517832008 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c++, c) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "for (int cX = 0; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:30.441824833 +0100\n+++ /tmp/tmpeawyovb5.java\t2023-03-24 21:27:30.441824833 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int cX = 0; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "for (int cID = 0; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:32.497817163 +0100\n+++ /tmp/tmp_kd48hqe.java\t2023-03-24 21:27:32.497817163 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int cID = 0; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "for (int c=0; c<r; c <= x; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:34.673809048 +0100\n+++ /tmp/tmpowmauysg.java\t2023-03-24 21:27:34.673809048 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= x; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "for (int c, c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:36.681801557 +0100\n+++ /tmp/tmpxfaqi06r.java\t2023-03-24 21:27:36.681801557 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c, c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "for (int c=0; c<r; c++, c); c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:38.401795142 +0100\n+++ /tmp/tmp2igaagy1.java\t2023-03-24 21:27:38.401795142 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c++, c); c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "for (int c=1; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:40.101788800 +0100\n+++ /tmp/tmpjpbfosmu.java\t2023-03-24 21:27:40.101788800 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=1; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "for (int c = i; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:43.933774503 +0100\n+++ /tmp/tmpbjtx6ws2.java\t2023-03-24 21:27:43.933774503 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = i; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "for (int c=0; c<r > 0; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:45.485768712 +0100\n+++ /tmp/tmpvqpgjirz.java\t2023-03-24 21:27:45.485768712 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r > 0; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "for (int r=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:46.965763188 +0100\n+++ /tmp/tmppdp2iwvd.java\t2023-03-24 21:27:46.965763188 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int r=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "for (int c=0; c<r; c--) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:48.525757368 +0100\n+++ /tmp/tmpmk9jfszx.java\t2023-03-24 21:27:48.525757368 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c--) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "for (int cA = 0; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:52.329743173 +0100\n+++ /tmp/tmpguj7owpg.java\t2023-03-24 21:27:52.329743173 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int cA = 0; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "for (int c=0; c<r; c <= q) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:54.093736589 +0100\n+++ /tmp/tmpji2pu6cm.java\t2023-03-24 21:27:54.093736589 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= q) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "for (int c=0; c<r; c+=r) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:27:55.801730213 +0100\n+++ /tmp/tmpcfifjvlo.java\t2023-03-24 21:27:55.801730213 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c+=r) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "for (int c=0; c < r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:00.225713701 +0100\n+++ /tmp/tmp_3i5apps.java\t2023-03-24 21:28:00.225713701 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c < r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "for (int c=0; c<r; c <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:04.913696198 +0100\n+++ /tmp/tmp_yp4jw2h.java\t2023-03-24 21:28:04.913696198 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "for (int c=0; c<r; c < n;c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:06.881688851 +0100\n+++ /tmp/tmpn40ouuvz.java\t2023-03-24 21:28:06.881688851 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < n;c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "for (int c=0; c<r; c = (c) c;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:08.813681637 +0100\n+++ /tmp/tmpkj2513l7.java\t2023-03-24 21:28:08.817681623 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c = (c) c;\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "for (int c=0; c<r; c = (c) r;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:10.609674933 +0100\n+++ /tmp/tmpkzq4oo6y.java\t2023-03-24 21:28:10.609674933 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c = (c) r;\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "for (int c=0; c<r; i++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:12.405668224 +0100\n+++ /tmp/tmpe61jad8q.java\t2023-03-24 21:28:12.409668210 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; i++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "for (int c=0; c<r; c < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:14.137661758 +0100\n+++ /tmp/tmp8ixjxyeu.java\t2023-03-24 21:28:14.137661758 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c < 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "for (int c = 0; c < g; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:15.777655632 +0100\n+++ /tmp/tmp9kqdr5lh.java\t2023-03-24 21:28:15.777655632 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < g; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "for (int c=0; c<r; c<r++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:17.469649312 +0100\n+++ /tmp/tmp24i0e7ur.java\t2023-03-24 21:28:17.469649312 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c<r++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "for (int c=0; c<r; c <= 'r') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:18.865644100 +0100\n+++ /tmp/tmp48j0izm_.java\t2023-03-24 21:28:18.865644100 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 'r') {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "for (int c=0; c<r;c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:20.297638752 +0100\n+++ /tmp/tmp10thbwdy.java\t2023-03-24 21:28:20.297638752 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r;c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "for (int c; c < n; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:23.825625573 +0100\n+++ /tmp/tmpm_25aaar.java\t2023-03-24 21:28:23.825625573 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c; c < n; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "for (int c=0; c<r; r++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:25.429619581 +0100\n+++ /tmp/tmpp2vartr5.java\t2023-03-24 21:28:25.433619567 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; r++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "for (int c=0; c<rL; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:29.341604968 +0100\n+++ /tmp/tmpd9lu2jgq.java\t2023-03-24 21:28:29.341604968 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<rL; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "for (int c=0; c<r; c<r) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:31.101598390 +0100\n+++ /tmp/tmp49nz23pj.java\t2023-03-24 21:28:31.101598390 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c<r) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "for (int c=0; c<r; c <= 12) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:32.829591934 +0100\n+++ /tmp/tmpkqdjaox8.java\t2023-03-24 21:28:32.829591934 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= 12) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "for (int c=0; c<r; c <= high) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:34.661585089 +0100\n+++ /tmp/tmpuz76_9e7.java\t2023-03-24 21:28:34.661585089 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c <= high) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "for (int c=0; c<r; c!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:36.597577856 +0100\n+++ /tmp/tmpgqjtpzfp.java\t2023-03-24 21:28:36.597577856 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c!= null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "for (int c=0; c<r); c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:38.513570697 +0100\n+++ /tmp/tmpl8aeu4hz.java\t2023-03-24 21:28:38.517570680 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r); c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "for (int c = 0; c < i; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:40.449563461 +0100\n+++ /tmp/tmp61z9lo6r.java\t2023-03-24 21:28:40.453563445 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c = 0; c < i; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "for (!int c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:42.533555673 +0100\n+++ /tmp/tmpzccwrw33.java\t2023-03-24 21:28:42.537555657 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (!int c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "for (int c=0; c<r, c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:44.353548870 +0100\n+++ /tmp/tmpjf4w2pgc.java\t2023-03-24 21:28:44.353548870 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r, c) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "for (int c=0; c< q; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:45.985542771 +0100\n+++ /tmp/tmp3dweqgwa.java\t2023-03-24 21:28:45.985542771 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c< q; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "for (int c=0; c<r; c)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:47.745536193 +0100\n+++ /tmp/tmpveay3zgm.java\t2023-03-24 21:28:47.745536193 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c)) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "for (char c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:49.357530167 +0100\n+++ /tmp/tmp94nlyk8l.java\t2023-03-24 21:28:49.361530151 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (char c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "for (int c=0; c <= q; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:53.233515678 +0100\n+++ /tmp/tmp51el7c8c.java\t2023-03-24 21:28:53.233515678 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c <= q; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "for (int i=0; c<r; i++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:55.097508708 +0100\n+++ /tmp/tmprn07asaf.java\t2023-03-24 21:28:55.101508694 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int i=0; c<r; i++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "for (int c=0; c < q; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:56.577503174 +0100\n+++ /tmp/tmp7pvamasp.java\t2023-03-24 21:28:56.577503174 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c < q; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "for (int c=0; c<r; n++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:28:57.985497910 +0100\n+++ /tmp/tmp12fwo0hi.java\t2023-03-24 21:28:57.985497910 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; n++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "for (int c=0; c!= null; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:29:29.009381871 +0100\n+++ /tmp/tmp970p5pd6.java\t2023-03-24 21:29:29.009381871 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c!= null; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "for (int c=0; c<a; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:29:30.497376302 +0100\n+++ /tmp/tmpy1tnceek.java\t2023-03-24 21:29:30.501376289 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<a; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "for (int c=0; c<m; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 21:29:31.989370720 +0100\n+++ /tmp/tmpdebpl0p4.java\t2023-03-24 21:29:31.989370720 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<m; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (int c=0; c<r+1; c++) {"
    },
    "quicksort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "} else if (x > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:35.781356530 +0100\n+++ /tmp/tmpm9ild00g.java\t2023-03-24 21:29:35.845356289 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "} else if (x > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:39.885341170 +0100\n+++ /tmp/tmpnm5imzex.java\t2023-03-24 21:29:39.889341154 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "} else if (x > 0 && x < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:41.605334733 +0100\n+++ /tmp/tmpas9accug.java\t2023-03-24 21:29:41.605334733 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "} else if (x > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:46.209317498 +0100\n+++ /tmp/tmpmx44xb42.java\t2023-03-24 21:29:46.209317498 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "} else if (x > pivot && x < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:48.261309816 +0100\n+++ /tmp/tmpsp_na82o.java\t2023-03-24 21:29:48.265309803 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "} else if (y > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:53.041291922 +0100\n+++ /tmp/tmpbvxgzml8.java\t2023-03-24 21:29:53.045291908 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "} else if (x > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:54.813285287 +0100\n+++ /tmp/tmpye9zx0dl.java\t2023-03-24 21:29:54.813285287 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "} else if (x > pivot && x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:29:59.033269486 +0100\n+++ /tmp/tmp2alqnobn.java\t2023-03-24 21:29:59.033269486 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "} else if (x > Matrices.EPS) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:00.565263749 +0100\n+++ /tmp/tmpeiex8g4u.java\t2023-03-24 21:30:00.565263749 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Matrices.EPS) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "} else if (x > 0 && x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:02.001258374 +0100\n+++ /tmp/tmpzasnxmui.java\t2023-03-24 21:30:02.001258374 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "} else if (x > Integer.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:03.525252667 +0100\n+++ /tmp/tmp3a1g9wyl.java\t2023-03-24 21:30:03.525252667 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Integer.MAX_VALUE) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "} else if (x > Float.MIN_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:07.153239081 +0100\n+++ /tmp/tmpylgtllsu.java\t2023-03-24 21:30:07.153239081 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Float.MIN_VALUE) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "} else if (x > '-') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:11.105224277 +0100\n+++ /tmp/tmpzz2pl0r0.java\t2023-03-24 21:30:11.105224277 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > '-') {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "} else if (x > 90) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:15.353208365 +0100\n+++ /tmp/tmphgn_ype4.java\t2023-03-24 21:30:15.353208365 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 90) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "} else if (x > arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:20.129190474 +0100\n+++ /tmp/tmpau61f0x1.java\t2023-03-24 21:30:20.129190474 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > arr.size()) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "} else if (x > Float.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:25.001172223 +0100\n+++ /tmp/tmp666klsi3.java\t2023-03-24 21:30:25.001172223 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Float.MAX_VALUE) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "} else if (x > Short.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:29.229156382 +0100\n+++ /tmp/tmpd9iv18_d.java\t2023-03-24 21:30:29.233156365 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Short.MAX_VALUE) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "} else if (x > 0 && y > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:33.265141258 +0100\n+++ /tmp/tmpkgei32cq.java\t2023-03-24 21:30:33.265141258 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "} else if (x > pivot || x < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:34.745135712 +0100\n+++ /tmp/tmpqpo_ktwi.java\t2023-03-24 21:30:34.749135696 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot || x < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "} else if (x >Numeric) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:38.317122325 +0100\n+++ /tmp/tmprx4x9irv.java\t2023-03-24 21:30:38.317122325 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Numeric) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "} else if (x > pivot && y < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:39.809116734 +0100\n+++ /tmp/tmpi27lgigx.java\t2023-03-24 21:30:39.809116734 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && y < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "} else if (x >reachable) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:41.385110828 +0100\n+++ /tmp/tmpqvgehklc.java\t2023-03-24 21:30:41.409110738 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >reachable) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "} else if (x > pivot && x < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:43.129104290 +0100\n+++ /tmp/tmpi5w_eu8p.java\t2023-03-24 21:30:43.129104290 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x < j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "} else if (x >pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:44.801098023 +0100\n+++ /tmp/tmph2t579mt.java\t2023-03-24 21:30:44.801098023 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "} else if (x >OrEmpty) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:49.217081472 +0100\n+++ /tmp/tmp5ssdg3dh.java\t2023-03-24 21:30:49.217081472 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >OrEmpty) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "} else if (x > 0 || x < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:51.273073763 +0100\n+++ /tmp/tmpvn47xob0.java\t2023-03-24 21:30:51.273073763 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || x < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "} else if (x > c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:56.001056038 +0100\n+++ /tmp/tmph9ts8vry.java\t2023-03-24 21:30:56.001056038 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > c) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "} else if (x > X) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:30:58.213047746 +0100\n+++ /tmp/tmpazn0odqq.java\t2023-03-24 21:30:58.213047746 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > X) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "} else if (x > h) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:00.165040426 +0100\n+++ /tmp/tmphc7ryzfz.java\t2023-03-24 21:31:00.165040426 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > h) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "} else if (x > -1 && x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:02.037033408 +0100\n+++ /tmp/tmptsz84w2k.java\t2023-03-24 21:31:02.037033408 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 && x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "} else if (x > 0 && y < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:03.745027005 +0100\n+++ /tmp/tmpcgrxd_4c.java\t2023-03-24 21:31:03.745027005 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "} else if (x > repaint) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:05.517020359 +0100\n+++ /tmp/tmpp1hoxfoz.java\t2023-03-24 21:31:05.517020359 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > repaint) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "} else if (x > arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:07.321013595 +0100\n+++ /tmp/tmpygf0739z.java\t2023-03-24 21:31:07.321013595 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > arr) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "} else if (x >PASSWORD) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:09.077007008 +0100\n+++ /tmp/tmp3bsg8eu0.java\t2023-03-24 21:31:09.077007008 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >PASSWORD) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "} else if (x > 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:10.829000438 +0100\n+++ /tmp/tmpoytxi2sx.java\t2023-03-24 21:31:10.833000425 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0.0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "} else if (x >DerivedValue.EOL) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:15.612982496 +0100\n+++ /tmp/tmp8vwvnpy8.java\t2023-03-24 21:31:15.612982496 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >DerivedValue.EOL) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "} else if (x > exit) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:17.352975970 +0100\n+++ /tmp/tmpxt7njmde.java\t2023-03-24 21:31:17.352975970 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > exit) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "} else if (x > 0 && x < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:19.116969355 +0100\n+++ /tmp/tmpwob3zcfy.java\t2023-03-24 21:31:19.116969355 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "} else if (x > | x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:20.880962737 +0100\n+++ /tmp/tmpu_kwaxf8.java\t2023-03-24 21:31:20.880962737 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > | x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "} else if (x > 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:22.560956437 +0100\n+++ /tmp/tmpbrkzy34v.java\t2023-03-24 21:31:22.560956437 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 3) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "} else if (x > pivot && y < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:26.584941342 +0100\n+++ /tmp/tmpb4lz1ags.java\t2023-03-24 21:31:26.588941325 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && y < j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "} else if (y > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:28.480934228 +0100\n+++ /tmp/tmp2qmj0tf8.java\t2023-03-24 21:31:28.480934228 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "} else if (x > pivot || x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:30.204927762 +0100\n+++ /tmp/tmp1k87rqxs.java\t2023-03-24 21:31:30.204927762 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot || x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "} else if (x > ch) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:31.936921264 +0100\n+++ /tmp/tmp275vovnn.java\t2023-03-24 21:31:31.936921264 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > ch) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "} else if (x >System.nanoTime()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:33.772914375 +0100\n+++ /tmp/tmpdak7v7ec.java\t2023-03-24 21:31:33.772914375 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >System.nanoTime()) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "} else if (x > Math.abs(z) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:37.860899035 +0100\n+++ /tmp/tmpm3akmh11.java\t2023-03-24 21:31:37.860899035 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.abs(z) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "} else if (x > Double.class) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:39.580892583 +0100\n+++ /tmp/tmp74dv0owe.java\t2023-03-24 21:31:39.580892583 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Double.class) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "} else if ( x > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:41.352885935 +0100\n+++ /tmp/tmpoqneqou3.java\t2023-03-24 21:31:41.352885935 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if ( x > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "} else if (x >Just) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:45.444870577 +0100\n+++ /tmp/tmpnt68z_xf.java\t2023-03-24 21:31:45.444870577 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Just) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "} else if (x > System.nanoTime()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:47.200863989 +0100\n+++ /tmp/tmpvo74yn9k.java\t2023-03-24 21:31:47.204863972 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > System.nanoTime()) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "} else if (x > pivot && y > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:51.228848872 +0100\n+++ /tmp/tmpb9g6tzpr.java\t2023-03-24 21:31:51.228848872 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && y > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "} else if (x >Sc) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:52.912842550 +0100\n+++ /tmp/tmpygwr82mo.java\t2023-03-24 21:31:52.912842550 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Sc) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "} else if (x >Absolute) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:54.616836155 +0100\n+++ /tmp/tmpt1oz50u0.java\t2023-03-24 21:31:54.616836155 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Absolute) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "} else if (x > & 0x1F) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:56.400829459 +0100\n+++ /tmp/tmp7sh8eq9e.java\t2023-03-24 21:31:56.400829459 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > & 0x1F) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "} else if (x > z) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:58.108823048 +0100\n+++ /tmp/tmpsovauk_u.java\t2023-03-24 21:31:58.108823048 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > z) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "} else if (x > -1 && y > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:31:59.852816500 +0100\n+++ /tmp/tmpg0h_0saz.java\t2023-03-24 21:31:59.852816500 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 && y > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "} else if (x > 0 && x <Histogram) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:01.640809791 +0100\n+++ /tmp/tmp2oiqaxh6.java\t2023-03-24 21:32:01.640809791 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x <Histogram) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "} else if (x >(7) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:03.428803076 +0100\n+++ /tmp/tmpuccsvbke.java\t2023-03-24 21:32:03.428803076 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >(7) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "} else if (x > pivot && x < tiny) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:05.064796935 +0100\n+++ /tmp/tmpdzugz902.java\t2023-03-24 21:32:05.064796935 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x < tiny) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "} else if (x > 31) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:06.864790178 +0100\n+++ /tmp/tmpu40zl9ym.java\t2023-03-24 21:32:06.864790178 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 31) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "} else if (x > defaultValue) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:11.148774096 +0100\n+++ /tmp/tmpwvg9ze_a.java\t2023-03-24 21:32:11.148774096 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > defaultValue) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "} else if (x > 0 && x < maxResults) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:12.840767742 +0100\n+++ /tmp/tmpvkkt54i8.java\t2023-03-24 21:32:12.840767742 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < maxResults) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "} else if (y > x && y < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:14.688760805 +0100\n+++ /tmp/tmp31y40l5o.java\t2023-03-24 21:32:14.688760805 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y > x && y < j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "} else if (x > LEFT) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:16.476754091 +0100\n+++ /tmp/tmp2iha92ie.java\t2023-03-24 21:32:16.476754091 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > LEFT) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "} else if (x > target) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:18.208747588 +0100\n+++ /tmp/tmpgjztps1e.java\t2023-03-24 21:32:18.208747588 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > target) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "} else if (x > jj) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:19.952741038 +0100\n+++ /tmp/tmpoeeg_shc.java\t2023-03-24 21:32:19.956741024 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > jj) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "} else if (x > o) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:21.704734459 +0100\n+++ /tmp/tmp1odiff9f.java\t2023-03-24 21:32:21.704734459 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > o) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "} else if (x > isLast) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:23.452727896 +0100\n+++ /tmp/tmp8b6mqe89.java\t2023-03-24 21:32:23.468727834 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > isLast) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "} else if (x > '_') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:25.224721240 +0100\n+++ /tmp/tmpez5nswip.java\t2023-03-24 21:32:25.224721240 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > '_') {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "} else if (x > arr.size() - 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:29.304705919 +0100\n+++ /tmp/tmpjubv1rqq.java\t2023-03-24 21:32:29.304705919 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > arr.size() - 1)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "} else if (x > Matrices.EOL) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:30.912699878 +0100\n+++ /tmp/tmp4_lvu50i.java\t2023-03-24 21:32:30.912699878 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Matrices.EOL) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "} else if (v > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:32.664693298 +0100\n+++ /tmp/tmp0fhrs_05.java\t2023-03-24 21:32:32.664693298 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (v > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "} else if (x > arr.size() - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:34.372686884 +0100\n+++ /tmp/tmpwmv64pg5.java\t2023-03-24 21:32:34.372686884 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > arr.size() - 1) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "} else if (x >Pos) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:38.408671723 +0100\n+++ /tmp/tmpwhp87jn1.java\t2023-03-24 21:32:38.408671723 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Pos) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "} else if (x > tiny && x < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:40.124665277 +0100\n+++ /tmp/tmpusdqubfg.java\t2023-03-24 21:32:40.128665264 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > tiny && x < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "} else if (x >Member) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:41.876658696 +0100\n+++ /tmp/tmp3gzidt25.java\t2023-03-24 21:32:41.876658696 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Member) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "} else if (x > 0 && x < len) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:43.576652310 +0100\n+++ /tmp/tmp4ki8d7qs.java\t2023-03-24 21:32:43.580652297 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < len) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "} else if (x >unit) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:45.284645894 +0100\n+++ /tmp/tmpmhzgicsc.java\t2023-03-24 21:32:45.284645894 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >unit) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "} else if (y > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:46.948639642 +0100\n+++ /tmp/tmpsfejicdc.java\t2023-03-24 21:32:46.948639642 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y > y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "} else if (x >HEIGHT) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:48.760632837 +0100\n+++ /tmp/tmpwt8lbswm.java\t2023-03-24 21:32:48.760632837 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >HEIGHT) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "} else if (x >Histogram) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:50.452626480 +0100\n+++ /tmp/tmppe41aja2.java\t2023-03-24 21:32:50.452626480 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Histogram) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "} else if (x > 0 && x < X) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:52.192619943 +0100\n+++ /tmp/tmpik96z4j2.java\t2023-03-24 21:32:52.192619943 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < X) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "} else if (x > 9) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:53.972613253 +0100\n+++ /tmp/tmpvx3rde_m.java\t2023-03-24 21:32:53.972613253 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 9) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "} else if (x > pivot || x < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:58.056597909 +0100\n+++ /tmp/tmp_xetvqx7.java\t2023-03-24 21:32:58.056597909 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot || x < j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "} else if (x > 'z') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:32:59.756591521 +0100\n+++ /tmp/tmp1rtxss8b.java\t2023-03-24 21:32:59.784591416 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 'z') {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "} else if (x > -1 && x < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:03.772576430 +0100\n+++ /tmp/tmpipd_jmm3.java\t2023-03-24 21:33:03.776576417 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 && x < x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "} else if (x > pivot && x <Histogram) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:07.904560902 +0100\n+++ /tmp/tmpyzdikkd8.java\t2023-03-24 21:33:07.904560902 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x <Histogram) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "} else if (x > pivot && x < statusCode) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:09.656554318 +0100\n+++ /tmp/tmpyulk3lrx.java\t2023-03-24 21:33:09.656554318 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x < statusCode) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "} else if (x >ByName) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:11.360547914 +0100\n+++ /tmp/tmpe3yv775u.java\t2023-03-24 21:33:11.360547914 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >ByName) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "} else if (x > pivot && x < p) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:13.096541392 +0100\n+++ /tmp/tmpo9_rfd4z.java\t2023-03-24 21:33:13.096541392 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x < p) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "} else if (x > -pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:14.820534910 +0100\n+++ /tmp/tmp0l6wyoir.java\t2023-03-24 21:33:14.820534910 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "} else if (y > x && y < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:18.844519788 +0100\n+++ /tmp/tmphxynluzu.java\t2023-03-24 21:33:18.844519788 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y > x && y < x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "} else if (x > 0 && x < h) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:20.496513578 +0100\n+++ /tmp/tmpash3t4q3.java\t2023-03-24 21:33:20.496513578 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < h) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "} else if (x > -1 && y > -1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:22.220507096 +0100\n+++ /tmp/tmp9wvxih_x.java\t2023-03-24 21:33:22.220507096 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 && y > -1) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "} else if (x > 0 && y < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:23.972500513 +0100\n+++ /tmp/tmphuoemmto.java\t2023-03-24 21:33:23.972500513 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y < j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "} else if (x > pivot && x <protocols) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:25.808493609 +0100\n+++ /tmp/tmpduy82yd0.java\t2023-03-24 21:33:25.808493609 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot && x <protocols) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "} else if (x >Promise) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:27.520487175 +0100\n+++ /tmp/tmpxffoekok.java\t2023-03-24 21:33:27.524487158 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Promise) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "} else if (x > 0 && x < 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:29.328480379 +0100\n+++ /tmp/tmphbbe_474.java\t2023-03-24 21:33:29.328480379 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < 3) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "} else if (x > initialValue) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:33.400465068 +0100\n+++ /tmp/tmpjn26r355.java\t2023-03-24 21:33:33.400465068 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > initialValue) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "} else if (x > 0 && x <pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 21:33:35.100458679 +0100\n+++ /tmp/tmpn8uic66c.java\t2023-03-24 21:33:35.100458679 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x <pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "} else if (x >= pivot) {"
    },
    "depth_first_search": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (node.getName().equals(node.getName())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:13.772989397 +0100\n+++ /tmp/tmpaytppzo5.java\t2023-03-24 21:31:13.844989128 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getName().equals(node.getName())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (node.getRole() == node.Role) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:15.716982106 +0100\n+++ /tmp/tmpa0uj9im1.java\t2023-03-24 21:31:15.716982106 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.Role) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (node.getRole() == node.getRole()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:17.428975687 +0100\n+++ /tmp/tmp29ec60ij.java\t2023-03-24 21:31:17.428975687 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.getRole()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (node.getToken().equals(node.getNode())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:19.120969339 +0100\n+++ /tmp/tmpz9i34k7e.java\t2023-03-24 21:31:19.120969339 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getToken().equals(node.getNode())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (node.getNodeId().equals(node.getNode())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:20.972962392 +0100\n+++ /tmp/tmpgb6_2497.java\t2023-03-24 21:31:20.972962392 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeId().equals(node.getNode())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (node.getRole().equals(node.getRole())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:22.648956106 +0100\n+++ /tmp/tmpgaaorzdk.java\t2023-03-24 21:31:22.648956106 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole().equals(node.getRole())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (node.getRole() == node.Role) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:24.332949790 +0100\n+++ /tmp/tmpjjtxl1x3.java\t2023-03-24 21:31:24.336949774 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.Role) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (!node.is(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:26.188942828 +0100\n+++ /tmp/tmpeuhv940d.java\t2023-03-24 21:31:26.188942828 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.is(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:27.880936480 +0100\n+++ /tmp/tmpc_5s4yd0.java\t2023-03-24 21:31:27.884936464 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (node.getToken().equals(node.getToken())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:29.608929998 +0100\n+++ /tmp/tmpnpd4txed.java\t2023-03-24 21:31:29.608929998 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getToken().equals(node.getToken())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (!node.getRole().equals(node.getRole())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:31.360923423 +0100\n+++ /tmp/tmpdzd1v2au.java\t2023-03-24 21:31:31.360923423 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getRole().equals(node.getRole())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (node.getNode().equals(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:33.132916777 +0100\n+++ /tmp/tmp7cl4ed1g.java\t2023-03-24 21:31:33.132916777 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().equals(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (node.getNodeId().equals(node.getNodeId())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:34.908910112 +0100\n+++ /tmp/tmp526f_051.java\t2023-03-24 21:31:34.908910112 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeId().equals(node.getNodeId())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (node.getNode().is(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:36.828902908 +0100\n+++ /tmp/tmpn0npe391.java\t2023-03-24 21:31:36.828902908 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().is(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (node.getToken().isGeneratedCode()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:38.616896200 +0100\n+++ /tmp/tmptvznckn5.java\t2023-03-24 21:31:38.616896200 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getToken().isGeneratedCode()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (node.getRole() == node.getRole()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:40.404889492 +0100\n+++ /tmp/tmp_st4ca64.java\t2023-03-24 21:31:40.408889476 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.getRole()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (node.getToken().equals(node.getNode())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:42.216882692 +0100\n+++ /tmp/tmp039j6e6w.java\t2023-03-24 21:31:42.216882692 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getToken().equals(node.getNode())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (!node.is(Node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:44.056875785 +0100\n+++ /tmp/tmp04t0611j.java\t2023-03-24 21:31:44.056875785 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.is(Node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (node.getTree().equals(node.getNode())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:45.880868940 +0100\n+++ /tmp/tmpaxi9tdiz.java\t2023-03-24 21:31:45.880868940 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getTree().equals(node.getNode())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (node.getRole() == node.graph) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:47.620862410 +0100\n+++ /tmp/tmp55msq0hp.java\t2023-03-24 21:31:47.620862410 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.graph) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (!node.getToken().equals(node.getNode())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:49.364855868 +0100\n+++ /tmp/tmp91xzu6hc.java\t2023-03-24 21:31:49.364855868 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getToken().equals(node.getNode())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (node.getToken().equals(node.getToken())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:51.152849157 +0100\n+++ /tmp/tmpiql6jxks.java\t2023-03-24 21:31:51.152849157 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getToken().equals(node.getToken())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (!node.equals(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:52.928842491 +0100\n+++ /tmp/tmpjt1ba2e_.java\t2023-03-24 21:31:52.928842491 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.equals(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (node.get nodes().equals(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:57.092826860 +0100\n+++ /tmp/tmpizoh8fdh.java\t2023-03-24 21:31:57.092826860 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.get nodes().equals(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (node.getNode().equals(node.getNode())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:31:58.764820584 +0100\n+++ /tmp/tmpcg61pd6m.java\t2023-03-24 21:31:58.764820584 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().equals(node.getNode())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (node.getRole().equals(node.getRole())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:00.500814070 +0100\n+++ /tmp/tmp_0cng_78.java\t2023-03-24 21:32:00.500814070 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole().equals(node.getRole())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:02.220807613 +0100\n+++ /tmp/tmpt3t5hmab.java\t2023-03-24 21:32:02.220807613 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeType() == Node.TEXT_NODE) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (node.getName().equals(node.getAlias())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:03.976801019 +0100\n+++ /tmp/tmp7rw_ss42.java\t2023-03-24 21:32:03.976801019 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getName().equals(node.getAlias())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (node.getNode() == node) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:05.656794715 +0100\n+++ /tmp/tmpxcozi0g9.java\t2023-03-24 21:32:05.656794715 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (node.getName().equals(node.getName())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:07.404788151 +0100\n+++ /tmp/tmp3xc3kcor.java\t2023-03-24 21:32:07.404788151 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getName().equals(node.getName())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (!node.getRole().equals(node.getRole())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:09.184781469 +0100\n+++ /tmp/tmpypaav3pu.java\t2023-03-24 21:32:09.184781469 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getRole().equals(node.getRole())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (node.getRole().equals(node.getClass())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:11.020774577 +0100\n+++ /tmp/tmp0l0_50jx.java\t2023-03-24 21:32:11.020774577 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole().equals(node.getClass())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (node.getSlots().contains(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:12.848767712 +0100\n+++ /tmp/tmp6c8cz350.java\t2023-03-24 21:32:12.848767712 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getSlots().contains(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (node.getRole() == node) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:14.708760730 +0100\n+++ /tmp/tmpm9njjzsm.java\t2023-03-24 21:32:14.712760713 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (!node.getNode().equals(node.getNode())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:16.476754091 +0100\n+++ /tmp/tmpobc51icv.java\t2023-03-24 21:32:16.480754074 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNode().equals(node.getNode())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (node.getName().equals(node.getNodeId())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:18.220747541 +0100\n+++ /tmp/tmpm5rltxkl.java\t2023-03-24 21:32:18.224747528 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getName().equals(node.getNodeId())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (node.getName().equals(node.name)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:20.012740812 +0100\n+++ /tmp/tmp0ngpm9_5.java\t2023-03-24 21:32:20.012740812 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getName().equals(node.name)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (!node.getNode().is(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:21.720734400 +0100\n+++ /tmp/tmpwkvngyeo.java\t2023-03-24 21:32:21.720734400 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNode().is(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (node.getPlaintext().contains(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:23.516727654 +0100\n+++ /tmp/tmpsmximjnc.java\t2023-03-24 21:32:23.516727654 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getPlaintext().contains(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (node.getNode().is(Node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:25.324720866 +0100\n+++ /tmp/tmp6u7x_beh.java\t2023-03-24 21:32:25.324720866 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().is(Node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (node.getChildNodes().contains(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:27.064714330 +0100\n+++ /tmp/tmp6nv3oc9g.java\t2023-03-24 21:32:27.068714317 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getChildNodes().contains(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (node.getRole() == node.graph) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:28.880707509 +0100\n+++ /tmp/tmpg6xyvxui.java\t2023-03-24 21:32:28.884707496 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.graph) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (node.getNode()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:30.740700524 +0100\n+++ /tmp/tmpjgdar42x.java\t2023-03-24 21:32:30.744700511 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (!node.getName().equals(node.getName())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:32.468694036 +0100\n+++ /tmp/tmpz7ud1vws.java\t2023-03-24 21:32:32.468694036 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getName().equals(node.getName())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (node.getNodes().isEmpty()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:34.276687245 +0100\n+++ /tmp/tmp9fn5jkan.java\t2023-03-24 21:32:34.276687245 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodes().isEmpty()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (node.getRole().equals(node.Role)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:36.036680635 +0100\n+++ /tmp/tmp25c7qder.java\t2023-03-24 21:32:36.036680635 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole().equals(node.Role)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (node.getNode().equals(Node.nodes)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:37.832673887 +0100\n+++ /tmp/tmplimvnb3q.java\t2023-03-24 21:32:37.832673887 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().equals(Node.nodes)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (node.getNode().is(Node.nodes)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:39.636667113 +0100\n+++ /tmp/tmpp778y40n.java\t2023-03-24 21:32:39.636667113 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().is(Node.nodes)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (node.getOpposite(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:41.432660366 +0100\n+++ /tmp/tmp75y8updm.java\t2023-03-24 21:32:41.432660366 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getOpposite(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (!node.getNode().equals(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:43.132653979 +0100\n+++ /tmp/tmp3olppf5h.java\t2023-03-24 21:32:43.140653950 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNode().equals(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (node.getToken().isGeneratedCode()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:44.892647366 +0100\n+++ /tmp/tmpbyn7om28.java\t2023-03-24 21:32:44.892647366 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getToken().isGeneratedCode()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (node.getRole() == node.getRole) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:46.696640589 +0100\n+++ /tmp/tmp_zwa31ab.java\t2023-03-24 21:32:46.696640589 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.getRole) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (node.getAliasInfo().isName(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:48.624633348 +0100\n+++ /tmp/tmpjmhgz26r.java\t2023-03-24 21:32:48.624633348 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getAliasInfo().isName(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (!node.getToken().equals(node.getNode())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:50.384626736 +0100\n+++ /tmp/tmpgmk28i4r.java\t2023-03-24 21:32:50.384626736 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getToken().equals(node.getNode())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:52.212619868 +0100\n+++ /tmp/tmp0acwesei.java\t2023-03-24 21:32:52.212619868 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (!node.getNode().equals(node.getNode())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:53.972613253 +0100\n+++ /tmp/tmp6ms1hzlr.java\t2023-03-24 21:32:53.972613253 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNode().equals(node.getNode())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (!node.getName().equals(node.getName())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:55.740606612 +0100\n+++ /tmp/tmp7aebb1uj.java\t2023-03-24 21:32:55.740606612 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getName().equals(node.getName())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (node.getNodeId().equals(node.getNode())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:57.492600030 +0100\n+++ /tmp/tmp4jqp4fk1.java\t2023-03-24 21:32:57.496600014 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeId().equals(node.getNode())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (!node.getNode().equals(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:32:59.280593311 +0100\n+++ /tmp/tmprqeo9pn9.java\t2023-03-24 21:32:59.280593311 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNode().equals(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (node.getPartitionByNodeId(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:01.072586578 +0100\n+++ /tmp/tmp54ztwp3m.java\t2023-03-24 21:33:01.076586562 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getPartitionByNodeId(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (node.getNode().equals(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:02.912579662 +0100\n+++ /tmp/tmpfug6xfn6.java\t2023-03-24 21:33:02.912579662 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().equals(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (node.getMetadata().isPresent()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:04.684573005 +0100\n+++ /tmp/tmpdblxz8up.java\t2023-03-24 21:33:04.684573005 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getMetadata().isPresent()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (node.getNode()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:06.420566481 +0100\n+++ /tmp/tmp3osrfvsf.java\t2023-03-24 21:33:06.420566481 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (node.getTree().equals(node.getNode())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:08.176559882 +0100\n+++ /tmp/tmp0gb1bagb.java\t2023-03-24 21:33:08.176559882 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getTree().equals(node.getNode())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (!node.getNode().is(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:09.900553403 +0100\n+++ /tmp/tmps252ey9t.java\t2023-03-24 21:33:09.900553403 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNode().is(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (node.getNode().isPresent()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:11.576547105 +0100\n+++ /tmp/tmpejiha8po.java\t2023-03-24 21:33:11.580547089 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().isPresent()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!node.getNode().is(Node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:13.300540625 +0100\n+++ /tmp/tmpdesdv862.java\t2023-03-24 21:33:13.304540610 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNode().is(Node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (node.getNegativeNodes().isEmpty()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:15.028534131 +0100\n+++ /tmp/tmpjldr_x_v.java\t2023-03-24 21:33:15.028534131 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNegativeNodes().isEmpty()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "int successornodes = node.getIncrementors().size();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:16.740527694 +0100\n+++ /tmp/tmp494jxx_t.java\t2023-03-24 21:33:16.744527681 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+int successornodes = node.getIncrementors().size();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (node.getNode().is(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:18.568520826 +0100\n+++ /tmp/tmpkmm07bbm.java\t2023-03-24 21:33:18.568520826 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().is(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (node.getSuccessors().isEmpty()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:20.440513787 +0100\n+++ /tmp/tmpgmvif4fc.java\t2023-03-24 21:33:20.440513787 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getSuccessors().isEmpty()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (!node.is(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:24.452498708 +0100\n+++ /tmp/tmpmf3qvevh.java\t2023-03-24 21:33:24.452498708 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.is(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (node.getRole() == node) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:26.108492483 +0100\n+++ /tmp/tmpoo250jpy.java\t2023-03-24 21:33:26.108492483 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (!node.getNodes().isEmpty()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:27.764486256 +0100\n+++ /tmp/tmpsn_0aw5o.java\t2023-03-24 21:33:27.768486243 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNodes().isEmpty()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (node.getNodeId().equals(node.getNodeId())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:29.520479655 +0100\n+++ /tmp/tmpg3r8838g.java\t2023-03-24 21:33:29.520479655 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeId().equals(node.getNodeId())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (node.getNode().isArray()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:31.276473056 +0100\n+++ /tmp/tmpo7ffgd8s.java\t2023-03-24 21:33:31.276473056 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode().isArray()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (node.getFinished()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:33.096466211 +0100\n+++ /tmp/tmpxc1y3co9.java\t2023-03-24 21:33:33.100466198 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getFinished()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (!node.get nodes().isEmpty()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:34.960459204 +0100\n+++ /tmp/tmpxrr3zsx9.java\t2023-03-24 21:33:34.960459204 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.get nodes().isEmpty()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (node.getFrom()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:36.632452917 +0100\n+++ /tmp/tmpo0_dstwa.java\t2023-03-24 21:33:36.632452917 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getFrom()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (node.getRole() == node.getRole) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:38.444446106 +0100\n+++ /tmp/tmpa4f3wqls.java\t2023-03-24 21:33:38.444446106 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.getRole) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (node.getRole().equals(node.getClass())) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:40.408438722 +0100\n+++ /tmp/tmpuw0qzaaa.java\t2023-03-24 21:33:40.408438722 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole().equals(node.getClass())) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (node.getSlots().isEmpty()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:42.776429818 +0100\n+++ /tmp/tmpi7w2vorh.java\t2023-03-24 21:33:42.776429818 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getSlots().isEmpty()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (!node.is(null)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:44.580423033 +0100\n+++ /tmp/tmpi84syuw0.java\t2023-03-24 21:33:44.580423033 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.is(null)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (node.getNode() == node) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:46.460415964 +0100\n+++ /tmp/tmpny19w05x.java\t2023-03-24 21:33:46.460415964 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (node.getNodeFlag()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:48.244409256 +0100\n+++ /tmp/tmpid8thyd9.java\t2023-03-24 21:33:48.244409256 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeFlag()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (node.getFinished()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:50.080402354 +0100\n+++ /tmp/tmpeu33fvmg.java\t2023-03-24 21:33:50.084402338 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getFinished()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (!node.getNodeIsText()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:51.876395600 +0100\n+++ /tmp/tmp3_4_26_d.java\t2023-03-24 21:33:51.880395584 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.getNodeIsText()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (node.is(Node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:53.664388876 +0100\n+++ /tmp/tmpohhwqzj4.java\t2023-03-24 21:33:53.664388876 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.is(Node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (!node.get nodes().isEmpty()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:55.448382164 +0100\n+++ /tmp/tmpacbqhe6m.java\t2023-03-24 21:33:55.448382164 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.get nodes().isEmpty()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (!node.equals(node)) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:57.228375473 +0100\n+++ /tmp/tmpjv5_whgq.java\t2023-03-24 21:33:57.228375473 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.equals(node)) return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "Boolean successornodes = node.getSuccessors().get(node.getNode());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:33:58.900369184 +0100\n+++ /tmp/tmpx6ian0vi.java\t2023-03-24 21:33:58.900369184 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Boolean successornodes = node.getSuccessors().get(node.getNode());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "int successornodes = node.getIncrementors().size();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:00.796362051 +0100\n+++ /tmp/tmppzjii2d2.java\t2023-03-24 21:34:00.796362051 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+int successornodes = node.getIncrementors().size();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (!node.is(node)) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:02.644355101 +0100\n+++ /tmp/tmpe454qqy9.java\t2023-03-24 21:34:02.644355101 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.is(node)) return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (!(node instanceof Node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:04.292348905 +0100\n+++ /tmp/tmphz2c40yc.java\t2023-03-24 21:34:04.292348905 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!(node instanceof Node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (node.getOrMoreNode()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:08.600332701 +0100\n+++ /tmp/tmpux5s1yks.java\t2023-03-24 21:34:08.600332701 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getOrMoreNode()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (!node.equals(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:10.280326380 +0100\n+++ /tmp/tmpuengtmlb.java\t2023-03-24 21:34:10.280326380 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.equals(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "List<Node> nodes = node.getNodes();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:14.212311589 +0100\n+++ /tmp/tmpm1ojijf2.java\t2023-03-24 21:34:14.212311589 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> nodes = node.getNodes();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (node.getFrom()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:15.920305164 +0100\n+++ /tmp/tmpu0tyu2dp.java\t2023-03-24 21:34:15.924305151 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getFrom()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "List<Node> nodes = new ArrayList<>(node.getNodes());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:17.624298756 +0100\n+++ /tmp/tmp_8zhz_oo.java\t2023-03-24 21:34:17.624298756 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> nodes = new ArrayList<>(node.getNodes());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "List<Node> nodes = node.get nodes();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 21:34:19.360292223 +0100\n+++ /tmp/tmpcwadpdx5.java\t2023-03-24 21:34:19.360292223 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> nodes = node.get nodes();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "nodesvisited.add(node);"
    },
    "rpn_eval": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:33:42.904429337 +0100\n+++ /tmp/tmpud9xkgmk.java\t2023-03-24 21:33:42.920429277 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:33:47.196413196 +0100\n+++ /tmp/tmpy9w2whmh.java\t2023-03-24 21:33:47.200413184 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (bin_op!= null) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:33:51.116398456 +0100\n+++ /tmp/tmp0u_pf2y4.java\t2023-03-24 21:33:51.120398443 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if ( bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:33:52.928391644 +0100\n+++ /tmp/tmp70m1v9bd.java\t2023-03-24 21:33:52.928391644 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (bin_op!=null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:33:57.164375712 +0100\n+++ /tmp/tmpmpig8xy_.java\t2023-03-24 21:33:57.164375712 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!=null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (r_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:01.212360489 +0100\n+++ /tmp/tmp9f1qpmrx.java\t2023-03-24 21:34:01.212360489 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (r_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (bin_op!= null) { c = bin.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:02.956353929 +0100\n+++ /tmp/tmpwpen66is.java\t2023-03-24 21:34:02.956353929 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if(bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:04.692347398 +0100\n+++ /tmp/tmpdkwvn9yj.java\t2023-03-24 21:34:04.692347398 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if(bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if ( bin_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:08.764332082 +0100\n+++ /tmp/tmpqgtuj6k2.java\t2023-03-24 21:34:08.764332082 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (bin_op.isPresent()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:12.760317051 +0100\n+++ /tmp/tmp_lis_62a.java\t2023-03-24 21:34:12.760317051 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isPresent()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (dis_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:14.464310643 +0100\n+++ /tmp/tmp2kw47u3p.java\t2023-03-24 21:34:14.464310643 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (dis_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (neg) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:16.160304263 +0100\n+++ /tmp/tmp22uugwfb.java\t2023-03-24 21:34:16.160304263 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (neg) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (deser!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:17.884297777 +0100\n+++ /tmp/tmpua5yjaqm.java\t2023-03-24 21:34:17.884297777 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (deser!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if ( bin_op!= null) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:19.500291696 +0100\n+++ /tmp/tmpphi8sgp4.java\t2023-03-24 21:34:19.500291696 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (bin_op!=null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:21.176285393 +0100\n+++ /tmp/tmplj4_imrh.java\t2023-03-24 21:34:21.176285393 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!=null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (bin_op!= null) c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:25.540268972 +0100\n+++ /tmp/tmpn44r9uc9.java\t2023-03-24 21:34:25.540268972 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (deser == null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:27.116263043 +0100\n+++ /tmp/tmp28kfwulw.java\t2023-03-24 21:34:27.116263043 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (deser == null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (Bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:28.796256724 +0100\n+++ /tmp/tmpkr27p217.java\t2023-03-24 21:34:28.796256724 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (Bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:30.468250431 +0100\n+++ /tmp/tmpwjk0yhfa.java\t2023-03-24 21:34:30.468250431 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:32.112244247 +0100\n+++ /tmp/tmpbgu2a291.java\t2023-03-24 21:34:32.112244247 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:36.164229001 +0100\n+++ /tmp/tmpmbudn7_d.java\t2023-03-24 21:34:36.164229001 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (r_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:40.156213978 +0100\n+++ /tmp/tmp97zuwa8s.java\t2023-03-24 21:34:40.156213978 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (r_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if ( bin_op!=null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:41.812207745 +0100\n+++ /tmp/tmptlglpmpu.java\t2023-03-24 21:34:41.812207745 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!=null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (bin_op!= null) c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:45.640193342 +0100\n+++ /tmp/tmpjv8pqhn3.java\t2023-03-24 21:34:45.640193342 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (lack_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:47.216187410 +0100\n+++ /tmp/tmpk7qnc3hd.java\t2023-03-24 21:34:47.216187410 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (lack_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (issue_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:48.892181103 +0100\n+++ /tmp/tmpon7qkapm.java\t2023-03-24 21:34:48.892181103 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (issue_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (r_op!=null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:50.572174778 +0100\n+++ /tmp/tmp02116bui.java\t2023-03-24 21:34:50.572174778 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (r_op!=null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (bin_op!= null) { c = bin_.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:52.212168608 +0100\n+++ /tmp/tmpkpuwvc4x.java\t2023-03-24 21:34:52.212168608 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if ( bin_op!= 0.0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:53.884162315 +0100\n+++ /tmp/tmpu2crv58g.java\t2023-03-24 21:34:53.884162315 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= 0.0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (orders_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:55.576155945 +0100\n+++ /tmp/tmpl0m_3b11.java\t2023-03-24 21:34:55.576155945 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (orders_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (!bin_op.isEmpty()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:57.204149817 +0100\n+++ /tmp/tmp5ptqosk5.java\t2023-03-24 21:34:57.204149817 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (!bin_op.isEmpty()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (spec_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:34:58.964143193 +0100\n+++ /tmp/tmp_4e1hgk7.java\t2023-03-24 21:34:58.964143193 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (spec_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (skew_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:00.680136736 +0100\n+++ /tmp/tmp3yjiutpk.java\t2023-03-24 21:35:00.680136736 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (skew_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (null!= bin_op) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:02.340130485 +0100\n+++ /tmp/tmp4x4qzfqj.java\t2023-03-24 21:35:02.340130485 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (null!= bin_op) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (bin_op!= 0.0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:06.124116241 +0100\n+++ /tmp/tmpovb_wkea.java\t2023-03-24 21:35:06.124116241 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= 0.0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (co_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:07.724110220 +0100\n+++ /tmp/tmp873wn6h7.java\t2023-03-24 21:35:07.724110220 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (co_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if(bin_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:09.376104002 +0100\n+++ /tmp/tmpgv6rntbb.java\t2023-03-24 21:35:09.380103986 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if(bin_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if ( doc_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:13.088090025 +0100\n+++ /tmp/tmp38lsaj5s.java\t2023-03-24 21:35:13.088090025 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( doc_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (but_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:14.720083883 +0100\n+++ /tmp/tmp21vaxh0t.java\t2023-03-24 21:35:14.720083883 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (but_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (Arithmetic_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:16.336077800 +0100\n+++ /tmp/tmpk13qmmfa.java\t2023-03-24 21:35:16.340077784 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (Arithmetic_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (bin_op!= null) { c = binRequestop.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:20.876060705 +0100\n+++ /tmp/tmpdu3xa0f_.java\t2023-03-24 21:35:20.876060705 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = binRequestop.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (bin_op!=null) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:30.172025705 +0100\n+++ /tmp/tmpbygp17g2.java\t2023-03-24 21:35:30.180025676 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!=null) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (!(bin_op instanceof Double)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:39.187991755 +0100\n+++ /tmp/tmppqzjnmc4.java\t2023-03-24 21:35:39.187991755 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (!(bin_op instanceof Double)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (bin_op == null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:35:48.467956806 +0100\n+++ /tmp/tmpbwuenpc_.java\t2023-03-24 21:35:48.467956806 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op == null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (ry_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:36:10.063875458 +0100\n+++ /tmp/tmppbck2738.java\t2023-03-24 21:36:10.063875458 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (ry_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (POSITION_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:36:19.535839776 +0100\n+++ /tmp/tmpj2q4tas1.java\t2023-03-24 21:36:19.535839776 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (POSITION_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (binRequestop!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:36:28.451806181 +0100\n+++ /tmp/tmpgl1z0u_v.java\t2023-03-24 21:36:28.451806181 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (binRequestop!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (timestamp!= bin_op) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:36:36.835774591 +0100\n+++ /tmp/tmpns2y4__7.java\t2023-03-24 21:36:36.835774591 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (timestamp!= bin_op) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (timestamp == bin_op) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:36:45.687741231 +0100\n+++ /tmp/tmpcjwbve8b.java\t2023-03-24 21:36:45.687741231 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (timestamp == bin_op) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (diff!= 0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:36:53.979709982 +0100\n+++ /tmp/tmp1ndz9pq_.java\t2023-03-24 21:36:53.979709982 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (diff!= 0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (visitor_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:02.231678880 +0100\n+++ /tmp/tmpw_gl2tis.java\t2023-03-24 21:37:02.231678880 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (visitor_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (our_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:10.115649162 +0100\n+++ /tmp/tmp8o2y6gre.java\t2023-03-24 21:37:10.115649162 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (our_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (rr_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:17.835620061 +0100\n+++ /tmp/tmptw8uedbl.java\t2023-03-24 21:37:17.835620061 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (rr_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (bin_op.isEmpty()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:24.919593353 +0100\n+++ /tmp/tmpxd3t5z_h.java\t2023-03-24 21:37:24.919593353 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isEmpty()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (dis_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:31.923566948 +0100\n+++ /tmp/tmpwc6aqrka.java\t2023-03-24 21:37:31.923566948 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (dis_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (where_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:38.527542049 +0100\n+++ /tmp/tmpiflujvxh.java\t2023-03-24 21:37:38.527542049 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (where_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if(bin_op!=null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:44.819518323 +0100\n+++ /tmp/tmpin1dz3gm.java\t2023-03-24 21:37:44.819518323 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if(bin_op!=null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (serializer.equals(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:37:59.703462193 +0100\n+++ /tmp/tmp4golll7s.java\t2023-03-24 21:37:59.703462193 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (serializer.equals(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (r_op!= null) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:05.819439129 +0100\n+++ /tmp/tmp18uheeoa.java\t2023-03-24 21:38:05.819439129 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (r_op!= null) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (OAuth_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:11.655417117 +0100\n+++ /tmp/tmp5h1mh1_l.java\t2023-03-24 21:38:11.655417117 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (OAuth_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (bin_op.isPresent()) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:17.123396495 +0100\n+++ /tmp/tmpe2bk3kzn.java\t2023-03-24 21:38:17.123396495 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isPresent()) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (PAGE_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:23.087373999 +0100\n+++ /tmp/tmpi113cria.java\t2023-03-24 21:38:23.087373999 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (PAGE_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (bin/op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:28.847352269 +0100\n+++ /tmp/tmpdra5h7tb.java\t2023-03-24 21:38:28.847352269 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin/op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (ur_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:34.419331252 +0100\n+++ /tmp/tmpm2x2jhub.java\t2023-03-24 21:38:34.427331222 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (ur_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (bin_op!= null) { c = bin bin.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:40.143309656 +0100\n+++ /tmp/tmpc69z_avk.java\t2023-03-24 21:38:40.143309656 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin bin.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (Bin_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:45.439289679 +0100\n+++ /tmp/tmpeinfzgeh.java\t2023-03-24 21:38:45.439289679 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (Bin_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if(bin_op!= null) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:50.679269907 +0100\n+++ /tmp/tmp3t_rvtym.java\t2023-03-24 21:38:50.695269849 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if(bin_op!= null) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (bin-op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:38:56.531247827 +0100\n+++ /tmp/tmp3e89li3w.java\t2023-03-24 21:38:56.531247827 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin-op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (63_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:01.531228961 +0100\n+++ /tmp/tmpke4dvprj.java\t2023-03-24 21:39:01.531228961 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (63_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (if_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:06.027211999 +0100\n+++ /tmp/tmp8fcdfav0.java\t2023-03-24 21:39:06.027211999 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (if_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (bin_op!= null) { c = bin.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:10.655194536 +0100\n+++ /tmp/tmps02fukib.java\t2023-03-24 21:39:10.655194536 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (bin_.isPresent()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:14.415180345 +0100\n+++ /tmp/tmpqrcd5kba.java\t2023-03-24 21:39:14.419180332 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_.isPresent()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (dis_op!= null) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:18.727164075 +0100\n+++ /tmp/tmp7qggfn3k.java\t2023-03-24 21:39:18.727164075 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (dis_op!= null) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (INTEGER_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:22.283150653 +0100\n+++ /tmp/tmpp5agl7ni.java\t2023-03-24 21:39:22.283150653 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (INTEGER_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if ( dis_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:26.131136131 +0100\n+++ /tmp/tmppw2td9i2.java\t2023-03-24 21:39:26.131136131 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( dis_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:30.075121248 +0100\n+++ /tmp/tmpdacxxd0c.java\t2023-03-24 21:39:30.075121248 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if ( bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:37.759092248 +0100\n+++ /tmp/tmpr0g2taai.java\t2023-03-24 21:39:37.763092231 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (bin_.isNaN()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:43.991068726 +0100\n+++ /tmp/tmpq5qgce5o.java\t2023-03-24 21:39:43.991068726 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_.isNaN()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (log!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:46.371059743 +0100\n+++ /tmp/tmp2tp3q5in.java\t2023-03-24 21:39:46.371059743 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (log!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (initialValue!= 0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:48.739050802 +0100\n+++ /tmp/tmpznrfwqi3.java\t2023-03-24 21:39:48.739050802 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (initialValue!= 0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (boolean) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:50.999042275 +0100\n+++ /tmp/tmppsg9rlv4.java\t2023-03-24 21:39:50.999042275 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (boolean) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (bin_.isEmpty()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:53.115034284 +0100\n+++ /tmp/tmpe041bnin.java\t2023-03-24 21:39:53.115034284 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_.isEmpty()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (neg) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:55.291026074 +0100\n+++ /tmp/tmp6ziyfjts.java\t2023-03-24 21:39:55.291026074 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (neg) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (bin_op!= null){ c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:39:57.355018280 +0100\n+++ /tmp/tmpg71twryh.java\t2023-03-24 21:39:57.355018280 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null){ c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (deserializer!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:02.270999722 +0100\n+++ /tmp/tmpfd9zh61o.java\t2023-03-24 21:40:02.274999710 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (deserializer!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if ( bin_op!= null) { c = bin.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:04.346991888 +0100\n+++ /tmp/tmp6yd85bji.java\t2023-03-24 21:40:04.346991888 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (bin_.isNumeric()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:06.366984260 +0100\n+++ /tmp/tmpugfixdhr.java\t2023-03-24 21:40:06.366984260 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_.isNumeric()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (bin_op!= null) { c = bin_.apply(a,b); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:08.478976289 +0100\n+++ /tmp/tmp08zjgvu2.java\t2023-03-24 21:40:08.478976289 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_.apply(a,b); } }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (deser!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:10.478968737 +0100\n+++ /tmp/tmpt17__xan.java\t2023-03-24 21:40:10.478968737 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (deser!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (dec!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:12.558960887 +0100\n+++ /tmp/tmp_atsm1za.java\t2023-03-24 21:40:12.558960887 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (dec!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a, b); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:14.618953110 +0100\n+++ /tmp/tmp7ulbwu2r.java\t2023-03-24 21:40:14.618953110 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a, b); } }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if ( bin_op!= null) { c = bin_op.apply(a,b); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:16.534945874 +0100\n+++ /tmp/tmpw6rwxk9f.java\t2023-03-24 21:40:16.534945874 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin_op.apply(a,b); } }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (deser!= null) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:18.478938537 +0100\n+++ /tmp/tmptr0pa9k4.java\t2023-03-24 21:40:18.478938537 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (deser!= null) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (li == 0.0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:20.570930640 +0100\n+++ /tmp/tmpzc1f8a1d.java\t2023-03-24 21:40:20.574930624 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (li == 0.0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if ( false) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:22.694922620 +0100\n+++ /tmp/tmpbewitik3.java\t2023-03-24 21:40:22.698922602 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( false) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (bin_op!= null) c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:27.246905431 +0100\n+++ /tmp/tmpziy4qard.java\t2023-03-24 21:40:27.246905431 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (nonZero) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:29.006898789 +0100\n+++ /tmp/tmpv2s2bxy9.java\t2023-03-24 21:40:29.006898789 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (nonZero) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (dirty) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:31.062891027 +0100\n+++ /tmp/tmpp4ing06v.java\t2023-03-24 21:40:31.062891027 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (dirty) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:33.026883611 +0100\n+++ /tmp/tmpzl40ycfl.java\t2023-03-24 21:40:33.030883593 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (neg) { c = bin_.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 21:40:37.498866736 +0100\n+++ /tmp/tmp764td0wf.java\t2023-03-24 21:40:37.498866736 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (neg) { c = bin_.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "c = bin_op.apply(b,a);"
    },
    "bucketsort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:24.532272767 +0100\n+++ /tmp/tmpt0dtep1a.java\t2023-03-24 21:34:24.580272584 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:28.404258197 +0100\n+++ /tmp/tmp0glle9na.java\t2023-03-24 21:34:28.404258197 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:32.324243448 +0100\n+++ /tmp/tmp8tco619z.java\t2023-03-24 21:34:32.324243448 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i > 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:36.116229181 +0100\n+++ /tmp/tmp43hfudjj.java\t2023-03-24 21:34:36.116229181 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i == 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version i++;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:40.144214024 +0100\n+++ /tmp/tmp6_m3acri.java\t2023-03-24 21:34:40.144214024 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version i++;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:43.876199980 +0100\n+++ /tmp/tmp5k_n8kl_.java\t2023-03-24 21:34:43.876199980 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i >= 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:47.780185286 +0100\n+++ /tmp/tmp1j86rwfn.java\t2023-03-24 21:34:47.784185273 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "for (Integer count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:51.408171634 +0100\n+++ /tmp/tmpdsblu1_b.java\t2023-03-24 21:34:51.408171634 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i >= len)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:55.260157136 +0100\n+++ /tmp/tmp2e596d5o.java\t2023-03-24 21:34:55.260157136 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i >= len)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "for (int count : arr) { // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:34:59.056142846 +0100\n+++ /tmp/tmps_abjv2f.java\t2023-03-24 21:34:59.056142846 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version x.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:35:02.788128799 +0100\n+++ /tmp/tmpnxlzzfwp.java\t2023-03-24 21:35:02.788128799 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version x.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version from fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:35:06.636114314 +0100\n+++ /tmp/tmp9cdnty_p.java\t2023-03-24 21:35:06.636114314 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version from fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version name",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:35:10.312100478 +0100\n+++ /tmp/tmprc78mqv0.java\t2023-03-24 21:35:10.324100432 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version name\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (count > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:35:14.256085631 +0100\n+++ /tmp/tmpv2x9b3xc.java\t2023-03-24 21:35:14.256085631 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (count > 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:35:20.224063160 +0100\n+++ /tmp/tmp3dy0yug8.java\t2023-03-24 21:35:20.224063160 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:35:42.763978286 +0100\n+++ /tmp/tmpb1qt54oq.java\t2023-03-24 21:35:42.763978286 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i!= 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:36:04.063898062 +0100\n+++ /tmp/tmpsrwi0182.java\t2023-03-24 21:36:04.063898062 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:36:24.739820167 +0100\n+++ /tmp/tmptzodnnln.java\t2023-03-24 21:36:24.739820167 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version of counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:36:44.751744758 +0100\n+++ /tmp/tmpp1tt6uyi.java\t2023-03-24 21:36:44.751744758 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version of counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "for (int count : arr) { // arr is counts in fixed version.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:37:04.179671537 +0100\n+++ /tmp/tmp5tpgo__v.java\t2023-03-24 21:37:04.179671537 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { // arr is counts in fixed version.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version i = 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:37:21.963604499 +0100\n+++ /tmp/tmptl3bti_a.java\t2023-03-24 21:37:21.963604499 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version i = 0;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version of counts.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:37:38.735541264 +0100\n+++ /tmp/tmptw9nt_t7.java\t2023-03-24 21:37:38.735541264 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version of counts.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version number",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:37:53.135486962 +0100\n+++ /tmp/tmphbjdqqp4.java\t2023-03-24 21:37:53.135486962 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version number\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version value",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:38:07.087434345 +0100\n+++ /tmp/tmp57ppt9tk.java\t2023-03-24 21:38:07.087434345 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version value\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "for (int count : arr) { // arr is counts in fixed version if (i > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:38:21.103381483 +0100\n+++ /tmp/tmph091rriz.java\t2023-03-24 21:38:21.103381483 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { // arr is counts in fixed version if (i > 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i >= buffer",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:38:34.543330785 +0100\n+++ /tmp/tmp_wwvoepu.java\t2023-03-24 21:38:34.543330785 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i >= buffer\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i == len)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:38:47.807280745 +0100\n+++ /tmp/tmp9llm37nz.java\t2023-03-24 21:38:47.807280745 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i == len)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i == 0)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:38:59.531236510 +0100\n+++ /tmp/tmphdwbm8yu.java\t2023-03-24 21:38:59.531236510 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i == 0)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version try {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:10.571194853 +0100\n+++ /tmp/tmpffl3hw7h.java\t2023-03-24 21:39:10.571194853 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version try {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version x.increment();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:19.151162475 +0100\n+++ /tmp/tmp6xg13r6u.java\t2023-03-24 21:39:19.151162475 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version x.increment();\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version at fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:27.743130047 +0100\n+++ /tmp/tmpjf6lv1x5.java\t2023-03-24 21:39:27.747130035 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version at fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i > 0)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:36.503096989 +0100\n+++ /tmp/tmp6s101wfc.java\t2023-03-24 21:39:36.507096973 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i > 0)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i >= count)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:43.227071607 +0100\n+++ /tmp/tmprr7wj4_0.java\t2023-03-24 21:39:43.227071607 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i >= count)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i >= max)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:48.667051077 +0100\n+++ /tmp/tmp0pj83pbp.java\t2023-03-24 21:39:48.671051061 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i >= max)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i >= n)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:53.571032564 +0100\n+++ /tmp/tmphfho7pm4.java\t2023-03-24 21:39:53.571032564 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i >= n)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:39:58.515013901 +0100\n+++ /tmp/tmph1607trk.java\t2023-03-24 21:39:58.515013901 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "for (int count : arr) { // arr is counts in fixed version if (i == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:03.386995512 +0100\n+++ /tmp/tmp0a_gyhnn.java\t2023-03-24 21:40:03.386995512 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { // arr is counts in fixed version if (i == 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version get fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:08.402976576 +0100\n+++ /tmp/tmpslr3x_4_.java\t2023-03-24 21:40:08.402976576 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version get fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version if (i >= 0)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:13.142958682 +0100\n+++ /tmp/tmpeivzegft.java\t2023-03-24 21:40:13.142958682 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version if (i >= 0)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version, in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:18.122939882 +0100\n+++ /tmp/tmp9psn8r6x.java\t2023-03-24 21:40:18.126939866 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version, in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version index",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:22.766922348 +0100\n+++ /tmp/tmp64gcq89m.java\t2023-03-24 21:40:22.766922348 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version index\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version field.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:27.374904948 +0100\n+++ /tmp/tmp73yhlqct.java\t2023-03-24 21:40:27.374904948 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version field.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version to fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:31.730888504 +0100\n+++ /tmp/tmpnayrurdz.java\t2023-03-24 21:40:31.734888486 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version to fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version, so:",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:36.534870365 +0100\n+++ /tmp/tmpfov8962e.java\t2023-03-24 21:40:36.534870365 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version, so:\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version prefix",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:41.534851496 +0100\n+++ /tmp/tmpw6couqk1.java\t2023-03-24 21:40:41.534851496 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version prefix\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version?",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:47.238829957 +0100\n+++ /tmp/tmp9ko2bfrh.java\t2023-03-24 21:40:47.238829957 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version?\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version i += 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:51.710813072 +0100\n+++ /tmp/tmp6wbh4_2q.java\t2023-03-24 21:40:51.710813072 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version i += 1;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version:",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:40:55.818797559 +0100\n+++ /tmp/tmpkx4t_abs.java\t2023-03-24 21:40:55.818797559 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version:\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version result",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:00.034781638 +0100\n+++ /tmp/tmpw1muwr48.java\t2023-03-24 21:41:00.034781638 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version result\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version boolean",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:04.070766396 +0100\n+++ /tmp/tmpq95xttvy.java\t2023-03-24 21:41:04.070766396 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version boolean\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version...",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:08.034751426 +0100\n+++ /tmp/tmp5qnxji4_.java\t2023-03-24 21:41:08.034751426 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version...\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:12.150735882 +0100\n+++ /tmp/tmpxfslz125.java\t2023-03-24 21:41:12.150735882 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version } }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:16.374719927 +0100\n+++ /tmp/tmpwblzo5kx.java\t2023-03-24 21:41:16.374719927 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version break; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version x x.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:20.314705048 +0100\n+++ /tmp/tmpmli2fs_n.java\t2023-03-24 21:41:20.326705003 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version x x.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:24.518689169 +0100\n+++ /tmp/tmp527orl1x.java\t2023-03-24 21:41:24.518689169 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version continue; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "for (int count : arr) { // arr is counts in fixed version i++;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:28.570673865 +0100\n+++ /tmp/tmpcfe9dex1.java\t2023-03-24 21:41:28.570673865 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { // arr is counts in fixed version i++;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version).",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:32.502659014 +0100\n+++ /tmp/tmp3xznsq2x.java\t2023-03-24 21:41:32.502659014 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version).\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:36.506643889 +0100\n+++ /tmp/tmpyosw4vzl.java\t2023-03-24 21:41:36.510643875 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version();\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version return i;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:40.586628478 +0100\n+++ /tmp/tmpdl92hgvb.java\t2023-03-24 21:41:40.586628478 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version return i;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:44.742612779 +0100\n+++ /tmp/tmpevh8q8pf.java\t2023-03-24 21:41:44.742612779 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version = true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:48.926596976 +0100\n+++ /tmp/tmpnbnuxgy4.java\t2023-03-24 21:41:48.926596976 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version = true;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version 7",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:53.006581563 +0100\n+++ /tmp/tmp80udwnb9.java\t2023-03-24 21:41:53.010581549 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version 7\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version index += 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:41:57.114566044 +0100\n+++ /tmp/tmp3ewlhwfc.java\t2023-03-24 21:41:57.118566029 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version index += 1;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "for (Integer count : arr) { for (Integer count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:01.102550980 +0100\n+++ /tmp/tmpcunxrwwk.java\t2023-03-24 21:42:01.102550980 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { for (Integer count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version values.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:02.802544556 +0100\n+++ /tmp/tmpfihftgu6.java\t2023-03-24 21:42:02.802544556 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version values.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version String",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:06.774529551 +0100\n+++ /tmp/tmpsh4oyhpk.java\t2023-03-24 21:42:06.774529551 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version String\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version x = 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:10.874514063 +0100\n+++ /tmp/tmp9csse2oe.java\t2023-03-24 21:42:10.874514063 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version x = 0;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "for (int count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:14.954498648 +0100\n+++ /tmp/tmpezfzd9gr.java\t2023-03-24 21:42:14.954498648 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version().",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:19.090483021 +0100\n+++ /tmp/tmp1qndb73h.java\t2023-03-24 21:42:19.090483021 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version().\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version */",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:23.102467863 +0100\n+++ /tmp/tmp3wotka6e.java\t2023-03-24 21:42:23.102467863 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version */\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version ) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:27.198452389 +0100\n+++ /tmp/tmpmbkhkll0.java\t2023-03-24 21:42:27.198452389 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version ) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version set.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:31.250437079 +0100\n+++ /tmp/tmpubnmkh3m.java\t2023-03-24 21:42:31.250437079 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version set.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version key",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:35.526420921 +0100\n+++ /tmp/tmp8hcyafq6.java\t2023-03-24 21:42:35.526420921 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version key\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version\")",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:39.558405687 +0100\n+++ /tmp/tmp8talsoro.java\t2023-03-24 21:42:39.558405687 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version\")\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version continue;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:43.750389846 +0100\n+++ /tmp/tmp0rwyo0jo.java\t2023-03-24 21:42:43.750389846 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version continue;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:47.810374507 +0100\n+++ /tmp/tmp0_jlsudg.java\t2023-03-24 21:42:47.810374507 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version offset",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:51.938358908 +0100\n+++ /tmp/tmp70aymrj3.java\t2023-03-24 21:42:51.938358908 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version offset\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version count++;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:42:57.322338563 +0100\n+++ /tmp/tmp7y82fsvg.java\t2023-03-24 21:42:57.322338563 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version count++;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "for (Integer count : arr) { // arr is counts in fixed version int",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:02.150320317 +0100\n+++ /tmp/tmplvpciq0v.java\t2023-03-24 21:43:02.150320317 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { // arr is counts in fixed version int\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "for (Integer count : arr) {// arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:07.278300938 +0100\n+++ /tmp/tmp4nwf76bt.java\t2023-03-24 21:43:07.282300925 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) {// arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "for (int count : arr) { // arr is counts in fixed version x.",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:12.350281772 +0100\n+++ /tmp/tmpfm8o4wh1.java\t2023-03-24 21:43:12.350281772 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { // arr is counts in fixed version x.\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "for(Integer count : arr) { // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:17.882260865 +0100\n+++ /tmp/tmpaekdxffo.java\t2023-03-24 21:43:17.882260865 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for(Integer count : arr) { // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "for (Integer count : arr){ // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:22.606243011 +0100\n+++ /tmp/tmpbx_hcqwm.java\t2023-03-24 21:43:22.606243011 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr){ // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "for (int count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:28.350221302 +0100\n+++ /tmp/tmp75drm6bk.java\t2023-03-24 21:43:28.354221289 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "for (Integer count : arr) { int count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:34.130199457 +0100\n+++ /tmp/tmptgva20qo.java\t2023-03-24 21:43:34.130199457 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { int count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "for (Integer count : arr) { i++;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:36.562190266 +0100\n+++ /tmp/tmpmz8nzcln.java\t2023-03-24 21:43:36.566190250 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { i++;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "for (Integer count : arr) { if (i >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:42.266168708 +0100\n+++ /tmp/tmpg0lejnrx.java\t2023-03-24 21:43:42.266168708 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { if (i >= 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "for (Integer count : arr) { if (i >= len)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:44.182161465 +0100\n+++ /tmp/tmpjukc24n1.java\t2023-03-24 21:43:44.182161465 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { if (i >= len)\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "for (int count : arr){ // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:46.482152771 +0100\n+++ /tmp/tmpl1b35de9.java\t2023-03-24 21:43:46.482152771 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr){ // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "for (Integer count : arr) { is is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:51.698133056 +0100\n+++ /tmp/tmpwexdtxu1.java\t2023-03-24 21:43:51.746132874 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { is is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "for (Integer count : arr) { if (i > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:54.094124000 +0100\n+++ /tmp/tmpqq_iqjjg.java\t2023-03-24 21:43:54.094124000 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { if (i > 0) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "for (Integer count : arr) { long count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:56.078116500 +0100\n+++ /tmp/tmpmmyhyuzi.java\t2023-03-24 21:43:56.158116199 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { long count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "for (Integer count : arr) { i = x.next();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:43:58.634106839 +0100\n+++ /tmp/tmp9d626aje.java\t2023-03-24 21:43:58.634106839 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { i = x.next();\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "for (Integer count : arr) { is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:44:00.766098781 +0100\n+++ /tmp/tmpcrarun_5.java\t2023-03-24 21:44:00.922098191 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "for (Integer count : arr) { i += count;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:44:02.874090811 +0100\n+++ /tmp/tmpx5n76ejv.java\t2023-03-24 21:44:03.034090208 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { i += count;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "for (Integer count : arr) { i = 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:44:08.430069810 +0100\n+++ /tmp/tmpghg51iec.java\t2023-03-24 21:44:08.430069810 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { i = 0;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "for (Integer count : arr) { return i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:44:13.450050834 +0100\n+++ /tmp/tmpf8elmr6r.java\t2023-03-24 21:44:13.454050819 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { return i; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "for (Integer count : arr) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:44:15.554042881 +0100\n+++ /tmp/tmp2dn9n_ak.java\t2023-03-24 21:44:15.554042881 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "for (Integer count : arr) { do {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:44:17.354036076 +0100\n+++ /tmp/tmpyoo4c2z0.java\t2023-03-24 21:44:17.562035290 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr) { do {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "for (int count : arr) { i++;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 21:44:19.718027138 +0100\n+++ /tmp/tmp5zo0_0zd.java\t2023-03-24 21:44:19.846026655 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr) { i++;\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (Integer count : counts) {"
    },
    "levenshtein": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (source.charAt(0) == '/' || source.charAt(target.length() - 1) == '/') return 1 + target.substring(1) + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:45.894835032 +0100\n+++ /tmp/tmpd65yzkp_.java\t2023-03-24 21:40:45.962834777 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || source.charAt(target.length() - 1) == '/') return 1 + target.substring(1) + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (source.charAt(0) == '/' || target.charAt(target.length() - 1) == '/') return 1 + target.substring(1) + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:47.902827450 +0100\n+++ /tmp/tmpkwr3_l07.java\t2023-03-24 21:40:47.902827450 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || target.charAt(target.length() - 1) == '/') return 1 + target.substring(1) + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:49.758820442 +0100\n+++ /tmp/tmpusb4pjls.java\t2023-03-24 21:40:49.770820397 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "return 1 + target.substring(1), target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:51.698813117 +0100\n+++ /tmp/tmp1b36ac0b.java\t2023-03-24 21:40:51.698813117 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1), target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:53.394806711 +0100\n+++ /tmp/tmplm00zhl8.java\t2023-03-24 21:40:53.394806711 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:55.170800004 +0100\n+++ /tmp/tmp4lhl9rzl.java\t2023-03-24 21:40:55.170800004 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (source.charAt(0) == '/' || target.charAt(source.charAt(1) == '\\\\') && target.charAt(1); return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:56.858793630 +0100\n+++ /tmp/tmps8z4169d.java\t2023-03-24 21:40:56.858793630 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || target.charAt(source.charAt(1) == '\\\\') && target.charAt(1); return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (source.charAt(0) == '/' || source.charAt(target.length() - 1) == '/') return 1 + target.substring(1) + source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:40:58.550787242 +0100\n+++ /tmp/tmpowx61nai.java\t2023-03-24 21:40:58.550787242 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || source.charAt(target.length() - 1) == '/') return 1 + target.substring(1) + source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)!= target.substring(1); return target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:00.298780640 +0100\n+++ /tmp/tmptfxvoyb9.java\t2023-03-24 21:41:00.298780640 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)!= target.substring(1); return target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (source.charAt(0) == '/' || target.charAt(source.length() - 1) == '/') return 1 + target.substring(1) + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:01.958774371 +0100\n+++ /tmp/tmput_ckl_j.java\t2023-03-24 21:41:01.958774371 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || target.charAt(source.length() - 1) == '/') return 1 + target.substring(1) + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (source.charAt(0) == '/' || source.charAt(target.length() - 1) == '/') return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:03.778767497 +0100\n+++ /tmp/tmpzf2549sj.java\t2023-03-24 21:41:03.778767497 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || source.charAt(target.length() - 1) == '/') return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)!= target.substring(1); return target.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:05.538760852 +0100\n+++ /tmp/tmp8qfxciwm.java\t2023-03-24 21:41:05.538760852 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)!= target.substring(1); return target.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:07.258754357 +0100\n+++ /tmp/tmpx8xt9hc6.java\t2023-03-24 21:41:07.258754357 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (source.charAt(0) == '/' || target.charAt(target.length() - 1) == '/') return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:09.026747680 +0100\n+++ /tmp/tmpgu126f4o.java\t2023-03-24 21:41:09.030747664 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || target.charAt(target.length() - 1) == '/') return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= '/') return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:10.726741258 +0100\n+++ /tmp/tmpb9oo_qt2.java\t2023-03-24 21:41:10.726741258 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= '/') return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return target.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:12.370735050 +0100\n+++ /tmp/tmp2982abk2.java\t2023-03-24 21:41:12.370735050 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return target.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "return 1 + target.substring(1) + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:14.038728751 +0100\n+++ /tmp/tmpin5mfy62.java\t2023-03-24 21:41:14.038728751 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (source.charAt(0) == '/' || target.charAt(source.charAt(1) == '\\\\') && target.charAt(1); else return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:15.802722088 +0100\n+++ /tmp/tmpnsfk9k_z.java\t2023-03-24 21:41:15.802722088 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || target.charAt(source.charAt(1) == '\\\\') && target.charAt(1); else return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:17.578715381 +0100\n+++ /tmp/tmpw8__wlop.java\t2023-03-24 21:41:17.582715365 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0)!= '/' || source.charAt(target.length() - 1)!= target.substring(1)); return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (source.charAt(0) == '/' || target.charAt(source.length() - 1) == '/') return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:19.370708613 +0100\n+++ /tmp/tmpd22_w8my.java\t2023-03-24 21:41:19.370708613 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/' || target.charAt(source.length() - 1) == '/') return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (source.charAt(0) == '\"' && target.charAt(target.length() - 1) == '/') return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:21.122701995 +0100\n+++ /tmp/tmpjvulo6r3.java\t2023-03-24 21:41:21.122701995 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\"' && target.charAt(target.length() - 1) == '/') return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "return 1 + source.substring(1) + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:22.822695575 +0100\n+++ /tmp/tmp2nfyxtne.java\t2023-03-24 21:41:22.822695575 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1) + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "return 1 + source.substring(1), target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:24.598688866 +0100\n+++ /tmp/tmpfyk4nqh3.java\t2023-03-24 21:41:24.598688866 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1), target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "return 1 + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:26.254682613 +0100\n+++ /tmp/tmppgbwyf82.java\t2023-03-24 21:41:26.254682613 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "return 1 + source.substring(1) - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:28.066675768 +0100\n+++ /tmp/tmparml62dg.java\t2023-03-24 21:41:28.066675768 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1) - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "return 1 + target.substring(1) + source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:29.878668924 +0100\n+++ /tmp/tmphwj7hp64.java\t2023-03-24 21:41:29.878668924 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) + source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "return 1 + target.substring(1 + target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:31.710662006 +0100\n+++ /tmp/tmpx8oyltkg.java\t2023-03-24 21:41:31.710662006 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1 + target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "return (1 + target.substring(1), target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:33.478655327 +0100\n+++ /tmp/tmpotvh2nmu.java\t2023-03-24 21:41:33.478655327 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return (1 + target.substring(1), target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "return 1 + target.substring(1) + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:35.246648650 +0100\n+++ /tmp/tmpaq74tqsf.java\t2023-03-24 21:41:35.250648634 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "return 1 + source.substring(1) + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:37.070641759 +0100\n+++ /tmp/tmpoayd48x6.java\t2023-03-24 21:41:37.070641759 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1) + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "return 1 + target.substring(1 + target.substring(1) + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:38.794635248 +0100\n+++ /tmp/tmp4yl2mvv4.java\t2023-03-24 21:41:38.794635248 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1 + target.substring(1) + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "return 1 + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:40.574628523 +0100\n+++ /tmp/tmpwkgn30lp.java\t2023-03-24 21:41:40.578628509 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "return 1 + target.substring(1) - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:42.442621468 +0100\n+++ /tmp/tmpvas6gu2n.java\t2023-03-24 21:41:42.442621468 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "return 1 + target.length();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:44.238614684 +0100\n+++ /tmp/tmp5vadioe6.java\t2023-03-24 21:41:44.242614668 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length();\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "return 1 + target.substring(1), target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:48.242599560 +0100\n+++ /tmp/tmpa66nqlub.java\t2023-03-24 21:41:48.278599423 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1), target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (source.charAt(0) == '/') return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:49.958593077 +0100\n+++ /tmp/tmp9zfk8bsv.java\t2023-03-24 21:41:49.962593061 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "return 1 + source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:51.726586398 +0100\n+++ /tmp/tmp2mpya6ga.java\t2023-03-24 21:41:51.730586382 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "return 1 + target.substring(1), target.substring(1) + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:53.642579161 +0100\n+++ /tmp/tmprehodc63.java\t2023-03-24 21:41:53.642579161 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1), target.substring(1) + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "return 1 + target.substring(1), target.substring(1) + source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:55.374572618 +0100\n+++ /tmp/tmp9bul1irs.java\t2023-03-24 21:41:55.374572618 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1), target.substring(1) + source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "return 1 + target.length() - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:57.098566106 +0100\n+++ /tmp/tmp1rbp5h1f.java\t2023-03-24 21:41:57.102566090 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "return 1 + target.substring(0, target.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:41:58.910559260 +0100\n+++ /tmp/tmpe_n3gwjn.java\t2023-03-24 21:41:58.910559260 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(0, target.length() - 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "return 1 + source.substring(1 + target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:00.670552611 +0100\n+++ /tmp/tmp6vytn0p6.java\t2023-03-24 21:42:00.670552611 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1 + target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "return 1 + target.substring(1, target.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:02.626545222 +0100\n+++ /tmp/tmpjvd47p6u.java\t2023-03-24 21:42:02.626545222 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1, target.length() - 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "return 1 + target.substring(1).length();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:04.358538679 +0100\n+++ /tmp/tmpnwbr8lxz.java\t2023-03-24 21:42:04.358538679 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1).length();\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "return 1 + target.substring(2), target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:08.534522902 +0100\n+++ /tmp/tmphy24y2mp.java\t2023-03-24 21:42:08.534522902 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(2), target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "return 1 + target.substring(1) - source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:10.230516494 +0100\n+++ /tmp/tmpi11o2qrf.java\t2023-03-24 21:42:10.230516494 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) - source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "return (1 + target.substring(1) - target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:12.034509679 +0100\n+++ /tmp/tmpvjwksg0h.java\t2023-03-24 21:42:12.034509679 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return (1 + target.substring(1) - target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "return 1 + source.substring(2), target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:13.886502683 +0100\n+++ /tmp/tmps9lxhtni.java\t2023-03-24 21:42:13.890502667 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(2), target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "return 1 + target.length() - source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:15.694495852 +0100\n+++ /tmp/tmp6jo8ofsn.java\t2023-03-24 21:42:15.694495852 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "return 1 + source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:17.466489157 +0100\n+++ /tmp/tmpzgd4t24p.java\t2023-03-24 21:42:17.466489157 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "return 1 + source.substring(1) - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:19.254482403 +0100\n+++ /tmp/tmpswuhqs5g.java\t2023-03-24 21:42:19.254482403 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1) - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "return 1 + source.substring(1), target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:21.078475510 +0100\n+++ /tmp/tmpp65ah5kv.java\t2023-03-24 21:42:21.078475510 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1), target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "return 1 + target.length() - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:22.874468724 +0100\n+++ /tmp/tmpaahqcwt8.java\t2023-03-24 21:42:22.874468724 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "return 1 + target.length() - 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:24.630462091 +0100\n+++ /tmp/tmp0zpnpzsm.java\t2023-03-24 21:42:24.630462091 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - 1;\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "return (1 + target.substring(1) - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:28.858446116 +0100\n+++ /tmp/tmpt2s8q2yo.java\t2023-03-24 21:42:28.858446116 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return (1 + target.substring(1) - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "return 1 + target.length() - target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:30.586439588 +0100\n+++ /tmp/tmpiq5p68vq.java\t2023-03-24 21:42:30.586439588 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "return 1 + target.substring(1), target.substring(1) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:32.278433194 +0100\n+++ /tmp/tmpuuq3gq68.java\t2023-03-24 21:42:32.278433194 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1), target.substring(1) + 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "return 1 + source.substring(0, target.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:34.002426679 +0100\n+++ /tmp/tmp3lwrrd_4.java\t2023-03-24 21:42:34.006426666 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(0, target.length() - 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "return 1 + target.substring(1 + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:35.810419848 +0100\n+++ /tmp/tmphffodlgy.java\t2023-03-24 21:42:35.810419848 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1 + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "return 1 + source.substring(1) + source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:37.474413562 +0100\n+++ /tmp/tmpnhkwsiw5.java\t2023-03-24 21:42:37.478413546 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1) + source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "return 1 + target.length() - source.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:39.278406744 +0100\n+++ /tmp/tmpoe07lk32.java\t2023-03-24 21:42:39.278406744 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - source.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "return 1 + target.length() - source.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:41.110399822 +0100\n+++ /tmp/tmpx1pwc8o3.java\t2023-03-24 21:42:41.110399822 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - source.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "return 1 + source.substring(1) + target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:42.830393324 +0100\n+++ /tmp/tmpg94p3h1d.java\t2023-03-24 21:42:42.830393324 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1) + target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "return 1 + target.substring(1) + target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:44.490387051 +0100\n+++ /tmp/tmpaxsryftt.java\t2023-03-24 21:42:44.490387051 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) + target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "return 1 + target.substring(1), target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:46.162380734 +0100\n+++ /tmp/tmp1u1gkw95.java\t2023-03-24 21:42:46.162380734 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1), target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "return 1 + target.length() - 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:47.866374295 +0100\n+++ /tmp/tmpmwzfy2f5.java\t2023-03-24 21:42:47.866374295 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - 2;\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "return 1 + source.substring(1).length();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:51.950358863 +0100\n+++ /tmp/tmppopaydca.java\t2023-03-24 21:42:51.950358863 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1).length();\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "return source.length() - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:56.510341630 +0100\n+++ /tmp/tmp3qlbe2pa.java\t2023-03-24 21:42:56.514341616 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return source.length() - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "return 1 + target.length() - 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:42:58.942332441 +0100\n+++ /tmp/tmp5lw5dfin.java\t2023-03-24 21:42:59.430330597 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - 2);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "return 1 + target.substring(1) - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:01.530322662 +0100\n+++ /tmp/tmp5noz8e04.java\t2023-03-24 21:43:01.530322662 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) - 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "return source.substring(1) + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:03.610314801 +0100\n+++ /tmp/tmpxo4jsr96.java\t2023-03-24 21:43:03.706314438 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return source.substring(1) + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "return source.length() - target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:05.758306683 +0100\n+++ /tmp/tmpf1q0_ho0.java\t2023-03-24 21:43:05.762306669 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return source.length() - target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "return 1 + target.substring(3));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:07.774299065 +0100\n+++ /tmp/tmpoypgqbek.java\t2023-03-24 21:43:07.778299050 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(3));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "return 1 + target.substring(2));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:09.618292096 +0100\n+++ /tmp/tmpbm5lrfum.java\t2023-03-24 21:43:09.678291870 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(2));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "return 1 + target.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:11.726284130 +0100\n+++ /tmp/tmpm75ejrws.java\t2023-03-24 21:43:11.726284130 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(2);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "return 1 + target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:14.674272988 +0100\n+++ /tmp/tmp5v873ghn.java\t2023-03-24 21:43:14.686272943 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "return source.length() / target.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:17.030264084 +0100\n+++ /tmp/tmpzhv8lwi_.java\t2023-03-24 21:43:17.030264084 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return source.length() / target.substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "return 1 + target.length() - 3;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:19.326255408 +0100\n+++ /tmp/tmprxbis7yn.java\t2023-03-24 21:43:19.330255392 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - 3;\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "return 1 + source.substring(3));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:25.474232173 +0100\n+++ /tmp/tmp3l2ia650.java\t2023-03-24 21:43:25.474232173 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(3));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "return 1 + target.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:27.186225702 +0100\n+++ /tmp/tmpxdvgxpp3.java\t2023-03-24 21:43:27.186225702 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length() - 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "return 1 + source.substring(2));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:29.134218340 +0100\n+++ /tmp/tmpjqgx9pty.java\t2023-03-24 21:43:29.134218340 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(2));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "return 1 + target.substring(0).length();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:30.986211341 +0100\n+++ /tmp/tmp4xdw9b8d.java\t2023-03-24 21:43:30.986211341 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(0).length();\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "return 1 + target.substring(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:34.910196509 +0100\n+++ /tmp/tmpomkmbh1h.java\t2023-03-24 21:43:35.018196101 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(3);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:36.970188723 +0100\n+++ /tmp/tmp6pgu39lh.java\t2023-03-24 21:43:36.970188723 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "return 1 + target.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:38.782181875 +0100\n+++ /tmp/tmpp4frwfnq.java\t2023-03-24 21:43:38.782181875 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(2);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "return 1 + target.length().substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:41.186172788 +0100\n+++ /tmp/tmpl0bi6_ob.java\t2023-03-24 21:43:41.694170870 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length().substring(1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "return 1 + target.substring(1) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:44.002162146 +0100\n+++ /tmp/tmp25pc6vro.java\t2023-03-24 21:43:44.006162130 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1) + 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "return 1 + target.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:46.138154072 +0100\n+++ /tmp/tmpwi7kbihn.java\t2023-03-24 21:43:46.258153618 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:48.322145817 +0100\n+++ /tmp/tmppt2rndwu.java\t2023-03-24 21:43:48.458145302 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "return 1 + source.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:50.534137456 +0100\n+++ /tmp/tmpqy3qsp49.java\t2023-03-24 21:43:50.638137064 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(2);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "return 1 + target.length();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:52.602129639 +0100\n+++ /tmp/tmpd_flgfn7.java\t2023-03-24 21:43:52.602129639 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.length();\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "return 1 + target.substring[2];",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:57.190112298 +0100\n+++ /tmp/tmpnfq55kuy.java\t2023-03-24 21:43:57.190112298 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring[2];\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return 1 + source.substring(1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:43:59.194104723 +0100\n+++ /tmp/tmpghb492op.java\t2023-03-24 21:43:59.194104723 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(1));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "return 1 + target.substring(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:44:01.226097040 +0100\n+++ /tmp/tmpquvvtrud.java\t2023-03-24 21:44:01.226097040 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + target.substring(3);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "return 1 + source.substring(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:44:03.370088936 +0100\n+++ /tmp/tmp_mgfn7jq.java\t2023-03-24 21:44:03.374088923 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + source.substring(3);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "return 1 + ));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:44:05.322081559 +0100\n+++ /tmp/tmpoccvq13q.java\t2023-03-24 21:44:05.326081544 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1 + ));\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "return 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:44:07.950071624 +0100\n+++ /tmp/tmp64l32r8c.java\t2023-03-24 21:44:07.950071624 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1;\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:44:14.054048551 +0100\n+++ /tmp/tmpvft577t8.java\t2023-03-24 21:44:14.054048551 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 1);\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "return 3;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:44:15.634042578 +0100\n+++ /tmp/tmpbktg5lbl.java\t2023-03-24 21:44:15.634042578 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 3;\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 21:44:22.026018415 +0100\n+++ /tmp/tmpe3u6p62j.java\t2023-03-24 21:44:22.026018415 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+return 0;\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return levenshtein(source.substring(1), target.substring(1));"
    },
    "flatten": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:31.249989504 +0100\n+++ /tmp/tmpw01yzfzo.java\t2023-03-24 21:44:31.249989504 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:33.141983683 +0100\n+++ /tmp/tmpdkcu0g6c.java\t2023-03-24 21:44:33.145983670 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:34.869978363 +0100\n+++ /tmp/tmpmyqu8a_t.java\t2023-03-24 21:44:34.869978363 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:36.581973089 +0100\n+++ /tmp/tmpchot1wra.java\t2023-03-24 21:44:36.581973089 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:38.237967985 +0100\n+++ /tmp/tmpyji_c0nl.java\t2023-03-24 21:44:38.237967985 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:39.937962740 +0100\n+++ /tmp/tmpqkwy_wo0.java\t2023-03-24 21:44:39.937962740 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:41.549957765 +0100\n+++ /tmp/tmpaw878_4u.java\t2023-03-24 21:44:41.553957753 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (!(x instanceof Integer)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:43.237952553 +0100\n+++ /tmp/tmp2tybc_ao.java\t2023-03-24 21:44:43.237952553 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Integer)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (!(x instanceof Number)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:45.017947051 +0100\n+++ /tmp/tmpp93_yj0r.java\t2023-03-24 21:44:45.021947039 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Number)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:46.709941819 +0100\n+++ /tmp/tmpvjpctxrh.java\t2023-03-24 21:44:46.709941819 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:48.441936459 +0100\n+++ /tmp/tmpzcrmkb4e.java\t2023-03-24 21:44:48.441936459 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (!(x instanceof Integer)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:50.277930776 +0100\n+++ /tmp/tmps6olj8tu.java\t2023-03-24 21:44:50.281930762 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Integer)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (!(x instanceof Number)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:51.977925509 +0100\n+++ /tmp/tmpeu5c9e7c.java\t2023-03-24 21:44:51.977925509 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Number)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (!(x instanceof Number)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:53.653920311 +0100\n+++ /tmp/tmp0k2mlv6g.java\t2023-03-24 21:44:53.653920311 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Number)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (!(x instanceof Integer)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:55.317915151 +0100\n+++ /tmp/tmpx7zqwqmo.java\t2023-03-24 21:44:55.317915151 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Integer)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:57.073909700 +0100\n+++ /tmp/tmp16ebjvmb.java\t2023-03-24 21:44:57.073909700 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); } } else {\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:44:58.809904309 +0100\n+++ /tmp/tmpmp1fbi2m.java\t2023-03-24 21:44:58.809904309 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:00.525898975 +0100\n+++ /tmp/tmps05r9du4.java\t2023-03-24 21:45:00.525898975 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); } } else {\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:02.325893377 +0100\n+++ /tmp/tmp88b1uezy.java\t2023-03-24 21:45:02.325893377 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:04.033888062 +0100\n+++ /tmp/tmp9y0gfsrk.java\t2023-03-24 21:45:04.037888050 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (!(x instanceof MapEntry)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:05.745882732 +0100\n+++ /tmp/tmpkfqwlm0p.java\t2023-03-24 21:45:05.745882732 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof MapEntry)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:07.481877323 +0100\n+++ /tmp/tmpbb7a07wc.java\t2023-03-24 21:45:07.481877323 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:09.185872012 +0100\n+++ /tmp/tmpyz1dd33s.java\t2023-03-24 21:45:09.189872000 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:10.853866809 +0100\n+++ /tmp/tmplugja2hq.java\t2023-03-24 21:45:10.857866797 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (!(x instanceof Boolean)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:12.533861566 +0100\n+++ /tmp/tmp9zebt1gy.java\t2023-03-24 21:45:12.537861554 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Boolean)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } return result; } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:14.293856069 +0100\n+++ /tmp/tmp5u2kefos.java\t2023-03-24 21:45:14.293856069 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } return result; } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (!(x instanceof Boolean)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:15.985850783 +0100\n+++ /tmp/tmpxvxl_qqe.java\t2023-03-24 21:45:15.985850783 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Boolean)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (!(x instanceof Map)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:17.753845254 +0100\n+++ /tmp/tmp8vbcbfj1.java\t2023-03-24 21:45:17.753845254 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } return result; } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:19.437839987 +0100\n+++ /tmp/tmpjtktdrv0.java\t2023-03-24 21:45:19.441839975 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } return result; } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (flatten(x)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:21.153834614 +0100\n+++ /tmp/tmprb_02vy6.java\t2023-03-24 21:45:21.153834614 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten(x)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (!(x instanceof MapEntry)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:22.913829102 +0100\n+++ /tmp/tmp0t3_hi5g.java\t2023-03-24 21:45:22.913829102 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof MapEntry)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return flatten(arr); } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:24.581823877 +0100\n+++ /tmp/tmpgqh83ck2.java\t2023-03-24 21:45:24.585823862 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return flatten(arr); } } else {\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:26.313818444 +0100\n+++ /tmp/tmpe3zeq6uk.java\t2023-03-24 21:45:26.317818432 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (x.equals(x.toString())) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:28.085812884 +0100\n+++ /tmp/tmpjvsy0tqh.java\t2023-03-24 21:45:28.089812872 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x.equals(x.toString())) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (!(x instanceof Class<?>)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:29.745807673 +0100\n+++ /tmp/tmp7mb820xs.java\t2023-03-24 21:45:29.745807673 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Class<?>)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } return result; } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:31.509802132 +0100\n+++ /tmp/tmpg9__kfmg.java\t2023-03-24 21:45:31.509802132 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } return result; } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:33.177796890 +0100\n+++ /tmp/tmpsppmsdpu.java\t2023-03-24 21:45:33.177796890 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } return result; } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:34.833791682 +0100\n+++ /tmp/tmp_n886utq.java\t2023-03-24 21:45:34.833791682 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } return result; } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (!(x instanceof List)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:36.521786373 +0100\n+++ /tmp/tmpywb0pyeg.java\t2023-03-24 21:45:36.521786373 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof List)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (!(x instanceof MapEntry)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:38.169781183 +0100\n+++ /tmp/tmpo0wke6h6.java\t2023-03-24 21:45:38.169781183 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof MapEntry)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (!(x instanceof Map)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:39.889775767 +0100\n+++ /tmp/tmpsoce8z2q.java\t2023-03-24 21:45:39.889775767 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (x.equals(x.toString())) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:41.685770105 +0100\n+++ /tmp/tmpelh85byf.java\t2023-03-24 21:45:41.685770105 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x.equals(x.toString())) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (!(x instanceof Class<?>)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:43.397764708 +0100\n+++ /tmp/tmppt7cge_5.java\t2023-03-24 21:45:43.397764708 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Class<?>)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (!(x instanceof Boolean)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:45.053759482 +0100\n+++ /tmp/tmpcha9z1bg.java\t2023-03-24 21:45:45.053759482 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Boolean)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (flatten(x)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:46.721754217 +0100\n+++ /tmp/tmpk5ahc3lw.java\t2023-03-24 21:45:46.721754217 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten(x)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!(x instanceof Map)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:48.381748974 +0100\n+++ /tmp/tmpvpja4ul5.java\t2023-03-24 21:45:48.385748962 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:50.053743690 +0100\n+++ /tmp/tmpk1wphfmv.java\t2023-03-24 21:45:50.057743678 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:51.693738504 +0100\n+++ /tmp/tmpx9wbvir2.java\t2023-03-24 21:45:51.697738492 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (!(x instanceof Number)) { result.add(flatten(x)); } else { return flatten(arr); } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:53.365733215 +0100\n+++ /tmp/tmp5yse72km.java\t2023-03-24 21:45:53.369733203 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Number)) { result.add(flatten(x)); } else { return flatten(arr); } } else {\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (!(x instanceof Map.Entry)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:55.225727328 +0100\n+++ /tmp/tmp43b9s0kt.java\t2023-03-24 21:45:55.225727328 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map.Entry)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (!(x instanceof List)) { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:56.917721969 +0100\n+++ /tmp/tmp9tvth6z8.java\t2023-03-24 21:45:56.921721957 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof List)) { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (!(x instanceof Short)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:45:58.665716432 +0100\n+++ /tmp/tmpb8b011ke.java\t2023-03-24 21:45:58.665716432 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Short)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (!(x instanceof List)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:00.369711029 +0100\n+++ /tmp/tmps7prkd7g.java\t2023-03-24 21:46:00.369711029 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof List)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (!arr.contains(x)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:02.073705622 +0100\n+++ /tmp/tmpynj8lmza.java\t2023-03-24 21:46:02.073705622 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!arr.contains(x)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (!(x instanceof Array)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:03.845699999 +0100\n+++ /tmp/tmp69104q7w.java\t2023-03-24 21:46:03.845699999 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Array)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (!(x instanceof Class<?>)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:05.573694513 +0100\n+++ /tmp/tmph8b2nz7u.java\t2023-03-24 21:46:05.577694498 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Class<?>)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (!(x instanceof Integer)) { result.add(flatten(x)); } else { return flatten(arr); } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:07.321688960 +0100\n+++ /tmp/tmp0fpp5mfs.java\t2023-03-24 21:46:07.321688960 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Integer)) { result.add(flatten(x)); } else { return flatten(arr); } } else {\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (!(x instanceof Number)) { result.add(flatten(x)); } } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:08.953683772 +0100\n+++ /tmp/tmp08g485u6.java\t2023-03-24 21:46:08.957683757 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Number)) { result.add(flatten(x)); } } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (!(x instanceof Integer)) { result.add(flatten(x)); } } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:10.621678467 +0100\n+++ /tmp/tmpkwmahryw.java\t2023-03-24 21:46:10.621678467 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Integer)) { result.add(flatten(x)); } } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (flatten(x, result)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:12.385672852 +0100\n+++ /tmp/tmpmj0zw0jm.java\t2023-03-24 21:46:12.385672852 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten(x, result)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (!(x instanceof Map.Entry)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:14.597665809 +0100\n+++ /tmp/tmp1n93gbxz.java\t2023-03-24 21:46:14.725665401 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map.Entry)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (!(x instanceof ArrayList)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:16.313660343 +0100\n+++ /tmp/tmp4fh7ux9q.java\t2023-03-24 21:46:16.313660343 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:18.041654835 +0100\n+++ /tmp/tmp3y28dygu.java\t2023-03-24 21:46:18.041654835 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } else { } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:20.509646963 +0100\n+++ /tmp/tmpglixv6o4.java\t2023-03-24 21:46:20.673646440 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } else { } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (!(x instanceof Long)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:22.629640198 +0100\n+++ /tmp/tmpylmiiv_3.java\t2023-03-24 21:46:22.685640017 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Long)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (!(x instanceof Short)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:24.265634973 +0100\n+++ /tmp/tmph5vm27gh.java\t2023-03-24 21:46:24.305634846 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Short)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:26.137628991 +0100\n+++ /tmp/tmp_kkapse_.java\t2023-03-24 21:46:26.165628902 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList<?>)) { result.add(flatten(x)); } } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (!(x instanceof String)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:27.761623799 +0100\n+++ /tmp/tmp2gkm6f87.java\t2023-03-24 21:46:27.761623799 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof String)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (!(x instanceof JSONArray)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:29.709617569 +0100\n+++ /tmp/tmpbmfjbrzw.java\t2023-03-24 21:46:29.737617480 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof JSONArray)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (flatten(x.toString()) == null) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:31.769610977 +0100\n+++ /tmp/tmpw78_l3vi.java\t2023-03-24 21:46:31.893610580 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten(x.toString()) == null) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (!(x instanceof Array)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:34.013603792 +0100\n+++ /tmp/tmpl5yj2upr.java\t2023-03-24 21:46:34.013603792 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Array)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (p == null) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:36.025597345 +0100\n+++ /tmp/tmpq90p3xe8.java\t2023-03-24 21:46:36.029597330 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (p == null) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (flatten(x, result)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:38.085590740 +0100\n+++ /tmp/tmprl2zcm6q.java\t2023-03-24 21:46:38.085590740 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten(x, result)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (!x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:40.785582077 +0100\n+++ /tmp/tmpe3hivhsd.java\t2023-03-24 21:46:40.785582077 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!x.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); } } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:42.213577494 +0100\n+++ /tmp/tmpzg1lqdi1.java\t2023-03-24 21:46:42.213577494 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr); } } } else {\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } else { } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:43.781572458 +0100\n+++ /tmp/tmpbn4mtftn.java\t2023-03-24 21:46:43.781572458 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } else { } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (!(x instanceof Date)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:45.841565839 +0100\n+++ /tmp/tmp6o2vj2ks.java\t2023-03-24 21:46:46.013565287 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Date)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (!(x instanceof File)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:47.753559693 +0100\n+++ /tmp/tmpayzhmfos.java\t2023-03-24 21:46:47.849559383 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof File)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (!(x instanceof ClassRef)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:50.153551972 +0100\n+++ /tmp/tmpubp6gnhc.java\t2023-03-24 21:46:50.153551972 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ClassRef)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (x instanceof Double) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:52.417544683 +0100\n+++ /tmp/tmppehygcdz.java\t2023-03-24 21:46:52.417544683 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x instanceof Double) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (!(x instanceof Long)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:54.517537919 +0100\n+++ /tmp/tmppso3hlh4.java\t2023-03-24 21:46:54.517537919 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Long)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (flatten(x.toString())) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:56.581531270 +0100\n+++ /tmp/tmpk43qk5ju.java\t2023-03-24 21:46:56.709530857 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten(x.toString())) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (!super.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:46:58.941523659 +0100\n+++ /tmp/tmpn1gbu_g8.java\t2023-03-24 21:46:59.053523297 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!super.equals(x)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); } } } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:00.533518521 +0100\n+++ /tmp/tmpdykc1l00.java\t2023-03-24 21:47:00.533518521 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr); } } } else {\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } else { } } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:02.673511613 +0100\n+++ /tmp/tmpmyil320s.java\t2023-03-24 21:47:02.673511613 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } else { } } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "result.add(flatten(x)); } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:04.549505554 +0100\n+++ /tmp/tmpzdu1xazu.java\t2023-03-24 21:47:04.577505465 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+result.add(flatten(x)); } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } else { return flatten(arr); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:06.645498781 +0100\n+++ /tmp/tmpftcdbyzy.java\t2023-03-24 21:47:06.793498304 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Map<?,?>)) { result.add(flatten(x)); } else { return flatten(arr); } }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (!(x instanceof ArrayList)) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:08.345493285 +0100\n+++ /tmp/tmp1sgaa9c2.java\t2023-03-24 21:47:08.345493285 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof ArrayList)) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (x instanceof Double) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:10.109487579 +0100\n+++ /tmp/tmp39a7b0gp.java\t2023-03-24 21:47:10.249487126 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x instanceof Double) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (!(x instanceof Integer)) { result.add(flatten(x)); } } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:12.337480368 +0100\n+++ /tmp/tmp6rf8vk37.java\t2023-03-24 21:47:12.341480357 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Integer)) { result.add(flatten(x)); } } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (!(x instanceof Number)) { result.add(flatten(x)); } } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:13.881475369 +0100\n+++ /tmp/tmpecxgta96.java\t2023-03-24 21:47:13.881475369 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Number)) { result.add(flatten(x)); } } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (p == null) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:15.633469694 +0100\n+++ /tmp/tmpmotdc7r9.java\t2023-03-24 21:47:15.737469356 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (p == null) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "result.add(flatten(x)); } return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:17.829462576 +0100\n+++ /tmp/tmp28by0ftb.java\t2023-03-24 21:47:17.829462576 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+result.add(flatten(x)); } return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (p instanceof Double) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:19.377457557 +0100\n+++ /tmp/tmp2fscimff.java\t2023-03-24 21:47:19.377457557 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (p instanceof Double) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "do { result.add(flatten(x)); } } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:21.261451445 +0100\n+++ /tmp/tmp11s89rm4.java\t2023-03-24 21:47:21.429450900 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+do { result.add(flatten(x)); } } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:23.709443501 +0100\n+++ /tmp/tmp6rwrkss5.java\t2023-03-24 21:47:23.709443501 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Float)) { result.add(flatten(x)); } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (p instanceof ArrayList) { result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:26.133435628 +0100\n+++ /tmp/tmpv5f62bqn.java\t2023-03-24 21:47:26.317435030 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (p instanceof ArrayList) { result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:28.281428646 +0100\n+++ /tmp/tmpfhc7d6vu.java\t2023-03-24 21:47:28.409428230 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(x instanceof Double)) { result.add(flatten(x)); } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "result.add(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:29.981423118 +0100\n+++ /tmp/tmpysijrrqk.java\t2023-03-24 21:47:29.981423118 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+result.add(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "do { result.add(flatten(x)); } } else { return flatten(arr);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 21:47:32.449415092 +0100\n+++ /tmp/tmp5mv0di7q.java\t2023-03-24 21:47:32.549414764 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+do { result.add(flatten(x)); } } else { return flatten(arr);\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "result.add((x)); } } return result; } else { return arr;"
    },
    "subsequences": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:30.765990993 +0100\n+++ /tmp/tmpjwtl3cuv.java\t2023-03-24 21:44:31.445988901 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "return new ArrayList();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:35.453976564 +0100\n+++ /tmp/tmpykpj5rwl.java\t2023-03-24 21:44:35.457976552 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (a < 0 || b > 255) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:39.529963999 +0100\n+++ /tmp/tmpc01wzbyh.java\t2023-03-24 21:44:39.529963999 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 255) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (a == 0 || b == 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:41.225958765 +0100\n+++ /tmp/tmpk4xy6ujf.java\t2023-03-24 21:44:41.225958765 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0 || b == 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (a < 0 || a == 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:45.185946532 +0100\n+++ /tmp/tmp695zm98t.java\t2023-03-24 21:44:45.185946532 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (a < 0 || a > 1) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:49.201934108 +0100\n+++ /tmp/tmplpfhj9z1.java\t2023-03-24 21:44:49.201934108 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a > 1) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (a < 0 || a > 1) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:53.301921404 +0100\n+++ /tmp/tmpyu4vymxf.java\t2023-03-24 21:44:53.305921392 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a > 1) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (a < 0 || a == 1) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:55.033916032 +0100\n+++ /tmp/tmp6n_k17mb.java\t2023-03-24 21:44:55.033916032 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == 1) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (a == 0 || b == 0) { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:44:59.133903302 +0100\n+++ /tmp/tmpb8kwu_72.java\t2023-03-24 21:44:59.137903289 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0 || b == 0) { return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (a < 0 || b > 100); return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:03.189890690 +0100\n+++ /tmp/tmp4rllh15l.java\t2023-03-24 21:45:03.193890676 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 100); return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (a < 0 || b > 1) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:04.941885236 +0100\n+++ /tmp/tmplsb9aa5e.java\t2023-03-24 21:45:04.945885223 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (a < 0 || b > 1) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:09.033872486 +0100\n+++ /tmp/tmpwpn78lkq.java\t2023-03-24 21:45:09.033872486 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (a < 0 || a == 0) { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:10.685867333 +0100\n+++ /tmp/tmpmjkoaxha.java\t2023-03-24 21:45:10.709867258 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == 0) { return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (a == 0) { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:14.785854533 +0100\n+++ /tmp/tmpq69hs8xt.java\t2023-03-24 21:45:14.789854520 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:18.877841739 +0100\n+++ /tmp/tmpgmp_qzpn.java\t2023-03-24 21:45:18.877841739 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (a == 0) return new ArrayList<>(); else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:22.905829128 +0100\n+++ /tmp/tmphn255trq.java\t2023-03-24 21:45:22.905829128 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>(); else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (a < 0 || b == 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:24.701823499 +0100\n+++ /tmp/tmplynpq9bu.java\t2023-03-24 21:45:24.701823499 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b == 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:28.797810650 +0100\n+++ /tmp/tmptiapyj77.java\t2023-03-24 21:45:28.797810650 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (a < 0 || a == 1) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:30.633804884 +0100\n+++ /tmp/tmp6eczmeld.java\t2023-03-24 21:45:30.637804872 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == 1) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:32.309799618 +0100\n+++ /tmp/tmpaf3imzsu.java\t2023-03-24 21:45:32.309799618 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (a < 0 || a == 1) { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:36.433786648 +0100\n+++ /tmp/tmpmkh3ac_0.java\t2023-03-24 21:45:36.437786636 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == 1) { return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (a < 0 || a > 1) { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:40.541773713 +0100\n+++ /tmp/tmp4a2uhut5.java\t2023-03-24 21:45:40.541773713 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a > 1) { return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (a == 0 || b == 0) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:44.749760442 +0100\n+++ /tmp/tmpead4d666.java\t2023-03-24 21:45:44.749760442 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0 || b == 0) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (a < 0 || b > 100); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:46.485754962 +0100\n+++ /tmp/tmpernkm99y.java\t2023-03-24 21:45:46.489754950 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 100); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (a < 0 || a == b) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:48.157749682 +0100\n+++ /tmp/tmp0fmqszfi.java\t2023-03-24 21:45:48.161749670 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == b) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (a < 0 || b > 1.0) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:49.877744246 +0100\n+++ /tmp/tmp1z1bwetn.java\t2023-03-24 21:45:49.877744246 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1.0) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (a < 0 || b > 255) return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:51.625738719 +0100\n+++ /tmp/tmpqvkna0j2.java\t2023-03-24 21:45:51.625738719 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 255) return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (a < 0) { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:55.629726048 +0100\n+++ /tmp/tmpha0zv67a.java\t2023-03-24 21:45:55.633726036 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (a - b < 0) { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:45:59.789712869 +0100\n+++ /tmp/tmppkq20bcz.java\t2023-03-24 21:45:59.793712854 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a - b < 0) { return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (a - b < 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:03.953699656 +0100\n+++ /tmp/tmp7u3ks7rx.java\t2023-03-24 21:46:03.957699645 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a - b < 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (a < 0 || a == 0) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:08.037686683 +0100\n+++ /tmp/tmp056k8rqu.java\t2023-03-24 21:46:08.037686683 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == 0) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "throw new IllegalStateException(\"Ciphertext: \" + a);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:10.233679699 +0100\n+++ /tmp/tmp2ysckvvf.java\t2023-03-24 21:46:10.233679699 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalStateException(\"Ciphertext: \" + a);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (a < 0 || b > 100); return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:15.781662037 +0100\n+++ /tmp/tmph7ueux1h.java\t2023-03-24 21:46:15.781662037 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 100); return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (a < 0 || a > 1) return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:21.085645125 +0100\n+++ /tmp/tmpcsy3htv7.java\t2023-03-24 21:46:21.085645125 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a > 1) return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (!a.equals(b)) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:27.805623660 +0100\n+++ /tmp/tmpsgi7ldjy.java\t2023-03-24 21:46:27.805623660 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (!a.equals(b)) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (a == 0) return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:29.709617569 +0100\n+++ /tmp/tmprkw7h3mg.java\t2023-03-24 21:46:29.737617480 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (a == 0) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:31.785610926 +0100\n+++ /tmp/tmpunnffmgg.java\t2023-03-24 21:46:31.893610580 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (a == b) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:33.993603855 +0100\n+++ /tmp/tmpw57y8pj5.java\t2023-03-24 21:46:33.993603855 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "throw new IllegalArgumentException(\"k must be at least 3\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:36.005597407 +0100\n+++ /tmp/tmpv0b7cfjd.java\t2023-03-24 21:46:36.009597395 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalArgumentException(\"k must be at least 3\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (a - b < 0) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:41.465579895 +0100\n+++ /tmp/tmpt8f16lsa.java\t2023-03-24 21:46:41.649579304 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a - b < 0) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "return new ArrayList<ArrayList>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:43.709572688 +0100\n+++ /tmp/tmpitiz_e7j.java\t2023-03-24 21:46:43.709572688 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<ArrayList>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:48.709556616 +0100\n+++ /tmp/tmp5f9behqo.java\t2023-03-24 21:46:48.709556616 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (a == b) return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:50.209551792 +0100\n+++ /tmp/tmptwnrqne5.java\t2023-03-24 21:46:50.213551778 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (a == null) return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:52.397544748 +0100\n+++ /tmp/tmplrgkvd0x.java\t2023-03-24 21:46:52.397544748 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == null) return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "return new ArrayList<>(50);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:46:54.497537984 +0100\n+++ /tmp/tmp_3u6q4gf.java\t2023-03-24 21:46:54.497537984 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(50);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (a < 0) return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:00.849517501 +0100\n+++ /tmp/tmpx2bmh0f3.java\t2023-03-24 21:47:00.853517489 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "throw new IllegalArgumentException(\"internal error\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:02.501512170 +0100\n+++ /tmp/tmpu3yck7gi.java\t2023-03-24 21:47:02.613511808 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalArgumentException(\"internal error\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "return new ArrayList<>(4);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:08.009494373 +0100\n+++ /tmp/tmphe3fk9j4.java\t2023-03-24 21:47:08.009494373 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(4);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "return new ArrayList<>(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:13.397476938 +0100\n+++ /tmp/tmpexu4wj7l.java\t2023-03-24 21:47:13.401476923 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(1);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "throw new RuntimeException(\"internal error\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:19.481457220 +0100\n+++ /tmp/tmp83ej3tsk.java\t2023-03-24 21:47:19.481457220 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new RuntimeException(\"internal error\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (a == 0) return new ArrayList();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:23.865442994 +0100\n+++ /tmp/tmpj3e775lq.java\t2023-03-24 21:47:23.865442994 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "throw new IllegalArgumentException(\"(\"internal error\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:29.997423068 +0100\n+++ /tmp/tmpbucke_g6.java\t2023-03-24 21:47:29.997423068 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalArgumentException(\"(\"internal error\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (a == 0) return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:32.429415156 +0100\n+++ /tmp/tmpkzqq_dzo.java\t2023-03-24 21:47:32.549414764 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "return new ArrayList<>(); return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:40.881387622 +0100\n+++ /tmp/tmpekffi0u5.java\t2023-03-24 21:47:40.881387622 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(); return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "throw new IllegalStateException(\"internal error\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:43.105380367 +0100\n+++ /tmp/tmps9pd8yel.java\t2023-03-24 21:47:43.105380367 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalStateException(\"internal error\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "return new ArrayList<>(16);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:47.581365756 +0100\n+++ /tmp/tmp4l0ty0fz.java\t2023-03-24 21:47:47.581365756 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(16);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "return Collections.emptyList();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:51.785352016 +0100\n+++ /tmp/tmper5qe3pb.java\t2023-03-24 21:47:51.785352016 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return Collections.emptyList();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:53.505346392 +0100\n+++ /tmp/tmp9kx116cq.java\t2023-03-24 21:47:53.505346392 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "throw new NullPointerException(\"a\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:55.217340790 +0100\n+++ /tmp/tmpa0f1xik5.java\t2023-03-24 21:47:55.217340790 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new NullPointerException(\"a\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "return new ArrayList<>(8);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:47:59.257327563 +0100\n+++ /tmp/tmpqj0ywasy.java\t2023-03-24 21:47:59.257327563 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(8);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "return new ArrayList<>(5);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:03.293314336 +0100\n+++ /tmp/tmpspg8ijug.java\t2023-03-24 21:48:03.297314324 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(5);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "return new ArrayList(50);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:07.401300860 +0100\n+++ /tmp/tmp__ukdzk0.java\t2023-03-24 21:48:07.409300834 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList(50);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "return new ArrayList<>(100);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:11.541287267 +0100\n+++ /tmp/tmpgyu7_7sc.java\t2023-03-24 21:48:11.545287256 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(100);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "return new ArrayList<>(0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:15.581273989 +0100\n+++ /tmp/tmpahr7ebh_.java\t2023-03-24 21:48:15.585273977 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(0);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "throw new UnsupportedOperationException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:19.713260396 +0100\n+++ /tmp/tmpi8t3jz4_.java\t2023-03-24 21:48:19.713260396 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new UnsupportedOperationException();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "return new ArrayList<>(a);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:23.637247477 +0100\n+++ /tmp/tmpgo30vnxm.java\t2023-03-24 21:48:23.637247477 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(a);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "return new ArrayList<>(48);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:27.693234108 +0100\n+++ /tmp/tmpkq_jp3sz.java\t2023-03-24 21:48:27.697234097 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(48);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "throw new NullPointerException(\"b\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:31.733220783 +0100\n+++ /tmp/tmpc7bq0tqj.java\t2023-03-24 21:48:31.737220769 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new NullPointerException(\"b\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "{ return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:35.889207060 +0100\n+++ /tmp/tmpt05jpg9n.java\t2023-03-24 21:48:35.889207060 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+{ return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "return new ArrayList<>(24);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:39.973193564 +0100\n+++ /tmp/tmphhlgkwxu.java\t2023-03-24 21:48:39.985193524 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(24);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "return new ArrayList<>(80);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:43.985180294 +0100\n+++ /tmp/tmpn777zzge.java\t2023-03-24 21:48:43.989180282 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(80);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "return new ArrayList<>(7);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:47.921167266 +0100\n+++ /tmp/tmp0zewb9jw.java\t2023-03-24 21:48:47.921167266 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(7);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "throw new NullPointerException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:51.833154303 +0100\n+++ /tmp/tmpb4n9sctu.java\t2023-03-24 21:48:51.837154291 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new NullPointerException();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "return new ArrayList<>(6);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:48:55.997140495 +0100\n+++ /tmp/tmpg6g96okv.java\t2023-03-24 21:48:55.997140495 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(6);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "return new ArrayList<>(47);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:00.061127009 +0100\n+++ /tmp/tmp8bys1d1q.java\t2023-03-24 21:49:00.061127009 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(47);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "return new ArrayList<>(9);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:04.021113853 +0100\n+++ /tmp/tmpz9wkusfl.java\t2023-03-24 21:49:04.025113842 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(9);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "return new ArrayList<>(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:08.061100424 +0100\n+++ /tmp/tmpu86rvf84.java\t2023-03-24 21:49:08.061100424 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(2);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "{ return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:12.201086650 +0100\n+++ /tmp/tmp1gr8ixe_.java\t2023-03-24 21:49:12.201086650 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+{ return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "return new ArrayList<>(); });",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:13.965080775 +0100\n+++ /tmp/tmpoky060su.java\t2023-03-24 21:49:13.969080764 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(); });\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "return new LinkedHashSet<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:15.753074822 +0100\n+++ /tmp/tmpxig1cn5v.java\t2023-03-24 21:49:15.753074822 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new LinkedHashSet<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "throw new IllegalStateException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:17.529068904 +0100\n+++ /tmp/tmplj14txp3.java\t2023-03-24 21:49:17.529068904 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalStateException();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:21.585055383 +0100\n+++ /tmp/tmppi7xqhgc.java\t2023-03-24 21:49:21.585055383 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return a;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "return new ArrayList(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:23.645048513 +0100\n+++ /tmp/tmph4_o8n8i.java\t2023-03-24 21:49:23.645048513 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList(1);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "return new ArrayList(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:28.545032155 +0100\n+++ /tmp/tmpeemdyldf.java\t2023-03-24 21:49:28.545032155 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList(2);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "return new LinkedList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:33.325016185 +0100\n+++ /tmp/tmp1oxcxfj7.java\t2023-03-24 21:49:33.325016185 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new LinkedList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "return new ArrayList(0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:36.053007066 +0100\n+++ /tmp/tmpf_r_5e5m.java\t2023-03-24 21:49:36.053007066 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList(0);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "return new HashSet<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:41.612988461 +0100\n+++ /tmp/tmp69o6ig0k.java\t2023-03-24 21:49:41.612988461 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new HashSet<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "// new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:44.396979138 +0100\n+++ /tmp/tmpa9y3g3k8.java\t2023-03-24 21:49:44.396979138 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+// new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "return new ArrayList(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:49.068963480 +0100\n+++ /tmp/tmp8otk71qu.java\t2023-03-24 21:49:49.068963480 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList(3);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "return new ArrayList());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:53.408948925 +0100\n+++ /tmp/tmptk7a3qv3.java\t2023-03-24 21:49:53.408948925 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList());\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "return new ArrayList(\"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:55.632941461 +0100\n+++ /tmp/tmpm8n4s5qi.java\t2023-03-24 21:49:55.632941461 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList(\"\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "return new ArrayList\";",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:49:58.296932515 +0100\n+++ /tmp/tmpdout6fkp.java\t2023-03-24 21:49:58.368932273 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList\";\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return new ArrayList>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:00.192926148 +0100\n+++ /tmp/tmpwk78ze5g.java\t2023-03-24 21:50:00.192926148 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "return null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:01.940920274 +0100\n+++ /tmp/tmpix3wzxha.java\t2023-03-24 21:50:01.940920274 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return null;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "return first;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:08.124899481 +0100\n+++ /tmp/tmpsi6bbu3w.java\t2023-03-24 21:50:08.124899481 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return first;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "return this;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:10.732890704 +0100\n+++ /tmp/tmpdhtzys_4.java\t2023-03-24 21:50:10.732890704 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return this;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "return ArrayList();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:13.156882541 +0100\n+++ /tmp/tmpahl4mny_.java\t2023-03-24 21:50:13.160882530 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return ArrayList();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:15.372875080 +0100\n+++ /tmp/tmpzv1wlpl5.java\t2023-03-24 21:50:15.376875066 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return b;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "continue;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:17.500867909 +0100\n+++ /tmp/tmpsla6oxia.java\t2023-03-24 21:50:17.500867909 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+continue;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 21:50:19.752860317 +0100\n+++ /tmp/tmpt1vm9eep.java\t2023-03-24 21:50:19.752860317 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "ArrayList empty_set = new ArrayList<ArrayList>(); empty_set.add(new ArrayList()); return empty_set;"
    },
    "kth": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "return kth(above, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:39.021393687 +0100\n+++ /tmp/tmpno4_khgc.java\t2023-03-24 21:47:39.229393008 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(above, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (max_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:44.025377367 +0100\n+++ /tmp/tmp244qx5h7.java\t2023-03-24 21:47:44.025377367 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (max_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (((long) num_lessoreq)!= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:47.585365741 +0100\n+++ /tmp/tmpxeg7tn1j.java\t2023-03-24 21:47:47.585365741 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq)!= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:49.505359471 +0100\n+++ /tmp/tmpp8ezpx_g.java\t2023-03-24 21:47:49.505359471 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:51.301353599 +0100\n+++ /tmp/tmpyhzbe9uz.java\t2023-03-24 21:47:51.301353599 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (get(num_lessoreq) == num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:53.093347738 +0100\n+++ /tmp/tmpaw4uphos.java\t2023-03-24 21:47:53.097347727 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (get(num_lessoreq) == num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (Math.abs(num_lessoreq) >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:54.953341654 +0100\n+++ /tmp/tmp_oa27lv9.java\t2023-03-24 21:47:54.957341642 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (((long) num_lessoreq) >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:56.805335592 +0100\n+++ /tmp/tmp4spwhx0f.java\t2023-03-24 21:47:56.805335592 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq) >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (visible_lessoreq && num_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:47:58.833328952 +0100\n+++ /tmp/tmpgo1r9xrz.java\t2023-03-24 21:47:58.833328952 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (visible_lessoreq && num_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (previous_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:00.565323279 +0100\n+++ /tmp/tmp38gl6ivb.java\t2023-03-24 21:48:00.565323279 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (previous_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (upper_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:02.373317353 +0100\n+++ /tmp/tmp5sd4hxeh.java\t2023-03-24 21:48:02.373317353 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (upper_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (Math.abs( num_lessoreq) >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:04.221311295 +0100\n+++ /tmp/tmpr992w724.java\t2023-03-24 21:48:04.221311295 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs( num_lessoreq) >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq) == null) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:06.069305233 +0100\n+++ /tmp/tmpth4bkz7y.java\t2023-03-24 21:48:06.069305233 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq) == null) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (((long) num_lessoreq).compareTo(num_lessoreq) >= 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:07.937299103 +0100\n+++ /tmp/tmpl3l_ruk7.java\t2023-03-24 21:48:07.937299103 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq).compareTo(num_lessoreq) >= 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (above.size() > num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:09.801292984 +0100\n+++ /tmp/tmp3zq51bba.java\t2023-03-24 21:48:09.805292969 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (above.size() > num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:11.593287096 +0100\n+++ /tmp/tmp2nrlw9k0.java\t2023-03-24 21:48:11.593287096 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (visible_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:15.633273818 +0100\n+++ /tmp/tmpw239m4qp.java\t2023-03-24 21:48:15.633273818 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (visible_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (((long) num_lessoreq) == num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:17.445267859 +0100\n+++ /tmp/tmp0w1e1u2v.java\t2023-03-24 21:48:17.445267859 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq) == num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if ( num_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:19.201262083 +0100\n+++ /tmp/tmp97i6ptgb.java\t2023-03-24 21:48:19.205262068 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( num_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (values.size() >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:21.129255735 +0100\n+++ /tmp/tmplavma8j4.java\t2023-03-24 21:48:21.129255735 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (values.size() >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:22.969249677 +0100\n+++ /tmp/tmpgtr6q7ut.java\t2023-03-24 21:48:22.969249677 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq) == 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:24.829243550 +0100\n+++ /tmp/tmpj3u9b4g9.java\t2023-03-24 21:48:24.833243536 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq) == 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (above.size() > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:26.617237655 +0100\n+++ /tmp/tmpi3ivu4vu.java\t2023-03-24 21:48:26.617237655 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (above.size() > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (upper_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:30.885223582 +0100\n+++ /tmp/tmp20x734vc.java\t2023-03-24 21:48:30.885223582 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (upper_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (Math.min(num_lessoreq, num_lessoreq) == 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:32.617217866 +0100\n+++ /tmp/tmpi7kpvcnt.java\t2023-03-24 21:48:32.617217866 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.min(num_lessoreq, num_lessoreq) == 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (values.size() >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:34.381212042 +0100\n+++ /tmp/tmplgi92hcq.java\t2023-03-24 21:48:34.381212042 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (values.size() >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "else if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:36.153206189 +0100\n+++ /tmp/tmpk3gbz25r.java\t2023-03-24 21:48:36.153206189 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+else if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (Math.min(num_lessoreq, num_lessoreq)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:37.841200611 +0100\n+++ /tmp/tmpr1sr6vl6.java\t2023-03-24 21:48:37.841200611 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.min(num_lessoreq, num_lessoreq)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq) > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:39.669194570 +0100\n+++ /tmp/tmpey0gb208.java\t2023-03-24 21:48:39.673194556 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq) > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (Checkpoint.get(num_lessoreq) == num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:41.549188354 +0100\n+++ /tmp/tmp2aa7psfv.java\t2023-03-24 21:48:41.549188354 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Checkpoint.get(num_lessoreq) == num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if ( previous_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:43.357182372 +0100\n+++ /tmp/tmp5hy9w_yq.java\t2023-03-24 21:48:43.357182372 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( previous_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (get(num_lessoreq) >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:45.181176336 +0100\n+++ /tmp/tmpfoczps7y.java\t2023-03-24 21:48:45.185176324 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (get(num_lessoreq) >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (((long) num_lessoreq) == (((long) num_lessoreq))); return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:47.025170232 +0100\n+++ /tmp/tmpt6gxby74.java\t2023-03-24 21:48:47.025170232 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq) == (((long) num_lessoreq))); return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (null!= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:48.849164190 +0100\n+++ /tmp/tmp_boawoqj.java\t2023-03-24 21:48:48.853164179 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (null!= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (Math.min(num_lessoreq, num_lessoreq) == null) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:50.645158240 +0100\n+++ /tmp/tmpmunxsuif.java\t2023-03-24 21:48:50.645158240 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.min(num_lessoreq, num_lessoreq) == null) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (((long) num_lessoreq) == 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:52.429152329 +0100\n+++ /tmp/tmpw9ze82x6.java\t2023-03-24 21:48:52.429152329 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq) == 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "else if (num_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:56.517138772 +0100\n+++ /tmp/tmpyex4wuvs.java\t2023-03-24 21:48:56.517138772 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+else if (num_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (values.size() == num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:58.149133354 +0100\n+++ /tmp/tmp5omy4w2o.java\t2023-03-24 21:48:58.177133261 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (values.size() == num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq)); } else { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:48:59.957127353 +0100\n+++ /tmp/tmpxg93o0ta.java\t2023-03-24 21:48:59.957127353 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq)); } else { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (UNKNOWN_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:01.669121669 +0100\n+++ /tmp/tmpf8zjaa8p.java\t2023-03-24 21:49:01.669121669 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (UNKNOWN_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (((long) num_lessoreq)!= (((long) num_lessoreq))); return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:03.497115596 +0100\n+++ /tmp/tmp8k27mucw.java\t2023-03-24 21:49:03.497115596 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq)!= (((long) num_lessoreq))); return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq) > 0); return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:05.281109666 +0100\n+++ /tmp/tmpajb4r4be.java\t2023-03-24 21:49:05.281109666 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq) > 0); return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if ('>_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:07.037103830 +0100\n+++ /tmp/tmp5apvfacj.java\t2023-03-24 21:49:07.037103830 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ('>_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (Math.min(num_lessoreq, num_lessoreq) > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:08.741098162 +0100\n+++ /tmp/tmpah2kzuyl.java\t2023-03-24 21:49:08.741098162 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.min(num_lessoreq, num_lessoreq) > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (((long) num_lessoreq) == (long) num_lessoreq)); return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:10.653091800 +0100\n+++ /tmp/tmpiz0yubft.java\t2023-03-24 21:49:10.653091800 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq) == (long) num_lessoreq)); return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (final int num_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:12.349086156 +0100\n+++ /tmp/tmp0r2ypdq6.java\t2023-03-24 21:49:12.353086142 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (final int num_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (StringUtils.isNotEmpty(num_lessoreq)) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:14.033080550 +0100\n+++ /tmp/tmpail_he7b.java\t2023-03-24 21:49:14.033080550 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (StringUtils.isNotEmpty(num_lessoreq)) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (min_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:15.797074675 +0100\n+++ /tmp/tmphdam8dzx.java\t2023-03-24 21:49:15.797074675 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (min_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (values.size() > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:17.557068812 +0100\n+++ /tmp/tmpigwyc8wf.java\t2023-03-24 21:49:17.557068812 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (values.size() > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (above.size() >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:19.329062904 +0100\n+++ /tmp/tmpak5k7wo0.java\t2023-03-24 21:49:19.329062904 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (above.size() >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (l > num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:21.217056611 +0100\n+++ /tmp/tmpkd9xvtt5.java\t2023-03-24 21:49:21.217056611 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (l > num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:23.005050649 +0100\n+++ /tmp/tmprmc72oot.java\t2023-03-24 21:49:23.005050649 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (static_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:25.069043760 +0100\n+++ /tmp/tmpdka3a6qd.java\t2023-03-24 21:49:25.069043760 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (static_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (l >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:27.633035201 +0100\n+++ /tmp/tmpq71lve1v.java\t2023-03-24 21:49:27.817034587 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (l >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (StringUtils.isNotEmpty(num_lessoreq)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:29.753028123 +0100\n+++ /tmp/tmp7ctt3e6k.java\t2023-03-24 21:49:29.845027814 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (StringUtils.isNotEmpty(num_lessoreq)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:32.069020383 +0100\n+++ /tmp/tmpmkv82egg.java\t2023-03-24 21:49:32.069020383 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (above.size() < num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:36.565005353 +0100\n+++ /tmp/tmpfoyjkb_i.java\t2023-03-24 21:49:36.565005353 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (above.size() < num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq)); return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:41.376989252 +0100\n+++ /tmp/tmptko10kzn.java\t2023-03-24 21:49:41.376989252 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq)); return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (Math.abs(num_lessoreq) > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:43.908980773 +0100\n+++ /tmp/tmpfnuaq9bo.java\t2023-03-24 21:49:44.012980423 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (((long) num_lessoreq) == 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:46.296972772 +0100\n+++ /tmp/tmpe4hc0qyn.java\t2023-03-24 21:49:46.296972772 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq) == 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (values.size() == num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:48.204966376 +0100\n+++ /tmp/tmppry8wv76.java\t2023-03-24 21:49:48.316966003 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (values.size() == num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (above.size() < num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:50.936957218 +0100\n+++ /tmp/tmpi_836mog.java\t2023-03-24 21:49:50.936957218 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (above.size() < num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (values.size() > num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:53.400948951 +0100\n+++ /tmp/tmpaui69h2j.java\t2023-03-24 21:49:53.400948951 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (values.size() > num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (get(num_lessoreq) == null) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:55.692941260 +0100\n+++ /tmp/tmpacmk8umf.java\t2023-03-24 21:49:55.692941260 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (get(num_lessoreq) == null) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (Math.abs( num_lessoreq) > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:49:58.004933497 +0100\n+++ /tmp/tmpmkx30zpy.java\t2023-03-24 21:49:58.004933497 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs( num_lessoreq) > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (((long) num_lessoreq) num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:00.268925893 +0100\n+++ /tmp/tmppfs9k363.java\t2023-03-24 21:50:00.268925893 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (((long) num_lessoreq) num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (l > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:01.940920274 +0100\n+++ /tmp/tmp6u4bwzcq.java\t2023-03-24 21:50:02.096919749 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (l > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (StringUtils.hasText(num_lessoreq)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:04.224912597 +0100\n+++ /tmp/tmp7afwehpp.java\t2023-03-24 21:50:04.224912597 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (StringUtils.hasText(num_lessoreq)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if ((\"/\".equals(num_lessoreq)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:06.732904163 +0100\n+++ /tmp/tmpg5t0lm_9.java\t2023-03-24 21:50:06.736904149 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ((\"/\".equals(num_lessoreq)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:08.524898133 +0100\n+++ /tmp/tmpqa_tiou4.java\t2023-03-24 21:50:08.524898133 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (above.size() == num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:10.660890946 +0100\n+++ /tmp/tmp6rhlbtdb.java\t2023-03-24 21:50:10.660890946 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (above.size() == num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (get(num_lessoreq).isPresent()) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:12.968883175 +0100\n+++ /tmp/tmp8qz0d4f5.java\t2023-03-24 21:50:12.968883175 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (get(num_lessoreq).isPresent()) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (get(num_lessoreq) > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:15.128875899 +0100\n+++ /tmp/tmp_2gibzcs.java\t2023-03-24 21:50:15.244875510 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (get(num_lessoreq) > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "try { return kth(above, k); } catch (final Exception e) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:17.796866910 +0100\n+++ /tmp/tmp9d2drdkr.java\t2023-03-24 21:50:17.796866910 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+try { return kth(above, k); } catch (final Exception e) { }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (Math.max(num_lessoreq, num_lessoreq)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:19.764860277 +0100\n+++ /tmp/tmplyziersb.java\t2023-03-24 21:50:19.764860277 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, num_lessoreq)); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (get(num_lessoreq) == 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:22.140852265 +0100\n+++ /tmp/tmpctqfshd6.java\t2023-03-24 21:50:22.244851913 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (get(num_lessoreq) == 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (li == num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:24.648843803 +0100\n+++ /tmp/tmpso8ih3wb.java\t2023-03-24 21:50:24.652843792 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (li == num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (iterator.hasNext()) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:27.492834205 +0100\n+++ /tmp/tmpvmg8abi8.java\t2023-03-24 21:50:27.496834190 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (iterator.hasNext()) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (r == num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:29.472827519 +0100\n+++ /tmp/tmppwf0cziz.java\t2023-03-24 21:50:29.472827519 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (r == num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (doc!= null) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:31.768819765 +0100\n+++ /tmp/tmpmr3392k0.java\t2023-03-24 21:50:31.768819765 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (doc!= null) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (l < num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:33.836812775 +0100\n+++ /tmp/tmp0cjbwtxb.java\t2023-03-24 21:50:33.836812775 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (l < num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (prettyPrint) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:35.916805745 +0100\n+++ /tmp/tmpdeqp5jb8.java\t2023-03-24 21:50:35.916805745 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (prettyPrint) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (log!= null) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:37.652799876 +0100\n+++ /tmp/tmpne6frgq8.java\t2023-03-24 21:50:37.652799876 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (log!= null) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (above.isEmpty()) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:39.412793923 +0100\n+++ /tmp/tmpzptalv50.java\t2023-03-24 21:50:39.768792717 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (above.isEmpty()) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (diff!= 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:41.428787103 +0100\n+++ /tmp/tmpjenporh9.java\t2023-03-24 21:50:41.428787103 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (diff!= 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (remaining > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:43.224781024 +0100\n+++ /tmp/tmpg7yfvyeg.java\t2023-03-24 21:50:43.224781024 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (remaining > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if ( counts.isEmpty()) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:45.768772409 +0100\n+++ /tmp/tmpn_3fqdzh.java\t2023-03-24 21:50:45.768772409 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( counts.isEmpty()) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (dirty) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:47.528766450 +0100\n+++ /tmp/tmpdaranyqk.java\t2023-03-24 21:50:47.528766450 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (dirty) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:50.012758033 +0100\n+++ /tmp/tmp7tl77ksf.java\t2023-03-24 21:50:50.012758033 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "return kth(relation, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:52.112750915 +0100\n+++ /tmp/tmpia4om8ff.java\t2023-03-24 21:50:52.112750915 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(relation, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "return kth(Inventory, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:54.284743552 +0100\n+++ /tmp/tmpq0gl03v3.java\t2023-03-24 21:50:54.284743552 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(Inventory, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "return kth(callback, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:56.388736415 +0100\n+++ /tmp/tmp8gerl2r0.java\t2023-03-24 21:50:56.452736198 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(callback, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return kth( 900, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:50:58.664728693 +0100\n+++ /tmp/tmpnw11q2lk.java\t2023-03-24 21:50:58.664728693 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth( 900, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "return kth(Levels, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:51:01.264719867 +0100\n+++ /tmp/tmpxne3z7ff.java\t2023-03-24 21:51:01.264719867 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(Levels, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "return kth(ious, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:51:03.048713811 +0100\n+++ /tmp/tmp2h33lnak.java\t2023-03-24 21:51:03.048713811 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(ious, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "return kth(gram, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:51:04.916707466 +0100\n+++ /tmp/tmpwjh5xio4.java\t2023-03-24 21:51:04.920707452 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(gram, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "return kth(LAB, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:51:06.788701105 +0100\n+++ /tmp/tmp1l8ww6j7.java\t2023-03-24 21:51:06.788701105 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(LAB, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return kth(There, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:51:08.588694986 +0100\n+++ /tmp/tmprzndu54k.java\t2023-03-24 21:51:08.588694986 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(There, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "return kth(ANGE, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:51:10.408688801 +0100\n+++ /tmp/tmpup297yrs.java\t2023-03-24 21:51:10.408688801 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(ANGE, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return kth(combo, k);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 21:51:12.164682828 +0100\n+++ /tmp/tmp18umyra8.java\t2023-03-24 21:51:12.164682828 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+return kth(combo, k);\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return kth(above, k-num_lessoreq);"
    },
    "next_permutation": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (perm.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:28.632830357 +0100\n+++ /tmp/tmpazfx3kct.java\t2023-03-24 21:50:29.236828317 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:35.084808558 +0100\n+++ /tmp/tmp_wdt4aoe.java\t2023-03-24 21:50:35.084808558 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (relative.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:40.856789037 +0100\n+++ /tmp/tmpum3weu1y.java\t2023-03-24 21:50:40.856789037 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (perm.get(j) == perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:43.312780726 +0100\n+++ /tmp/tmp6fad6s6n.java\t2023-03-24 21:50:43.312780726 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) == perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (perm.get(j) > perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:45.140774537 +0100\n+++ /tmp/tmpw14389ob.java\t2023-03-24 21:50:45.276774077 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) > perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": true
            },
            {
                "k": 6,
                "tentative_fix": "if (row.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:50.536756258 +0100\n+++ /tmp/tmplid1nltv.java\t2023-03-24 21:50:50.540756244 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (row.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (perm.get(j) < perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:52.724748841 +0100\n+++ /tmp/tmpva0mvrku.java\t2023-03-24 21:50:52.728748826 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) < perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (filter.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:54.316743444 +0100\n+++ /tmp/tmpdouucqlo.java\t2023-03-24 21:50:54.316743444 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (filter.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (j.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:56.652735518 +0100\n+++ /tmp/tmp0bd7vfka.java\t2023-03-24 21:50:56.652735518 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (perm.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:50:58.912727851 +0100\n+++ /tmp/tmpq7lvucf8.java\t2023-03-24 21:50:58.916727837 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (relative.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:03.360712751 +0100\n+++ /tmp/tmphgcuv4x3.java\t2023-03-24 21:51:03.360712751 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (ret.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:05.116706784 +0100\n+++ /tmp/tmp93mlpro_.java\t2023-03-24 21:51:05.116706784 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (ret.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (perm.get(j) == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:06.952700549 +0100\n+++ /tmp/tmp0x_x6lpa.java\t2023-03-24 21:51:06.952700549 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) == i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (visible.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:10.948686964 +0100\n+++ /tmp/tmpddsj70ov.java\t2023-03-24 21:51:10.948686964 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (visible.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (file.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:12.672681102 +0100\n+++ /tmp/tmps0628l5x.java\t2023-03-24 21:51:12.672681102 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (file.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (prefix.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:14.344675415 +0100\n+++ /tmp/tmpn7p3y3lh.java\t2023-03-24 21:51:14.344675415 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (prefix.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (relative.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:16.700667397 +0100\n+++ /tmp/tmpavjrgqyz.java\t2023-03-24 21:51:16.700667397 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (ent.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:19.032659460 +0100\n+++ /tmp/tmptiq01s5g.java\t2023-03-24 21:51:19.032659460 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (ent.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (((long) j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:21.052652581 +0100\n+++ /tmp/tmpzoxkqw9i.java\t2023-03-24 21:51:21.052652581 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (((long) j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (ret.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:25.224638369 +0100\n+++ /tmp/tmpv2y009u_.java\t2023-03-24 21:51:25.224638369 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (ret.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (perm.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:26.988632356 +0100\n+++ /tmp/tmpopwa5n0w.java\t2023-03-24 21:51:26.988632356 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:30.880619086 +0100\n+++ /tmp/tmp80qghc69.java\t2023-03-24 21:51:30.880619086 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (j.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:32.672612971 +0100\n+++ /tmp/tmpdruv08zm.java\t2023-03-24 21:51:32.676612960 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:34.496606749 +0100\n+++ /tmp/tmpvl3qs9b9.java\t2023-03-24 21:51:34.496606749 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (target.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:36.204600920 +0100\n+++ /tmp/tmpxf_ew1q5.java\t2023-03-24 21:51:36.208600906 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (target.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (relative.get(i) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:37.980594856 +0100\n+++ /tmp/tmpv7ed__bj.java\t2023-03-24 21:51:37.980594856 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(i) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (img.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:39.720588915 +0100\n+++ /tmp/tmp5f31qnap.java\t2023-03-24 21:51:39.720588915 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (img.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (j.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:41.524582753 +0100\n+++ /tmp/tmpnzust44u.java\t2023-03-24 21:51:41.524582753 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (perm.get(j) == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:43.296576698 +0100\n+++ /tmp/tmpb9wh5gjo.java\t2023-03-24 21:51:43.300576684 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (o.equals(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:45.064570656 +0100\n+++ /tmp/tmptx5fsmho.java\t2023-03-24 21:51:45.064570656 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (o.equals(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (filter.get(j) > perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:46.796564735 +0100\n+++ /tmp/tmp_3ylfdd6.java\t2023-03-24 21:51:46.796564735 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (filter.get(j) > perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (((long) j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:48.612558526 +0100\n+++ /tmp/tmp7aff8jb_.java\t2023-03-24 21:51:48.612558526 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (((long) j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (files.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:52.668544651 +0100\n+++ /tmp/tmp7kn7uua_.java\t2023-03-24 21:51:52.668544651 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (files.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (j.get(i) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:54.516538327 +0100\n+++ /tmp/tmp_2vxk7_a.java\t2023-03-24 21:51:54.520538312 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (rows.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:56.416531824 +0100\n+++ /tmp/tmpnh2m78mu.java\t2023-03-24 21:51:56.416531824 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (rows.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (filter.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:58.156525865 +0100\n+++ /tmp/tmpx0i2_apx.java\t2023-03-24 21:51:58.156525865 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (filter.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (component.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:51:59.896519906 +0100\n+++ /tmp/tmpgscj7upq.java\t2023-03-24 21:51:59.896519906 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (component.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (target.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:01.640513932 +0100\n+++ /tmp/tmpmdk7nae4.java\t2023-03-24 21:52:01.640513932 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (target.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (js.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:03.372507997 +0100\n+++ /tmp/tmpee85oru1.java\t2023-03-24 21:52:03.372507997 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (js.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (relative.get(j) > perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:05.036502294 +0100\n+++ /tmp/tmpt2_oh_qe.java\t2023-03-24 21:52:05.036502294 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(j) > perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (perm.get(j).get(i) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:06.700496588 +0100\n+++ /tmp/tmpopy8foqo.java\t2023-03-24 21:52:06.700496588 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j).get(i) > 0) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (perm.get(i) < perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:08.464490541 +0100\n+++ /tmp/tmpei8evhfo.java\t2023-03-24 21:52:08.464490541 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(i) < perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (perm.get(i) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:12.524476612 +0100\n+++ /tmp/tmpqh7wpi5x.java\t2023-03-24 21:52:12.524476612 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(i) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (obj.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:16.704462266 +0100\n+++ /tmp/tmp_37l1wx7.java\t2023-03-24 21:52:16.704462266 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (obj.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (el.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:18.452456264 +0100\n+++ /tmp/tmpljcy_vvd.java\t2023-03-24 21:52:18.456456250 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (el.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (coordinates.get(j) == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:20.308449890 +0100\n+++ /tmp/tmpce69zg_r.java\t2023-03-24 21:52:20.308449890 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (coordinates.get(j) == i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if ( j.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:22.064443855 +0100\n+++ /tmp/tmp8b7t723u.java\t2023-03-24 21:52:22.068443844 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if ( j.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (src.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:23.788437932 +0100\n+++ /tmp/tmp2wf9h8wo.java\t2023-03-24 21:52:23.788437932 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (src.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (row.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:25.544431898 +0100\n+++ /tmp/tmprfs9uvjb.java\t2023-03-24 21:52:25.548431884 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (row.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (comparator.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:27.272425956 +0100\n+++ /tmp/tmphs_uacpy.java\t2023-03-24 21:52:27.276425942 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (comparator.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (perm.get(j) > perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:29.080419740 +0100\n+++ /tmp/tmpfz8hvowm.java\t2023-03-24 21:52:29.080419740 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) > perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (visible.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:30.772413919 +0100\n+++ /tmp/tmps3dr5ayg.java\t2023-03-24 21:52:30.772413919 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (visible.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (event.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:32.604407617 +0100\n+++ /tmp/tmpo6i5qcsf.java\t2023-03-24 21:52:32.604407617 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (event.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (o.equals(j) || i.equals(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:34.416401382 +0100\n+++ /tmp/tmpm63aaigw.java\t2023-03-24 21:52:34.416401382 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (o.equals(j) || i.equals(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (file.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:36.204395227 +0100\n+++ /tmp/tmpztfdyif0.java\t2023-03-24 21:52:36.204395227 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (file.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (prefix.equals(perm.get(i).getValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:37.936389264 +0100\n+++ /tmp/tmpre9ko5ww.java\t2023-03-24 21:52:37.936389264 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (prefix.equals(perm.get(i).getValue())) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (((long) j) == perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:39.684383246 +0100\n+++ /tmp/tmp4fs25hup.java\t2023-03-24 21:52:39.684383246 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (((long) j) == perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (ret.get(j) == perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:41.388377376 +0100\n+++ /tmp/tmpm8ge0o8e.java\t2023-03-24 21:52:41.392377362 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (ret.get(j) == perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (Report.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:43.024371741 +0100\n+++ /tmp/tmpbujrhgur.java\t2023-03-24 21:52:43.028371727 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (Report.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (relative.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:44.784365674 +0100\n+++ /tmp/tmpqynk1dmx.java\t2023-03-24 21:52:44.784365674 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (relative.get(j) == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:46.560359555 +0100\n+++ /tmp/tmp4coo_vrw.java\t2023-03-24 21:52:46.560359555 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(j) == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (perm.get(j).get(i - 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:48.320353487 +0100\n+++ /tmp/tmpdi9lpx4_.java\t2023-03-24 21:52:48.320353487 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j).get(i - 1)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (Report.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:50.076347432 +0100\n+++ /tmp/tmpf9mo3p28.java\t2023-03-24 21:52:50.080347418 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (Report.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (comparator.get(j) == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:51.832341374 +0100\n+++ /tmp/tmp9sfxszv6.java\t2023-03-24 21:52:51.832341374 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (comparator.get(j) == i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (ret.get(j) == perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:53.584335332 +0100\n+++ /tmp/tmpsi4r4_mz.java\t2023-03-24 21:52:53.584335332 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (ret.get(j) == perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (!next_perm.get(j) == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:55.384329120 +0100\n+++ /tmp/tmpqgkap6i2.java\t2023-03-24 21:52:55.384329120 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) == i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (StringUtils.isNotEmpty(perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:57.112323155 +0100\n+++ /tmp/tmpfole4ldi.java\t2023-03-24 21:52:57.112323155 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (StringUtils.isNotEmpty(perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (perm.get(j) == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:52:58.944316833 +0100\n+++ /tmp/tmpkz24rp0u.java\t2023-03-24 21:52:58.944316833 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) == null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (perm.get(j)!= i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:02.956302978 +0100\n+++ /tmp/tmpr66kuhon.java\t2023-03-24 21:53:02.956302978 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j)!= i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (comparator.compare(row.get(j) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:07.244288162 +0100\n+++ /tmp/tmpctlsamn7.java\t2023-03-24 21:53:07.244288162 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (comparator.compare(row.get(j) > 0) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (j.get(j) == perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:09.024282010 +0100\n+++ /tmp/tmpysyenwmw.java\t2023-03-24 21:53:09.024282010 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) == perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (o.equals(perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:10.764275995 +0100\n+++ /tmp/tmpqb3xrsib.java\t2023-03-24 21:53:10.768275981 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (o.equals(perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (comparator.compare(new ArrayList<Integer>() {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:12.588269688 +0100\n+++ /tmp/tmpz3qjob1k.java\t2023-03-24 21:53:12.588269688 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (comparator.compare(new ArrayList<Integer>() {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (o.equals(\".\") || i.equals(\"..\")) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:14.324263683 +0100\n+++ /tmp/tmp_38p_21h.java\t2023-03-24 21:53:14.324263683 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (o.equals(\".\") || i.equals(\"..\")) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (coordinates.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:16.120257470 +0100\n+++ /tmp/tmpp6a1b_rd.java\t2023-03-24 21:53:16.132257428 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (coordinates.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (ret.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:17.900251311 +0100\n+++ /tmp/tmpda0ynr5b.java\t2023-03-24 21:53:17.900251311 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (ret.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (!(j.get(i) instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:19.684245137 +0100\n+++ /tmp/tmparumza7b.java\t2023-03-24 21:53:19.688245123 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!(j.get(i) instanceof Integer)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (o.equals(perm.get(i).getValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:21.488238892 +0100\n+++ /tmp/tmpi6_tw8y6.java\t2023-03-24 21:53:21.488238892 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (o.equals(perm.get(i).getValue())) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (!(j instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:23.260232756 +0100\n+++ /tmp/tmphe9x44gh.java\t2023-03-24 21:53:23.260232756 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!(j instanceof Integer)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (!(perm.get(j) instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:25.132226274 +0100\n+++ /tmp/tmp5zwwnk2g.java\t2023-03-24 21:53:25.136226260 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!(perm.get(j) instanceof Integer)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (filter.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:29.260211972 +0100\n+++ /tmp/tmpek5iwcx6.java\t2023-03-24 21:53:29.260211972 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (filter.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (get(j) == perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:31.152205416 +0100\n+++ /tmp/tmp8r4wdllk.java\t2023-03-24 21:53:31.152205416 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (get(j) == perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (isNotEmpty(perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:32.896199371 +0100\n+++ /tmp/tmpr2dc1nnw.java\t2023-03-24 21:53:32.896199371 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (isNotEmpty(perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (filter.get(j) > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:34.676193198 +0100\n+++ /tmp/tmp85n6_5c1.java\t2023-03-24 21:53:34.676193198 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (filter.get(j) > j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (j.get(j) == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:36.488186915 +0100\n+++ /tmp/tmpnkce765y.java\t2023-03-24 21:53:36.488186915 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (prefix.equals(perm.get(i - 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:38.348180464 +0100\n+++ /tmp/tmpq08ni25c.java\t2023-03-24 21:53:38.348180464 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (prefix.equals(perm.get(i - 1)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (relative.get(j) == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:40.000174732 +0100\n+++ /tmp/tmpngibhtm8.java\t2023-03-24 21:53:40.000174732 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (relative.get(j) == i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (obj.get(j) == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:41.740168694 +0100\n+++ /tmp/tmpshvq458k.java\t2023-03-24 21:53:41.740168694 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (obj.get(j) == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (filter.get(j) == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:43.564162364 +0100\n+++ /tmp/tmptqc9lq85.java\t2023-03-24 21:53:43.564162364 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (filter.get(j) == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (isArray(perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:45.356156144 +0100\n+++ /tmp/tmpc0ux6pbj.java\t2023-03-24 21:53:45.356156144 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (isArray(perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (possible.get(j) == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:47.140149950 +0100\n+++ /tmp/tmp1073_8no.java\t2023-03-24 21:53:47.140149950 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (possible.get(j) == null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (perm.get(j) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:48.900143838 +0100\n+++ /tmp/tmp8knahjqr.java\t2023-03-24 21:53:48.900143838 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) > 0) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (perm.get(j)!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:52.904129928 +0100\n+++ /tmp/tmpppivafkf.java\t2023-03-24 21:53:52.904129928 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j)!= null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (ret.get(j) == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:57.016115637 +0100\n+++ /tmp/tmp0b876k8r.java\t2023-03-24 21:53:57.016115637 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (ret.get(j) == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:53:58.832109324 +0100\n+++ /tmp/tmptk9zbgnu.java\t2023-03-24 21:53:58.832109324 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (isIncludable(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:54:00.648103009 +0100\n+++ /tmp/tmp_fvg_ry4.java\t2023-03-24 21:54:00.652102995 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (isIncludable(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (get(j) == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:54:02.416096859 +0100\n+++ /tmp/tmpfkxjawou.java\t2023-03-24 21:54:02.420096845 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (get(j) == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (rows.equals(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:54:04.160090793 +0100\n+++ /tmp/tmp2h956e3x.java\t2023-03-24 21:54:04.160090793 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (rows.equals(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (o1.equals(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:54:05.944084585 +0100\n+++ /tmp/tmpcnn_hqv8.java\t2023-03-24 21:54:05.944084585 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (o1.equals(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (entry.getValue() == perm) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 21:54:07.676078559 +0100\n+++ /tmp/tmp2_cqyo6r.java\t2023-03-24 21:54:07.680078545 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (entry.getValue() == perm) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (perm.get(j) > perm.get(i)) {"
    },
    "shunting_yard": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:19.764656967 +0100\n+++ /tmp/tmpuk3vjg5_.java\t2023-03-24 21:51:19.796656859 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:21.476651138 +0100\n+++ /tmp/tmpqnw136xd.java\t2023-03-24 21:51:21.476651138 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:23.152645427 +0100\n+++ /tmp/tmph0e_rs7o.java\t2023-03-24 21:51:23.156645415 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:24.952639296 +0100\n+++ /tmp/tmp7r3mpf4w.java\t2023-03-24 21:51:24.952639296 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:26.724633257 +0100\n+++ /tmp/tmprxgfpq92.java\t2023-03-24 21:51:26.724633257 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:28.500627202 +0100\n+++ /tmp/tmp0gy6bbh2.java\t2023-03-24 21:51:28.504627188 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:30.240621268 +0100\n+++ /tmp/tmp5wqh712i.java\t2023-03-24 21:51:30.244621253 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:32.056615075 +0100\n+++ /tmp/tmp2b7d4wy6.java\t2023-03-24 21:51:32.060615061 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:33.748609301 +0100\n+++ /tmp/tmpjdbeus6v.java\t2023-03-24 21:51:33.748609301 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:35.468603432 +0100\n+++ /tmp/tmp_vu2y6ni.java\t2023-03-24 21:51:35.468603432 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:37.352597001 +0100\n+++ /tmp/tmpbxvrdnd7.java\t2023-03-24 21:51:37.352597001 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:39.104591018 +0100\n+++ /tmp/tmpqcsx38td.java\t2023-03-24 21:51:39.104591018 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:40.772585322 +0100\n+++ /tmp/tmpe0wf0sdj.java\t2023-03-24 21:51:40.776585308 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:42.512579377 +0100\n+++ /tmp/tmpkxxu2fex.java\t2023-03-24 21:51:42.512579377 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:44.260573404 +0100\n+++ /tmp/tmpc9vwpmsu.java\t2023-03-24 21:51:44.260573404 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 0); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:46.004567444 +0100\n+++ /tmp/tmphf86asao.java\t2023-03-24 21:51:46.004567444 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 0); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:47.652561809 +0100\n+++ /tmp/tmpibb6k7l4.java\t2023-03-24 21:51:47.652561809 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:49.432555722 +0100\n+++ /tmp/tmpr0llqncf.java\t2023-03-24 21:51:49.432555722 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:51.136549893 +0100\n+++ /tmp/tmphmfdr_o3.java\t2023-03-24 21:51:51.136549893 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:52.796544214 +0100\n+++ /tmp/tmprivm2j31.java\t2023-03-24 21:51:52.796544214 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\"); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:54.556538190 +0100\n+++ /tmp/tmpa68gl0oi.java\t2023-03-24 21:51:54.560538176 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:56.304532207 +0100\n+++ /tmp/tmpnjsmmpvm.java\t2023-03-24 21:51:56.304532207 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:58.000526400 +0100\n+++ /tmp/tmpt7x6zm8j.java\t2023-03-24 21:51:58.000526400 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:51:59.720520510 +0100\n+++ /tmp/tmp04vcgomw.java\t2023-03-24 21:51:59.724520496 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:01.372514850 +0100\n+++ /tmp/tmppqt2oz1g.java\t2023-03-24 21:52:01.376514836 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:03.044509119 +0100\n+++ /tmp/tmp3hmlocpo.java\t2023-03-24 21:52:03.044509119 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:04.736503323 +0100\n+++ /tmp/tmp80dfudl7.java\t2023-03-24 21:52:04.736503323 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\"); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:06.404497605 +0100\n+++ /tmp/tmpdkzmiimx.java\t2023-03-24 21:52:06.404497605 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:08.140491652 +0100\n+++ /tmp/tmpdbkp5r8y.java\t2023-03-24 21:52:08.140491652 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:09.864485740 +0100\n+++ /tmp/tmpy0o0u7z_.java\t2023-03-24 21:52:09.864485740 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:11.560479921 +0100\n+++ /tmp/tmpcwpslgfu.java\t2023-03-24 21:52:11.560479921 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:13.320473882 +0100\n+++ /tmp/tmpmn8mlls2.java\t2023-03-24 21:52:13.320473882 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:15.004468103 +0100\n+++ /tmp/tmphxumy9vs.java\t2023-03-24 21:52:15.004468103 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:16.720462209 +0100\n+++ /tmp/tmpfgi5u9xw.java\t2023-03-24 21:52:16.720462209 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); continue; }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:18.544455946 +0100\n+++ /tmp/tmpra0x8pza.java\t2023-03-24 21:52:18.548455935 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1;\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:20.288449958 +0100\n+++ /tmp/tmp0cavjeig.java\t2023-03-24 21:52:20.288449958 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:22.020444008 +0100\n+++ /tmp/tmpntggtyoh.java\t2023-03-24 21:52:22.020444008 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:23.756438042 +0100\n+++ /tmp/tmpp3gappzy.java\t2023-03-24 21:52:23.756438042 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:25.432432283 +0100\n+++ /tmp/tmpfj7j3mem.java\t2023-03-24 21:52:25.432432283 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:27.228426109 +0100\n+++ /tmp/tmpvqzwq6gg.java\t2023-03-24 21:52:27.228426109 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:28.956420165 +0100\n+++ /tmp/tmpx05ejy7d.java\t2023-03-24 21:52:28.956420165 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:30.744414016 +0100\n+++ /tmp/tmp5bke4ewn.java\t2023-03-24 21:52:30.744414016 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); } }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:32.532407863 +0100\n+++ /tmp/tmp_hdk18ir.java\t2023-03-24 21:52:32.536407852 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:34.252401944 +0100\n+++ /tmp/tmpjwsxvgqg.java\t2023-03-24 21:52:34.252401944 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); return new ArrayList(100); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:35.972396026 +0100\n+++ /tmp/tmply9100h7.java\t2023-03-24 21:52:35.972396026 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); return new ArrayList(100); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:37.648390256 +0100\n+++ /tmp/tmptrywv_j7.java\t2023-03-24 21:52:37.652390242 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); continue; }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:39.368384334 +0100\n+++ /tmp/tmpz82uxuj5.java\t2023-03-24 21:52:39.372384320 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 0); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:41.136378244 +0100\n+++ /tmp/tmpkmw2ubrj.java\t2023-03-24 21:52:41.136378244 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); continue; }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:42.860372306 +0100\n+++ /tmp/tmph_6aodmt.java\t2023-03-24 21:52:42.860372306 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:44.728365869 +0100\n+++ /tmp/tmpzvrvw5x_.java\t2023-03-24 21:52:44.728365869 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:46.440359968 +0100\n+++ /tmp/tmp8q8j2e0v.java\t2023-03-24 21:52:46.444359954 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); } }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", \"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:48.096354259 +0100\n+++ /tmp/tmpn70cv32i.java\t2023-03-24 21:52:48.096354259 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", \"\"); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:49.952347858 +0100\n+++ /tmp/tmp6y3_u1uw.java\t2023-03-24 21:52:49.952347858 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:51.676341914 +0100\n+++ /tmp/tmpijivzoyc.java\t2023-03-24 21:52:51.680341900 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:53.464335746 +0100\n+++ /tmp/tmpkcatfx_0.java\t2023-03-24 21:52:53.464335746 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"*\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:55.188329798 +0100\n+++ /tmp/tmp_qi6wrp1.java\t2023-03-24 21:52:55.188329798 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"*\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", Character.class.getName());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:56.888323929 +0100\n+++ /tmp/tmpbpthqv1p.java\t2023-03-24 21:52:56.892323914 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", Character.class.getName());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:52:58.544318213 +0100\n+++ /tmp/tmpr04smtue.java\t2023-03-24 21:52:58.544318213 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:00.268312261 +0100\n+++ /tmp/tmpynl05swh.java\t2023-03-24 21:53:00.268312261 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"*\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:02.044306129 +0100\n+++ /tmp/tmphwuknggt.java\t2023-03-24 21:53:02.048306115 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); continue; }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:03.728300311 +0100\n+++ /tmp/tmp41zqfq49.java\t2023-03-24 21:53:03.728300311 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2\"); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:05.420294466 +0100\n+++ /tmp/tmpjy2cq__p.java\t2023-03-24 21:53:05.420294466 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2\"); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:07.292287995 +0100\n+++ /tmp/tmplvc71mbn.java\t2023-03-24 21:53:07.292287995 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:09.044281940 +0100\n+++ /tmp/tmp_5wfbd6h.java\t2023-03-24 21:53:09.044281940 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:10.768275981 +0100\n+++ /tmp/tmpa3x3w0w3.java\t2023-03-24 21:53:10.768275981 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", new ArrayList(100);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:12.492270020 +0100\n+++ /tmp/tmpp70yoem4.java\t2023-03-24 21:53:12.492270020 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", new ArrayList(100);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:14.308263739 +0100\n+++ /tmp/tmp4z9nzaqx.java\t2023-03-24 21:53:14.308263739 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1;\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"*\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:16.044257732 +0100\n+++ /tmp/tmpsybdpb7h.java\t2023-03-24 21:53:16.048257718 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"*\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:17.800251658 +0100\n+++ /tmp/tmp_yqem_f_.java\t2023-03-24 21:53:17.804251644 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:19.568245536 +0100\n+++ /tmp/tmp0pmx31wz.java\t2023-03-24 21:53:19.568245536 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:21.332239430 +0100\n+++ /tmp/tmp7t1lfq_n.java\t2023-03-24 21:53:21.332239430 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1; }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:23.028233559 +0100\n+++ /tmp/tmp97222n66.java\t2023-03-24 21:53:23.028233559 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:24.712227728 +0100\n+++ /tmp/tmpk8ov2ens.java\t2023-03-24 21:53:24.712227728 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", 1); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:26.436221756 +0100\n+++ /tmp/tmptuq4thxd.java\t2023-03-24 21:53:26.440221742 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 1); precedence.put(\"/\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:28.100215990 +0100\n+++ /tmp/tmpjmz9z9sv.java\t2023-03-24 21:53:28.100215990 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\", 1); precedence.put(\"/\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:29.852209922 +0100\n+++ /tmp/tmpqq0nsnok.java\t2023-03-24 21:53:29.852209922 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:31.492204237 +0100\n+++ /tmp/tmp0_3ouc_f.java\t2023-03-24 21:53:31.492204237 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:33.116198608 +0100\n+++ /tmp/tmpa703pdcr.java\t2023-03-24 21:53:33.116198608 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", \"\"); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:34.784192824 +0100\n+++ /tmp/tmpdcjinabe.java\t2023-03-24 21:53:34.784192824 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"\"); precedence.put(\"/\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:36.500186873 +0100\n+++ /tmp/tmpqifgy9m3.java\t2023-03-24 21:53:36.500186873 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\",\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:38.248180811 +0100\n+++ /tmp/tmpiihhtycy.java\t2023-03-24 21:53:38.248180811 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\",\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:39.960174869 +0100\n+++ /tmp/tmp7mdc_wm6.java\t2023-03-24 21:53:39.960174869 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 0); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:41.676168916 +0100\n+++ /tmp/tmp5ew4hkpb.java\t2023-03-24 21:53:41.676168916 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:43.456162740 +0100\n+++ /tmp/tmp2vw96pcp.java\t2023-03-24 21:53:43.460162726 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); } }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\",2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:45.128156935 +0100\n+++ /tmp/tmpyvljbg6w.java\t2023-03-24 21:53:45.128156935 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); precedence.put(\"/\",2); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:46.812151089 +0100\n+++ /tmp/tmprkscf5uq.java\t2023-03-24 21:53:46.812151089 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2; }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 1); 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:48.588144921 +0100\n+++ /tmp/tmptqbx16ih.java\t2023-03-24 21:53:48.588144921 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0); precedence.put(\"/\", 1); 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); precedence.put(\"/\", \"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:50.292139002 +0100\n+++ /tmp/tmpd_m5u2rs.java\t2023-03-24 21:53:50.328138878 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\",2); precedence.put(\"/\", \"\"); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", new ArrayList(100); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:52.104132708 +0100\n+++ /tmp/tmpf4wlsqty.java\t2023-03-24 21:53:52.104132708 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", new ArrayList(100); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", Character.class.getName()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:53.820126745 +0100\n+++ /tmp/tmp1hh58cbd.java\t2023-03-24 21:53:53.820126745 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", Character.class.getName()); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); precedence.put(\"/\", \"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:55.508120879 +0100\n+++ /tmp/tmpah5b95mr.java\t2023-03-24 21:53:55.508120879 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); precedence.put(\"/\", 1); precedence.put(\"/\", \"\"); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1, precedence.get(\"*\",2); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:57.196115012 +0100\n+++ /tmp/tmpbt6r889r.java\t2023-03-24 21:53:57.200114998 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1, precedence.get(\"*\",2); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\",\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:53:58.900109088 +0100\n+++ /tmp/tmpam7uzqi0.java\t2023-03-24 21:53:58.900109088 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2); precedence.put(\"/\",\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\",2); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:54:00.616103119 +0100\n+++ /tmp/tmph0zojo34.java\t2023-03-24 21:54:00.616103119 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\",2); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2\"); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:54:02.340097123 +0100\n+++ /tmp/tmpg9dzfjj_.java\t2023-03-24 21:54:02.340097123 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2\"); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:54:04.104090987 +0100\n+++ /tmp/tmpjwtilxl4.java\t2023-03-24 21:54:04.104090987 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"*\",2); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\",2); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:54:05.836084961 +0100\n+++ /tmp/tmpxxsyncb8.java\t2023-03-24 21:54:05.836084961 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\",2); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"/\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:54:07.580078893 +0100\n+++ /tmp/tmp6ip02dzp.java\t2023-03-24 21:54:07.584078879 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", \"/\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", element);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:54:09.280072975 +0100\n+++ /tmp/tmpehla298d.java\t2023-03-24 21:54:09.280072975 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\", element);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); return rp; } }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 21:54:11.152066458 +0100\n+++ /tmp/tmp2xzgsq7_.java\t2023-03-24 21:54:11.156066444 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1); precedence.put(\"/\",2); return rp; } }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "precedence.put(\"+\", 1); precedence.put(\"-\", 1); precedence.put(\"*\", 2); precedence.put(\"/\", 2); ArrayList rpntokens = new ArrayList(100); ArrayDeque opstack = new ArrayDeque(); for (Object token : tokens) { if (Integer.class.isInstance(token)) { // cover also Double case I guess? rpntokens.add((Integer) token); } else { String operator = (String) token; while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) { rpntokens.add(opstack.pop()); } opstack.push(token); }"
    },
    "possible_change": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (total.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:11.296065957 +0100\n+++ /tmp/tmpstkcgjt6.java\t2023-03-24 21:54:11.296065957 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (dirty.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:13.096059688 +0100\n+++ /tmp/tmpiijccdd7.java\t2023-03-24 21:54:13.096059688 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (dirty.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (total < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:14.820053685 +0100\n+++ /tmp/tmp9ce_hzs1.java\t2023-03-24 21:54:14.824053671 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (columns.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:18.740040028 +0100\n+++ /tmp/tmp82069vn9.java\t2023-03-24 21:54:18.740040028 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (columns.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if ( total.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:20.540033755 +0100\n+++ /tmp/tmptzs35_qd.java\t2023-03-24 21:54:20.540033755 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( total.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (values.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:22.260027761 +0100\n+++ /tmp/tmpgixrqfqd.java\t2023-03-24 21:54:22.260027761 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (values.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (coin.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:23.972021792 +0100\n+++ /tmp/tmp7y6nuk9c.java\t2023-03-24 21:54:23.976021778 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (coin.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (total.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:25.796015432 +0100\n+++ /tmp/tmp1z7x5hk0.java\t2023-03-24 21:54:25.800015418 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if ( total.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:27.528009392 +0100\n+++ /tmp/tmp0ujsyy7z.java\t2023-03-24 21:54:27.528009392 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( total.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (min < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:29.432002750 +0100\n+++ /tmp/tmphubphvsm.java\t2023-03-24 21:54:29.432002750 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (min < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (compression.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:31.023997196 +0100\n+++ /tmp/tmpj8ocokfa.java\t2023-03-24 21:54:31.023997196 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (compression.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if ( thread.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:32.447992227 +0100\n+++ /tmp/tmp5tn2advi.java\t2023-03-24 21:54:32.447992227 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( thread.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if ( gender.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:34.035986686 +0100\n+++ /tmp/tmp1tn5i0hk.java\t2023-03-24 21:54:34.035986686 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( gender.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if ( total < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:35.535981450 +0100\n+++ /tmp/tmpmbyqeosj.java\t2023-03-24 21:54:35.535981450 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( total < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (Collectors.isPresent()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:39.143968854 +0100\n+++ /tmp/tmptc0dhs1r.java\t2023-03-24 21:54:39.143968854 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Collectors.isPresent()) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (try.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:40.763963197 +0100\n+++ /tmp/tmpfz7rh8h3.java\t2023-03-24 21:54:40.763963197 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (try.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (li < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:42.291957858 +0100\n+++ /tmp/tmpqcr02zr2.java\t2023-03-24 21:54:42.295957844 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (li < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (combo.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:44.051951711 +0100\n+++ /tmp/tmp98s0xo59.java\t2023-03-24 21:54:44.051951711 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (combo.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (fields.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:45.903945239 +0100\n+++ /tmp/tmpsyqlv04i.java\t2023-03-24 21:54:45.903945239 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (fields.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if ( isA.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:47.655939117 +0100\n+++ /tmp/tmpj3lfd6xk.java\t2023-03-24 21:54:47.655939117 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( isA.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (source.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:49.595932336 +0100\n+++ /tmp/tmpf03iu46i.java\t2023-03-24 21:54:49.599932322 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (source.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if ( cur.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:51.127926980 +0100\n+++ /tmp/tmpv8rx2uf0.java\t2023-03-24 21:54:51.131926966 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( cur.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (parts.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:52.603921820 +0100\n+++ /tmp/tmp5iyriizz.java\t2023-03-24 21:54:52.603921820 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (parts.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (child.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:54.119916518 +0100\n+++ /tmp/tmpevrtfhux.java\t2023-03-24 21:54:54.119916518 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (child.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (lause.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:55.611911301 +0100\n+++ /tmp/tmphor2ohgd.java\t2023-03-24 21:54:55.611911301 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (lause.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (izations.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:57.187905787 +0100\n+++ /tmp/tmp1b_67aj7.java\t2023-03-24 21:54:57.187905787 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (izations.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (child.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:54:58.783900204 +0100\n+++ /tmp/tmpdakh0uyq.java\t2023-03-24 21:54:58.783900204 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (child.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (items.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:00.527894102 +0100\n+++ /tmp/tmpndby3ecf.java\t2023-03-24 21:55:00.527894102 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (items.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (relation.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:02.107888569 +0100\n+++ /tmp/tmp19gvsfqv.java\t2023-03-24 21:55:02.107888569 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (relation.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (Restrictions.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:03.811882606 +0100\n+++ /tmp/tmpbudhmxyn.java\t2023-03-24 21:55:03.811882606 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Restrictions.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (rough.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:05.615876292 +0100\n+++ /tmp/tmp6wxp57fo.java\t2023-03-24 21:55:05.619876275 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (rough.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (content.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:07.423869960 +0100\n+++ /tmp/tmpwno22_xz.java\t2023-03-24 21:55:07.423869960 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (content.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (cur.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:09.143863936 +0100\n+++ /tmp/tmpobwm7ltx.java\t2023-03-24 21:55:09.143863936 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (cur.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if ( subType.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:10.699858485 +0100\n+++ /tmp/tmppakbidxu.java\t2023-03-24 21:55:10.699858485 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( subType.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (slice.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:12.175853314 +0100\n+++ /tmp/tmp2tj9jik6.java\t2023-03-24 21:55:12.179853300 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (slice.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (yellow.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:13.755847780 +0100\n+++ /tmp/tmptkb6j8ue.java\t2023-03-24 21:55:13.755847780 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (yellow.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (root.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:15.271842467 +0100\n+++ /tmp/tmpgztfv82h.java\t2023-03-24 21:55:15.271842467 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (root.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (FIER.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:16.763837239 +0100\n+++ /tmp/tmprlmbkkdl.java\t2023-03-24 21:55:16.767837225 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (FIER.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (IllegalArgument.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:18.323831771 +0100\n+++ /tmp/tmp14puikwd.java\t2023-03-24 21:55:18.323831771 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (IllegalArgument.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if ( isPresent.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:19.903826231 +0100\n+++ /tmp/tmpg34g7zye.java\t2023-03-24 21:55:19.903826231 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( isPresent.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if ( ee.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:21.503820621 +0100\n+++ /tmp/tmps1uyghht.java\t2023-03-24 21:55:21.503820621 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( ee.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (total.length > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:23.299814324 +0100\n+++ /tmp/tmpsd59ut13.java\t2023-03-24 21:55:23.303814310 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total.length > 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (field.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:25.055808164 +0100\n+++ /tmp/tmp6sem9cbm.java\t2023-03-24 21:55:25.055808164 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (field.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (Collectors.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:26.803802033 +0100\n+++ /tmp/tmp7gmz6583.java\t2023-03-24 21:55:26.803802033 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Collectors.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (fields.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:28.487796124 +0100\n+++ /tmp/tmplb9w7z7c.java\t2023-03-24 21:55:28.487796124 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (fields.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if ( resource.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:30.079790538 +0100\n+++ /tmp/tmpeu4ecoqy.java\t2023-03-24 21:55:30.083790524 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( resource.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if ( totalBytes.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:31.739784712 +0100\n+++ /tmp/tmpx7j16698.java\t2023-03-24 21:55:31.739784712 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( totalBytes.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (enumber.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:33.347779068 +0100\n+++ /tmp/tmp5rqgw1qg.java\t2023-03-24 21:55:33.347779068 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (enumber.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (content.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:34.971773367 +0100\n+++ /tmp/tmpbz827qza.java\t2023-03-24 21:55:34.971773367 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (content.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (started) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:36.703767285 +0100\n+++ /tmp/tmp9dg6bpu_.java\t2023-03-24 21:55:36.703767285 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (started) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (parent!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:38.463761105 +0100\n+++ /tmp/tmp392mqbct.java\t2023-03-24 21:55:38.463761105 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (parent!= null) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (amp.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:40.059755500 +0100\n+++ /tmp/tmphl7q1qba.java\t2023-03-24 21:55:40.063755486 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (amp.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (ald.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:41.767749500 +0100\n+++ /tmp/tmpjpzb_m55.java\t2023-03-24 21:55:41.771749486 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ald.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (CallExpression.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:43.219744399 +0100\n+++ /tmp/tmpfavcd4lm.java\t2023-03-24 21:55:43.219744399 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (CallExpression.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if ( jsonWriter.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:44.647739381 +0100\n+++ /tmp/tmp1f72vj_4.java\t2023-03-24 21:55:44.647739381 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jsonWriter.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if ( speech.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:46.019734560 +0100\n+++ /tmp/tmphjj34rza.java\t2023-03-24 21:55:46.019734560 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( speech.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (response.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:47.451729527 +0100\n+++ /tmp/tmplscqri2_.java\t2023-03-24 21:55:47.451729527 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (response.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if ( jt.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:48.963724213 +0100\n+++ /tmp/tmpw0pqyjxw.java\t2023-03-24 21:55:48.963724213 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jt.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (responseType == total) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:50.451718981 +0100\n+++ /tmp/tmpgws5qj5s.java\t2023-03-24 21:55:50.451718981 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (responseType == total) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if ( contentLength.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:51.931713779 +0100\n+++ /tmp/tmphmm500nd.java\t2023-03-24 21:55:51.931713779 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( contentLength.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (sch.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:53.523708179 +0100\n+++ /tmp/tmp1oatjssg.java\t2023-03-24 21:55:53.527708165 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (sch.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if ( total.length > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:55.091702666 +0100\n+++ /tmp/tmpi58pl4w6.java\t2023-03-24 21:55:55.091702666 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( total.length > 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (lause.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:56.595697376 +0100\n+++ /tmp/tmppl0vqgxh.java\t2023-03-24 21:55:56.595697376 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (lause.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (arguments.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:58.203691718 +0100\n+++ /tmp/tmpqk_qgx_m.java\t2023-03-24 21:55:58.203691718 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (arguments.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (cur.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:55:59.867685863 +0100\n+++ /tmp/tmp9j4hypjo.java\t2023-03-24 21:55:59.871685849 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (cur.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (child == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:01.495680136 +0100\n+++ /tmp/tmp4epq68rc.java\t2023-03-24 21:56:01.499680124 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (child == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (viewer.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:02.995674857 +0100\n+++ /tmp/tmpw2x_sg0k.java\t2023-03-24 21:56:02.995674857 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (viewer.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (dirty.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:05.127667352 +0100\n+++ /tmp/tmplbsw40r7.java\t2023-03-24 21:56:05.127667352 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (dirty.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if ( total.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:07.339659565 +0100\n+++ /tmp/tmpgpjw53o4.java\t2023-03-24 21:56:07.343659551 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( total.length < 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (upper > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:08.695654790 +0100\n+++ /tmp/tmpv_5v9zrh.java\t2023-03-24 21:56:08.695654790 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (upper > 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (try.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:10.067649958 +0100\n+++ /tmp/tmpyhqjtpwv.java\t2023-03-24 21:56:10.067649958 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (try.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if ( jsonWriter.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:11.443645113 +0100\n+++ /tmp/tmptjjooser.java\t2023-03-24 21:56:11.447645099 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jsonWriter.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (total.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:12.863640112 +0100\n+++ /tmp/tmp_y55ndbm.java\t2023-03-24 21:56:12.863640112 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total.length < 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (arguments.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:14.807633263 +0100\n+++ /tmp/tmpnhfxunzl.java\t2023-03-24 21:56:14.807633263 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (arguments.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (child < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:17.275624566 +0100\n+++ /tmp/tmpppdgw_zq.java\t2023-03-24 21:56:17.275624566 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (child < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (li == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:19.199617787 +0100\n+++ /tmp/tmp58k8jtqe.java\t2023-03-24 21:56:19.203617773 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (li == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (total == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:21.135610962 +0100\n+++ /tmp/tmp5dpkkpxq.java\t2023-03-24 21:56:21.135610962 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (root.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:32.371571338 +0100\n+++ /tmp/tmpbi69d_mu.java\t2023-03-24 21:56:32.379571310 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (root.isEmpty()) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (Case_ == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:40.103544052 +0100\n+++ /tmp/tmpyur8zwkt.java\t2023-03-24 21:56:40.103544052 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Case_ == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (erializer < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:49.063512405 +0100\n+++ /tmp/tmp898qkgfq.java\t2023-03-24 21:56:49.063512405 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (erializer < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (total >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:56:58.491479085 +0100\n+++ /tmp/tmp8dx6v2oq.java\t2023-03-24 21:56:58.491479085 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total >= 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (hashCode == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:57:20.987399483 +0100\n+++ /tmp/tmpuwcnm0l_.java\t2023-03-24 21:57:20.987399483 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (hashCode == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (remaining < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:57:29.443369528 +0100\n+++ /tmp/tmp29hiq47u.java\t2023-03-24 21:57:29.443369528 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (remaining < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (remaining == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:57:36.875343184 +0100\n+++ /tmp/tmpy0vnftr4.java\t2023-03-24 21:57:36.875343184 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (remaining == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (test < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:57:45.399312954 +0100\n+++ /tmp/tmpvtxjjj0r.java\t2023-03-24 21:57:45.399312954 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (test < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (upper < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:57:53.271285020 +0100\n+++ /tmp/tmpevks30_h.java\t2023-03-24 21:57:53.275285006 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (upper < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (resource < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:00.555259157 +0100\n+++ /tmp/tmpaes7_fr5.java\t2023-03-24 21:58:00.555259157 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (resource < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if ( thread < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:07.535234363 +0100\n+++ /tmp/tmptmvmejld.java\t2023-03-24 21:58:07.547234323 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( thread < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (dirty == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:15.755205149 +0100\n+++ /tmp/tmpcbvtc9w0.java\t2023-03-24 21:58:15.755205149 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (dirty == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (status < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:23.787176588 +0100\n+++ /tmp/tmpmynjw13w.java\t2023-03-24 21:58:23.787176588 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (status < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (content.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:31.143150419 +0100\n+++ /tmp/tmprpm41rze.java\t2023-03-24 21:58:31.147150405 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (content.length < 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (arguments.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:38.151125474 +0100\n+++ /tmp/tmpxv3fvusk.java\t2023-03-24 21:58:38.151125474 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (arguments.length < 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (when < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:45.027100990 +0100\n+++ /tmp/tmpphworgl9.java\t2023-03-24 21:58:45.027100990 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (when < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (columns == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:51.359078434 +0100\n+++ /tmp/tmpuvwxt51l.java\t2023-03-24 21:58:51.359078434 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (columns == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (total.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:58:57.503056538 +0100\n+++ /tmp/tmpa1sd1v0s.java\t2023-03-24 21:58:57.503056538 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (total.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (compression.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:59:03.351035690 +0100\n+++ /tmp/tmpo2je4tyy.java\t2023-03-24 21:59:03.351035690 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (compression.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (child > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:59:09.047015378 +0100\n+++ /tmp/tmpdv5ux9ah.java\t2023-03-24 21:59:09.047015378 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (child > 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (Following) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:59:15.230993317 +0100\n+++ /tmp/tmpcsm2xwak.java\t2023-03-24 21:59:15.230993317 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Following) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (true) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:59:21.122972291 +0100\n+++ /tmp/tmp8v4m0_dw.java\t2023-03-24 21:59:21.122972291 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (true) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (fields.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 21:59:35.250921842 +0100\n+++ /tmp/tmp8dhe6akf.java\t2023-03-24 21:59:35.254921828 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (fields.length < 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (total < 0 ||coins.length==0) {"
    },
    "sieve": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (max.equals(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:54:17.780043374 +0100\n+++ /tmp/tmpw7w7jamy.java\t2023-03-24 21:54:17.836043178 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (max == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:54:21.932028903 +0100\n+++ /tmp/tmp93zh42dp.java\t2023-03-24 21:54:21.932028903 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (max.equals(n=3)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:54:25.936014944 +0100\n+++ /tmp/tmpcgpf8y8g.java\t2023-03-24 21:54:25.936014944 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=3)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (max == Integer.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:54:41.867959340 +0100\n+++ /tmp/tmpivg6h70m.java\t2023-03-24 21:54:41.871959326 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == Integer.MAX_VALUE) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (max.equals(n=2)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:54:45.795945617 +0100\n+++ /tmp/tmp6fs5yj_i.java\t2023-03-24 21:54:45.795945617 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=2)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (max < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:01.815889593 +0100\n+++ /tmp/tmpmsj74qmz.java\t2023-03-24 21:55:01.815889593 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (max.equals(n= 3)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:05.859875435 +0100\n+++ /tmp/tmpmvjnr1zu.java\t2023-03-24 21:55:05.863875421 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n= 3)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (max!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:21.739819794 +0100\n+++ /tmp/tmpndl63pv8.java\t2023-03-24 21:55:21.739819794 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max!= null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (max == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:25.563806383 +0100\n+++ /tmp/tmpkwewracf.java\t2023-03-24 21:55:25.563806383 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (max > n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:29.263793401 +0100\n+++ /tmp/tmpr5_56t6f.java\t2023-03-24 21:55:29.267793387 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max > n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (max.equals(n2)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:32.935780514 +0100\n+++ /tmp/tmp2jek6qp6.java\t2023-03-24 21:55:32.939780500 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n2)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (!max.equals(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:34.595774687 +0100\n+++ /tmp/tmp6777s1xs.java\t2023-03-24 21:55:34.595774687 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (!max.equals(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (max.equals(n=1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:38.271761780 +0100\n+++ /tmp/tmpmiad2u10.java\t2023-03-24 21:55:38.271761780 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=1)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (!max.equals(n=3)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:55:57.035695827 +0100\n+++ /tmp/tmpmpof15wt.java\t2023-03-24 21:55:57.035695827 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (!max.equals(n=3)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (this.max.equals(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:58:06.847236808 +0100\n+++ /tmp/tmp7iynoe8n.java\t2023-03-24 21:58:06.847236808 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max.equals(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (max > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:58:14.871208292 +0100\n+++ /tmp/tmpffrj_vry.java\t2023-03-24 21:58:14.871208292 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (max == Integer.MIN_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:58:31.695148453 +0100\n+++ /tmp/tmp3ckpe2v4.java\t2023-03-24 21:58:31.695148453 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == Integer.MIN_VALUE) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (max.equals(n.parent)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:58:47.467092300 +0100\n+++ /tmp/tmpv78_wra0.java\t2023-03-24 21:58:47.467092300 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.parent)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (max == Long.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:58:53.187071921 +0100\n+++ /tmp/tmp4g9w8h0i.java\t2023-03-24 21:58:53.187071921 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == Long.MAX_VALUE) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (max.equals(n=3;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:59:06.667023869 +0100\n+++ /tmp/tmpi05beuz9.java\t2023-03-24 21:59:06.667023869 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=3;\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (n.equals(max)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:59:12.923001551 +0100\n+++ /tmp/tmpdhyo_qhr.java\t2023-03-24 21:59:12.923001551 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n.equals(max)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (max < n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:59:19.150979329 +0100\n+++ /tmp/tmpicn9rde0.java\t2023-03-24 21:59:19.150979329 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (max < 0 || n > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:59:33.322928732 +0100\n+++ /tmp/tmpn1900ptb.java\t2023-03-24 21:59:33.322928732 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < 0 || n > max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (max.equals(n3)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:59:47.082879563 +0100\n+++ /tmp/tmpw_d1hg8h.java\t2023-03-24 21:59:47.082879563 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n3)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (max.equals(n.b)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:59:52.898858773 +0100\n+++ /tmp/tmphg8w11lv.java\t2023-03-24 21:59:52.898858773 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.b)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (max.equals(n=2)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 21:59:58.718837959 +0100\n+++ /tmp/tmpnedd0who.java\t2023-03-24 21:59:58.718837959 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=2)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (max.equals(n[max])) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:00:23.854747994 +0100\n+++ /tmp/tmpky6fxrca.java\t2023-03-24 22:00:23.858747980 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n[max])) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (max!= Integer.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:00:29.010729526 +0100\n+++ /tmp/tmpuggxbfaw.java\t2023-03-24 22:00:29.010729526 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max!= Integer.MAX_VALUE) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (max.equals(n= remaining)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:00:41.586684461 +0100\n+++ /tmp/tmpjkv4laig.java\t2023-03-24 22:00:41.586684461 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n= remaining)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (max.equals(n - 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:00:47.038664915 +0100\n+++ /tmp/tmpnnxy89b2.java\t2023-03-24 22:00:47.038664915 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n - 1)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (max.equals(n.min)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:00:57.118628763 +0100\n+++ /tmp/tmphaoc5c7g.java\t2023-03-24 22:00:57.118628763 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.min)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!max.equals(n=2)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:01:00.426616896 +0100\n+++ /tmp/tmp4hdpaloj.java\t2023-03-24 22:01:00.426616896 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (!max.equals(n=2)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (max < 0 || max > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:01:53.546426078 +0100\n+++ /tmp/tmpvolbmqkt.java\t2023-03-24 22:01:53.546426078 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < 0 || max > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (max.equals(nLabel)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:01:57.826410684 +0100\n+++ /tmp/tmpnffd7rrd.java\t2023-03-24 22:01:57.830410671 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(nLabel)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (max.equals(n.c)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:01:59.450404842 +0100\n+++ /tmp/tmpkoi91mzi.java\t2023-03-24 22:01:59.450404842 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.c)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (max.equals(n=2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:01.138398769 +0100\n+++ /tmp/tmpqki5893u.java\t2023-03-24 22:02:01.142398755 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=2;\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (max.equals(n.bit)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:02.882392495 +0100\n+++ /tmp/tmp1enlaybm.java\t2023-03-24 22:02:02.886392481 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.bit)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (max < Integer.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:04.622386235 +0100\n+++ /tmp/tmp0i5b2m3b.java\t2023-03-24 22:02:04.622386235 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < Integer.MAX_VALUE) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (max.equals(n.p)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:08.530372173 +0100\n+++ /tmp/tmpgdkoxfgz.java\t2023-03-24 22:02:08.530372173 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.p)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (max.equals( n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:10.202366156 +0100\n+++ /tmp/tmpy_v4qsze.java\t2023-03-24 22:02:10.202366156 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals( n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (max.equals(n.name())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:14.214351716 +0100\n+++ /tmp/tmpm22zvtd6.java\t2023-03-24 22:02:14.214351716 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.name())) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (list_comp(n, max)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:16.002345281 +0100\n+++ /tmp/tmpp7xiww6b.java\t2023-03-24 22:02:16.002345281 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (list_comp(n, max)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (max < 0 || n > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:17.702339160 +0100\n+++ /tmp/tmpbjorg45e.java\t2023-03-24 22:02:17.702339160 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < 0 || n > 1) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (max % n == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:21.722324687 +0100\n+++ /tmp/tmpzn27c8_r.java\t2023-03-24 22:02:21.722324687 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max % n == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (max[n] == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:25.618310658 +0100\n+++ /tmp/tmpaw773lym.java\t2023-03-24 22:02:25.618310658 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max[n] == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (max.equals(n.toString())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:27.298304607 +0100\n+++ /tmp/tmpopbe7k60.java\t2023-03-24 22:02:27.298304607 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.toString())) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (max.equals(n.u)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:29.014298428 +0100\n+++ /tmp/tmp57eqn30f.java\t2023-03-24 22:02:29.014298428 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.u)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (min.equals(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:30.786292045 +0100\n+++ /tmp/tmpfd4zqc91.java\t2023-03-24 22:02:30.786292045 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (min.equals(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (max.equals(n=24)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:32.522285792 +0100\n+++ /tmp/tmp7mqblxg0.java\t2023-03-24 22:02:32.522285792 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=24)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (max.equals(n= 2)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:39.538260516 +0100\n+++ /tmp/tmpb13kqln_.java\t2023-03-24 22:02:39.542260502 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n= 2)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (max.equals(n=2])) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:55.554202791 +0100\n+++ /tmp/tmpw6nixix7.java\t2023-03-24 22:02:55.554202791 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=2])) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (map.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:57.130197108 +0100\n+++ /tmp/tmpo2m_lhil.java\t2023-03-24 22:02:57.130197108 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (map.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (max.equals(n=31)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:02:58.822191007 +0100\n+++ /tmp/tmpq8l0y85y.java\t2023-03-24 22:02:58.826190993 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=31)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (max > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:05.842165693 +0100\n+++ /tmp/tmp5jd67i3h.java\t2023-03-24 22:03:05.842165693 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max > max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (max.equals(max)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:09.854151221 +0100\n+++ /tmp/tmp49l007yd.java\t2023-03-24 22:03:09.854151221 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(max)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (max.equals(n.w)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:13.734137225 +0100\n+++ /tmp/tmp8s8z_5ff.java\t2023-03-24 22:03:13.734137225 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.w)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (max == true) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:15.422131135 +0100\n+++ /tmp/tmpk9wji6sm.java\t2023-03-24 22:03:15.422131135 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == true) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (max.equals(n.max)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:17.090125116 +0100\n+++ /tmp/tmppuifgi8z.java\t2023-03-24 22:03:17.090125116 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.max)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (Integer.MAX_VALUE == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:18.790118981 +0100\n+++ /tmp/tmp839vb_h1.java\t2023-03-24 22:03:18.794118967 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Integer.MAX_VALUE == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (max!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:22.810104477 +0100\n+++ /tmp/tmpc1wxi89g.java\t2023-03-24 22:03:22.810104477 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max!= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (max.equals(n[n])) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:26.610090760 +0100\n+++ /tmp/tmpidlkdukl.java\t2023-03-24 22:03:26.610090760 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n[n])) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (this.max == n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:28.406084278 +0100\n+++ /tmp/tmppbmf6k09.java\t2023-03-24 22:03:28.406084278 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max == n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (max == null || max == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:30.090078199 +0100\n+++ /tmp/tmp5qio8puh.java\t2023-03-24 22:03:30.090078199 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == null || max == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (max.equals(nName)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:34.070063830 +0100\n+++ /tmp/tmpcvtcxz8m.java\t2023-03-24 22:03:34.070063830 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(nName)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (max == n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:35.762057722 +0100\n+++ /tmp/tmpfzqf08rb.java\t2023-03-24 22:03:35.762057722 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (max.equals(n.name)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:39.654043668 +0100\n+++ /tmp/tmphy1jr_nc.java\t2023-03-24 22:03:39.654043668 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n.name)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (max.equals(n=1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:03:41.402037358 +0100\n+++ /tmp/tmpsrfs_0vv.java\t2023-03-24 22:03:41.402037358 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=1)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (max.equals(n[max)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:00.365968853 +0100\n+++ /tmp/tmpt40n2_6w.java\t2023-03-24 22:04:00.365968853 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n[max)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (max == g) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:02.081962650 +0100\n+++ /tmp/tmprkwjvj1x.java\t2023-03-24 22:04:02.081962650 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == g) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (max < 0 || n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:03.717956737 +0100\n+++ /tmp/tmpadef4wnh.java\t2023-03-24 22:04:03.717956737 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < 0 || n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (max.equals(nId)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:07.785942036 +0100\n+++ /tmp/tmpqlp9bo0w.java\t2023-03-24 22:04:07.789942022 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(nId)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (max == false) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:09.557935630 +0100\n+++ /tmp/tmpn53rhfo2.java\t2023-03-24 22:04:09.557935630 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == false) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (max.equals(n1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:11.341929183 +0100\n+++ /tmp/tmp9gmmgowv.java\t2023-03-24 22:04:11.341929183 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n1)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (max.equals(n depth)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:13.117922761 +0100\n+++ /tmp/tmpuqtko71h.java\t2023-03-24 22:04:13.117922761 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n depth)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (Math.abs(max) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:14.833916559 +0100\n+++ /tmp/tmpljh4052p.java\t2023-03-24 22:04:14.833916559 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(max) > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (max.equals(nn)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:18.565903065 +0100\n+++ /tmp/tmpizdwdhjv.java\t2023-03-24 22:04:18.565903065 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(nn)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (max.equals(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:20.565895835 +0100\n+++ /tmp/tmpwmdz0kw4.java\t2023-03-24 22:04:20.565895835 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(x)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (this.max!= n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:22.029890540 +0100\n+++ /tmp/tmpdb61htos.java\t2023-03-24 22:04:22.033890527 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (min == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:23.737884364 +0100\n+++ /tmp/tmpgfntkfye.java\t2023-03-24 22:04:23.741884350 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (min == null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (max == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:25.457878144 +0100\n+++ /tmp/tmp7y3p6myb.java\t2023-03-24 22:04:25.457878144 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == 0.0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (max % 10 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:29.537863388 +0100\n+++ /tmp/tmpeofj3f_v.java\t2023-03-24 22:04:29.541863372 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max % 10 == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (max.equals(t)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:33.753848137 +0100\n+++ /tmp/tmppmcvd_lv.java\t2023-03-24 22:04:33.753848137 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(t)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (min > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:35.497841830 +0100\n+++ /tmp/tmp0qii6ex4.java\t2023-03-24 22:04:35.497841830 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (min > max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (max > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:37.325835215 +0100\n+++ /tmp/tmpgs4jd_89.java\t2023-03-24 22:04:37.325835215 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max > x) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (max <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:39.001829153 +0100\n+++ /tmp/tmpttay0peu.java\t2023-03-24 22:04:39.001829153 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (this.max > n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:43.209813926 +0100\n+++ /tmp/tmpnaslyd7o.java\t2023-03-24 22:04:43.209813926 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (max < m) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:44.981807515 +0100\n+++ /tmp/tmph8m4k9j3.java\t2023-03-24 22:04:44.981807515 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < m) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (!(max instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:46.697801305 +0100\n+++ /tmp/tmp89w35p16.java\t2023-03-24 22:04:46.697801305 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (!(max instanceof Integer)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (max.equals(n));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:50.813786409 +0100\n+++ /tmp/tmpwlcjk1_y.java\t2023-03-24 22:04:50.813786409 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n));\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (max % n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:52.421780588 +0100\n+++ /tmp/tmpyysae4y5.java\t2023-03-24 22:04:52.421780588 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max % n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (max > true) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:54.141774363 +0100\n+++ /tmp/tmpw4hjp02r.java\t2023-03-24 22:04:54.141774363 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max > true) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (max == max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:55.881768065 +0100\n+++ /tmp/tmp7hstcp92.java\t2023-03-24 22:04:55.885768052 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (max.equals(n=20) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:04:59.933753397 +0100\n+++ /tmp/tmpnaorhxmz.java\t2023-03-24 22:04:59.933753397 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max.equals(n=20) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (max % n!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:05:01.781746706 +0100\n+++ /tmp/tmpl8kb_ggc.java\t2023-03-24 22:05:01.781746706 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max % n!= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (max < 0 || n > 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:05:05.805732138 +0100\n+++ /tmp/tmp20dlhv75.java\t2023-03-24 22:05:05.805732138 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < 0 || n > 2);\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (max == e) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:05:07.477726084 +0100\n+++ /tmp/tmpfz7d82ox.java\t2023-03-24 22:05:07.477726084 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max == e) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (max\".equals(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:05:09.185719898 +0100\n+++ /tmp/tmp_1dj1hz3.java\t2023-03-24 22:05:09.189719885 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max\".equals(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (max < current) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:05:10.793714076 +0100\n+++ /tmp/tmpmpqjx4gy.java\t2023-03-24 22:05:10.793714076 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max < current) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (subLog!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:05:12.461708034 +0100\n+++ /tmp/tmptqj81wnp.java\t2023-03-24 22:05:12.461708034 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (subLog!= null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (max!= current) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 22:05:14.205701719 +0100\n+++ /tmp/tmpq6etk5od.java\t2023-03-24 22:05:14.205701719 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max!= current) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (all(list_comp(n, primes))) {"
    },
    "minimum_spanning_tree": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:03.974604166 +0100\n+++ /tmp/tmpsvcmc9g7.java\t2023-03-24 22:01:03.986604122 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:06.238596040 +0100\n+++ /tmp/tmpmc_1pazu.java\t2023-03-24 22:01:06.238596040 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeType() == Node.ELEMENT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (node.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:08.242588849 +0100\n+++ /tmp/tmpjaoki04q.java\t2023-03-24 22:01:08.242588849 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (node.is(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:11.398577521 +0100\n+++ /tmp/tmpyq4fz1i9.java\t2023-03-24 22:01:11.398577521 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (node.getName().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:13.686569305 +0100\n+++ /tmp/tmp3xjq_c63.java\t2023-03-24 22:01:13.686569305 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (node.getNodes().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:15.402563145 +0100\n+++ /tmp/tmppx5_y50d.java\t2023-03-24 22:01:15.402563145 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodes().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (node.getTree().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:17.246556524 +0100\n+++ /tmp/tmphhjbtfun.java\t2023-03-24 22:01:17.246556524 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (node.getAttributes().containsKey(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:19.058550018 +0100\n+++ /tmp/tmpbiq_m3uc.java\t2023-03-24 22:01:19.062550004 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getAttributes().containsKey(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (node.is(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:20.914543353 +0100\n+++ /tmp/tmpf38zd58k.java\t2023-03-24 22:01:20.918543339 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (node.getCardinality() == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:22.730536831 +0100\n+++ /tmp/tmp3lqrw0lf.java\t2023-03-24 22:01:22.730536831 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCardinality() == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (node.getTree().equals(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:24.626530021 +0100\n+++ /tmp/tmpq78hdnum.java\t2023-03-24 22:01:24.626530021 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (node.getChildren().size() == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:26.482523355 +0100\n+++ /tmp/tmpz7l_oztb.java\t2023-03-24 22:01:26.482523355 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildren().size() == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (orderByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:28.222517103 +0100\n+++ /tmp/tmpt4nome4p.java\t2023-03-24 22:01:28.222517103 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (node.getParent() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:30.034510593 +0100\n+++ /tmp/tmp_lee9fs1.java\t2023-03-24 22:01:30.034510593 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getParent() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (node.getChildCount() > 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:31.734504485 +0100\n+++ /tmp/tmp6bqj4g04.java\t2023-03-24 22:01:31.734504485 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() > 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (node.get(vertex_v)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:33.370498608 +0100\n+++ /tmp/tmp498lg1o9.java\t2023-03-24 22:01:33.374498593 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (node.getOpposite(node)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:36.110488762 +0100\n+++ /tmp/tmppoixulb7.java\t2023-03-24 22:01:36.114488746 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getOpposite(node)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (node.getNodes().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:39.670475967 +0100\n+++ /tmp/tmp6van6ag5.java\t2023-03-24 22:01:39.674475953 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodes().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (node.getequals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:43.226463184 +0100\n+++ /tmp/tmpnts4xvrp.java\t2023-03-24 22:01:43.226463184 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getequals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (node.getNodeId().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:46.386451824 +0100\n+++ /tmp/tmp9wl3pzqd.java\t2023-03-24 22:01:46.386451824 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeId().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (!isSpanningTree(node)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:49.914439139 +0100\n+++ /tmp/tmpgoojm2_p.java\t2023-03-24 22:01:49.914439139 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (!isSpanningTree(node)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (node.getToken() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:52.742428970 +0100\n+++ /tmp/tmpt3i6p5ba.java\t2023-03-24 22:01:52.742428970 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getToken() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (node.getNode().isTree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:54.510422611 +0100\n+++ /tmp/tmp83_wejxi.java\t2023-03-24 22:01:54.510422611 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNode().isTree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (node.getNodes().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:56.662414871 +0100\n+++ /tmp/tmpyeo5ezym.java\t2023-03-24 22:01:56.662414871 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodes().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (node.getCount() > 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:01:58.566408022 +0100\n+++ /tmp/tmprawq4kc0.java\t2023-03-24 22:01:58.566408022 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCount() > 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (node.getName().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:00.482401131 +0100\n+++ /tmp/tmpggzj9xx5.java\t2023-03-24 22:02:00.482401131 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (node.getChildren().size() > 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:02.326394496 +0100\n+++ /tmp/tmpu3kdua9u.java\t2023-03-24 22:02:02.326394496 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildren().size() > 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (node.getToken().isGeneratedCode()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:04.106388092 +0100\n+++ /tmp/tmp9yjm2oss.java\t2023-03-24 22:02:04.106388092 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getToken().isGeneratedCode()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (o!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:06.114380868 +0100\n+++ /tmp/tmp6cun9ene.java\t2023-03-24 22:02:06.114380868 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (o!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (node.getNode().isTextual()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:08.070373829 +0100\n+++ /tmp/tmplftcd_db.java\t2023-03-24 22:02:08.074373815 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNode().isTextual()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (node.getEdgeWeight(edge) < 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:09.890367278 +0100\n+++ /tmp/tmpxf0zu9ll.java\t2023-03-24 22:02:09.890367278 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getEdgeWeight(edge) < 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (node.getParent() == graph) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:11.782360470 +0100\n+++ /tmp/tmpz_t1ztwk.java\t2023-03-24 22:02:11.782360470 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getParent() == graph) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (node.getNode().isTree()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:13.662353702 +0100\n+++ /tmp/tmpritlspg9.java\t2023-03-24 22:02:13.662353702 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNode().isTree()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (node.getTree().equals(node.getTree())) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:15.570346835 +0100\n+++ /tmp/tmpv2e7a4ih.java\t2023-03-24 22:02:15.570346835 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(node.getTree())) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (node.getOpposite(node)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:17.466340009 +0100\n+++ /tmp/tmp_w489sqr.java\t2023-03-24 22:02:17.466340009 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getOpposite(node)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (node.getAttributes().containsKey(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:19.342333255 +0100\n+++ /tmp/tmpcsjpyfu7.java\t2023-03-24 22:02:19.346333241 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getAttributes().containsKey(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (node.getNodeValue().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:21.362325984 +0100\n+++ /tmp/tmp0addo6om.java\t2023-03-24 22:02:21.366325968 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeValue().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (node.getobj().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:23.226319272 +0100\n+++ /tmp/tmpsijpx2gb.java\t2023-03-24 22:02:23.226319272 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getobj().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (node.getParentNode() == graph) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:25.086312574 +0100\n+++ /tmp/tmp6ez55533.java\t2023-03-24 22:02:25.086312574 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getParentNode() == graph) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (node.getName() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:27.018305615 +0100\n+++ /tmp/tmplvlbk6c2.java\t2023-03-24 22:02:27.018305615 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (node.getToken().isInstance(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:28.902298830 +0100\n+++ /tmp/tmpglm0xlzf.java\t2023-03-24 22:02:28.902298830 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getToken().isInstance(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (node.getCount() == 1) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:30.786292045 +0100\n+++ /tmp/tmppqqmzr3o.java\t2023-03-24 22:02:30.786292045 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCount() == 1) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:32.614285461 +0100\n+++ /tmp/tmpwg3as5a_.java\t2023-03-24 22:02:32.614285461 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeType() == Node.TEXT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (groupByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:34.410278991 +0100\n+++ /tmp/tmpwi374odz.java\t2023-03-24 22:02:34.414278977 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (node.getTree().isTree()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:36.322272102 +0100\n+++ /tmp/tmpi6xnp7m2.java\t2023-03-24 22:02:36.322272102 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().isTree()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (o.equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:37.938266281 +0100\n+++ /tmp/tmppneiehok.java\t2023-03-24 22:02:37.942266267 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (o.equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (node.getMessages().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:39.570260401 +0100\n+++ /tmp/tmp4p8lzrjc.java\t2023-03-24 22:02:39.570260401 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getMessages().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (node.getNodes().contains(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:41.466253570 +0100\n+++ /tmp/tmp7a6544hk.java\t2023-03-24 22:02:41.466253570 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodes().contains(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (node.getParent(vertex)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:43.390246636 +0100\n+++ /tmp/tmpnmxwl70b.java\t2023-03-24 22:02:43.390246636 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getParent(vertex)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (node.getNodeId().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:44.946241028 +0100\n+++ /tmp/tmpfqqt2c1i.java\t2023-03-24 22:02:44.946241028 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeId().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (o.equals(node.getNode())) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:46.514235377 +0100\n+++ /tmp/tmpx1_jvjai.java\t2023-03-24 22:02:46.526235333 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (o.equals(node.getNode())) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (node.getToken().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:48.218229236 +0100\n+++ /tmp/tmphtra237v.java\t2023-03-24 22:02:48.218229236 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getToken().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (node.getTree().isTree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:49.810223497 +0100\n+++ /tmp/tmp1ceqc__1.java\t2023-03-24 22:02:49.814223483 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().isTree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (node.getTree().equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:51.462217543 +0100\n+++ /tmp/tmp06qp4ki_.java\t2023-03-24 22:02:51.466217529 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (node.getMetadata().isArray()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:53.206211257 +0100\n+++ /tmp/tmp20_k1qcz.java\t2023-03-24 22:02:53.206211257 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getMetadata().isArray()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (node.getNodes().contains(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:55.014204737 +0100\n+++ /tmp/tmpxgpcff3h.java\t2023-03-24 22:02:55.014204737 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodes().contains(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (node.getNode().isArray()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:56.846198132 +0100\n+++ /tmp/tmpkm224a5q.java\t2023-03-24 22:02:56.850198118 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNode().isArray()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (graph.getEdge(vertex, node)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:02:58.670191557 +0100\n+++ /tmp/tmppsmtb6sn.java\t2023-03-24 22:02:58.670191557 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (graph.getEdge(vertex, node)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (isTree(node)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:00.586184647 +0100\n+++ /tmp/tmp5wefrdi3.java\t2023-03-24 22:03:00.586184647 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (isTree(node)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (node.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:02.486177795 +0100\n+++ /tmp/tmp77dtlntg.java\t2023-03-24 22:03:02.490177781 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:04.038172198 +0100\n+++ /tmp/tmpa2hjo2lu.java\t2023-03-24 22:03:04.042172184 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeType() == Node.ELEMENT) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (o.equals(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:05.650166384 +0100\n+++ /tmp/tmpk261vjn0.java\t2023-03-24 22:03:05.650166384 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (o.equals(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (node.get Node().isGeneratedCode()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:07.578159431 +0100\n+++ /tmp/tmpp6kabwv3.java\t2023-03-24 22:03:07.582159417 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get Node().isGeneratedCode()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (node.getParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:09.382152924 +0100\n+++ /tmp/tmpq43et2ti.java\t2023-03-24 22:03:09.382152924 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (weighted) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:11.254146172 +0100\n+++ /tmp/tmpp47pdzp4.java\t2023-03-24 22:03:11.254146172 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (weighted) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node, edge_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:13.150139331 +0100\n+++ /tmp/tmp16eu24bk.java\t2023-03-24 22:03:13.150139331 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node, edge_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (orderByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:14.982132722 +0100\n+++ /tmp/tmpmjkasuui.java\t2023-03-24 22:03:14.986132708 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:16.794126183 +0100\n+++ /tmp/tmpp7ego_p5.java\t2023-03-24 22:03:16.794126183 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (groupByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:18.614119617 +0100\n+++ /tmp/tmpr3iz_g65.java\t2023-03-24 22:03:18.614119617 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (node.getAttributes().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:20.550112632 +0100\n+++ /tmp/tmpq9h2u4ix.java\t2023-03-24 22:03:20.550112632 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getAttributes().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (node.getNumberNode() == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:22.526105500 +0100\n+++ /tmp/tmp212phayt.java\t2023-03-24 22:03:22.526105500 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNumberNode() == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (node.getParent() == node) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:24.410098701 +0100\n+++ /tmp/tmpq9520rc1.java\t2023-03-24 22:03:24.410098701 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getParent() == node) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (node.getCardinality() == 1) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:26.350091698 +0100\n+++ /tmp/tmpre9ry0iw.java\t2023-03-24 22:03:26.350091698 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCardinality() == 1) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (orderByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:28.202085014 +0100\n+++ /tmp/tmpg0w35ayo.java\t2023-03-24 22:03:28.202085014 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (groupByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:30.078078243 +0100\n+++ /tmp/tmp49844to2.java\t2023-03-24 22:03:30.078078243 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (isOverriddenNode(node)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:31.882071731 +0100\n+++ /tmp/tmpzu2aip2a.java\t2023-03-24 22:03:31.882071731 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (isOverriddenNode(node)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (iterator.hasNext()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:33.766064928 +0100\n+++ /tmp/tmpkq6ko2n7.java\t2023-03-24 22:03:33.766064928 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (iterator.hasNext()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (node.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node, edge_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:35.698057953 +0100\n+++ /tmp/tmpd6pm3ap7.java\t2023-03-24 22:03:35.698057953 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node, edge_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:37.566051208 +0100\n+++ /tmp/tmppp0wpnrs.java\t2023-03-24 22:03:37.566051208 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().equals(vertex_v)) { groupByNode = update(groupByNode, node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (node.getChildren().size() == 0) { groupByNode = update(groupByNode, node, edge_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:39.434044463 +0100\n+++ /tmp/tmp5ahgkiw7.java\t2023-03-24 22:03:39.434044463 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildren().size() == 0) { groupByNode = update(groupByNode, node, edge_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (node.getFinished()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:41.330037616 +0100\n+++ /tmp/tmp3ht11q1o.java\t2023-03-24 22:03:41.334037602 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getFinished()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (groupByNode.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:43.230030756 +0100\n+++ /tmp/tmp5j1fa0n8.java\t2023-03-24 22:03:43.230030756 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { groupByNode = update(groupByNode, node, edge_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:45.070024110 +0100\n+++ /tmp/tmp3scu2bbg.java\t2023-03-24 22:03:45.070024110 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeType() == Node.ELEMENT_NODE) { groupByNode = update(groupByNode, node, edge_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (orderByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:46.698018230 +0100\n+++ /tmp/tmplc1ziwzv.java\t2023-03-24 22:03:46.698018230 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (groupByNode.get(vertex_v) == minSpanningTree) { groupByNode = update(groupByNode, node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:48.222012726 +0100\n+++ /tmp/tmpzsjohu8i.java\t2023-03-24 22:03:48.226012712 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v) == minSpanningTree) { groupByNode = update(groupByNode, node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (groupByNode.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:49.838006889 +0100\n+++ /tmp/tmpbcauveaf.java\t2023-03-24 22:03:49.838006889 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (o == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:51.530000775 +0100\n+++ /tmp/tmpql35rual.java\t2023-03-24 22:03:51.530000775 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (o == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (orderByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, edge_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:53.161994881 +0100\n+++ /tmp/tmpx6y29ac3.java\t2023-03-24 22:03:53.161994881 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, node, edge_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (orderByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:54.929988493 +0100\n+++ /tmp/tmp5f6qfxlp.java\t2023-03-24 22:03:54.929988493 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v) == 0) { groupByNode = update(groupByNode, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (node.get 5) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:56.709982063 +0100\n+++ /tmp/tmpn5gjp9zd.java\t2023-03-24 22:03:56.709982063 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get 5) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (node.getName().equals(vertex_u)) { groupByNode = update(groupByNode, node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:03:58.453975760 +0100\n+++ /tmp/tmpmpmqdavo.java\t2023-03-24 22:03:58.457975746 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName().equals(vertex_u)) { groupByNode = update(groupByNode, node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (orderByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:00.309969053 +0100\n+++ /tmp/tmp5lwl_4ua.java\t2023-03-24 22:04:00.309969053 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (graph.getEdge(vertex, node)!= null) { groupByNode = update(groupByNode, node, edge_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:02.253962028 +0100\n+++ /tmp/tmpv50dt0e9.java\t2023-03-24 22:04:02.253962028 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (graph.getEdge(vertex, node)!= null) { groupByNode = update(groupByNode, node, edge_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (groupByNode.get(vertex_v) == vertex_u) { groupByNode = update(groupByNode, node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:04.097955366 +0100\n+++ /tmp/tmpmgbro_qh.java\t2023-03-24 22:04:04.097955366 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v) == vertex_u) { groupByNode = update(groupByNode, node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (node.getAttributes().containsKey(vertex_v)) { groupByNode = update(groupByNode, node, edge_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:05.885948904 +0100\n+++ /tmp/tmpevw87kcw.java\t2023-03-24 22:04:05.885948904 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getAttributes().containsKey(vertex_v)) { groupByNode = update(groupByNode, node, edge_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (orderByNode.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, vertex_v); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:07.709942311 +0100\n+++ /tmp/tmp4bz763z1.java\t2023-03-24 22:04:07.713942297 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (orderByNode.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, vertex_v); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (groupByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:09.597935487 +0100\n+++ /tmp/tmpfi9pjl_9.java\t2023-03-24 22:04:09.601935471 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v) == null) { groupByNode = update(groupByNode, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (groupByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:11.429928864 +0100\n+++ /tmp/tmpksbic7ae.java\t2023-03-24 22:04:11.429928864 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (groupByNode.get(vertex_v)!= null) { groupByNode = update(groupByNode, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (node.getNodes().equals(vertex_u)) { groupByNode = update(groupByNode, node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:13.213922415 +0100\n+++ /tmp/tmpbmvfeoo2.java\t2023-03-24 22:04:13.213922415 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodes().equals(vertex_u)) { groupByNode = update(groupByNode, node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (node.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 22:04:15.025915864 +0100\n+++ /tmp/tmpodgj07q6.java\t2023-03-24 22:04:15.025915864 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v) == groupByNode) { groupByNode = update(groupByNode, node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "groupByNode.put(node, groupByNode.get(vertex_u));"
    },
    "kheapsort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (Integer x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:21.809891335 +0100\n+++ /tmp/tmp4y0ioib0.java\t2023-03-24 22:04:21.861891148 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "for (int x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:25.889876581 +0100\n+++ /tmp/tmp7btwnybk.java\t2023-03-24 22:04:25.889876581 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "for (String x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:30.077861435 +0100\n+++ /tmp/tmpe_20ficj.java\t2023-03-24 22:04:30.081861421 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (String x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "for (Long x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:31.741855416 +0100\n+++ /tmp/tmplmypypr4.java\t2023-03-24 22:04:31.741855416 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Long x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "for (final int x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:33.533848933 +0100\n+++ /tmp/tmppsg3wthf.java\t2023-03-24 22:04:33.533848933 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (final int x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "for (final Integer x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:37.509834550 +0100\n+++ /tmp/tmp6qjzjhg7.java\t2023-03-24 22:04:37.513834537 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (final Integer x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "for (Int x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:41.473820207 +0100\n+++ /tmp/tmpe4v08f94.java\t2023-03-24 22:04:41.473820207 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Int x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "for (BigInteger x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:43.309813566 +0100\n+++ /tmp/tmp43640r_3.java\t2023-03-24 22:04:43.309813566 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (BigInteger x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "for (Integer x : arr){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:45.001807441 +0100\n+++ /tmp/tmpzwdjdsuh.java\t2023-03-24 22:04:45.033807326 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr){\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "for (Boolean x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:48.997792981 +0100\n+++ /tmp/tmpmns1uffz.java\t2023-03-24 22:04:48.997792981 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Boolean x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "for (x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:50.777786539 +0100\n+++ /tmp/tmp45xcbc_s.java\t2023-03-24 22:04:50.781786525 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "for (Integer x : arr.values()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:52.365780791 +0100\n+++ /tmp/tmpv9fj0sv3.java\t2023-03-24 22:04:52.365780791 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr.values()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "for (Type x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:54.109774480 +0100\n+++ /tmp/tmpm_3gos0g.java\t2023-03-24 22:04:54.109774480 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Type x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "for (Short x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:55.885768052 +0100\n+++ /tmp/tmpw4g5wh4_.java\t2023-03-24 22:04:55.885768052 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Short x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "for (int x : arr){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:04:57.701761478 +0100\n+++ /tmp/tmpzspkza3n.java\t2023-03-24 22:04:57.701761478 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr){\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "for (Segment x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:01.845746475 +0100\n+++ /tmp/tmpcrfeo9fu.java\t2023-03-24 22:05:01.849746461 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Segment x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "for (File x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:03.637739987 +0100\n+++ /tmp/tmpbv_609o6.java\t2023-03-24 22:05:03.637739987 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (File x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "for (ByteBuffer x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:05.533733121 +0100\n+++ /tmp/tmp1_xdsv4w.java\t2023-03-24 22:05:05.533733121 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (ByteBuffer x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "for (Byte x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:07.269726836 +0100\n+++ /tmp/tmp__pwfm1h.java\t2023-03-24 22:05:07.269726836 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Byte x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "for (Float x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:08.913720884 +0100\n+++ /tmp/tmpqdrdmbe1.java\t2023-03-24 22:05:08.913720884 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Float x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "for (int x : arr.values()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:10.685714466 +0100\n+++ /tmp/tmpiuszx7uh.java\t2023-03-24 22:05:10.685714466 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr.values()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "for (String c : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:12.441708108 +0100\n+++ /tmp/tmp0frudgyq.java\t2023-03-24 22:05:12.441708108 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (String c : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "for (Object x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:14.185701791 +0100\n+++ /tmp/tmpp601p7b3.java\t2023-03-24 22:05:14.185701791 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Object x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "for (long x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:15.973695315 +0100\n+++ /tmp/tmpc7bfac0p.java\t2023-03-24 22:05:15.997695227 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (long x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "for (Pair x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:17.929688230 +0100\n+++ /tmp/tmp4at_lvi0.java\t2023-03-24 22:05:17.929688230 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Pair x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "for ( int x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:20.213679957 +0100\n+++ /tmp/tmphzqqr0e4.java\t2023-03-24 22:05:20.213679957 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for ( int x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "for (List x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:24.257665308 +0100\n+++ /tmp/tmpii4iw8l9.java\t2023-03-24 22:05:24.257665308 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (List x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "for (Map.Entry x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:26.073658729 +0100\n+++ /tmp/tmpmlbyzmpe.java\t2023-03-24 22:05:26.077658715 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Map.Entry x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "for (Integer x : arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:27.761652614 +0100\n+++ /tmp/tmpet_1v6mq.java\t2023-03-24 22:05:27.761652614 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "for (Integer x : bits) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:29.345646873 +0100\n+++ /tmp/tmpkr8g522i.java\t2023-03-24 22:05:29.345646873 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : bits) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "for (Enum x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:31.021640802 +0100\n+++ /tmp/tmpr5xksxir.java\t2023-03-24 22:05:31.021640802 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Enum x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "for (T x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:32.705634698 +0100\n+++ /tmp/tmpub79wgzt.java\t2023-03-24 22:05:32.705634698 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (T x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "for (Future x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:34.385628611 +0100\n+++ /tmp/tmpuc4h1bgm.java\t2023-03-24 22:05:34.385628611 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Future x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "for (Entry x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:36.129622291 +0100\n+++ /tmp/tmp90nmj96f.java\t2023-03-24 22:05:36.129622291 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Entry x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "for (int x : arr.clear()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:37.849616057 +0100\n+++ /tmp/tmpe4v8amrw.java\t2023-03-24 22:05:37.849616057 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr.clear()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "for (Class x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:39.505610055 +0100\n+++ /tmp/tmpqhxq2zp_.java\t2023-03-24 22:05:39.509610041 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Class x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "for (Iterator x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:41.229603807 +0100\n+++ /tmp/tmpyk42_yge.java\t2023-03-24 22:05:41.229603807 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Iterator x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "for (String x : arr){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:42.949597573 +0100\n+++ /tmp/tmpo01v4o77.java\t2023-03-24 22:05:42.949597573 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (String x : arr){\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "for (Cxx x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:44.705591209 +0100\n+++ /tmp/tmpkd5qkgfb.java\t2023-03-24 22:05:44.705591209 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Cxx x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "for (Node x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:46.489584742 +0100\n+++ /tmp/tmp1zahwujg.java\t2023-03-24 22:05:46.489584742 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Node x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "for(Integer x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:48.217578478 +0100\n+++ /tmp/tmpx85169jz.java\t2023-03-24 22:05:48.217578478 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for(Integer x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "for (Or x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:52.217563976 +0100\n+++ /tmp/tmpm3vohyhz.java\t2023-03-24 22:05:52.217563976 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Or x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "for (getValue x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:53.825558146 +0100\n+++ /tmp/tmpfvn8x5y9.java\t2023-03-24 22:05:53.825558146 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (getValue x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "for (Number x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:55.497552085 +0100\n+++ /tmp/tmp6emeust0.java\t2023-03-24 22:05:55.497552085 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Number x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "for (final long x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:57.245545745 +0100\n+++ /tmp/tmp6bt9w_xw.java\t2023-03-24 22:05:57.245545745 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (final long x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "for (Field x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:05:58.949539567 +0100\n+++ /tmp/tmpqo4w5ca5.java\t2023-03-24 22:05:58.949539567 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Field x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "for (Integer x : arr.entrySet()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:00.629533475 +0100\n+++ /tmp/tmpurrk1m0e.java\t2023-03-24 22:06:00.633533461 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr.entrySet()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "for (Character x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:05.021517548 +0100\n+++ /tmp/tmpp5les5iq.java\t2023-03-24 22:06:05.929514254 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Character x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "for (Integer x : arr.clear()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:09.025503027 +0100\n+++ /tmp/tmp981mrq7q.java\t2023-03-24 22:06:09.029503010 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr.clear()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "for (Set x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:11.561493827 +0100\n+++ /tmp/tmpevbkkf2d.java\t2023-03-24 22:06:11.561493827 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Set x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "for (Integer x :arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:13.461486934 +0100\n+++ /tmp/tmptm2prelz.java\t2023-03-24 22:06:13.461486934 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x :arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "for ( Code x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:18.233469623 +0100\n+++ /tmp/tmpd4s3lv3q.java\t2023-03-24 22:06:18.233469623 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for ( Code x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "for (Edge x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:19.785463992 +0100\n+++ /tmp/tmpy4n_go8b.java\t2023-03-24 22:06:19.785463992 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Edge x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "for ( Integer x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:21.721456969 +0100\n+++ /tmp/tmp6y2nmyqr.java\t2023-03-24 22:06:21.721456969 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for ( Integer x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "for (Factory x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:26.517439566 +0100\n+++ /tmp/tmpbhm6pxtj.java\t2023-03-24 22:06:26.521439553 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Factory x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "for (Integer y : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:29.349429289 +0100\n+++ /tmp/tmpg37og4la.java\t2023-03-24 22:06:29.349429289 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer y : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "for (Point x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:31.821420320 +0100\n+++ /tmp/tmpzg3r7gg4.java\t2023-03-24 22:06:31.821420320 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Point x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "for (int x : bits) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:35.593406629 +0100\n+++ /tmp/tmpgqhhiwo4.java\t2023-03-24 22:06:36.581403043 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : bits) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "for ((x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:39.529392342 +0100\n+++ /tmp/tmpmmvpn195.java\t2023-03-24 22:06:39.749391544 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for ((x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "for (Parameter x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:41.273386011 +0100\n+++ /tmp/tmp1_7i5sfn.java\t2023-03-24 22:06:41.273386011 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Parameter x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "for (One x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:43.345378490 +0100\n+++ /tmp/tmprxz8tf6p.java\t2023-03-24 22:06:43.345378490 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (One x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "for (int x : arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:46.961365364 +0100\n+++ /tmp/tmpldhxh8ya.java\t2023-03-24 22:06:48.025361502 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "for (V x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:51.065350465 +0100\n+++ /tmp/tmpttf_pics.java\t2023-03-24 22:06:51.065350465 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (V x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "for (ArrayList x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:54.289338757 +0100\n+++ /tmp/tmp_j9xnw_9.java\t2023-03-24 22:06:54.293338743 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (ArrayList x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "for (Integer x : arr2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:56.489330769 +0100\n+++ /tmp/tmpqu_xnxhi.java\t2023-03-24 22:06:56.489330769 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr2) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "for (v : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:06:58.457323623 +0100\n+++ /tmp/tmphb_wll2y.java\t2023-03-24 22:06:58.457323623 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (v : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "for (boolean x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:00.181317363 +0100\n+++ /tmp/tmp7he8eo0e.java\t2023-03-24 22:07:00.181317363 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (boolean x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "for (Thread x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:02.765307978 +0100\n+++ /tmp/tmp2ftkfjcn.java\t2023-03-24 22:07:02.769307961 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Thread x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "for (Matcher x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:04.805300569 +0100\n+++ /tmp/tmpsqyb624i.java\t2023-03-24 22:07:04.805300569 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Matcher x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "for (Record x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:07.397291154 +0100\n+++ /tmp/tmp1ie63tqo.java\t2023-03-24 22:07:07.397291154 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Record x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "for (0 x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:09.565283278 +0100\n+++ /tmp/tmpr4z7wdhs.java\t2023-03-24 22:07:09.565283278 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (0 x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "for (Block x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:11.445276451 +0100\n+++ /tmp/tmp654c9f78.java\t2023-03-24 22:07:11.445276451 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Block x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "for (Inet x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:13.905267513 +0100\n+++ /tmp/tmpka2k33_m.java\t2023-03-24 22:07:13.905267513 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Inet x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "for (Any x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:16.337258678 +0100\n+++ /tmp/tmp4uc87e9e.java\t2023-03-24 22:07:16.337258678 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Any x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "for (Option x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:18.349251370 +0100\n+++ /tmp/tmpfm1xu6ad.java\t2023-03-24 22:07:18.349251370 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Option x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "for (Collections x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:20.945241937 +0100\n+++ /tmp/tmpev7ohp7_.java\t2023-03-24 22:07:20.945241937 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Collections x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "for (Integer x : c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:23.733231807 +0100\n+++ /tmp/tmpxzdj7dm9.java\t2023-03-24 22:07:23.733231807 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : c) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "for (TreeNode x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:25.773224394 +0100\n+++ /tmp/tmpa718u_p1.java\t2023-03-24 22:07:25.777224381 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (TreeNode x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "for (Data x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:28.393214873 +0100\n+++ /tmp/tmp2mggn38o.java\t2023-03-24 22:07:28.393214873 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Data x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "for (; x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:30.209208275 +0100\n+++ /tmp/tmpf7a29v5e.java\t2023-03-24 22:07:30.209208275 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (; x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "for (T c : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:31.897202140 +0100\n+++ /tmp/tmp2_gatnwq.java\t2023-03-24 22:07:31.993201792 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (T c : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "for (Stack x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:34.189193811 +0100\n+++ /tmp/tmpo3gdra2u.java\t2023-03-24 22:07:34.189193811 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Stack x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "for (Map x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:36.505185394 +0100\n+++ /tmp/tmpqsztuxj8.java\t2023-03-24 22:07:36.505185394 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Map x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "for (integer x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:39.049176148 +0100\n+++ /tmp/tmpjzhk203s.java\t2023-03-24 22:07:39.049176148 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (integer x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "for ( V x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:41.485167293 +0100\n+++ /tmp/tmph2a824mr.java\t2023-03-24 22:07:41.485167293 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for ( V x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "for (Max x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:43.473160066 +0100\n+++ /tmp/tmp7wr07kxv.java\t2023-03-24 22:07:43.473160066 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Max x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "for (int x : arr2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:45.213153740 +0100\n+++ /tmp/tmp15n_u1qk.java\t2023-03-24 22:07:45.213153740 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr2) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "for (t : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:46.949147429 +0100\n+++ /tmp/tmpqibqondq.java\t2023-03-24 22:07:46.949147429 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (t : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "for (PropertyValue x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:48.697141076 +0100\n+++ /tmp/tmp3m3mu9gm.java\t2023-03-24 22:07:48.697141076 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (PropertyValue x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "for (E x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:50.509134488 +0100\n+++ /tmp/tmptmroovd9.java\t2023-03-24 22:07:50.509134488 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (E x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "for (Label x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:52.213128292 +0100\n+++ /tmp/tmp2x3jtkku.java\t2023-03-24 22:07:52.213128292 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Label x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "for (Latitude x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:53.905122140 +0100\n+++ /tmp/tmpfmgvai0t.java\t2023-03-24 22:07:53.905122140 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Latitude x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "for (int x :arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:55.637115842 +0100\n+++ /tmp/tmph3jrwfvd.java\t2023-03-24 22:07:55.637115842 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x :arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "for (entry x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:07:59.537101662 +0100\n+++ /tmp/tmpjx8vq53x.java\t2023-03-24 22:07:59.541101649 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (entry x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "for (Double x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:08:01.357095044 +0100\n+++ /tmp/tmpycdm5qz2.java\t2023-03-24 22:08:01.381094957 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Double x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "for (Value x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:08:03.129088600 +0100\n+++ /tmp/tmpx98mte4t.java\t2023-03-24 22:08:03.129088600 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Value x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "for (Path x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:08:04.881082229 +0100\n+++ /tmp/tmpt5k1a_xn.java\t2023-03-24 22:08:04.885082215 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Path x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "for (Element x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:08:06.581076048 +0100\n+++ /tmp/tmp0bofwi7r.java\t2023-03-24 22:08:06.581076048 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Element x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "for (value : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:08:08.241070008 +0100\n+++ /tmp/tmp_qofzkre.java\t2023-03-24 22:08:08.245069994 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (value : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "for (Integer x : arr) { //?",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 22:08:09.849064161 +0100\n+++ /tmp/tmp7jct7j6b.java\t2023-03-24 22:08:09.853064148 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr) { //?\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (Integer x : arr.subList(k, arr.size())) {"
    },
    "detect_cycle": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (hare.getNodeId(node) == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:20.453679087 +0100\n+++ /tmp/tmphndda2gl.java\t2023-03-24 22:05:20.493678944 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node) == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (hare.getNodeId(node) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:22.133673001 +0100\n+++ /tmp/tmp5ab8aph4.java\t2023-03-24 22:05:22.133673001 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (hare.getNodeValue().equals(tortoise.getNodeValue())) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:23.969666351 +0100\n+++ /tmp/tmpi1cuew_7.java\t2023-03-24 22:05:23.969666351 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(tortoise.getNodeValue())) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (hare.getNodeType() == Node.ELEMENT_NODE || tortoise == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:25.541660656 +0100\n+++ /tmp/tmpcfd16d6a.java\t2023-03-24 22:05:25.541660656 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeType() == Node.ELEMENT_NODE || tortoise == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (hare.getNodeCount() == 1 && tortoise.getNodeCount() == 1) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:27.273654382 +0100\n+++ /tmp/tmp9wk_3y29.java\t2023-03-24 22:05:27.273654382 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeCount() == 1 && tortoise.getNodeCount() == 1) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (hare.getNode.getNodeValue() == node || tortoise == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:29.037647989 +0100\n+++ /tmp/tmpanammwse.java\t2023-03-24 22:05:29.037647989 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue() == node || tortoise == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (hare.getNodeValue().equals(node.getNodeValue())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:30.749641787 +0100\n+++ /tmp/tmpfib829ai.java\t2023-03-24 22:05:30.753641773 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(node.getNodeValue())) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (hare.getNode().getNodeValue().equals(node.getNodeValue())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:32.549635263 +0100\n+++ /tmp/tmpl9fax0d8.java\t2023-03-24 22:05:32.549635263 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeValue().equals(node.getNodeValue())) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (hare.getNodeValue().equals(tortoise.getNodeValue())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:34.301628915 +0100\n+++ /tmp/tmpph0b0rhg.java\t2023-03-24 22:05:34.301628915 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(tortoise.getNodeValue())) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (hare.getNodeType() == Node.ELEMENT_NODE || hortoise == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:36.045622595 +0100\n+++ /tmp/tmpe87y_nra.java\t2023-03-24 22:05:36.045622595 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeType() == Node.ELEMENT_NODE || hortoise == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (hare.getNode().getNodeValue().equals(tortoise.getNodeValue())) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:37.705616581 +0100\n+++ /tmp/tmpl3rgery8.java\t2023-03-24 22:05:37.705616581 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeValue().equals(tortoise.getNodeValue())) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (hare.getNode().getNodeType() == Node.ELEMENT_NODE) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:39.405610417 +0100\n+++ /tmp/tmpsnhbt79o.java\t2023-03-24 22:05:39.405610417 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeType() == Node.ELEMENT_NODE) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (hare.getNode.getNodeValue() == node || tortoise == node) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:41.165604040 +0100\n+++ /tmp/tmplfba2dbv.java\t2023-03-24 22:05:41.165604040 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue() == node || tortoise == node) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (hare.getNode.getNodeValue().equals(node.getNodeValue())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:42.901597748 +0100\n+++ /tmp/tmpvs_6myit.java\t2023-03-24 22:05:42.905597732 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue().equals(node.getNodeValue())) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (hare.getNode.getNodeValue() == node || tortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:44.677591311 +0100\n+++ /tmp/tmp1683cbv2.java\t2023-03-24 22:05:44.681591295 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue() == node || tortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (hare.getFinished()) { if (hortoise == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:46.413585017 +0100\n+++ /tmp/tmp5ua7cg3j.java\t2023-03-24 22:05:46.413585017 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getFinished()) { if (hortoise == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (hare.getNodeValue().equals(tortoise.getNodeValue())) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:48.177578624 +0100\n+++ /tmp/tmpyzwo7zur.java\t2023-03-24 22:05:48.177578624 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(tortoise.getNodeValue())) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (hare.getNodeValue().equals(node.getNodeValue())) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:49.905572357 +0100\n+++ /tmp/tmp7n3o58qi.java\t2023-03-24 22:05:49.905572357 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(node.getNodeValue())) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (hare.getNodeCount() == 1 && tortoise.get(1) == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:51.565566340 +0100\n+++ /tmp/tmpn2zxmp5y.java\t2023-03-24 22:05:51.565566340 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeCount() == 1 && tortoise.get(1) == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (hare.getNode.getNodeValue().equals(tortoise.getNodeValue())) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:53.329559945 +0100\n+++ /tmp/tmpm0ropka8.java\t2023-03-24 22:05:53.333559931 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue().equals(tortoise.getNodeValue())) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (hare.getNodeValue().equals(node.getNodeValue())) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:55.077553607 +0100\n+++ /tmp/tmp3mzfti71.java\t2023-03-24 22:05:55.077553607 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(node.getNodeValue())) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (hare.getNodeValue() == node || tortoise == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:56.873547095 +0100\n+++ /tmp/tmp61bl2tk8.java\t2023-03-24 22:05:56.873547095 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue() == node || tortoise == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (hare.getNodeType() == Node.ELEMENT_NODE) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:05:58.565540961 +0100\n+++ /tmp/tmpe8exzf27.java\t2023-03-24 22:05:58.565540961 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeType() == Node.ELEMENT_NODE) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (hare.getNode.getNodeValue().equals(node.getNodeValue())) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:00.369534418 +0100\n+++ /tmp/tmpz719ia5x.java\t2023-03-24 22:06:00.369534418 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue().equals(node.getNodeValue())) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (hare.getNode().getNodeValue().equals(node.getNodeValue())) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:02.217527716 +0100\n+++ /tmp/tmpm5enwc2a.java\t2023-03-24 22:06:03.033524757 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeValue().equals(node.getNodeValue())) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (hare.getNode().getNodeValue().equals(tortoise.getNodeValue())) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:05.985514051 +0100\n+++ /tmp/tmpvamk_6tg.java\t2023-03-24 22:06:07.125509917 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeValue().equals(tortoise.getNodeValue())) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (hare.getNodeValue() == node || tortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:09.285502083 +0100\n+++ /tmp/tmpgudzgypz.java\t2023-03-24 22:06:09.285502083 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue() == node || tortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (hare.getNodeCount() == 1 && tortoise.getNodeCount() == 1) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:11.309494740 +0100\n+++ /tmp/tmp_6qe1qfq.java\t2023-03-24 22:06:11.309494740 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeCount() == 1 && tortoise.getNodeCount() == 1) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (hare.getNode().getNodeType() == Node.ELEMENT_NODE) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:13.461486934 +0100\n+++ /tmp/tmpvpbi000o.java\t2023-03-24 22:06:13.465486920 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeType() == Node.ELEMENT_NODE) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (hare.getNodeCount() == 1 && tortoise.get(1) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:15.465479666 +0100\n+++ /tmp/tmp88j9nlu8.java\t2023-03-24 22:06:15.465479666 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeCount() == 1 && tortoise.get(1) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (hare.getNode().getNodeValue().equals(node.getNodeValue())) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:17.337472873 +0100\n+++ /tmp/tmp8ny8m50q.java\t2023-03-24 22:06:17.337472873 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeValue().equals(node.getNodeValue())) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (hare.getNodeType() == Node.ELEMENT_NODE || tortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:19.609464631 +0100\n+++ /tmp/tmp9ecrtgh6.java\t2023-03-24 22:06:19.609464631 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeType() == Node.ELEMENT_NODE || tortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (hare.getNodeCount() == 0) { if (hortoise == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:21.725456955 +0100\n+++ /tmp/tmppkpewsc1.java\t2023-03-24 22:06:21.729456939 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeCount() == 0) { if (hortoise == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (hare.getNodeId(node.getNodeId()) == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:23.957448855 +0100\n+++ /tmp/tmp4r6vw19b.java\t2023-03-24 22:06:23.957448855 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node.getNodeId()) == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (hare.getNode().getNodeType() == Node.ELEMENT_NODE) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:25.961441585 +0100\n+++ /tmp/tmpxuz4hfw4.java\t2023-03-24 22:06:25.961441585 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeType() == Node.ELEMENT_NODE) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (hare.getNodeType() == Node.ELEMENT_NODE || hortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:28.085433876 +0100\n+++ /tmp/tmp9psj3rq1.java\t2023-03-24 22:06:28.085433876 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeType() == Node.ELEMENT_NODE || hortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (hare.getNode.getNodeValue().equals(node.getNodeValue())) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:30.213426154 +0100\n+++ /tmp/tmplq8vu3mn.java\t2023-03-24 22:06:30.213426154 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue().equals(node.getNodeValue())) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (hare.getNodeCount() == 1 && hortoise.getNodeCount() == 1) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:31.753420567 +0100\n+++ /tmp/tmp8ni785ya.java\t2023-03-24 22:06:31.757420550 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeCount() == 1 && hortoise.getNodeCount() == 1) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (hare.getNodeId(node) == null) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:34.121411971 +0100\n+++ /tmp/tmp5cenxwi9.java\t2023-03-24 22:06:34.125411957 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node) == null) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (hare.getNode() == node || tortoise == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:36.637402840 +0100\n+++ /tmp/tmp7dl9jrcl.java\t2023-03-24 22:06:37.569399457 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node || tortoise == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (hare.getNode()) { if (hortoise == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:41.149386463 +0100\n+++ /tmp/tmpj4kfo2sc.java\t2023-03-24 22:06:41.149386463 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode()) { if (hortoise == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (hare.getFinished()) { if (hortoise == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:43.421378214 +0100\n+++ /tmp/tmpc6y5z0j7.java\t2023-03-24 22:06:43.421378214 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getFinished()) { if (hortoise == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (hare.getNodeValue() == node || tortoise == node) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:46.965365348 +0100\n+++ /tmp/tmpe2o91kz0.java\t2023-03-24 22:06:48.025361502 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue() == node || tortoise == node) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (hare.getNode.getNodeValue() == Node.ELEMENT_NODE) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:51.321349533 +0100\n+++ /tmp/tmpvy4pbxlc.java\t2023-03-24 22:06:51.321349533 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue() == Node.ELEMENT_NODE) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (hare.getNode() == node || hortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:54.097339453 +0100\n+++ /tmp/tmpe56f7h57.java\t2023-03-24 22:06:54.101339439 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node || hortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (hare.getNode() == node || hortoise == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:56.221331742 +0100\n+++ /tmp/tmpfs3i_eov.java\t2023-03-24 22:06:56.337331320 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node || hortoise == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (hare.getNodeValue().equals(tortoise)) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:06:58.437323694 +0100\n+++ /tmp/tmpwgxs3311.java\t2023-03-24 22:06:58.437323694 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(tortoise)) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (hortoise.get(node.getNodeValue()) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:00.193317319 +0100\n+++ /tmp/tmp_focnenb.java\t2023-03-24 22:07:00.193317319 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.get(node.getNodeValue()) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (hare.getNode() == node || tortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:02.785307904 +0100\n+++ /tmp/tmphh0vulpe.java\t2023-03-24 22:07:02.785307904 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node || tortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (hare.getNodeAsInt() == node || tortoise == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:04.825300495 +0100\n+++ /tmp/tmptfg2jhik.java\t2023-03-24 22:07:04.825300495 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeAsInt() == node || tortoise == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (hortoise == null) { if (hortoise == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:07.001292593 +0100\n+++ /tmp/tmp4z9hmepe.java\t2023-03-24 22:07:07.161292010 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) { if (hortoise == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (hare.getNode.getNodeValue() == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:09.337284108 +0100\n+++ /tmp/tmpf74_f0gu.java\t2023-03-24 22:07:09.337284108 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue() == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (hare.getNodeName().equals(tortoise.getNodeName())) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:11.489276289 +0100\n+++ /tmp/tmpuul4ras5.java\t2023-03-24 22:07:11.489276289 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeName().equals(tortoise.getNodeName())) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (hortoise.get(node.getNodeValue()) == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:13.937267399 +0100\n+++ /tmp/tmpmrpqhrod.java\t2023-03-24 22:07:13.937267399 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.get(node.getNodeValue()) == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (hare.getNodeType() == Node.ELEMENT_NODE) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:16.073259637 +0100\n+++ /tmp/tmpbo1oeu45.java\t2023-03-24 22:07:16.073259637 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeType() == Node.ELEMENT_NODE) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (hortoise == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:18.213251863 +0100\n+++ /tmp/tmpogkm5cpm.java\t2023-03-24 22:07:18.325251455 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (hare.getNode.getType() == Node.ELEMENT_NODE) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:21.249240833 +0100\n+++ /tmp/tmp12gduoz5.java\t2023-03-24 22:07:21.249240833 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getType() == Node.ELEMENT_NODE) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (hare.getNodeId(node.getNodeId()) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:23.545232489 +0100\n+++ /tmp/tmp4tevtj9k.java\t2023-03-24 22:07:23.545232489 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node.getNodeId()) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (hare.getNodeValue() == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:25.805224277 +0100\n+++ /tmp/tmp21y0dwc0.java\t2023-03-24 22:07:25.805224277 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue() == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (hare.getNode().getType() == Node.ELEMENT_NODE) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:28.173215673 +0100\n+++ /tmp/tmp0_io9qww.java\t2023-03-24 22:07:28.173215673 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getType() == Node.ELEMENT_NODE) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (hare.get(node.getNodeValue()) == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:30.213208261 +0100\n+++ /tmp/tmpf2q5m290.java\t2023-03-24 22:07:30.213208261 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.get(node.getNodeValue()) == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (hare.getSuccessor() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:32.073201502 +0100\n+++ /tmp/tmp9_s5rcdr.java\t2023-03-24 22:07:32.073201502 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getSuccessor() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (hare.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:34.453192852 +0100\n+++ /tmp/tmpaca9zn4c.java\t2023-03-24 22:07:34.453192852 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (hare.getNode().getNodeType() == Node.TEXT_NODE) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:36.429185668 +0100\n+++ /tmp/tmpoe_x88r5.java\t2023-03-24 22:07:36.433185654 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode().getNodeType() == Node.TEXT_NODE) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (hare.get(node.getNodeValue()) == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:39.189175638 +0100\n+++ /tmp/tmplem0d43h.java\t2023-03-24 22:07:39.189175638 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.get(node.getNodeValue()) == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (hare.getNodeId(node) == null) return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:41.729166405 +0100\n+++ /tmp/tmpj63920p1.java\t2023-03-24 22:07:41.729166405 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node) == null) return false;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (hare.getNode == node || hortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:43.501159965 +0100\n+++ /tmp/tmpn23qds3i.java\t2023-03-24 22:07:43.501159965 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode == node || hortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (hare.getNodeValue().equals(tortoise)) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:45.313153376 +0100\n+++ /tmp/tmp8d1_rda6.java\t2023-03-24 22:07:45.317153362 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(tortoise)) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (hare.get(node.getNodeValue()) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:47.041147095 +0100\n+++ /tmp/tmpizubhmf8.java\t2023-03-24 22:07:47.041147095 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.get(node.getNodeValue()) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (hare.getNodeId(node) == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:48.749140887 +0100\n+++ /tmp/tmp26p674c2.java\t2023-03-24 22:07:48.749140887 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node) == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (hare.get(node) == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:50.437134748 +0100\n+++ /tmp/tmp3pv4irby.java\t2023-03-24 22:07:50.437134748 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.get(node) == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (hortoise == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:52.125128612 +0100\n+++ /tmp/tmpmh_r8wt3.java\t2023-03-24 22:07:52.125128612 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (hare.getNode.getNodeValue() == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:53.853122329 +0100\n+++ /tmp/tmp_ztek139.java\t2023-03-24 22:07:53.853122329 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode.getNodeValue() == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (hare.getNode == node || tortoise == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:55.609115946 +0100\n+++ /tmp/tmp6yflgu6w.java\t2023-03-24 22:07:55.609115946 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode == node || tortoise == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (hare.get(node.getNodeValue()) == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:57.357109589 +0100\n+++ /tmp/tmpb3zagsbt.java\t2023-03-24 22:07:57.357109589 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.get(node.getNodeValue()) == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (hare.getNodeValue() == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:07:59.101103247 +0100\n+++ /tmp/tmppjtcl12y.java\t2023-03-24 22:07:59.101103247 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue() == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (hortoise.getCount() == 1) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:00.757097225 +0100\n+++ /tmp/tmplq_jqdj8.java\t2023-03-24 22:08:00.757097225 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getCount() == 1) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (hortoise.getSuccessor() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:02.525090796 +0100\n+++ /tmp/tmpks_1nzsl.java\t2023-03-24 22:08:02.525090796 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getSuccessor() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (hare.get(node) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:04.329084236 +0100\n+++ /tmp/tmpfoj1ik05.java\t2023-03-24 22:08:04.329084236 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.get(node) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (hh.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:06.093077822 +0100\n+++ /tmp/tmp3c_jd84s.java\t2023-03-24 22:08:06.097077806 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hh.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (hortoise.getNodeId() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:07.789071652 +0100\n+++ /tmp/tmplu122oob.java\t2023-03-24 22:08:07.789071652 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNodeId() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (hare.getNode() == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:09.593065092 +0100\n+++ /tmp/tmpdfphjez8.java\t2023-03-24 22:08:09.593065092 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (hare.getNodeAsInt() == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:11.469058268 +0100\n+++ /tmp/tmp0tgf77d2.java\t2023-03-24 22:08:11.473058254 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeAsInt() == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (hare.getNodeNode(node) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:13.205051955 +0100\n+++ /tmp/tmpn9lto98b.java\t2023-03-24 22:08:13.205051955 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeNode(node) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (hare.getNode()) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:15.053045232 +0100\n+++ /tmp/tmpklgj3a4t.java\t2023-03-24 22:08:15.057045218 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode()) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (hare.getNodeAsInt() == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:16.733039122 +0100\n+++ /tmp/tmpuxzgv4kb.java\t2023-03-24 22:08:16.733039122 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeAsInt() == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (ha.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:18.593032355 +0100\n+++ /tmp/tmp63fm7pr3.java\t2023-03-24 22:08:18.593032355 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (ha.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (hare.getNodeCount() == 1) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:20.285026199 +0100\n+++ /tmp/tmp6ytpam_q.java\t2023-03-24 22:08:20.289026185 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeCount() == 1) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (hare.getNode(node) == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:22.081019666 +0100\n+++ /tmp/tmpft_sw4d0.java\t2023-03-24 22:08:22.081019666 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode(node) == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (hh.getSuccessor() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:23.873013149 +0100\n+++ /tmp/tmpgjg4gtun.java\t2023-03-24 22:08:23.873013149 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hh.getSuccessor() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (ha.getSuccessor() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:25.581006933 +0100\n+++ /tmp/tmpvh1_964g.java\t2023-03-24 22:08:25.581006933 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (ha.getSuccessor() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (hare.getNodeId(node) == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:27.417000254 +0100\n+++ /tmp/tmptfz54i7c.java\t2023-03-24 22:08:27.417000254 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeId(node) == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (hare.getNode() == node) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:29.060994271 +0100\n+++ /tmp/tmpy3koq95q.java\t2023-03-24 22:08:29.064994257 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (hare.getNodeDescription() == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:30.756988102 +0100\n+++ /tmp/tmp1y3numsk.java\t2023-03-24 22:08:30.756988102 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeDescription() == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (hare.getNode == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:32.500981755 +0100\n+++ /tmp/tmpj3xpc_wi.java\t2023-03-24 22:08:32.500981755 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (hortoise == null) break;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:34.264975337 +0100\n+++ /tmp/tmpvtbo6f49.java\t2023-03-24 22:08:34.264975337 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) break;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (hortoise == null) return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:35.984969078 +0100\n+++ /tmp/tmp8o_f2zho.java\t2023-03-24 22:08:36.004969004 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) return false;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:37.712962789 +0100\n+++ /tmp/tmpi4l6gjay.java\t2023-03-24 22:08:37.712962789 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if);\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:39.300957010 +0100\n+++ /tmp/tmpr62bjfq_.java\t2023-03-24 22:08:39.340956865 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 22:08:40.952951000 +0100\n+++ /tmp/tmpp_resajr.java\t2023-03-24 22:08:40.952951000 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (null==hare ||hare.getSuccessor() == null)"
    },
    "lis": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "longest = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:15.369044084 +0100\n+++ /tmp/tmpnnf9ny3k.java\t2023-03-24 22:08:15.401043966 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "longest = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:19.305029765 +0100\n+++ /tmp/tmpqvch8zuv.java\t2023-03-24 22:08:19.309029751 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "longest = val / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:23.409014835 +0100\n+++ /tmp/tmpmuv5l074.java\t2023-03-24 22:08:23.409014835 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "longest = val + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:27.481000021 +0100\n+++ /tmp/tmp76_uxnla.java\t2023-03-24 22:08:27.481000021 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "tagName = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:31.412985714 +0100\n+++ /tmp/tmp16xg_ttp.java\t2023-03-24 22:08:31.420985684 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+tagName = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "pivot = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:33.280978919 +0100\n+++ /tmp/tmpg1whroxl.java\t2023-03-24 22:08:33.280978919 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+pivot = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "remains = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:35.168972046 +0100\n+++ /tmp/tmp_czvfw0g.java\t2023-03-24 22:08:35.172972032 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+remains = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "sl = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:37.020965308 +0100\n+++ /tmp/tmptks7sb23.java\t2023-03-24 22:08:37.024965295 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+sl = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "=0 = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:38.884958524 +0100\n+++ /tmp/tmpmxr5rbe0.java\t2023-03-24 22:08:38.888958510 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+=0 = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "shorthand = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:40.660952063 +0100\n+++ /tmp/tmpgl_xck8s.java\t2023-03-24 22:08:40.664952046 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+shorthand = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "mini = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:42.532945248 +0100\n+++ /tmp/tmpznts83o3.java\t2023-03-24 22:08:42.532945248 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+mini = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "SourceFile = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:44.536937955 +0100\n+++ /tmp/tmpzw228m86.java\t2023-03-24 22:08:44.536937955 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+SourceFile = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "longest = val + 10;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:46.484930864 +0100\n+++ /tmp/tmp58i7kr7k.java\t2023-03-24 22:08:46.484930864 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + 10;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "appending = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:50.608915854 +0100\n+++ /tmp/tmp3b26008r.java\t2023-03-24 22:08:50.612915840 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+appending = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "recipient = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:52.420909259 +0100\n+++ /tmp/tmpcgn5vg18.java\t2023-03-24 22:08:52.424909246 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+recipient = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "permutations = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:54.300902416 +0100\n+++ /tmp/tmpntgmh0ji.java\t2023-03-24 22:08:54.300902416 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+permutations = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "iblings = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:56.156895660 +0100\n+++ /tmp/tmpbsz_44qo.java\t2023-03-24 22:08:56.156895660 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+iblings = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "lessThan = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:57.852889485 +0100\n+++ /tmp/tmp6dpbl62_.java\t2023-03-24 22:08:57.852889485 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+lessThan = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "exiting = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:08:59.368883966 +0100\n+++ /tmp/tmpj3rs38ee.java\t2023-03-24 22:08:59.368883966 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+exiting = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "rolling = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:00.848878579 +0100\n+++ /tmp/tmp3m63axye.java\t2023-03-24 22:09:00.848878579 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+rolling = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "watcher = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:02.340873146 +0100\n+++ /tmp/tmplrrd8s1q.java\t2023-03-24 22:09:02.352873102 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+watcher = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "\"? = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:03.912867423 +0100\n+++ /tmp/tmpkftghtsj.java\t2023-03-24 22:09:03.916867409 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+\"? = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "Cat = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:05.380862080 +0100\n+++ /tmp/tmpl2efra16.java\t2023-03-24 22:09:05.380862080 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Cat = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "DC = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:06.860856690 +0100\n+++ /tmp/tmpr2siahs7.java\t2023-03-24 22:09:06.860856690 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+DC = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "FoundError = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:08.380851156 +0100\n+++ /tmp/tmpi2kj_74v.java\t2023-03-24 22:09:08.380851156 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+FoundError = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "1] = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:09.928845521 +0100\n+++ /tmp/tmpe07gmej2.java\t2023-03-24 22:09:09.928845521 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+1] = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "ActionEvent = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:11.384840219 +0100\n+++ /tmp/tmpxp97mk_5.java\t2023-03-24 22:09:11.384840219 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ActionEvent = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "ham = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:12.892834726 +0100\n+++ /tmp/tmpmfx17xtf.java\t2023-03-24 22:09:12.892834726 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ham = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "clusions = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:14.432829118 +0100\n+++ /tmp/tmpvolg91ab.java\t2023-03-24 22:09:14.436829104 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+clusions = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "LineString = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:15.956823571 +0100\n+++ /tmp/tmp_zbm5gox.java\t2023-03-24 22:09:15.960823554 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+LineString = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "commented = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:17.476818034 +0100\n+++ /tmp/tmp05mwn18w.java\t2023-03-24 22:09:17.476818034 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+commented = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "ATFORM = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:19.004812470 +0100\n+++ /tmp/tmppa0zdicu.java\t2023-03-24 22:09:19.004812470 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ATFORM = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "PAY = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:20.548806846 +0100\n+++ /tmp/tmply21nek7.java\t2023-03-24 22:09:20.548806846 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+PAY = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "missed = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:22.048801383 +0100\n+++ /tmp/tmpl5ppz1ti.java\t2023-03-24 22:09:22.052801370 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+missed = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "AttributeSet = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:24.104793897 +0100\n+++ /tmp/tmpo_uup6rw.java\t2023-03-24 22:09:24.104793897 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+AttributeSet = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "lessThan = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:25.860787501 +0100\n+++ /tmp/tmptwrc7sv9.java\t2023-03-24 22:09:25.864787484 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+lessThan = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "utc = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:28.088779384 +0100\n+++ /tmp/tmpvnffydti.java\t2023-03-24 22:09:28.088779384 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+utc = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "probe = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:30.332771210 +0100\n+++ /tmp/tmp1t2ju1z7.java\t2023-03-24 22:09:30.336771196 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+probe = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "LATED = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:32.444763518 +0100\n+++ /tmp/tmp0aq7t7hf.java\t2023-03-24 22:09:32.444763518 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+LATED = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "tagName = val + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:34.492756059 +0100\n+++ /tmp/tmpmklr9swo.java\t2023-03-24 22:09:34.496756042 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+tagName = val + 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "wr = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:36.604748364 +0100\n+++ /tmp/tmpkf80uol3.java\t2023-03-24 22:09:36.640748233 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+wr = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "dim = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:38.504741442 +0100\n+++ /tmp/tmpms49o7xy.java\t2023-03-24 22:09:38.504741442 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+dim = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "unload = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:40.596733821 +0100\n+++ /tmp/tmp5b64hj0x.java\t2023-03-24 22:09:40.596733821 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+unload = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "ToDate = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:42.728726053 +0100\n+++ /tmp/tmp9yp_veuo.java\t2023-03-24 22:09:42.796725807 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ToDate = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "=[ = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:44.880718215 +0100\n+++ /tmp/tmpzw3ul0zr.java\t2023-03-24 22:09:44.884718198 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+=[ = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "tests = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:46.688711626 +0100\n+++ /tmp/tmpbqql2f5d.java\t2023-03-24 22:09:46.688711626 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+tests = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "Framework = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:48.524704936 +0100\n+++ /tmp/tmpy66fdlgu.java\t2023-03-24 22:09:48.524704936 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Framework = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "letter = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:50.632697257 +0100\n+++ /tmp/tmpe40uyy35.java\t2023-03-24 22:09:50.632697257 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+letter = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "shorthand = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:53.128688160 +0100\n+++ /tmp/tmp79o1538l.java\t2023-03-24 22:09:53.128688160 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+shorthand = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "argv = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:54.944681545 +0100\n+++ /tmp/tmpzgsg9p19.java\t2023-03-24 22:09:54.944681545 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+argv = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "RepeatedField = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:56.972674152 +0100\n+++ /tmp/tmp9568434o.java\t2023-03-24 22:09:57.072673788 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+RepeatedField = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "fos = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:09:58.992666793 +0100\n+++ /tmp/tmpxkr11ecp.java\t2023-03-24 22:09:58.992666793 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+fos = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "*** = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:00.852660014 +0100\n+++ /tmp/tmp6qfykhjh.java\t2023-03-24 22:10:00.852660014 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+*** = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "Foreign = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:03.004652171 +0100\n+++ /tmp/tmpfy6j8dn0.java\t2023-03-24 22:10:03.008652157 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Foreign = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "sl = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:04.976644985 +0100\n+++ /tmp/tmpp275mg7a.java\t2023-03-24 22:10:04.976644985 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+sl = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "KeyId = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:07.052637418 +0100\n+++ /tmp/tmphj6tlho7.java\t2023-03-24 22:10:07.116637183 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+KeyId = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "anno = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:09.100629952 +0100\n+++ /tmp/tmpgtrcuyqh.java\t2023-03-24 22:10:09.104629939 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+anno = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "chunkSize = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:11.024622939 +0100\n+++ /tmp/tmpko_m2c_3.java\t2023-03-24 22:10:11.028622925 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+chunkSize = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "dns = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:13.196615023 +0100\n+++ /tmp/tmp2uwsubpz.java\t2023-03-24 22:10:13.196615023 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+dns = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "splitted = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:15.032608329 +0100\n+++ /tmp/tmpgdxw6ncx.java\t2023-03-24 22:10:15.036608315 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+splitted = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "Foreign = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:17.380599771 +0100\n+++ /tmp/tmppvs2suhi.java\t2023-03-24 22:10:17.488599377 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Foreign = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "strategy = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:19.496592057 +0100\n+++ /tmp/tmp69ididru.java\t2023-03-24 22:10:19.496592057 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+strategy = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "trunc = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:21.416585058 +0100\n+++ /tmp/tmp9ehptt_0.java\t2023-03-24 22:10:21.416585058 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+trunc = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "ENCODING = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:23.560577244 +0100\n+++ /tmp/tmpsyypao8u.java\t2023-03-24 22:10:23.560577244 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ENCODING = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "specified = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:25.616569746 +0100\n+++ /tmp/tmpoysku1f8.java\t2023-03-24 22:10:25.616569746 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+specified = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": ",0 = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:27.812561740 +0100\n+++ /tmp/tmpuxa3llx3.java\t2023-03-24 22:10:27.868561536 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+,0 = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "SAME = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:29.664554988 +0100\n+++ /tmp/tmpiz7v4wea.java\t2023-03-24 22:10:29.664554988 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+SAME = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "mnemonic = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:31.600547929 +0100\n+++ /tmp/tmpqhvr0tjc.java\t2023-03-24 22:10:31.604547915 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+mnemonic = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "comput = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:33.728540170 +0100\n+++ /tmp/tmp0m9osn3n.java\t2023-03-24 22:10:33.728540170 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+comput = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "notifier = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:35.640533199 +0100\n+++ /tmp/tmpsrn176m1.java\t2023-03-24 22:10:35.640533199 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+notifier = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "bal = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:37.464526547 +0100\n+++ /tmp/tmpufbib92x.java\t2023-03-24 22:10:37.464526547 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+bal = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "UAL = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:39.576518846 +0100\n+++ /tmp/tmp7x4w6kwk.java\t2023-03-24 22:10:39.576518846 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+UAL = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "codePoint = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:41.600511465 +0100\n+++ /tmp/tmpho35xhap.java\t2023-03-24 22:10:41.604511452 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+codePoint = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "conditions = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:43.696503822 +0100\n+++ /tmp/tmpu6kfqbzl.java\t2023-03-24 22:10:43.756503603 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+conditions = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "Sequential = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:45.684496572 +0100\n+++ /tmp/tmp0zw5t54p.java\t2023-03-24 22:10:45.684496572 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Sequential = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "ATFORM = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:47.656489380 +0100\n+++ /tmp/tmp9xsfdeta.java\t2023-03-24 22:10:47.656489380 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ATFORM = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "bounded = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:49.812481519 +0100\n+++ /tmp/tmpe8vvrqw5.java\t2023-03-24 22:10:49.812481519 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+bounded = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "ranges = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:51.976473624 +0100\n+++ /tmp/tmpqp6hmdkz.java\t2023-03-24 22:10:51.976473624 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ranges = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "bytecode = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:54.320465076 +0100\n+++ /tmp/tmp9qk07f1c.java\t2023-03-24 22:10:54.320465076 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+bytecode = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "ales = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:56.224458130 +0100\n+++ /tmp/tmp5m_0gjz0.java\t2023-03-24 22:10:56.228458116 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ales = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "recursive = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:10:58.256450721 +0100\n+++ /tmp/tmpuu1k5idm.java\t2023-03-24 22:10:58.256450721 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+recursive = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "longest = i / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:00.592442198 +0100\n+++ /tmp/tmp5y1l59qv.java\t2023-03-24 22:11:00.592442198 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = i / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "exiting = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:04.212428993 +0100\n+++ /tmp/tmpez4wrx_a.java\t2023-03-24 22:11:04.212428993 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+exiting = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "ksession = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:05.744423405 +0100\n+++ /tmp/tmp8t4zoboj.java\t2023-03-24 22:11:05.748423392 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ksession = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "sigma = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:07.276417816 +0100\n+++ /tmp/tmp97loucir.java\t2023-03-24 22:11:07.276417816 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+sigma = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "extensions = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:08.768412373 +0100\n+++ /tmp/tmpvh3o0wxi.java\t2023-03-24 22:11:08.768412373 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+extensions = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "LineString = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:10.268406901 +0100\n+++ /tmp/tmp6g7f5gg0.java\t2023-03-24 22:11:10.268406901 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+LineString = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "divisor = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:11.816401253 +0100\n+++ /tmp/tmp1w50ms64.java\t2023-03-24 22:11:11.816401253 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+divisor = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "=0 = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:13.344395678 +0100\n+++ /tmp/tmp3p3mtzss.java\t2023-03-24 22:11:13.344395678 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+=0 = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "Mappers = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:14.768390483 +0100\n+++ /tmp/tmp9k6zd13i.java\t2023-03-24 22:11:14.768390483 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Mappers = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "longest = i + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:16.240385115 +0100\n+++ /tmp/tmpgpfezail.java\t2023-03-24 22:11:16.240385115 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = i + 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "missed = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:19.620372781 +0100\n+++ /tmp/tmp6hnz7_xq.java\t2023-03-24 22:11:19.620372781 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+missed = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "Buckets = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:21.136367251 +0100\n+++ /tmp/tmp836m4w0c.java\t2023-03-24 22:11:21.136367251 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Buckets = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "asc = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:22.592361939 +0100\n+++ /tmp/tmpcv80aokd.java\t2023-03-24 22:11:22.592361939 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+asc = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "Mappers = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:24.176356157 +0100\n+++ /tmp/tmpk4gdwd4c.java\t2023-03-24 22:11:24.176356157 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Mappers = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "sex = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:25.724350509 +0100\n+++ /tmp/tmpd29t_shb.java\t2023-03-24 22:11:25.724350509 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+sex = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "permutations = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:27.212345079 +0100\n+++ /tmp/tmpje32jmpy.java\t2023-03-24 22:11:27.212345079 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+permutations = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "sl = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:28.728339546 +0100\n+++ /tmp/tmpyhxpbawo.java\t2023-03-24 22:11:28.728339546 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+sl = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "sl = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:30.236334044 +0100\n+++ /tmp/tmp1lq54aq5.java\t2023-03-24 22:11:30.236334044 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+sl = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "});",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 22:11:31.760328483 +0100\n+++ /tmp/tmp1nt1z9nj.java\t2023-03-24 22:11:31.760328483 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+});\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "longest = Math.max(longest,length + 1);"
    },
    "reverse_linked_list": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (nextnode == null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:08:45.316935116 +0100\n+++ /tmp/tmpturbf0gl.java\t2023-03-24 22:08:45.376934900 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (nextnode!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:08:49.304920601 +0100\n+++ /tmp/tmph_seh2p2.java\t2023-03-24 22:08:49.308920587 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (nextnode == null) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:08:53.192906448 +0100\n+++ /tmp/tmpbvg99pmp.java\t2023-03-24 22:08:53.192906448 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (nextnode!= null) { nextnode = nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:18:55.438705153 +0100\n+++ /tmp/tmp74go6fvd.java\t2023-03-24 22:18:55.438705153 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { nextnode = nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (nextnode!= null) { return nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:08.118658435 +0100\n+++ /tmp/tmp4v5d7pvk.java\t2023-03-24 22:19:08.118658435 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { return nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (nextnode == null) { return nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:20.446613017 +0100\n+++ /tmp/tmpxrx4ujwf.java\t2023-03-24 22:19:20.446613017 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { return nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (nextnode == null) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:30.726575145 +0100\n+++ /tmp/tmp79fgxlvi.java\t2023-03-24 22:19:30.730575129 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (nextnode.getParent() == node) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:38.742545614 +0100\n+++ /tmp/tmpa23o_2sx.java\t2023-03-24 22:19:38.746545600 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getParent() == node) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (nextnode.getNode() == node) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:41.846534180 +0100\n+++ /tmp/tmpejkd1w4_.java\t2023-03-24 22:19:41.846534180 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (nextnode!= null) { nextnode = node.next; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:44.726523571 +0100\n+++ /tmp/tmpo2ymdr_3.java\t2023-03-24 22:19:44.726523571 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { nextnode = node.next; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (nextnode == null) { nextnode = node.next; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:47.726512521 +0100\n+++ /tmp/tmpsaudluk1.java\t2023-03-24 22:19:47.726512521 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { nextnode = node.next; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (nextnode.getParent() == node) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:50.850501012 +0100\n+++ /tmp/tmpnf8cjizp.java\t2023-03-24 22:19:50.850501012 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getParent() == node) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (nextnode.getNode() == node) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:53.602490875 +0100\n+++ /tmp/tmp64z4u750.java\t2023-03-24 22:19:53.606490861 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (nextnode == null) { nextnode = node; continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:19:56.354480739 +0100\n+++ /tmp/tmpet40dahh.java\t2023-03-24 22:19:56.354480739 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { nextnode = node; continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (nextnode!= null) { node = nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:00.188258468 +0100\n+++ /tmp/tmpm_37oh_8.java\t2023-03-24 22:30:00.192258451 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node = nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (nextnode!= null) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:03.420246578 +0100\n+++ /tmp/tmp17c950bq.java\t2023-03-24 22:30:03.420246578 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "node.addChild(nextNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:06.560235029 +0100\n+++ /tmp/tmprr_tygou.java\t2023-03-24 22:30:06.560235029 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(nextNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (nextnode!= null) { return next; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:07.988229779 +0100\n+++ /tmp/tmp8wpevih0.java\t2023-03-24 22:30:07.988229779 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { return next; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (nextnode!= null) { node.setValue(nextnode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:09.376224672 +0100\n+++ /tmp/tmpyzuyk3dd.java\t2023-03-24 22:30:09.380224659 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.setValue(nextnode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (nextnode!= null) { node.set(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:10.788219479 +0100\n+++ /tmp/tmpjmy9x_ve.java\t2023-03-24 22:30:10.788219479 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.set(nextNode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (nextnode == null) { return nextNode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:12.232214168 +0100\n+++ /tmp/tmp77oeud4c.java\t2023-03-24 22:30:12.232214168 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { return nextNode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (nextnode!= null) { next node = nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:13.600209139 +0100\n+++ /tmp/tmpmk2mbdmk.java\t2023-03-24 22:30:13.600209139 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { next node = nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (nextnode!= null) { nextNode = nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:15.088203664 +0100\n+++ /tmp/tmpyz5obowz.java\t2023-03-24 22:30:15.092203651 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { nextNode = nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (nextnode!= null) { return nextNode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:16.580198177 +0100\n+++ /tmp/tmp0g5lwbb4.java\t2023-03-24 22:30:16.580198177 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { return nextNode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (nextnode!= null) { node.add(next); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:18.024192867 +0100\n+++ /tmp/tmp9wg86wiv.java\t2023-03-24 22:30:18.024192867 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.add(next); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (nextnode == null) { nextnode = node; break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:19.440187657 +0100\n+++ /tmp/tmpr3lwwkp2.java\t2023-03-24 22:30:19.440187657 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { nextnode = node; break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (!prevnode.is(nextNode)) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:22.760175446 +0100\n+++ /tmp/tmp2tndon5w.java\t2023-03-24 22:30:22.760175446 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (!prevnode.is(nextNode)) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (nextnode == null) { node = nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:24.196170165 +0100\n+++ /tmp/tmpnz5o66tm.java\t2023-03-24 22:30:24.200170152 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { node = nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (nextnode!= null) { ++nextnode; continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:27.556157807 +0100\n+++ /tmp/tmp8z69gw8y.java\t2023-03-24 22:30:27.556157807 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { ++nextnode; continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (nextnode.getParent() == null) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:28.988152540 +0100\n+++ /tmp/tmp8d7m2kgo.java\t2023-03-24 22:30:28.992152528 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getParent() == null) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (nextnode.getNode() == node) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:30.388147391 +0100\n+++ /tmp/tmpqtz0kwln.java\t2023-03-24 22:30:30.388147391 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (nextnode == null) { node = nextnode; continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:31.776142287 +0100\n+++ /tmp/tmp5vsg0iyv.java\t2023-03-24 22:30:31.776142287 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { node = nextnode; continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (nextnode!= null) { node.setValue(prevnode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:34.992130458 +0100\n+++ /tmp/tmp3c6jswep.java\t2023-03-24 22:30:34.992130458 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.setValue(prevnode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (nextnode!= null) { node.next = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:36.424125194 +0100\n+++ /tmp/tmpr_k8v6ri.java\t2023-03-24 22:30:36.428125177 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.next = node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (nextnode!= null) { node = nextnode; continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:37.864119897 +0100\n+++ /tmp/tmpf995dwaf.java\t2023-03-24 22:30:37.864119897 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node = nextnode; continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (nextnode!= null) { prevnode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:41.096108010 +0100\n+++ /tmp/tmpjj9pn__f.java\t2023-03-24 22:30:41.096108010 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { prevnode = node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (nextnode == null) { prevnode = node; continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:30:44.376095945 +0100\n+++ /tmp/tmph6hm04ll.java\t2023-03-24 22:30:44.376095945 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { prevnode = node; continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (nextnode!= null) { node.next = nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:40:46.985880183 +0100\n+++ /tmp/tmpmkgtcuzt.java\t2023-03-24 22:40:46.985880183 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.next = nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (nextnode == null) { nextnode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:40:48.357875140 +0100\n+++ /tmp/tmp6c4jthf0.java\t2023-03-24 22:40:48.357875140 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { nextnode = node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (nextnode!= null) { throw nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:50:51.331658584 +0100\n+++ /tmp/tmpjfgev5n0.java\t2023-03-24 22:50:51.331658584 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { throw nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (nextnode == null) { nextnode = nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:50:59.619628119 +0100\n+++ /tmp/tmpayposuvc.java\t2023-03-24 22:50:59.619628119 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { nextnode = nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (nextnode!= null) { node.addChild(next); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:51:17.363562893 +0100\n+++ /tmp/tmppl_spzo9.java\t2023-03-24 22:51:17.363562893 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.addChild(next); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (nextnode!= null) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:51:25.099534456 +0100\n+++ /tmp/tmpao5921hl.java\t2023-03-24 22:51:25.099534456 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (nextnode == null) { prevnode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:51:42.395470882 +0100\n+++ /tmp/tmpph4be36a.java\t2023-03-24 22:51:42.395470882 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { prevnode = node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (prevnode!= null) { nextnode = node.next; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:51:59.363408511 +0100\n+++ /tmp/tmpcrgr3rkf.java\t2023-03-24 22:51:59.363408511 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (prevnode!= null) { nextnode = node.next; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "prevnode = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:05.923384398 +0100\n+++ /tmp/tmp592rs1tw.java\t2023-03-24 22:52:05.923384398 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (nextnode!= null) { nextnode = nextNode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:12.431360474 +0100\n+++ /tmp/tmpy5zofl3f.java\t2023-03-24 22:52:12.431360474 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { nextnode = nextNode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "node.addChild(prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:17.887340418 +0100\n+++ /tmp/tmpy75uyyzc.java\t2023-03-24 22:52:17.887340418 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (!nextnode.isMarked) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:23.631319305 +0100\n+++ /tmp/tmpod272u1o.java\t2023-03-24 22:52:23.631319305 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (!nextnode.isMarked) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (prevnode!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:29.419298029 +0100\n+++ /tmp/tmp5fwqlkur.java\t2023-03-24 22:52:29.419298029 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (prevnode!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "node.setValue(nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:42.675245057 +0100\n+++ /tmp/tmptit_10q6.java\t2023-03-24 22:52:42.675245057 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setValue(nextnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "node.nextNode = node.nextNode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:48.283218088 +0100\n+++ /tmp/tmpwq6qtiyy.java\t2023-03-24 22:52:48.283218088 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.nextNode = node.nextNode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (nextnode!= null) { ++nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:53.699192101 +0100\n+++ /tmp/tmpi88gy456.java\t2023-03-24 22:52:53.699192101 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { ++nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "node.addChild(nextNode, null, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:52:59.331165137 +0100\n+++ /tmp/tmppcudeubz.java\t2023-03-24 22:52:59.331165137 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(nextNode, null, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (nextnode == null) { return next; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:53:04.551140199 +0100\n+++ /tmp/tmpexvraug6.java\t2023-03-24 22:53:04.551140199 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { return next; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (!nextnode.isMarked) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:53:09.791115220 +0100\n+++ /tmp/tmpvq_4vlm2.java\t2023-03-24 22:53:09.791115220 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (!nextnode.isMarked) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (prevnode == null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:53:14.951090672 +0100\n+++ /tmp/tmp4py2_0rp.java\t2023-03-24 22:53:14.951090672 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (prevnode == null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "prevnode.addChild(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:53:22.979052577 +0100\n+++ /tmp/tmp1guxpp2n.java\t2023-03-24 22:53:22.979052577 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "node.addChild(nextNode, parent, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:53:26.563035610 +0100\n+++ /tmp/tmplc82cgpj.java\t2023-03-24 22:53:26.567035590 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(nextNode, parent, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (prevnode == null) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 22:53:29.651021007 +0100\n+++ /tmp/tmpgwzfrwu9.java\t2023-03-24 22:53:29.679020875 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (prevnode == null) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "prevnode.addChild(nextNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:33.832396200 +0100\n+++ /tmp/tmpe1dww7zr.java\t2023-03-24 23:03:33.832396200 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(nextNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "node.addChild(nextNode, child);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:35.236390464 +0100\n+++ /tmp/tmp8m83258x.java\t2023-03-24 23:03:35.236390464 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(nextNode, child);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "node.addChild(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:36.636384745 +0100\n+++ /tmp/tmpmo9yfcre.java\t2023-03-24 23:03:36.636384745 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "node.setNode(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:37.952379368 +0100\n+++ /tmp/tmp9tfext9k.java\t2023-03-24 23:03:37.952379368 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setNode(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "node.nextNode = node.nextNode();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:39.312373817 +0100\n+++ /tmp/tmpui4wb3h7.java\t2023-03-24 23:03:39.312373817 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.nextNode = node.nextNode();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "node.setParent(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:40.724368050 +0100\n+++ /tmp/tmpu13hm6et.java\t2023-03-24 23:03:40.724368050 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setParent(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "prevNode = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:42.124362337 +0100\n+++ /tmp/tmpeibmbgwd.java\t2023-03-24 23:03:42.124362337 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "node.removeChild(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:43.500356722 +0100\n+++ /tmp/tmpy5ssf7t3.java\t2023-03-24 23:03:43.500356722 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.removeChild(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "node.next = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:44.924350909 +0100\n+++ /tmp/tmp2_u1arl0.java\t2023-03-24 23:03:44.924350909 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.next = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "node.prevNode = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:46.372345004 +0100\n+++ /tmp/tmpt0lmragf.java\t2023-03-24 23:03:46.372345004 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.prevNode = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "node.add(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:47.756339359 +0100\n+++ /tmp/tmpl37f887l.java\t2023-03-24 23:03:47.760339340 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.add(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "prevnode = node.prevNode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:49.120333794 +0100\n+++ /tmp/tmp2zbyh_5b.java\t2023-03-24 23:03:49.124333780 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.prevNode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (nextnode!= null) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:50.544327988 +0100\n+++ /tmp/tmpv3jwl570.java\t2023-03-24 23:03:50.544327988 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "node.setValue(prevnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:53.860314471 +0100\n+++ /tmp/tmp8z2suxjt.java\t2023-03-24 23:03:53.860314471 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setValue(prevnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "node.setChild(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:55.324308505 +0100\n+++ /tmp/tmps2h55kbu.java\t2023-03-24 23:03:55.328308490 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setChild(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "prevNode = node.nextNode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:56.764302640 +0100\n+++ /tmp/tmpzlrgbe9r.java\t2023-03-24 23:03:56.768302625 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.nextNode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "node.add(prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:58.168296921 +0100\n+++ /tmp/tmp4x_rvoai.java\t2023-03-24 23:03:58.168296921 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.add(prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "node.setNode(nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:03:59.564291235 +0100\n+++ /tmp/tmp0wlqgg7_.java\t2023-03-24 23:03:59.564291235 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setNode(nextnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "prevnode = node.nextNode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:01.012285341 +0100\n+++ /tmp/tmpe7gddvfh.java\t2023-03-24 23:04:01.012285341 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.nextNode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "node.addChild(prevnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:02.468279413 +0100\n+++ /tmp/tmpz5a7uaqv.java\t2023-03-24 23:04:02.472279395 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "node.addChild(prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:03.912273534 +0100\n+++ /tmp/tmpuxwx_eti.java\t2023-03-24 23:04:03.916273520 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "node.addChild(nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:05.312267836 +0100\n+++ /tmp/tmpd67tsegx.java\t2023-03-24 23:04:05.312267836 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(nextnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "node.setParent(nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:06.700262189 +0100\n+++ /tmp/tmp6sbk872j.java\t2023-03-24 23:04:06.700262189 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setParent(nextnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "prevnode = node.clone();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:08.168256217 +0100\n+++ /tmp/tmp1b19bh7i.java\t2023-03-24 23:04:08.168256217 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.clone();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "node = node.nextNode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:09.580250473 +0100\n+++ /tmp/tmpyxaw_fpp.java\t2023-03-24 23:04:09.580250473 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node = node.nextNode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "result.add(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:10.976244797 +0100\n+++ /tmp/tmpmdix7ne0.java\t2023-03-24 23:04:10.976244797 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+result.add(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "node = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:12.436238861 +0100\n+++ /tmp/tmp8f_3254_.java\t2023-03-24 23:04:12.436238861 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "node.append(nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:13.816233251 +0100\n+++ /tmp/tmpmm16wplb.java\t2023-03-24 23:04:13.820233235 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.append(nextnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "node.append(prevnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:15.264227366 +0100\n+++ /tmp/tmp2ys3jft7.java\t2023-03-24 23:04:15.264227366 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.append(prevnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "node.add(prevnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:16.696221548 +0100\n+++ /tmp/tmpwfjz128s.java\t2023-03-24 23:04:16.696221548 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.add(prevnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "node.set(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:18.124215744 +0100\n+++ /tmp/tmpvz82b3b8.java\t2023-03-24 23:04:18.124215744 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.set(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "nextnode = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:19.520210073 +0100\n+++ /tmp/tmp1bs6thsy.java\t2023-03-24 23:04:19.524210057 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+nextnode = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "node.setValue(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:21.000204062 +0100\n+++ /tmp/tmpa6ts3q6i.java\t2023-03-24 23:04:21.000204062 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setValue(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "matched.add(nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:22.444198201 +0100\n+++ /tmp/tmpemm0xu5x.java\t2023-03-24 23:04:22.448198182 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+matched.add(nextnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "node.add(next);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:23.920192206 +0100\n+++ /tmp/tmp1sh957yz.java\t2023-03-24 23:04:23.920192206 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.add(next);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "prevNode = nextnode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:25.392186232 +0100\n+++ /tmp/tmpg0e_m3hj.java\t2023-03-24 23:04:25.392186232 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = nextnode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "prevnode = node.child;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:26.796180532 +0100\n+++ /tmp/tmp8mlusxh7.java\t2023-03-24 23:04:26.800180516 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.child;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "prevnode = node.next();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:28.224174738 +0100\n+++ /tmp/tmpz4s2hh1g.java\t2023-03-24 23:04:28.224174738 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.next();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "prevnode = node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:29.680168830 +0100\n+++ /tmp/tmpzv91ffi5.java\t2023-03-24 23:04:29.680168830 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": true
            },
            {
                "k": 100,
                "tentative_fix": "node.add(prev);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 23:04:32.952155559 +0100\n+++ /tmp/tmpbg6ltqaq.java\t2023-03-24 23:04:32.952155559 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.add(prev);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "prevnode = node;"
    },
    "sqrt": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:11:38.384304311 +0100\n+++ /tmp/tmp397v3zez.java\t2023-03-24 22:11:38.440304105 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "for (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:11:59.912225730 +0100\n+++ /tmp/tmp2b0nibrs.java\t2023-03-24 22:11:59.912225730 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+for (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "try { while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:01.344220502 +0100\n+++ /tmp/tmpqr7h2l22.java\t2023-03-24 22:12:01.344220502 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+try { while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "while (true) { while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:02.800215186 +0100\n+++ /tmp/tmpiupcxypk.java\t2023-03-24 22:12:02.800215186 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (true) { while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "while (Modifier.isStatic(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:04.224209988 +0100\n+++ /tmp/tmp7ql2hne4.java\t2023-03-24 22:12:04.224209988 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "while (recursive) { while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:05.684204659 +0100\n+++ /tmp/tmpd6nmlj6h.java\t2023-03-24 22:12:05.684204659 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (recursive) { while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "while (Modifier.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:07.092199517 +0100\n+++ /tmp/tmpq9sblaz5.java\t2023-03-24 22:12:07.092199517 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "while (Collectors.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:08.580194085 +0100\n+++ /tmp/tmpho9n1to4.java\t2023-03-24 22:12:08.580194085 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "try (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:10.084188595 +0100\n+++ /tmp/tmps472kr70.java\t2023-03-24 22:12:10.088188578 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+try (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "while (weighted) { while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:11.540183279 +0100\n+++ /tmp/tmpgf3ixe1a.java\t2023-03-24 22:12:11.544183262 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (weighted) { while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (recursive) { while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:12.964178078 +0100\n+++ /tmp/tmpzgjlq5dd.java\t2023-03-24 22:12:12.964178078 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (recursive) { while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "while(Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:14.388172881 +0100\n+++ /tmp/tmpzf6ofneh.java\t2023-03-24 22:12:14.388172881 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while(Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "while (limit!= 0) { while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:35.820094615 +0100\n+++ /tmp/tmp_7hrz_3h.java\t2023-03-24 22:12:35.824094602 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (limit!= 0) { while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "while (Cipher.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:37.248089399 +0100\n+++ /tmp/tmpe07k57cg.java\t2023-03-24 22:12:37.248089399 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Cipher.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "while ( assigned.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:38.664084227 +0100\n+++ /tmp/tmp196ho6e0.java\t2023-03-24 22:12:38.664084227 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while ( assigned.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "while (Profiles) { while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:40.152078792 +0100\n+++ /tmp/tmp22vz543z.java\t2023-03-24 22:12:40.152078792 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Profiles) { while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "while (Collections.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:41.504073854 +0100\n+++ /tmp/tmpu42o3k6p.java\t2023-03-24 22:12:41.508073842 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collections.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "while (Math.abs(x -approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:12:42.920068682 +0100\n+++ /tmp/tmp5b3ijnze.java\t2023-03-24 22:12:42.920068682 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x -approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "while ( shapes.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:04.331990465 +0100\n+++ /tmp/tmpgi4f0s56.java\t2023-03-24 22:13:04.335990451 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while ( shapes.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "while (Aggregation.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:05.827985001 +0100\n+++ /tmp/tmp5z0_7xk7.java\t2023-03-24 22:13:05.827985001 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Aggregation.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "while (crosses.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:07.267979740 +0100\n+++ /tmp/tmppng0etse.java\t2023-03-24 22:13:07.267979740 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (crosses.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "while (Dummy.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:08.739974360 +0100\n+++ /tmp/tmppwsifr2v.java\t2023-03-24 22:13:08.739974360 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Dummy.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "while (!Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:10.167969142 +0100\n+++ /tmp/tmpx683yfs5.java\t2023-03-24 22:13:10.167969142 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (!Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:11.619963837 +0100\n+++ /tmp/tmpa10bze6q.java\t2023-03-24 22:13:11.623963823 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "while (AffineTransform.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:15.147950949 +0100\n+++ /tmp/tmpalsfikwu.java\t2023-03-24 22:13:15.151950932 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (AffineTransform.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "while (Modifier.isStatic(x-approx) || epsilon < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:16.611945597 +0100\n+++ /tmp/tmp4bo2al9y.java\t2023-03-24 22:13:16.611945597 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) || epsilon < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon) { while (true) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:18.167939912 +0100\n+++ /tmp/tmpv2a_k3v_.java\t2023-03-24 22:13:18.167939912 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon) { while (true) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "while (cr.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:19.595934694 +0100\n+++ /tmp/tmputogkooe.java\t2023-03-24 22:13:19.595934694 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (cr.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "while (Math.abs(x-approx) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:21.087929242 +0100\n+++ /tmp/tmp8oczyd6x.java\t2023-03-24 22:13:21.087929242 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "while (Scroll * (x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:24.491916806 +0100\n+++ /tmp/tmpnlawun3y.java\t2023-03-24 22:13:24.491916806 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Scroll * (x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "while (limit!= Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:25.923911572 +0100\n+++ /tmp/tmpn79ycztt.java\t2023-03-24 22:13:25.927911555 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (limit!= Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "while (Modifier.isStatic(x-approx) && epsilon > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:27.443906016 +0100\n+++ /tmp/tmpocbcq_ie.java\t2023-03-24 22:13:27.443906016 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) && epsilon > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "while (flatMap.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:28.867900812 +0100\n+++ /tmp/tmpns2pz3cr.java\t2023-03-24 22:13:28.867900812 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (flatMap.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "while (Modifier.isStatic(x-approx) || epsilon > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:30.343895421 +0100\n+++ /tmp/tmpph4gylnx.java\t2023-03-24 22:13:30.347895403 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) || epsilon > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "while (ons.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:31.763890231 +0100\n+++ /tmp/tmp2kkzj1ga.java\t2023-03-24 22:13:31.763890231 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ons.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "while (Modifier.isStatic(x-approx) || epsilon >= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:33.259884762 +0100\n+++ /tmp/tmpbi2qnmmn.java\t2023-03-24 22:13:33.263884749 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) || epsilon >= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:34.783879192 +0100\n+++ /tmp/tmpvxspykp8.java\t2023-03-24 22:13:34.783879192 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon) { }\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "while (Modifier.isStatic(x-approx) || epsilon == epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:36.187874060 +0100\n+++ /tmp/tmp2soncr8s.java\t2023-03-24 22:13:36.187874060 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) || epsilon == epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "while (Profiles && Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:37.607868870 +0100\n+++ /tmp/tmphs17ps66.java\t2023-03-24 22:13:37.611868856 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Profiles && Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "while (Math.abs(x-distance) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:39.115863362 +0100\n+++ /tmp/tmpln7ntu7x.java\t2023-03-24 22:13:39.115863362 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-distance) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "while (Collectors.compare(x-approx, epsilon) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:40.583857994 +0100\n+++ /tmp/tmpubohkops.java\t2023-03-24 22:13:40.583857994 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.compare(x-approx, epsilon) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "while (WebSocket * (x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:42.059852600 +0100\n+++ /tmp/tmpwz2ageds.java\t2023-03-24 22:13:42.059852600 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (WebSocket * (x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "while (Collectors.compareTo(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:43.551847149 +0100\n+++ /tmp/tmptpuns17h.java\t2023-03-24 22:13:43.551847149 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.compareTo(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "while (Modifier.isTrue(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:45.027841751 +0100\n+++ /tmp/tmpsdp5xk_i.java\t2023-03-24 22:13:45.027841751 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isTrue(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "while (Modifier.is(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:46.499836374 +0100\n+++ /tmp/tmphpxf9zsx.java\t2023-03-24 22:13:46.499836374 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.is(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "while (Modifier.isStatic(x-approx) || epsilon == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:47.959831037 +0100\n+++ /tmp/tmp_xcdaa7m.java\t2023-03-24 22:13:47.959831037 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) || epsilon == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "while (Modifier.isStatic(x-approx) && epsilon >= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:49.491825435 +0100\n+++ /tmp/tmplt89s1zc.java\t2023-03-24 22:13:49.491825435 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) && epsilon >= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "while (flatMap.compareTo(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:51.011819879 +0100\n+++ /tmp/tmpygchu1jz.java\t2023-03-24 22:13:51.015819867 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (flatMap.compareTo(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "while (Modifier.isStatic(x-approx) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:52.475814530 +0100\n+++ /tmp/tmpdqyowg6j.java\t2023-03-24 22:13:52.475814530 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "while (sum > Math.abs(x-approx) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:53.935809193 +0100\n+++ /tmp/tmpps7fmf37.java\t2023-03-24 22:13:53.935809193 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (sum > Math.abs(x-approx) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "while (sum > Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:55.439803695 +0100\n+++ /tmp/tmpcg647zeh.java\t2023-03-24 22:13:55.475803564 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (sum > Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "while (Modifier.isNaN(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:56.915798298 +0100\n+++ /tmp/tmpp79tgppl.java\t2023-03-24 22:13:56.919798284 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isNaN(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:58.419792800 +0100\n+++ /tmp/tmpc9183fke.java\t2023-03-24 22:13:58.419792800 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon)) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "while (partition * (x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:13:59.863787521 +0100\n+++ /tmp/tmpdo301y4q.java\t2023-03-24 22:13:59.863787521 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (partition * (x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "while (Collectors.get(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:01.355782067 +0100\n+++ /tmp/tmpuosmuub1.java\t2023-03-24 22:14:01.355782067 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.get(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "while (Terminal(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:02.875776513 +0100\n+++ /tmp/tmp7ra1oeey.java\t2023-03-24 22:14:02.875776513 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Terminal(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "while (Modifier.isNaN(x-approx) || epsilon == epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:04.435770807 +0100\n+++ /tmp/tmpyuxxfgl3.java\t2023-03-24 22:14:04.435770807 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isNaN(x-approx) || epsilon == epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "while (Modifier.signum(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:05.967765209 +0100\n+++ /tmp/tmpq4u3_vnp.java\t2023-03-24 22:14:05.967765209 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.signum(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "while (Modifier.isStatic(x-approx) && epsilon!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:07.383760031 +0100\n+++ /tmp/tmpvx_rys13.java\t2023-03-24 22:14:07.383760031 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) && epsilon!= 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "while (enable(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:08.875754578 +0100\n+++ /tmp/tmppzmkx_kj.java\t2023-03-24 22:14:08.875754578 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (enable(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "while (Collections.singleton(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:10.347749194 +0100\n+++ /tmp/tmp8ywbx588.java\t2023-03-24 22:14:10.347749194 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collections.singleton(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "while (fit * (x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:11.895743537 +0100\n+++ /tmp/tmpa03p0qys.java\t2023-03-24 22:14:11.899743520 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (fit * (x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "while (Modifier.isStatic(x-approx) || epsilon == 1.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:13.371738141 +0100\n+++ /tmp/tmp7p6uevf4.java\t2023-03-24 22:14:13.371738141 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) || epsilon == 1.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "while (Modifier.isStatic(x-approx) && epsilon!= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:14.823732832 +0100\n+++ /tmp/tmpm7z022u2.java\t2023-03-24 22:14:14.823732832 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) && epsilon!= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon) { // it could be -ve",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:16.279727506 +0100\n+++ /tmp/tmpn1v_9nsz.java\t2023-03-24 22:14:16.279727506 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon) { // it could be -ve\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "while (Modifier.isStatic(x-approx) && epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:37.775648905 +0100\n+++ /tmp/tmphu2bnqxg.java\t2023-03-24 22:14:37.775648905 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isStatic(x-approx) && epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon) { // 1d; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:14:39.251643507 +0100\n+++ /tmp/tmp_n645p0g.java\t2023-03-24 22:14:39.251643507 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon) { // 1d; }\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "while (Collectors.vertexSet().size() > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:00.795564712 +0100\n+++ /tmp/tmp_7yjxdmx.java\t2023-03-24 22:15:00.799564698 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.vertexSet().size() > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "while (Control(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:02.207559550 +0100\n+++ /tmp/tmpb6z0uz0s.java\t2023-03-24 22:15:02.207559550 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Control(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "while (Collectors.abs(x -approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:03.659554237 +0100\n+++ /tmp/tmpifau9hv9.java\t2023-03-24 22:15:03.659554237 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.abs(x -approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "while (Math.abs(x-partition) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:05.075549058 +0100\n+++ /tmp/tmpbb_eenwo.java\t2023-03-24 22:15:05.075549058 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-partition) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "while (Modifier.isNaN(x-approx) || epsilon == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:06.439544071 +0100\n+++ /tmp/tmpimnetc8d.java\t2023-03-24 22:15:06.439544071 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.isNaN(x-approx) || epsilon == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon) { // found",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:07.807539066 +0100\n+++ /tmp/tmp2cb27ofh.java\t2023-03-24 22:15:07.811539049 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon) { // found\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "while (Collectors.signum() > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:29.075461260 +0100\n+++ /tmp/tmpwhvd0tc6.java\t2023-03-24 22:15:29.075461260 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.signum() > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "while (Collectors.compareTo(x-approx) > 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:30.451456226 +0100\n+++ /tmp/tmpktpu170p.java\t2023-03-24 22:15:30.451456226 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Collectors.compareTo(x-approx) > 0;\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "while ( ks - x > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:31.787451340 +0100\n+++ /tmp/tmp10w6g1s2.java\t2023-03-24 22:15:31.787451340 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while ( ks - x > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "while ( (5 - x > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:33.215446115 +0100\n+++ /tmp/tmpaoro_w9t.java\t2023-03-24 22:15:33.215446115 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while ( (5 - x > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "while (ScrollToapprox > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:34.567441169 +0100\n+++ /tmp/tmp6oxrou4d.java\t2023-03-24 22:15:34.567441169 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ScrollToapprox > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "while (approx > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:15:35.931436176 +0100\n+++ /tmp/tmp4licai51.java\t2023-03-24 22:15:35.931436176 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (approx > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "while (Modifier.FINAL) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:00.243347213 +0100\n+++ /tmp/tmp3eehf3ov.java\t2023-03-24 22:16:00.243347213 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modifier.FINAL) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "while (shapes - x > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:01.635342120 +0100\n+++ /tmp/tmpazwr1zei.java\t2023-03-24 22:16:01.635342120 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (shapes - x > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "while (Modulus < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:02.955337289 +0100\n+++ /tmp/tmpbu94u1zf.java\t2023-03-24 22:16:02.955337289 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modulus < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "while (ScrollToapprox < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:04.291332402 +0100\n+++ /tmp/tmpvvm1dg65.java\t2023-03-24 22:16:04.291332402 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ScrollToapprox < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "while ( latency - x > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:05.671327349 +0100\n+++ /tmp/tmpt9odaee5.java\t2023-03-24 22:16:05.671327349 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while ( latency - x > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "while (Modulus > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:07.235321625 +0100\n+++ /tmp/tmpx7mnd0aa.java\t2023-03-24 22:16:07.235321625 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Modulus > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "while (ascending - x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:16.643287193 +0100\n+++ /tmp/tmp648ae0or.java\t2023-03-24 22:16:16.643287193 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ascending - x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "while (ss == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:25.487254822 +0100\n+++ /tmp/tmp_jcry5sa.java\t2023-03-24 22:16:25.487254822 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ss == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "while (ss!= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:34.727221001 +0100\n+++ /tmp/tmpr5ubnvnv.java\t2023-03-24 22:16:34.727221001 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ss!= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "while (true) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:43.247189815 +0100\n+++ /tmp/tmpi367urle.java\t2023-03-24 22:16:43.247189815 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (true) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "while (ss == epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:16:52.171157145 +0100\n+++ /tmp/tmpqsgmrhez.java\t2023-03-24 22:16:52.171157145 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ss == epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "while (ip > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:17:00.099128117 +0100\n+++ /tmp/tmp3mex06ht.java\t2023-03-24 22:17:00.099128117 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (ip > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "while (approx < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:17:07.927099459 +0100\n+++ /tmp/tmpe36ie8hn.java\t2023-03-24 22:17:07.927099459 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (approx < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "while (approx < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:17:26.835030223 +0100\n+++ /tmp/tmpd7byossx.java\t2023-03-24 22:17:26.835030223 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (approx < x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "while ( (5 - x / 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:18:06.634884464 +0100\n+++ /tmp/tmpu_qujbzm.java\t2023-03-24 22:18:06.634884464 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while ( (5 - x / 2);\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "while (sum > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:18:13.510859269 +0100\n+++ /tmp/tmpceqvp3zp.java\t2023-03-24 22:18:13.518859241 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (sum > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "while (weighted) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:18:19.574837057 +0100\n+++ /tmp/tmp8xgi57sj.java\t2023-03-24 22:18:19.574837057 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (weighted) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "while (recursive) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:18:25.886813935 +0100\n+++ /tmp/tmpg_avtz29.java\t2023-03-24 22:18:25.894813906 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (recursive) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "while ( 300) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:18:31.754792422 +0100\n+++ /tmp/tmpvmn30qhb.java\t2023-03-24 22:18:31.754792422 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while ( 300) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "try {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:18:37.198772362 +0100\n+++ /tmp/tmp8b_v_fny.java\t2023-03-24 22:18:37.198772362 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+try {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 22:18:42.534752700 +0100\n+++ /tmp/tmp6tuum0q1.java\t2023-03-24 22:18:42.534752700 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "while (Math.abs(x-approx*approx) > epsilon) {"
    }
}