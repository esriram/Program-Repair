{
    "topological_ordering": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (!Objects.equals(nextNode.getSuccessors(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:02:50.242193958 +0100\n+++ /tmp/tmp84s0jthe.java\t2023-03-24 13:02:50.258193898 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getSuccessors(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:02:54.974176391 +0100\n+++ /tmp/tmpar1msiun.java\t2023-03-24 13:02:54.974176391 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.get(i + 1))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:02:56.958169027 +0100\n+++ /tmp/tmpue8sqq8h.java\t2023-03-24 13:02:56.958169027 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.get(i + 1))) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (!jpaProvider.supportsTreatJoin() && nextNode.isTreatJoinNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:02:58.898161825 +0100\n+++ /tmp/tmpspl_dj22.java\t2023-03-24 13:02:58.898161825 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatJoin() && nextNode.isTreatJoinNode()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (!key.equals(nextNode.key) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:00.666155261 +0100\n+++ /tmp/tmpu79639l5.java\t2023-03-24 13:03:00.670155247 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!key.equals(nextNode.key) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:02.434148696 +0100\n+++ /tmp/tmpas4ml4qw.java\t2023-03-24 13:03:02.434148696 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.ELEMENT_NODE) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getToken().getValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:04.186142194 +0100\n+++ /tmp/tmp23mftn9u.java\t2023-03-24 13:03:04.186142194 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getToken().getValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (!Objects.equals(nextNode.getParent(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:05.946135659 +0100\n+++ /tmp/tmpyf6_ue97.java\t2023-03-24 13:03:05.950135643 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getParent(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getOppositeMatched())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:07.682129214 +0100\n+++ /tmp/tmpwk0p6dzo.java\t2023-03-24 13:03:07.682129214 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getOppositeMatched())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:09.406122812 +0100\n+++ /tmp/tmpu4gqq6c3.java\t2023-03-24 13:03:09.406122812 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (listSize < node.getLength() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:11.206116128 +0100\n+++ /tmp/tmpedd0rly6.java\t2023-03-24 13:03:11.206116128 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (listSize < node.getLength() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (!LISTNode.contains(nextNode) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:13.014109417 +0100\n+++ /tmp/tmpg_p12s2g.java\t2023-03-24 13:03:13.014109417 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!LISTNode.contains(nextNode) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (!Objects.equals(nextNode.getTargetNamespace(), nextNode.getTargetNamespace())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:14.934102287 +0100\n+++ /tmp/tmpaed6x9rv.java\t2023-03-24 13:03:14.934102287 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getTargetNamespace(), nextNode.getTargetNamespace())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (!listSize < node.getLength() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:16.786095411 +0100\n+++ /tmp/tmpfu_7zkro.java\t2023-03-24 13:03:16.786095411 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!listSize < node.getLength() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeValue(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:18.622088593 +0100\n+++ /tmp/tmpjm5_s2i3.java\t2023-03-24 13:03:18.626088579 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeValue(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (!Objects.equals(nextNode.getTargetNamespace(), nextNode.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:20.410081953 +0100\n+++ /tmp/tmpa9t6rhof.java\t2023-03-24 13:03:20.410081953 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getTargetNamespace(), nextNode.getNodeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (listSize >= nextNode.getCount() &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:22.210075270 +0100\n+++ /tmp/tmpiuy35ixt.java\t2023-03-24 13:03:22.210075270 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (listSize >= nextNode.getCount() &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (!CurrentNode.contains(nextNode) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:24.018068557 +0100\n+++ /tmp/tmpsvvvdv_o.java\t2023-03-24 13:03:24.018068557 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!CurrentNode.contains(nextNode) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (!degree.contains(nextNode) &&!orderedNodes.contains(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:25.838061798 +0100\n+++ /tmp/tmpujpeskd9.java\t2023-03-24 13:03:25.838061798 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!degree.contains(nextNode) &&!orderedNodes.contains(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (!Objects.equals(nextNode.getLabeledName(), nextNode.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:27.634055129 +0100\n+++ /tmp/tmphh4toyl_.java\t2023-03-24 13:03:27.642055099 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getLabeledName(), nextNode.getNodeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (!jpaProvider.supportsTreatJoin() && nextNode.isTainted()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:29.466048324 +0100\n+++ /tmp/tmp1whhulnr.java\t2023-03-24 13:03:29.466048324 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatJoin() && nextNode.isTainted()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getRole())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:31.230041774 +0100\n+++ /tmp/tmp8ye8n7de.java\t2023-03-24 13:03:31.234041758 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getRole())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getParent())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:32.926035476 +0100\n+++ /tmp/tmpowdkdvbb.java\t2023-03-24 13:03:32.926035476 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getParent())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!Objects.equals(previousNode.getSuccessors(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:34.722028804 +0100\n+++ /tmp/tmprg77apl0.java\t2023-03-24 13:03:34.722028804 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(previousNode.getSuccessors(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getTokenValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:36.426022477 +0100\n+++ /tmp/tmp0rz5h0j6.java\t2023-03-24 13:03:36.426022477 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getTokenValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getOppositeVertex())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:38.198015894 +0100\n+++ /tmp/tmpfzx0p4ts.java\t2023-03-24 13:03:38.198015894 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getOppositeVertex())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeType(), nextNode.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:39.958009358 +0100\n+++ /tmp/tmpr_qg0yeh.java\t2023-03-24 13:03:39.958009358 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeType(), nextNode.getNodeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:41.678002971 +0100\n+++ /tmp/tmpk2h7cthc.java\t2023-03-24 13:03:41.678002971 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (!jpaProvider.supportsTreatJoin() && nextNode.isCopyBookOrGeneratedNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:43.385996627 +0100\n+++ /tmp/tmpl5sxro54.java\t2023-03-24 13:03:43.385996627 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatJoin() && nextNode.isCopyBookOrGeneratedNode()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (!target.equals(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:45.113990208 +0100\n+++ /tmp/tmpawigpc5t.java\t2023-03-24 13:03:45.113990208 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!target.equals(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:46.941983417 +0100\n+++ /tmp/tmppxz1svke.java\t2023-03-24 13:03:46.941983417 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodeType())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:48.733976762 +0100\n+++ /tmp/tmpyxkherhm.java\t2023-03-24 13:03:48.733976762 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodeType())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.get(i))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:50.525970105 +0100\n+++ /tmp/tmp9gwfub_1.java\t2023-03-24 13:03:50.525970105 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.get(i))) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (!jpaProvider.supportsTreatJoin() && nextNode.isNullNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:52.253963688 +0100\n+++ /tmp/tmp_2qz5rdi.java\t2023-03-24 13:03:52.253963688 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatJoin() && nextNode.isNullNode()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (!Objects.equals(nextNode.getFormat(), nextNode.getFormat())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:53.937957431 +0100\n+++ /tmp/tmpr3pl7ury.java\t2023-03-24 13:03:53.941957417 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getFormat(), nextNode.getFormat())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (!parameters.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:55.645951088 +0100\n+++ /tmp/tmpe1kd3fnq.java\t2023-03-24 13:03:55.645951088 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!parameters.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getOppositeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:57.329944831 +0100\n+++ /tmp/tmpwl98zt_i.java\t2023-03-24 13:03:57.329944831 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getOppositeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (nextNode.getNodeType() == Node.ELEMENT_NODE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:03:59.029938517 +0100\n+++ /tmp/tmp19zatx20.java\t2023-03-24 13:03:59.029938517 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (nextNode.getNodeType() == Node.ELEMENT_NODE) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (!(nextNode.getNodeName().equals(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:00.837931801 +0100\n+++ /tmp/tmprd880qdv.java\t2023-03-24 13:04:00.837931801 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(nextNode.getNodeName().equals(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (!parameters.containsKey(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:02.437925856 +0100\n+++ /tmp/tmp48q_0lvf.java\t2023-03-24 13:04:02.437925856 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!parameters.containsKey(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (!prefix.equals(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:04.237919169 +0100\n+++ /tmp/tmpodmdyfy2.java\t2023-03-24 13:04:04.237919169 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!prefix.equals(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (!jpaProvider.supportsTreatJoin() && nextNode.isCollectionValued()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:05.961912763 +0100\n+++ /tmp/tmpni3uf0bj.java\t2023-03-24 13:04:05.965912750 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatJoin() && nextNode.isCollectionValued()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (Objects.equals(nextNode.getSuccessors(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:07.757906093 +0100\n+++ /tmp/tmpn6gyla8r.java\t2023-03-24 13:04:07.757906093 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(nextNode.getSuccessors(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (!Objects.equals(nextNode.getOppositeMatched(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:11.829890963 +0100\n+++ /tmp/tmp27wws5_7.java\t2023-03-24 13:04:11.829890963 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getOppositeMatched(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getField())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:13.457884915 +0100\n+++ /tmp/tmpp9xdd13r.java\t2023-03-24 13:04:13.457884915 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getField())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.get(i - 1))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:15.081878881 +0100\n+++ /tmp/tmp3bme_v4g.java\t2023-03-24 13:04:15.081878881 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.get(i - 1))) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (node.getNodeType()!= Node.ELEMENT_NODE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:16.789872535 +0100\n+++ /tmp/tmpx_1b00e6.java\t2023-03-24 13:04:16.789872535 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType()!= Node.ELEMENT_NODE) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getAlias())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:18.485866234 +0100\n+++ /tmp/tmpegwv4q7b.java\t2023-03-24 13:04:18.485866234 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getAlias())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getMetadata().getName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:20.173859962 +0100\n+++ /tmp/tmp0qbirtxh.java\t2023-03-24 13:04:20.173859962 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getMetadata().getName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeValue(), nextNode.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:21.853853719 +0100\n+++ /tmp/tmp89q9blas.java\t2023-03-24 13:04:21.853853719 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeValue(), nextNode.getNodeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (!jpaProvider.supportsTreatNode() && nextNode.isNullFirstNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:23.693846881 +0100\n+++ /tmp/tmpox0llquh.java\t2023-03-24 13:04:23.693846881 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatNode() && nextNode.isNullFirstNode()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (!jpaProvider.supportsTreatJoin() && nextNode.isNullFirstNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:25.385840596 +0100\n+++ /tmp/tmpt9xhcbqf.java\t2023-03-24 13:04:25.385840596 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatJoin() && nextNode.isNullFirstNode()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (Objects.equals(nextNode.getNodeName(), nextNode.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:27.085834278 +0100\n+++ /tmp/tmpd6vv75s9.java\t2023-03-24 13:04:27.089834264 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(nextNode.getNodeName(), nextNode.getNodeValue())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (!jpaProvider.supportsTreatNode() && nextNode.isTreatNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:28.825827811 +0100\n+++ /tmp/tmpkrjoh5dl.java\t2023-03-24 13:04:28.829827798 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatNode() && nextNode.isTreatNode()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (!jpaProvider.supportsTreatJoin() && nextNode.isJoinNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:30.565821347 +0100\n+++ /tmp/tmp568bic1i.java\t2023-03-24 13:04:30.565821347 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsTreatJoin() && nextNode.isJoinNode()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getDescendant(i))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:32.349814718 +0100\n+++ /tmp/tmpkmm4deuo.java\t2023-03-24 13:04:32.349814718 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getDescendant(i))) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (!Objects.equals(nextNode.getSuccessors(), nextNode.get(i))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:34.093808235 +0100\n+++ /tmp/tmpkmxda0fd.java\t2023-03-24 13:04:34.093808235 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getSuccessors(), nextNode.get(i))) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (!Objects.equals(nextNode.getFormat(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:35.833801769 +0100\n+++ /tmp/tmpmbr2c46r.java\t2023-03-24 13:04:35.833801769 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getFormat(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getMetadata().isArray())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:37.545795408 +0100\n+++ /tmp/tmpdzb8vf16.java\t2023-03-24 13:04:37.545795408 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getMetadata().isArray())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (!CurrentNodes.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:39.321788809 +0100\n+++ /tmp/tmps_5refop.java\t2023-03-24 13:04:39.325788792 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!CurrentNodes.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (Objects.equals(nextNode.getNodeName(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:40.993782594 +0100\n+++ /tmp/tmps1fetn6u.java\t2023-03-24 13:04:40.993782594 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (Objects.equals(nextNode.getNodeName(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (!Objects.equals(nextNode.getAlias(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:42.725776158 +0100\n+++ /tmp/tmpjwv537yc.java\t2023-03-24 13:04:42.725776158 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getAlias(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getToken())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:44.421769854 +0100\n+++ /tmp/tmp9jpfatiz.java\t2023-03-24 13:04:44.421769854 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getToken())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodes())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:46.145763447 +0100\n+++ /tmp/tmp86ip20wb.java\t2023-03-24 13:04:46.145763447 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getNodes())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:47.877757008 +0100\n+++ /tmp/tmphw11nqt1.java\t2023-03-24 13:04:47.877757008 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (node.getNodeType() == Node.TEXT_NODE) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (!Objects.equals(nextNode.getNodeName(), nextNode.getUuid())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:49.537750840 +0100\n+++ /tmp/tmp0mncmgup.java\t2023-03-24 13:04:49.541750824 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getNodeName(), nextNode.getUuid())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!mappedByNode.containsKey(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:51.181744728 +0100\n+++ /tmp/tmpe14ynjxf.java\t2023-03-24 13:04:51.185744715 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!mappedByNode.containsKey(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (!Objects.equals(nextNode.getLabeledName(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:52.869738455 +0100\n+++ /tmp/tmppklkgt_j.java\t2023-03-24 13:04:52.869738455 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getLabeledName(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (!Objects.equals(nextNode.getIdentifier(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:54.557732181 +0100\n+++ /tmp/tmpadvdpf9n.java\t2023-03-24 13:04:54.557732181 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getIdentifier(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (nextNode.getNodeType() == Node.TEXT_NODE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:56.261725847 +0100\n+++ /tmp/tmpl285d0kj.java\t2023-03-24 13:04:56.261725847 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (nextNode.getNodeType() == Node.TEXT_NODE) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (!Objects.equals(nextNode.get(i), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:57.993719409 +0100\n+++ /tmp/tmp1i7y9j8x.java\t2023-03-24 13:04:57.993719409 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.get(i), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (!Objects.equals(nextNode.getLocalName(), nextNode.get(i))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:04:59.681713135 +0100\n+++ /tmp/tmppq4buush.java\t2023-03-24 13:04:59.681713135 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getLocalName(), nextNode.get(i))) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!jpaNodes.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:01.445706580 +0100\n+++ /tmp/tmphea92ccj.java\t2023-03-24 13:05:01.445706580 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaNodes.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (!mapped.containsKey(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:03.217699993 +0100\n+++ /tmp/tmpr65kqjz_.java\t2023-03-24 13:05:03.217699993 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!mapped.containsKey(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (!Objects.equals(nextNode.getCode(), nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:04.933693614 +0100\n+++ /tmp/tmpfh39xug5.java\t2023-03-24 13:05:04.937693598 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getCode(), nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (!(nextNode.getNodeName().equals(prefix)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:06.713686997 +0100\n+++ /tmp/tmpx9j2ifol.java\t2023-03-24 13:05:06.713686997 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(nextNode.getNodeName().equals(prefix)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (!key.equals(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:08.349680916 +0100\n+++ /tmp/tmpnlygw1of.java\t2023-03-24 13:05:08.349680916 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!key.equals(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (target.addNode(nextNode.getNode()) == node) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:10.085674461 +0100\n+++ /tmp/tmpdmw7_a9q.java\t2023-03-24 13:05:10.085674461 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (target.addNode(nextNode.getNode()) == node) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (target.equals(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:11.809668052 +0100\n+++ /tmp/tmpkcacb5aw.java\t2023-03-24 13:05:11.809668052 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (target.equals(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (!elements.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:13.525661674 +0100\n+++ /tmp/tmp9kar_2aj.java\t2023-03-24 13:05:13.525661674 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!elements.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (!target.containsEdge(nextNode, nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:15.333654951 +0100\n+++ /tmp/tmp9fzfjt3v.java\t2023-03-24 13:05:15.333654951 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!target.containsEdge(nextNode, nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (!(nextNode.getNodeName().equals(name))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:17.045648589 +0100\n+++ /tmp/tmpufmui1gc.java\t2023-03-24 13:05:17.045648589 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(nextNode.getNodeName().equals(name))) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (!namespace.equals(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:18.825641970 +0100\n+++ /tmp/tmpkayyq9og.java\t2023-03-24 13:05:18.825641970 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!namespace.equals(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (!Objects.equals(nextNode.getSuccessors(), node)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:20.557635532 +0100\n+++ /tmp/tmp5_c_sout.java\t2023-03-24 13:05:20.557635532 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getSuccessors(), node)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (!nodes.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:24.637620364 +0100\n+++ /tmp/tmprud_h6xq.java\t2023-03-24 13:05:24.637620364 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!nodes.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (!namedNodes.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:26.333614058 +0100\n+++ /tmp/tmpn5gug7q7.java\t2023-03-24 13:05:26.333614058 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!namedNodes.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (!Objects.equals(nextNode.getSuccessors())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:27.993607886 +0100\n+++ /tmp/tmp636lfjw2.java\t2023-03-24 13:05:27.993607886 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!Objects.equals(nextNode.getSuccessors())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (!parameters.containsKey(nextNode.getNode())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:29.717601475 +0100\n+++ /tmp/tmp4tcxlh6g.java\t2023-03-24 13:05:29.717601475 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!parameters.containsKey(nextNode.getNode())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (!jpaProvider.supportsCollectionValue(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:31.397595230 +0100\n+++ /tmp/tmpdara5n5w.java\t2023-03-24 13:05:31.397595230 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsCollectionValue(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (!jpaProvider.supportsNamedParameter(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:33.109588865 +0100\n+++ /tmp/tmprkbsra11.java\t2023-03-24 13:05:33.109588865 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProvider.supportsNamedParameter(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (!mappedNodes.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:34.777582663 +0100\n+++ /tmp/tmp4jxrqd1z.java\t2023-03-24 13:05:34.777582663 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!mappedNodes.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (!properties.contains(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:36.601575879 +0100\n+++ /tmp/tmp2f6dgdfo.java\t2023-03-24 13:05:36.601575879 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!properties.contains(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (!listSize >= startNode.getIndex()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:38.313569514 +0100\n+++ /tmp/tmpgmff9vpr.java\t2023-03-24 13:05:38.313569514 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!listSize >= startNode.getIndex()) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (!target.equals(nextNode.getParent())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:40.113562820 +0100\n+++ /tmp/tmpolorxy31.java\t2023-03-24 13:05:40.113562820 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!target.equals(nextNode.getParent())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (!parameters.contains(nextNode.getNode())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:41.793556575 +0100\n+++ /tmp/tmpj2u4nt_i.java\t2023-03-24 13:05:41.797556558 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!parameters.contains(nextNode.getNode())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (prefix.equals(nextNode.getNodeName())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:43.569549969 +0100\n+++ /tmp/tmpca5kmpth.java\t2023-03-24 13:05:43.573549956 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (prefix.equals(nextNode.getNodeName())) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (!currentNode.equals(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:45.253543708 +0100\n+++ /tmp/tmp5smdloac.java\t2023-03-24 13:05:45.253543708 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!currentNode.equals(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (!(nextNode instanceof SequenceFlow)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:46.969537328 +0100\n+++ /tmp/tmpp4r_2q2p.java\t2023-03-24 13:05:46.969537328 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!(nextNode instanceof SequenceFlow)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (!currentNode.is(nextNode)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:48.729530782 +0100\n+++ /tmp/tmptznhkck_.java\t2023-03-24 13:05:48.733530768 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!currentNode.is(nextNode)) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (!jpaProviderDeletesCollection) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/topological_ordering/java_programs/TOPOLOGICAL_ORDERING.java\t2023-03-24 13:05:50.441524415 +0100\n+++ /tmp/tmppj3dco89.java\t2023-03-24 13:05:50.445524402 +0100\n@@ -12,11 +12,11 @@\n \n         int listSize = orderedNodes.size();\n         for (int i = 0; i < listSize; i++) {\n             Node node = orderedNodes.get(i);\n             for (Node nextNode : node.getSuccessors()) {\n-                if (orderedNodes.containsAll(nextNode.getSuccessors()) && !orderedNodes.contains(nextNode)) {\n+if (!jpaProviderDeletesCollection) {\n                     orderedNodes.add(nextNode);\n                     listSize++;\n                 }\n             }\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (orderedNodes.containsAll(nextNode.getPredecessors()) && !orderedNodes.contains(nextNode)) {"
    },
    "next_palindrome": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:02:50.138194342 +0100\n+++ /tmp/tmpqc5s4xpx.java\t2023-03-24 13:02:50.198194120 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:02:52.106187038 +0100\n+++ /tmp/tmphwd8phsl.java\t2023-03-24 13:02:52.106187038 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:02:54.082179703 +0100\n+++ /tmp/tmpvpqsku28.java\t2023-03-24 13:02:54.082179703 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:02:58.674162657 +0100\n+++ /tmp/tmpdpjkdw5p.java\t2023-03-24 13:02:58.674162657 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:00.322156539 +0100\n+++ /tmp/tmpjpijhozb.java\t2023-03-24 13:03:00.322156539 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:02.050150123 +0100\n+++ /tmp/tmpt813nhf_.java\t2023-03-24 13:03:02.050150123 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:03.806143604 +0100\n+++ /tmp/tmpzr0upum9.java\t2023-03-24 13:03:03.806143604 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:05.550137129 +0100\n+++ /tmp/tmpl4sd2iqr.java\t2023-03-24 13:03:05.550137129 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:07.486129942 +0100\n+++ /tmp/tmpdss87y39.java\t2023-03-24 13:03:07.486129942 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:09.290123242 +0100\n+++ /tmp/tmpld8pnym4.java\t2023-03-24 13:03:09.290123242 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:13.486107663 +0100\n+++ /tmp/tmpveah2z11.java\t2023-03-24 13:03:13.486107663 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:15.206101277 +0100\n+++ /tmp/tmparo0t8qz.java\t2023-03-24 13:03:15.210101263 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:16.930094875 +0100\n+++ /tmp/tmp1qmykqqf.java\t2023-03-24 13:03:16.930094875 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:18.670088414 +0100\n+++ /tmp/tmpiuj3i2i5.java\t2023-03-24 13:03:18.670088414 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:20.466081745 +0100\n+++ /tmp/tmp5u44f9nm.java\t2023-03-24 13:03:20.466081745 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0))); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:22.226075211 +0100\n+++ /tmp/tmpjdrl_yly.java\t2023-03-24 13:03:22.226075211 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:24.002068614 +0100\n+++ /tmp/tmpu42cbm3x.java\t2023-03-24 13:03:24.002068614 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, -1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:25.862061709 +0100\n+++ /tmp/tmp909zcesz.java\t2023-03-24 13:03:25.862061709 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, -1)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:30.078046052 +0100\n+++ /tmp/tmpn5uixqfh.java\t2023-03-24 13:03:30.078046052 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:31.610040363 +0100\n+++ /tmp/tmpjw4wciel.java\t2023-03-24 13:03:31.614040347 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 2); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:33.162034599 +0100\n+++ /tmp/tmp9d_is66a.java\t2023-03-24 13:03:33.162034599 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:37.062020115 +0100\n+++ /tmp/tmpe3qc_soi.java\t2023-03-24 13:03:37.062020115 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:38.806013636 +0100\n+++ /tmp/tmpne9odoyj.java\t2023-03-24 13:03:38.806013636 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (iterable.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:40.450007531 +0100\n+++ /tmp/tmpwgazm25w.java\t2023-03-24 13:03:40.450007531 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iterable.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:42.094001425 +0100\n+++ /tmp/tmpjhqladlt.java\t2023-03-24 13:03:42.098001411 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0) ); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:43.789995127 +0100\n+++ /tmp/tmp2bv9gcmj.java\t2023-03-24 13:03:43.789995127 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0) ); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:47.781980298 +0100\n+++ /tmp/tmpbuxp81bb.java\t2023-03-24 13:03:47.781980298 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:49.517973849 +0100\n+++ /tmp/tmp9zne_6qd.java\t2023-03-24 13:03:49.517973849 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:51.217967535 +0100\n+++ /tmp/tmp3m9dzx32.java\t2023-03-24 13:03:51.217967535 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 3)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:52.885961340 +0100\n+++ /tmp/tmpm6zdjdq9.java\t2023-03-24 13:03:52.885961340 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 3)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:03:56.977946139 +0100\n+++ /tmp/tmpzarr06if.java\t2023-03-24 13:03:56.977946139 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 2)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:01.089930864 +0100\n+++ /tmp/tmp4nkmhxyk.java\t2023-03-24 13:04:01.089930864 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:02.689924919 +0100\n+++ /tmp/tmpw717tqip.java\t2023-03-24 13:04:02.689924919 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if ( once.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:06.593910416 +0100\n+++ /tmp/tmpjp3_701w.java\t2023-03-24 13:04:06.593910416 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( once.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (bd.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:08.221904368 +0100\n+++ /tmp/tmprxgkgyba.java\t2023-03-24 13:04:08.221904368 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (bd.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (iterable.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:09.833898380 +0100\n+++ /tmp/tmp6fww16bl.java\t2023-03-24 13:04:09.833898380 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iterable.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (definition.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:11.605891796 +0100\n+++ /tmp/tmpk6zv7g3f.java\t2023-03-24 13:04:11.605891796 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (definition.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:13.285885554 +0100\n+++ /tmp/tmphsf91skf.java\t2023-03-24 13:04:13.285885554 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (AUTO_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:15.009879149 +0100\n+++ /tmp/tmpwmj2qxwk.java\t2023-03-24 13:04:15.009879149 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (AUTO_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (Unknown.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:16.669872980 +0100\n+++ /tmp/tmpkmvuor4x.java\t2023-03-24 13:04:16.673872966 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Unknown.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (value!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:18.365866680 +0100\n+++ /tmp/tmpvmzvsefj.java\t2023-03-24 13:04:18.365866680 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (value!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if ( otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:20.125860140 +0100\n+++ /tmp/tmpht2vb6qh.java\t2023-03-24 13:04:20.125860140 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (Unknown.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:21.805853898 +0100\n+++ /tmp/tmp3qizm1gx.java\t2023-03-24 13:04:21.809853882 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Unknown.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0.0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:23.693846881 +0100\n+++ /tmp/tmp5e78osxj.java\t2023-03-24 13:04:23.693846881 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0.0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (bd.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:25.469840282 +0100\n+++ /tmp/tmplbuo61pm.java\t2023-03-24 13:04:25.493840193 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (bd.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:27.193833877 +0100\n+++ /tmp/tmp9h934e7s.java\t2023-03-24 13:04:27.193833877 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:28.889827575 +0100\n+++ /tmp/tmpwb3dod6l.java\t2023-03-24 13:04:28.889827575 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0; }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (resolver.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:30.553821390 +0100\n+++ /tmp/tmpb9hhrmqs.java\t2023-03-24 13:04:30.553821390 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (resolver.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (content!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:32.349814718 +0100\n+++ /tmp/tmp02b9fl__.java\t2023-03-24 13:04:32.349814718 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (content!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (pe.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:34.093808235 +0100\n+++ /tmp/tmpqpth3sd9.java\t2023-03-24 13:04:34.093808235 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (pe.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:35.837801755 +0100\n+++ /tmp/tmpzsmx6cl_.java\t2023-03-24 13:04:35.837801755 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0))); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, \"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:37.537795438 +0100\n+++ /tmp/tmpwcv3rqwe.java\t2023-03-24 13:04:37.537795438 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, \"\"); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (pe.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:39.253789061 +0100\n+++ /tmp/tmpmh3lr4do.java\t2023-03-24 13:04:39.253789061 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (pe.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (1\", otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:40.993782594 +0100\n+++ /tmp/tmpn97wo8r9.java\t2023-03-24 13:04:40.993782594 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (1\", otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:42.697776260 +0100\n+++ /tmp/tmppr6_307z.java\t2023-03-24 13:04:42.697776260 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:44.345770135 +0100\n+++ /tmp/tmpim_w89j9.java\t2023-03-24 13:04:44.349770122 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Unknown.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (content!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:46.025763894 +0100\n+++ /tmp/tmppny4xbud.java\t2023-03-24 13:04:46.029763877 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (content!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (definition.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:47.629757931 +0100\n+++ /tmp/tmpk3_ztqe5.java\t2023-03-24 13:04:47.629757931 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (definition.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (value.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:49.365751478 +0100\n+++ /tmp/tmpbntscvev.java\t2023-03-24 13:04:49.369751465 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (value.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if ( once.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:51.081745102 +0100\n+++ /tmp/tmpjmmuh972.java\t2023-03-24 13:04:51.081745102 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( once.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (iterable.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:52.833738590 +0100\n+++ /tmp/tmpq1ynszuf.java\t2023-03-24 13:04:52.833738590 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (iterable.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (resolver.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:54.537732257 +0100\n+++ /tmp/tmpnfqn2cjc.java\t2023-03-24 13:04:54.537732257 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (resolver.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:56.241725923 +0100\n+++ /tmp/tmp2ekuw5dt.java\t2023-03-24 13:04:56.241725923 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (digit_list!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0))); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 30)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:04:57.921719677 +0100\n+++ /tmp/tmpuu0lu4u5.java\t2023-03-24 13:04:57.925719663 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 30)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:01.917704824 +0100\n+++ /tmp/tmpbj83zwwz.java\t2023-03-24 13:05:01.917704824 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if ( SET_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:03.557698729 +0100\n+++ /tmp/tmp8_fj7iom.java\t2023-03-24 13:05:03.609698534 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( SET_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (value!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:05.237692483 +0100\n+++ /tmp/tmpi4ch3a39.java\t2023-03-24 13:05:05.237692483 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (value!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Arrays.asList(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:06.861686447 +0100\n+++ /tmp/tmpzragepms.java\t2023-03-24 13:05:06.861686447 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Arrays.asList(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (definition.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:08.569680098 +0100\n+++ /tmp/tmpm0nkf2_0.java\t2023-03-24 13:05:08.569680098 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (definition.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:10.317673600 +0100\n+++ /tmp/tmpanlzna0_.java\t2023-03-24 13:05:10.317673600 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 1) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (window.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:12.001667338 +0100\n+++ /tmp/tmpa29iatfw.java\t2023-03-24 13:05:12.001667338 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (window.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (selected.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:13.629661287 +0100\n+++ /tmp/tmpej3mwizs.java\t2023-03-24 13:05:13.629661287 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (selected.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (resolver.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:15.321654997 +0100\n+++ /tmp/tmp7lel64n5.java\t2023-03-24 13:05:15.321654997 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (resolver.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (resolver.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:17.041648602 +0100\n+++ /tmp/tmp72b3tfx3.java\t2023-03-24 13:05:17.041648602 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (resolver.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:18.865641821 +0100\n+++ /tmp/tmpq0fxec42.java\t2023-03-24 13:05:18.865641821 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), \"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:20.557635532 +0100\n+++ /tmp/tmpc6fi17ho.java\t2023-03-24 13:05:20.557635532 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), \"\"); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), \"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:22.269629167 +0100\n+++ /tmp/tmpmi0r_m3h.java\t2023-03-24 13:05:22.273629151 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0), \"); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (window_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:23.957622891 +0100\n+++ /tmp/tmp97w4lv5v.java\t2023-03-24 13:05:23.957622891 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (window_list.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length,0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:25.593616808 +0100\n+++ /tmp/tmptjkzh8ar.java\t2023-03-24 13:05:25.593616808 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length,0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:27.285610519 +0100\n+++ /tmp/tmpne99h7f_.java\t2023-03-24 13:05:27.285610519 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (pe.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:28.945604346 +0100\n+++ /tmp/tmpdd9oc3tr.java\t2023-03-24 13:05:28.945604346 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (pe.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:30.585598249 +0100\n+++ /tmp/tmpnuamq1xp.java\t2023-03-24 13:05:30.585598249 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if ( otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:32.213592196 +0100\n+++ /tmp/tmp_hkpg50c.java\t2023-03-24 13:05:32.213592196 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if ( otherwise.length() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (block.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:33.873586024 +0100\n+++ /tmp/tmpo4uxv9d3.java\t2023-03-24 13:05:33.877586007 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (block.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (AUTO.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:35.553579775 +0100\n+++ /tmp/tmptbg6dtwn.java\t2023-03-24 13:05:35.553579775 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (AUTO.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:37.137573887 +0100\n+++ /tmp/tmpo0saxziu.java\t2023-03-24 13:05:37.137573887 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.length!= 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:38.965567090 +0100\n+++ /tmp/tmp6iel0x96.java\t2023-03-24 13:05:38.965567090 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (prependDocType) { otherwise.addAll(Collections.nCopies(digit_list.length, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list, 0, 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:40.649560828 +0100\n+++ /tmp/tmp36km6gtq.java\t2023-03-24 13:05:40.649560828 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list, 0, 1); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (aliases!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:42.297554699 +0100\n+++ /tmp/tmpurfv2u0u.java\t2023-03-24 13:05:42.297554699 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (aliases!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list, 0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:43.953548543 +0100\n+++ /tmp/tmpykpjjfmn.java\t2023-03-24 13:05:43.997548378 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list, 0)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (zoomFactor == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:45.709542011 +0100\n+++ /tmp/tmp5uegfitk.java\t2023-03-24 13:05:45.709542011 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (zoomFactor == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (readOnly) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:47.333535975 +0100\n+++ /tmp/tmpz20l2hp5.java\t2023-03-24 13:05:47.333535975 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (readOnly) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (otherwise!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:49.037529638 +0100\n+++ /tmp/tmpkja7tjv2.java\t2023-03-24 13:05:49.041529621 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise!= null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (override == null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:50.729523344 +0100\n+++ /tmp/tmp2tpy4by1.java\t2023-03-24 13:05:50.729523344 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (override == null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (otherwise == null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:52.401517126 +0100\n+++ /tmp/tmpl_0r7l00.java\t2023-03-24 13:05:52.401517126 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise == null) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (1] == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:54.325509972 +0100\n+++ /tmp/tmpqy_9p0rt.java\t2023-03-24 13:05:54.325509972 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (1] == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (Correct) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:56.441502104 +0100\n+++ /tmp/tmpb2sccb10.java\t2023-03-24 13:05:56.441502104 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (Correct) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (override) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:05:58.373494917 +0100\n+++ /tmp/tmp1w5x3wxq.java\t2023-03-24 13:05:58.377494904 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (override) { otherwise.addAll(Collections.nCopies(digit_list.length, otherwise)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (i == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:06:00.045488699 +0100\n+++ /tmp/tmpyojufhdw.java\t2023-03-24 13:06:00.045488699 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (i == 0) { otherwise.addAll(Collections.nCopies(digit_list.length, 0); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_palindrome/java_programs/NEXT_PALINDROME.java\t2023-03-24 13:06:01.641482766 +0100\n+++ /tmp/tmpc96au0ts.java\t2023-03-24 13:06:01.645482749 +0100\n@@ -30,11 +30,11 @@\n             }\n         }\n \n         ArrayList<Integer> otherwise = new ArrayList<Integer>();\n         otherwise.add(1);\n-        otherwise.addAll(Collections.nCopies(digit_list.length, 0));\n+if (otherwise.size() == 0) { otherwise.addAll(Collections.nCopies(digit_list)); }\n         otherwise.add(1);\n \n         return String.valueOf(otherwise);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "otherwise.addAll(Collections.nCopies(digit_list.length-1, 0));"
    },
    "detect_cycle": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:05:57.749497238 +0100\n+++ /tmp/tmp5ldwx64g.java\t2023-03-24 13:05:57.809497017 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (hortoise.getFirst() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:05:59.541490575 +0100\n+++ /tmp/tmp3g0actn5.java\t2023-03-24 13:05:59.541490575 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:01.233484281 +0100\n+++ /tmp/tmp4n56rj17.java\t2023-03-24 13:06:01.233484281 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:03.069477455 +0100\n+++ /tmp/tmpwm3hncqi.java\t2023-03-24 13:06:03.069477455 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:04.893470669 +0100\n+++ /tmp/tmpbf95sik6.java\t2023-03-24 13:06:04.893470669 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:06.673464051 +0100\n+++ /tmp/tmp9pqry8c1.java\t2023-03-24 13:06:06.677464035 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (tortoise.getFirst() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:08.361457771 +0100\n+++ /tmp/tmpn4vy1uzn.java\t2023-03-24 13:06:08.373457728 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:10.065451435 +0100\n+++ /tmp/tmp2l106lr6.java\t2023-03-24 13:06:10.065451435 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:11.861444755 +0100\n+++ /tmp/tmpbkk6m7kl.java\t2023-03-24 13:06:11.861444755 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:13.641438134 +0100\n+++ /tmp/tmpmsicv25o.java\t2023-03-24 13:06:13.641438134 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getFirst() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:15.365431722 +0100\n+++ /tmp/tmphgg3tnuu.java\t2023-03-24 13:06:15.365431722 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getFirst() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getFirst() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:17.113425221 +0100\n+++ /tmp/tmpqr6udl3a.java\t2023-03-24 13:06:17.113425221 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getFirst() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:18.861418719 +0100\n+++ /tmp/tmp8p2z190z.java\t2023-03-24 13:06:18.861418719 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (hare.getNode() == node.getNodeValue() && tortoise.getNodeValue().equals(tortoise.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:20.633412126 +0100\n+++ /tmp/tmprmrz_9o1.java\t2023-03-24 13:06:20.637412113 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node.getNodeValue() && tortoise.getNodeValue().equals(tortoise.getNodeValue())) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:22.253406101 +0100\n+++ /tmp/tmpqb7j03uf.java\t2023-03-24 13:06:22.253406101 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:23.861400119 +0100\n+++ /tmp/tmpcf_wjayb.java\t2023-03-24 13:06:23.861400119 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (hortoise.getFirst() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:25.461394168 +0100\n+++ /tmp/tmpwaoi24ly.java\t2023-03-24 13:06:25.465394154 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (hortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:27.213387650 +0100\n+++ /tmp/tmpjdvcepe_.java\t2023-03-24 13:06:27.217387637 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:28.925381282 +0100\n+++ /tmp/tmpgtngm8e4.java\t2023-03-24 13:06:28.925381282 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (hortoise.getFirst() == node.getNextSibling()) { if (tortoise.getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:30.697374692 +0100\n+++ /tmp/tmpwkqi9l8l.java\t2023-03-24 13:06:30.701374676 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == node.getNextSibling()) { if (tortoise.getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (hortoise.getNextSibling() == null) { if (tortoise.getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:32.429368248 +0100\n+++ /tmp/tmpat1aomt5.java\t2023-03-24 13:06:32.433368234 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling() == null) { if (tortoise.getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:34.229361552 +0100\n+++ /tmp/tmpy0xrgz8n.java\t2023-03-24 13:06:34.229361552 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getNextSibling() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (hortoise.getSuccessor() == null) { if (tortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:35.913355289 +0100\n+++ /tmp/tmpl4f55x86.java\t2023-03-24 13:06:35.913355289 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getSuccessor() == null) { if (tortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:37.589349054 +0100\n+++ /tmp/tmprr_6dwlk.java\t2023-03-24 13:06:37.589349054 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (hortoise.getNextSibling() == null) { if (tortoise.getNextSibling().getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:39.621341495 +0100\n+++ /tmp/tmpi8sc6awq.java\t2023-03-24 13:06:39.621341495 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling() == null) { if (tortoise.getNextSibling().getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getSecond() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:41.845333220 +0100\n+++ /tmp/tmpjgmddk04.java\t2023-03-24 13:06:41.845333220 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getSecond() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (tortoise.getNode() == node.getNodeValue() && node.getNodeValue().equals(tortoise.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:43.709326286 +0100\n+++ /tmp/tmppfykz3c6.java\t2023-03-24 13:06:43.797325959 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNode() == node.getNodeValue() && node.getNodeValue().equals(tortoise.getNodeValue())) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { tortoise = true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:45.905318117 +0100\n+++ /tmp/tmptfnqannv.java\t2023-03-24 13:06:46.025317670 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { tortoise = true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getFirst() == null) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:47.517312119 +0100\n+++ /tmp/tmpqfu_j_um.java\t2023-03-24 13:06:47.517312119 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getFirst() == null) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (tortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:49.637304231 +0100\n+++ /tmp/tmpeqnuz2wk.java\t2023-03-24 13:06:49.781303695 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (hare.getNodeValue().equals(tortoise)) { if (tortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:51.829296075 +0100\n+++ /tmp/tmp281geigk.java\t2023-03-24 13:06:51.833296062 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(tortoise)) { if (tortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (hortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:54.313286834 +0100\n+++ /tmp/tmp65s9cmtz.java\t2023-03-24 13:06:54.317286821 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (hortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { tortoise = true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:56.797277591 +0100\n+++ /tmp/tmp4t8qs3xz.java\t2023-03-24 13:06:56.797277591 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) { tortoise = true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getFirst().getSecond() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:06:58.913269719 +0100\n+++ /tmp/tmp4nbv2f1s.java\t2023-03-24 13:06:59.057269184 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getFirst().getSecond() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getFirst() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:01.337260701 +0100\n+++ /tmp/tmpydy32lgo.java\t2023-03-24 13:07:01.341260685 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getFirst() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (tortoise.getNextSibling() == null) { if (tortoise.getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:04.121250341 +0100\n+++ /tmp/tmpynodmdr7.java\t2023-03-24 13:07:04.121250341 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNextSibling() == null) { if (tortoise.getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getSecond() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:06.321242156 +0100\n+++ /tmp/tmpi0zwa_r9.java\t2023-03-24 13:07:06.325242142 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getSecond() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getFirst() == null) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:08.737233167 +0100\n+++ /tmp/tmprh9kws82.java\t2023-03-24 13:07:08.737233167 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getFirst() == null) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (hortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:10.805225472 +0100\n+++ /tmp/tmpx31hcvwf.java\t2023-03-24 13:07:11.001224741 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (hortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (tortoise.getFirst() == node.getNextSibling()) { if (tortoise.getNextSibling() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:13.285216243 +0100\n+++ /tmp/tmpuzexygy3.java\t2023-03-24 13:07:13.285216243 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == node.getNextSibling()) { if (tortoise.getNextSibling() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (tortoise.getFirst() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:15.453208177 +0100\n+++ /tmp/tmpjpgogdqa.java\t2023-03-24 13:07:15.453208177 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (hortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:17.697199827 +0100\n+++ /tmp/tmpi69dcf4j.java\t2023-03-24 13:07:17.697199827 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:20.113190836 +0100\n+++ /tmp/tmp308ciojm.java\t2023-03-24 13:07:20.113190836 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getFirst().getNextSibling() == null) { return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (hortoise.getFirst() == null) throw new IllegalArgumentException(\"no such edge in graph: \" + torto.getNode());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:22.405182305 +0100\n+++ /tmp/tmp69i11uah.java\t2023-03-24 13:07:22.409182292 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) throw new IllegalArgumentException(\"no such edge in graph: \" + torto.getNode());\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (hortoise.getFirst() == node.getNextSibling()) { if (tortoise.getNextSibling() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:24.581174210 +0100\n+++ /tmp/tmpyd78reb6.java\t2023-03-24 13:07:24.581174210 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == node.getNextSibling()) { if (tortoise.getNextSibling() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (tortoise.getNode() == node.getNodeValue() && node.getNodeValue().equals(tortoise)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:27.153164638 +0100\n+++ /tmp/tmpxosx_y5v.java\t2023-03-24 13:07:27.153164638 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNode() == node.getNodeValue() && node.getNodeValue().equals(tortoise)) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (tortoise == null) { if (tortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:28.997157776 +0100\n+++ /tmp/tmp3h4w2w4j.java\t2023-03-24 13:07:28.997157776 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise == null) { if (tortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getFirst() == null) return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:31.953146773 +0100\n+++ /tmp/tmpfyywnizk.java\t2023-03-24 13:07:31.953146773 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getFirst() == null) return false; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (hortoise == null) { if (tortoise.getSuccessor() == null) return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:34.081138853 +0100\n+++ /tmp/tmpgpv32oep.java\t2023-03-24 13:07:34.081138853 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) { if (tortoise.getSuccessor() == null) return true; }\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (hortoise.getFirst() == null)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:36.489129893 +0100\n+++ /tmp/tmpb3lfweqx.java\t2023-03-24 13:07:36.489129893 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null)\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (hortoise.getFirst() == null) throw new IllegalArgumentException(\"no such edge in graph: \" + node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:38.701121660 +0100\n+++ /tmp/tmp7qsyy0zs.java\t2023-03-24 13:07:38.701121660 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) throw new IllegalArgumentException(\"no such edge in graph: \" + node);\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (tortoise.getNode() == node.getNodeValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:41.653110674 +0100\n+++ /tmp/tmpcpn4_y7r.java\t2023-03-24 13:07:41.825110033 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNode() == node.getNodeValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (hortoise.getNode() == node.getNodeValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:43.657103214 +0100\n+++ /tmp/tmpjslf__7x.java\t2023-03-24 13:07:43.657103214 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNode() == node.getNodeValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (hortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:45.689095653 +0100\n+++ /tmp/tmpayd97sjn.java\t2023-03-24 13:07:45.729095504 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling()!= null) { if (tortoise.getNextSibling().getNextSibling() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:47.209089994 +0100\n+++ /tmp/tmpjw6h2qu9.java\t2023-03-24 13:07:47.213089981 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:49.117082893 +0100\n+++ /tmp/tmpu5b154rb.java\t2023-03-24 13:07:49.117082893 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) { if (tortoise.getSuccessor() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (tortoise.getFirst() == null)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:51.229075033 +0100\n+++ /tmp/tmpagngolup.java\t2023-03-24 13:07:51.229075033 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null)\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (hortoise.getFirst() == null && tortoise.getSecond() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:53.741065684 +0100\n+++ /tmp/tmpsabg6ama.java\t2023-03-24 13:07:53.741065684 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null && tortoise.getSecond() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (hare.getNode() == node.getNode().getNodeValue().equals(tortoise)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:55.913057597 +0100\n+++ /tmp/tmpdsccr4ih.java\t2023-03-24 13:07:55.913057597 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node.getNode().getNodeValue().equals(tortoise)) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (hare.getNode() == node.getNodeValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:57.437051926 +0100\n+++ /tmp/tmp1d1mvxl4.java\t2023-03-24 13:07:57.437051926 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node.getNodeValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (hare.getNodeValue().equals(tortoise.getNodeValue())) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:07:59.421044540 +0100\n+++ /tmp/tmpc4olg7xw.java\t2023-03-24 13:07:59.421044540 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue().equals(tortoise.getNodeValue())) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (hortoise.getNodeValue() == node.getNodeValue().getValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:01.537036665 +0100\n+++ /tmp/tmpn59no_8p.java\t2023-03-24 13:08:01.725035964 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNodeValue() == node.getNodeValue().getValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (hortoise.getNodeValue() == node.getNodeValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:03.157030634 +0100\n+++ /tmp/tmpnain8mkj.java\t2023-03-24 13:08:03.205030455 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNodeValue() == node.getNodeValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (hortoise.getFirst() == null) return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:05.209022997 +0100\n+++ /tmp/tmpsor1cz91.java\t2023-03-24 13:08:05.209022997 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) return false;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (hortoise.getNode() == node.getNodeValue().getValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:07.109015925 +0100\n+++ /tmp/tmpm8g8nj8c.java\t2023-03-24 13:08:07.109015925 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNode() == node.getNodeValue().getValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (hortoise.getFirst() == node.getChild().getChildCount()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:09.429007287 +0100\n+++ /tmp/tmpuz73vpcw.java\t2023-03-24 13:08:09.433007274 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == node.getChild().getChildCount()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (hortoise.getFirst() == node.getNodeValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:10.965001571 +0100\n+++ /tmp/tmp55gc1ypb.java\t2023-03-24 13:08:11.117001005 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == node.getNodeValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (hortoise.getNodeValue() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:13.224993158 +0100\n+++ /tmp/tmp1w_b74bs.java\t2023-03-24 13:08:13.400992503 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNodeValue() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (tortoise.getNodeValue() == node.getNodeValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:15.580984388 +0100\n+++ /tmp/tmp8vd82u89.java\t2023-03-24 13:08:15.580984388 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNodeValue() == node.getNodeValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (tortoise.getNode() == node.getNodeValue().getValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:17.072978833 +0100\n+++ /tmp/tmp6mgmchji.java\t2023-03-24 13:08:17.124978638 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNode() == node.getNodeValue().getValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (hortoise.getFirst() == node.getChildCount()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:18.772972505 +0100\n+++ /tmp/tmpckx0bw53.java\t2023-03-24 13:08:18.772972505 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == node.getChildCount()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (hortoise.getSuccessor() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:20.448966266 +0100\n+++ /tmp/tmpb2l15ibj.java\t2023-03-24 13:08:20.448966266 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getSuccessor() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (hortoise.getFirst() == null) break;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:22.172959846 +0100\n+++ /tmp/tmpf0zch8op.java\t2023-03-24 13:08:22.172959846 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) break;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (hortoise.getFirst().getNextSibling() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:23.896953429 +0100\n+++ /tmp/tmpo4aj0fkt.java\t2023-03-24 13:08:23.896953429 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst().getNextSibling() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (hortoise.getFirst() == node) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:25.584947144 +0100\n+++ /tmp/tmpmhrd_njl.java\t2023-03-24 13:08:25.584947144 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == node) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (tortoise.getNode() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:27.356940549 +0100\n+++ /tmp/tmprwet2nvn.java\t2023-03-24 13:08:27.356940549 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNode() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (hare.getNode() == node.getNode()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:29.020934354 +0100\n+++ /tmp/tmpq22w3du8.java\t2023-03-24 13:08:29.020934354 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node.getNode()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (hortoise.getSuccessor() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:30.740927950 +0100\n+++ /tmp/tmphy4f5sta.java\t2023-03-24 13:08:30.740927950 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getSuccessor() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (tortoise.getFirst() == null) return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:32.396921785 +0100\n+++ /tmp/tmp3fw69qn6.java\t2023-03-24 13:08:32.396921785 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) return false;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (hortoise.getNextSibling() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:34.128915335 +0100\n+++ /tmp/tmpsybq1lhk.java\t2023-03-24 13:08:34.128915335 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (hortoise.getNode() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:35.804909097 +0100\n+++ /tmp/tmpubllbus1.java\t2023-03-24 13:08:35.804909097 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNode() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (hortoise.getFirst() == node) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:37.452902962 +0100\n+++ /tmp/tmp54otf30a.java\t2023-03-24 13:08:37.456902945 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == node) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (hortoise.getNextSibling() == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:39.096896840 +0100\n+++ /tmp/tmp9m4ihlqw.java\t2023-03-24 13:08:39.096896840 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling() == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (hortoise.getFirst() == null) continue;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:40.864890258 +0100\n+++ /tmp/tmp0txzxo2u.java\t2023-03-24 13:08:40.864890258 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getFirst() == null) continue;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (hare.getNodeValue() == node.getNodeValue()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:42.552883971 +0100\n+++ /tmp/tmplktzguct.java\t2023-03-24 13:08:42.552883971 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNodeValue() == node.getNodeValue()) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (tortoise.getFirst() == null) break;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:44.188877882 +0100\n+++ /tmp/tmpyvgrur7t.java\t2023-03-24 13:08:44.188877882 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == null) break;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (tortoise.getNodeValue() == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:46.052870940 +0100\n+++ /tmp/tmpf0bvjsxg.java\t2023-03-24 13:08:46.052870940 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNodeValue() == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (tortoise.getFirst() == node) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:47.692864835 +0100\n+++ /tmp/tmp3_7kik9u.java\t2023-03-24 13:08:47.692864835 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getFirst() == node) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (hortoise.getNextSibling() == null)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:49.384858534 +0100\n+++ /tmp/tmpz9nrrhsz.java\t2023-03-24 13:08:49.384858534 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNextSibling() == null)\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (tortoise.getNode() == null)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:51.168851893 +0100\n+++ /tmp/tmpmsitb6vg.java\t2023-03-24 13:08:51.168851893 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise.getNode() == null)\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (hortoise.getSuccessor() == null)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:52.972845174 +0100\n+++ /tmp/tmpvr8ydnbp.java\t2023-03-24 13:08:52.972845174 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getSuccessor() == null)\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (hortoise.getNodeValue() == null)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:54.768838487 +0100\n+++ /tmp/tmpo3i19m59.java\t2023-03-24 13:08:54.768838487 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNodeValue() == null)\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (hortoise.getNode() == null)",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:56.572831771 +0100\n+++ /tmp/tmp8i1j7ooc.java\t2023-03-24 13:08:56.576831754 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.getNode() == null)\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (hare.getNode() == node) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:08:58.428824859 +0100\n+++ /tmp/tmpg7z5ogap.java\t2023-03-24 13:08:58.428824859 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hare.getNode() == node) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (tortoise == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:09:00.052818813 +0100\n+++ /tmp/tmpnt025qdp.java\t2023-03-24 13:09:00.052818813 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (hortoise == null) return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:09:01.828812200 +0100\n+++ /tmp/tmpf689elmu.java\t2023-03-24 13:09:01.828812200 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) return true;\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (tortoise == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:09:03.524805883 +0100\n+++ /tmp/tmpctkheej7.java\t2023-03-24 13:09:03.524805883 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (tortoise == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (hortoise == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:09:05.172799748 +0100\n+++ /tmp/tmptudf1d57.java\t2023-03-24 13:09:05.172799748 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise == null) {\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (hortoise.get();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:09:06.796793699 +0100\n+++ /tmp/tmpmbrphf10.java\t2023-03-24 13:09:06.796793699 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if (hortoise.get();\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/detect_cycle/java_programs/DETECT_CYCLE.java\t2023-03-24 13:09:08.440787579 +0100\n+++ /tmp/tmpv8swrrp6.java\t2023-03-24 13:09:08.444787562 +0100\n@@ -13,11 +13,11 @@\n     public static boolean detect_cycle(Node node) {\n         Node hare = node;\n         Node tortoise = node;\n \n         while (true) {\n-            if (hare.getSuccessor() == null)\n+if\n                 return false;\n \n             tortoise = tortoise.getSuccessor();\n             hare = hare.getSuccessor().getSuccessor();\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (null==hare ||hare.getSuccessor() == null)"
    },
    "quicksort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "} else if (x > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:05.861467071 +0100\n+++ /tmp/tmpp6i1611m.java\t2023-03-24 13:06:05.909466892 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "} else if (x > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:10.109451270 +0100\n+++ /tmp/tmpv5bdnepe.java\t2023-03-24 13:06:10.109451270 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "} else if (x > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:11.869444725 +0100\n+++ /tmp/tmpbb3wg6h3.java\t2023-03-24 13:06:11.869444725 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "} else if (x > 0 || y > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:15.957429520 +0100\n+++ /tmp/tmp2kke73_z.java\t2023-03-24 13:06:15.961429504 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "} else if (x > 0 || x < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:17.729422929 +0100\n+++ /tmp/tmpxu_tkrzn.java\t2023-03-24 13:06:17.729422929 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || x < 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "} else if (x > 0 && y > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:21.757407947 +0100\n+++ /tmp/tmptgjnndzc.java\t2023-03-24 13:06:21.761407930 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "} else if (x > _pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:23.565401221 +0100\n+++ /tmp/tmpcsvqj3bi.java\t2023-03-24 13:06:23.565401221 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > _pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "} else if (x > 0 && x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:25.373394495 +0100\n+++ /tmp/tmpfsvvyq8g.java\t2023-03-24 13:06:25.373394495 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "} else if (x > -1 && y > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:27.089388113 +0100\n+++ /tmp/tmpeojjzwab.java\t2023-03-24 13:06:27.089388113 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 && y > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "} else if (pivot.size() > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:28.845381580 +0100\n+++ /tmp/tmpf_q38lwl.java\t2023-03-24 13:06:28.845381580 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot.size() > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "} else if (x > 0xff || x < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:30.653374854 +0100\n+++ /tmp/tmpynu_8m9i.java\t2023-03-24 13:06:30.653374854 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0xff || x < 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "} else if (y > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:34.805359409 +0100\n+++ /tmp/tmpro2n56hk.java\t2023-03-24 13:06:34.805359409 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "} else if (x > 0 || x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:36.561352879 +0100\n+++ /tmp/tmp2u2yfri6.java\t2023-03-24 13:06:36.565352862 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "} else if (x > -1 && x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:38.309346375 +0100\n+++ /tmp/tmp2pc2ahef.java\t2023-03-24 13:06:38.309346375 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 && x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "} else if (x > Math.abs(z) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:39.941340305 +0100\n+++ /tmp/tmp3xarjjb_.java\t2023-03-24 13:06:39.941340305 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.abs(z) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "} else if (pivot.equals(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:41.633334010 +0100\n+++ /tmp/tmpvt905ph_.java\t2023-03-24 13:06:41.745333593 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot.equals(x)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "} else if (x > System.currentTimeMillis()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:47.681311508 +0100\n+++ /tmp/tmpwylnghkz.java\t2023-03-24 13:06:47.681311508 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > System.currentTimeMillis()) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "} else if (x > 0 || y >'') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:52.621293129 +0100\n+++ /tmp/tmp659b0o1o.java\t2023-03-24 13:06:52.621293129 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y >'') {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "} else if (x > 0xff) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:54.309286851 +0100\n+++ /tmp/tmpe69a_9rq.java\t2023-03-24 13:06:54.309286851 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0xff) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "} else if (x > X) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:06:59.777266506 +0100\n+++ /tmp/tmppmwdx2p0.java\t2023-03-24 13:06:59.777266506 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > X) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "} else if (z > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:01.349260655 +0100\n+++ /tmp/tmped54qju1.java\t2023-03-24 13:07:01.349260655 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (z > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "} else if (x > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:03.949250982 +0100\n+++ /tmp/tmpa8aferw9.java\t2023-03-24 13:07:04.093250447 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > j) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "} else if (x > Math.max(0, x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:06.301242232 +0100\n+++ /tmp/tmpe_f3enmv.java\t2023-03-24 13:07:06.301242232 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.max(0, x)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "} else if (x > h) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:11.725222047 +0100\n+++ /tmp/tmpin2vxrbf.java\t2023-03-24 13:07:11.729222034 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > h) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "} else if (x > Math.abs(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:13.341216034 +0100\n+++ /tmp/tmpvxbw8m6k.java\t2023-03-24 13:07:13.341216034 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.abs(x)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "} else if (x > 0 && y >'') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:18.545196671 +0100\n+++ /tmp/tmpuwp2w3qc.java\t2023-03-24 13:07:18.561196611 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y >'') {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "} else if (pivot >= x && x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:20.125190790 +0100\n+++ /tmp/tmpkp37f4bz.java\t2023-03-24 13:07:20.125190790 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot >= x && x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "} else if (x > start) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:22.409182292 +0100\n+++ /tmp/tmppcjttx6h.java\t2023-03-24 13:07:22.409182292 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > start) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "} else if (x > -1 || x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:24.541174358 +0100\n+++ /tmp/tmp99w1avjm.java\t2023-03-24 13:07:24.541174358 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 || x < y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "} else if (x > Math.floor(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:26.885165636 +0100\n+++ /tmp/tmpgu_ze84z.java\t2023-03-24 13:07:26.885165636 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.floor(x)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "} else if (x > this.pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:32.381145182 +0100\n+++ /tmp/tmpbozp3r9a.java\t2023-03-24 13:07:32.381145182 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > this.pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "} else if (pivot > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:34.041139002 +0100\n+++ /tmp/tmpnd2p62uo.java\t2023-03-24 13:07:34.041139002 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot > x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "} else if (x > SURR1_LAST) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:39.837117433 +0100\n+++ /tmp/tmpzbowha1t.java\t2023-03-24 13:07:39.837117433 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > SURR1_LAST) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "} else if (x > Integer.MIN_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:41.529111136 +0100\n+++ /tmp/tmp3f7g7lcw.java\t2023-03-24 13:07:41.589110912 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Integer.MIN_VALUE) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "} else if (x > > 0 || x < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:46.973090874 +0100\n+++ /tmp/tmp55700rft.java\t2023-03-24 13:07:46.977090857 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > > 0 || x < 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "} else if (x > 0 || y > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:49.121082879 +0100\n+++ /tmp/tmp2xxyhvml.java\t2023-03-24 13:07:49.121082879 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "} else if ( x > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:51.233075017 +0100\n+++ /tmp/tmpcc5vesdt.java\t2023-03-24 13:07:51.233075017 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if ( x > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "} else if (x > 0x80) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:07:57.169052924 +0100\n+++ /tmp/tmpdcpt8ioi.java\t2023-03-24 13:07:57.169052924 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0x80) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "} else if ( x > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:03.021031140 +0100\n+++ /tmp/tmpv09wokur.java\t2023-03-24 13:08:03.025031127 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if ( x > y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "} else if (x > '+' || x < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:05.209022997 +0100\n+++ /tmp/tmp13a20qay.java\t2023-03-24 13:08:05.273022759 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > '+' || x < 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "} else if (x > 0 && x < pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:11.488999621 +0100\n+++ /tmp/tmpre6rgzjg.java\t2023-03-24 13:08:11.492999604 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "} else if (x > Math.abs(y)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:16.700980217 +0100\n+++ /tmp/tmpioiaz3yg.java\t2023-03-24 13:08:16.700980217 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.abs(y)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "} else if (pivot.contains(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:18.668972892 +0100\n+++ /tmp/tmpz_fn_yfk.java\t2023-03-24 13:08:18.668972892 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot.contains(x)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "} else if (x > -1 && y > -1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:20.432966326 +0100\n+++ /tmp/tmpoo_z6nyo.java\t2023-03-24 13:08:20.436966309 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > -1 && y > -1) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "} else if (z == x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:22.228959638 +0100\n+++ /tmp/tmpz1mh0e31.java\t2023-03-24 13:08:22.232959624 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (z == x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "} else if (x >'' || x < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:23.956953204 +0100\n+++ /tmp/tmp5029q53c.java\t2023-03-24 13:08:23.956953204 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >'' || x < 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "} else if (x > System.out.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:25.612947039 +0100\n+++ /tmp/tmpujtijbql.java\t2023-03-24 13:08:25.612947039 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > System.out.size()) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "} else if (x > Short.MAX_VALUE) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:27.388940427 +0100\n+++ /tmp/tmpu1rz786x.java\t2023-03-24 13:08:27.392940414 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Short.MAX_VALUE) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "} else if (y > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:31.436925357 +0100\n+++ /tmp/tmpk7s_76k1.java\t2023-03-24 13:08:31.436925357 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y > y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "} else if (pivot >= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:33.144919000 +0100\n+++ /tmp/tmpegqv6h_6.java\t2023-03-24 13:08:33.144919000 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot >= x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "} else if (x > 0 && y > h) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:37.264903659 +0100\n+++ /tmp/tmpsi6dr47j.java\t2023-03-24 13:08:37.264903659 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y > h) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "} else if (x > Math.abs(x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:39.044897034 +0100\n+++ /tmp/tmpcs3qb172.java\t2023-03-24 13:08:39.048897018 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.abs(x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "} else if (x > 0 && y <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:40.760890645 +0100\n+++ /tmp/tmpdhu13_a_.java\t2023-03-24 13:08:40.760890645 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y <= x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "} else if (x > ch) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:42.424884450 +0100\n+++ /tmp/tmpkcwg_uqj.java\t2023-03-24 13:08:42.428884433 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > ch) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "} else if (x > 0x - start) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:44.168877954 +0100\n+++ /tmp/tmpaf8ya716.java\t2023-03-24 13:08:44.172877941 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0x - start) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "} else if (x > 0 && y > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:45.868871627 +0100\n+++ /tmp/tmp1nrl08m4.java\t2023-03-24 13:08:45.868871627 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && y > 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "} else if (x > (pivot - x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:47.540865399 +0100\n+++ /tmp/tmpkl6tr8_l.java\t2023-03-24 13:08:47.540865399 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > (pivot - x)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "} else if (x > t) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:51.596850298 +0100\n+++ /tmp/tmpb797sq_t.java\t2023-03-24 13:08:51.596850298 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > t) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "} else if (pivot >= x && y <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:53.296843968 +0100\n+++ /tmp/tmpnyoeujvx.java\t2023-03-24 13:08:53.300843955 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot >= x && y <= x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "} else if (pivot >= x && x <= y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:54.984837684 +0100\n+++ /tmp/tmpn49ccesu.java\t2023-03-24 13:08:54.984837684 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot >= x && x <= y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "} else if (x > arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:08:56.708831265 +0100\n+++ /tmp/tmp28wikk66.java\t2023-03-24 13:08:56.708831265 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > arr.size()) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "} else if (x > 0 && x < p) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:00.688816445 +0100\n+++ /tmp/tmp_2nuchin.java\t2023-03-24 13:09:00.688816445 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 && x < p) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "} else if (x > _pivot || x < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:02.384810128 +0100\n+++ /tmp/tmp82l6t0kd.java\t2023-03-24 13:09:02.384810128 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > _pivot || x < 0) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "} else if (x > 0 || y > \", \") {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:04.188803412 +0100\n+++ /tmp/tmp5sr2tgl1.java\t2023-03-24 13:09:04.188803412 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > \", \") {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "} else if (x > 0 || y > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:05.924796948 +0100\n+++ /tmp/tmp4fqzn62s.java\t2023-03-24 13:09:05.924796948 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "} else if (x > 0 || y > className) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:07.640790558 +0100\n+++ /tmp/tmpeg_93ve3.java\t2023-03-24 13:09:07.640790558 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > className) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "} else if (x > 0 || y > h) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:09.492783660 +0100\n+++ /tmp/tmpne2k_l43.java\t2023-03-24 13:09:09.492783660 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > h) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "} else if (x > 0 || y > w) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:11.404776542 +0100\n+++ /tmp/tmp4zb0ds2j.java\t2023-03-24 13:09:11.404776542 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > w) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "} else if (x > 0 || y > p) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:13.292769509 +0100\n+++ /tmp/tmp0sf19a1g.java\t2023-03-24 13:09:13.292769509 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > p) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "} else if (x > Math.abs(pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:15.032763031 +0100\n+++ /tmp/tmp7hayx701.java\t2023-03-24 13:09:15.036763014 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > Math.abs(pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "} else if (x > 0 || y > in) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:16.776756536 +0100\n+++ /tmp/tmp47rcvydv.java\t2023-03-24 13:09:16.776756536 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > in) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "} else if (x > NILBIGINT) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:18.512750072 +0100\n+++ /tmp/tmpr6ymj1y_.java\t2023-03-24 13:09:18.512750072 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > NILBIGINT) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "} else if (pivot.size() > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:20.272743518 +0100\n+++ /tmp/tmpwdb5ta79.java\t2023-03-24 13:09:20.272743518 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (pivot.size() > y) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "} else if (x > 0 || y > 8) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:21.972737185 +0100\n+++ /tmp/tmpb5viin4d.java\t2023-03-24 13:09:21.972737185 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > 8) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "} else if (x > o) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:23.680730826 +0100\n+++ /tmp/tmpspoo1wur.java\t2023-03-24 13:09:23.680730826 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > o) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "} else if (x > 0x -pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:25.412724376 +0100\n+++ /tmp/tmpn_pj84_s.java\t2023-03-24 13:09:25.416724359 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0x -pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "} else if (x > 0x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:27.100718089 +0100\n+++ /tmp/tmpoi391u8d.java\t2023-03-24 13:09:27.100718089 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "} else if (x > c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:28.784711816 +0100\n+++ /tmp/tmpos9dkh6x.java\t2023-03-24 13:09:28.784711816 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > c) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "} else if (x >(7)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:30.548705247 +0100\n+++ /tmp/tmp76prs2m4.java\t2023-03-24 13:09:30.548705247 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >(7)) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "} else if (x > 0 || y > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:34.736689649 +0100\n+++ /tmp/tmp5ikgkvw5.java\t2023-03-24 13:09:34.740689636 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 0 || y > 1) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "} else if (x > threshold) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:36.504683066 +0100\n+++ /tmp/tmpvtvh_lsw.java\t2023-03-24 13:09:36.504683066 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > threshold) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "} else if (iter.hasNext()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:38.252676556 +0100\n+++ /tmp/tmp5e25u5lr.java\t2023-03-24 13:09:38.252676556 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (iter.hasNext()) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "} else if (x > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:39.972670148 +0100\n+++ /tmp/tmpjkpl18mx.java\t2023-03-24 13:09:39.972670148 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > max) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "} else if (x > len) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:41.436664698 +0100\n+++ /tmp/tmp1wewji1f.java\t2023-03-24 13:09:41.436664698 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > len) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "} else if (x > d) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:42.972658977 +0100\n+++ /tmp/tmpmv0qhs0_.java\t2023-03-24 13:09:42.972658977 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > d) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "} else if (x >'') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:44.584652973 +0100\n+++ /tmp/tmpezy83h6e.java\t2023-03-24 13:09:44.584652973 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >'') {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "} else if (x >ROOT) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:46.140647176 +0100\n+++ /tmp/tmpllphy4xr.java\t2023-03-24 13:09:46.140647176 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >ROOT) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "} else if (x > var) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:47.732641248 +0100\n+++ /tmp/tmpsnbumue6.java\t2023-03-24 13:09:47.732641248 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > var) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "} else if (x >(7) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:49.300635408 +0100\n+++ /tmp/tmp252nix55.java\t2023-03-24 13:09:49.300635408 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >(7) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "} else if (x > tiny) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:50.936629315 +0100\n+++ /tmp/tmpz9i2p7x9.java\t2023-03-24 13:09:50.936629315 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > tiny) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "} else if (x >Pos) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:52.748622563 +0100\n+++ /tmp/tmpsjcg1ue0.java\t2023-03-24 13:09:52.748622563 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Pos) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "} else if (y < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:54.412616368 +0100\n+++ /tmp/tmpg35kk2rh.java\t2023-03-24 13:09:54.412616368 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (y < x) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "} else if (x >duration) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:56.292609365 +0100\n+++ /tmp/tmp_emwa9vz.java\t2023-03-24 13:09:56.292609365 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >duration) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "} else if (x > 99) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:09:57.936603242 +0100\n+++ /tmp/tmp52nrswgu.java\t2023-03-24 13:09:57.964603136 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 99) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "} else if (x > 90) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:10:01.948588298 +0100\n+++ /tmp/tmp9o0bh423.java\t2023-03-24 13:10:01.952588281 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 90) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "} else if (x >charset) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:10:06.032573086 +0100\n+++ /tmp/tmpkg1onhfa.java\t2023-03-24 13:10:06.036573069 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >charset) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "} else if (t > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:10:07.900566127 +0100\n+++ /tmp/tmpuzs9irby.java\t2023-03-24 13:10:07.900566127 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (t > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "} else if (x >Var) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:10:09.712559376 +0100\n+++ /tmp/tmpwta0640g.java\t2023-03-24 13:10:09.712559376 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x >Var) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "} else if (x > 32) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:10:11.440552940 +0100\n+++ /tmp/tmp03_8jvy4.java\t2023-03-24 13:10:11.440552940 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (x > 32) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "} else if (v > pivot) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/quicksort/java_programs/QUICKSORT.java\t2023-03-24 13:10:15.668537191 +0100\n+++ /tmp/tmp994sjyvw.java\t2023-03-24 13:10:15.668537191 +0100\n@@ -21,11 +21,11 @@\n         ArrayList<Integer> greater = new ArrayList<Integer>();\n \n         for (Integer x : arr.subList(1, arr.size())) {\n             if (x < pivot) {\n                 lesser.add(x);\n-            } else if (x > pivot) {\n+} else if (v > pivot) {\n                 greater.add(x);\n             }\n         }\n         ArrayList<Integer> middle = new ArrayList<Integer>();\n         middle.add(pivot);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "} else if (x >= pivot) {"
    },
    "sqrt": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (Math.abs(x - x) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:12.560772237 +0100\n+++ /tmp/tmpt_7dipka.java\t2023-03-24 13:09:12.604772072 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - x) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:16.772756550 +0100\n+++ /tmp/tmp0g69y34v.java\t2023-03-24 13:09:16.772756550 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (comparator.compare(x, y) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:20.644742130 +0100\n+++ /tmp/tmpyolvd80s.java\t2023-03-24 13:09:20.644742130 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, y) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (Math.abs(x - y) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:22.356735755 +0100\n+++ /tmp/tmp8mk286io.java\t2023-03-24 13:09:22.356735755 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - y) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (Math.abs(x-approx) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:24.140729112 +0100\n+++ /tmp/tmp85qa_qdc.java\t2023-03-24 13:09:24.140729112 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x-approx) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (comparator.compare(x, y) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:28.032714617 +0100\n+++ /tmp/tmpmlxcs940.java\t2023-03-24 13:09:28.032714617 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, y) > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (epsilon <= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:29.708708375 +0100\n+++ /tmp/tmp_6ffls9e.java\t2023-03-24 13:09:29.708708375 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon <= 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (Math.abs(x - b) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:33.728693405 +0100\n+++ /tmp/tmpyja7h1pt.java\t2023-03-24 13:09:33.744693346 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - b) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "while (Math.abs(x-approx) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:35.588686478 +0100\n+++ /tmp/tmp2mikkjnn.java\t2023-03-24 13:09:35.592686462 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+while (Math.abs(x-approx) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (comparator.compare(x - 1) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:57.732604002 +0100\n+++ /tmp/tmp1n7v5rmj.java\t2023-03-24 13:09:57.732604002 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - 1) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (Math.abs(x / 2) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:09:59.548597238 +0100\n+++ /tmp/tmpq336w0g0.java\t2023-03-24 13:09:59.552597221 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x / 2) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (Math.abs(x) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:03.704581755 +0100\n+++ /tmp/tmp639c1cdn.java\t2023-03-24 13:10:03.704581755 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (Math.abs(x - x) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:07.932566008 +0100\n+++ /tmp/tmpnilboklj.java\t2023-03-24 13:10:07.932566008 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - x) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (Math.abs(x -approx) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:11.948551048 +0100\n+++ /tmp/tmpala1b59q.java\t2023-03-24 13:10:11.948551048 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x -approx) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (epsilon < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:16.076535671 +0100\n+++ /tmp/tmpquhagqo_.java\t2023-03-24 13:10:16.076535671 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (!Math.abs(x - x) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:19.984521114 +0100\n+++ /tmp/tmpwc1s72_v.java\t2023-03-24 13:10:19.984521114 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (!Math.abs(x - x) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (Math.abs(x-approx) >= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:21.788514393 +0100\n+++ /tmp/tmpxk8xby0n.java\t2023-03-24 13:10:21.788514393 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x-approx) >= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (Math.abs(x - epsilon) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:25.740499669 +0100\n+++ /tmp/tmppfblt0oy.java\t2023-03-24 13:10:25.740499669 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - epsilon) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (comparator.compare(x - last > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:29.864484306 +0100\n+++ /tmp/tmpgxcc2qkl.java\t2023-03-24 13:10:29.864484306 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - last > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (Math.abs(x - tiny) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:31.640477692 +0100\n+++ /tmp/tmp4r_gus4h.java\t2023-03-24 13:10:31.640477692 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - tiny) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (Math.abs(x - EPS) < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:33.428471028 +0100\n+++ /tmp/tmpt8lexua4.java\t2023-03-24 13:10:33.428471028 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - EPS) < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (comparator.compare(x > 0) < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:35.228464325 +0100\n+++ /tmp/tmpyl5ho5_c.java\t2023-03-24 13:10:35.228464325 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x > 0) < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (comparator.compare(x, epsilon) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:37.020457647 +0100\n+++ /tmp/tmpoichwv8x.java\t2023-03-24 13:10:37.020457647 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, epsilon) > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (comparator.compare(x / 2) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:38.792451047 +0100\n+++ /tmp/tmpkl9s7e6t.java\t2023-03-24 13:10:38.792451047 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x / 2) > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (comparator.compare(x - x) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:40.656444102 +0100\n+++ /tmp/tmpy_t9wzug.java\t2023-03-24 13:10:40.656444102 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - x) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (comparator.compare(x, 0) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:42.380437680 +0100\n+++ /tmp/tmpxtofvt_6.java\t2023-03-24 13:10:42.380437680 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, 0) > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (comparator.compare(x - 1, 0) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:44.232430778 +0100\n+++ /tmp/tmp8pp_j82o.java\t2023-03-24 13:10:44.232430778 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - 1, 0) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (comparator.compare(x - start) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:45.944424402 +0100\n+++ /tmp/tmpj12hdpdu.java\t2023-03-24 13:10:45.944424402 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - start) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (comparator.compare(x, epsilon) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:47.668417976 +0100\n+++ /tmp/tmpeu7hl3r_.java\t2023-03-24 13:10:47.668417976 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, epsilon) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (comparator.compare(x, 0.0) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:49.416411464 +0100\n+++ /tmp/tmpw0smlwev.java\t2023-03-24 13:10:49.420411451 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, 0.0) > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (comparator.compare(x, m) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:51.144405026 +0100\n+++ /tmp/tmpy5jgd65s.java\t2023-03-24 13:10:51.144405026 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, m) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (Math.abs(x - 2) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:52.896398501 +0100\n+++ /tmp/tmphct62u92.java\t2023-03-24 13:10:52.896398501 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - 2) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (comparator.compare(x, y) == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:57.008383180 +0100\n+++ /tmp/tmpuyso1hee.java\t2023-03-24 13:10:57.008383180 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x, y) == 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (comparator.compare(x - 2) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:10:58.792376533 +0100\n+++ /tmp/tmpl3e760vp.java\t2023-03-24 13:10:58.792376533 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - 2) > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (Integer.MAX_VALUE >= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:00.508370137 +0100\n+++ /tmp/tmpvv988ohl.java\t2023-03-24 13:11:00.508370137 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Integer.MAX_VALUE >= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (Math.abs(x - 1)) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:04.568355012 +0100\n+++ /tmp/tmpfhuuwnkk.java\t2023-03-24 13:11:04.568355012 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x - 1)) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (epsilon < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:06.152349108 +0100\n+++ /tmp/tmpyane0ciq.java\t2023-03-24 13:11:06.152349108 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (epsilon < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:10.024334683 +0100\n+++ /tmp/tmpylmo54s8.java\t2023-03-24 13:11:10.024334683 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon < x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (Math.abs(x) > epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:14.024319779 +0100\n+++ /tmp/tmpwtrnycff.java\t2023-03-24 13:11:14.024319779 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Math.abs(x) > epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (comparator.compare(x - 0) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:18.052304770 +0100\n+++ /tmp/tmpg7s23kdn.java\t2023-03-24 13:11:18.056304753 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - 0) < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (comparator.compare(x - x, -1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:19.732298510 +0100\n+++ /tmp/tmpmz8izmo5.java\t2023-03-24 13:11:19.732298510 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator.compare(x - x, -1)) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if ( getParameter(x, y) < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:21.492291949 +0100\n+++ /tmp/tmp0aymj21x.java\t2023-03-24 13:11:21.492291949 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if ( getParameter(x, y) < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (epsilon <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:23.308285185 +0100\n+++ /tmp/tmpoe1i9848.java\t2023-03-24 13:11:23.308285185 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon <= x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (x < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:27.352270113 +0100\n+++ /tmp/tmpyqmei3n5.java\t2023-03-24 13:11:27.352270113 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (x < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (x % 2 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:31.256255567 +0100\n+++ /tmp/tmp1ptvv3dt.java\t2023-03-24 13:11:31.260255550 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (x % 2 == 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (epsilon <= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:35.212240826 +0100\n+++ /tmp/tmphk8iv0_r.java\t2023-03-24 13:11:35.212240826 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon <= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (Float.MAX_VALUE >= epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:39.556224636 +0100\n+++ /tmp/tmpmcw3a1e5.java\t2023-03-24 13:11:39.556224636 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Float.MAX_VALUE >= epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (epsilon <= x / 2d) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:44.388206631 +0100\n+++ /tmp/tmpxo7umks9.java\t2023-03-24 13:11:44.392206614 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon <= x / 2d) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (approximate < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:48.816190127 +0100\n+++ /tmp/tmp8l4ja4ra.java\t2023-03-24 13:11:48.820190114 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (approximate < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (epsilon > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:50.668183228 +0100\n+++ /tmp/tmp_rnh578p.java\t2023-03-24 13:11:50.668183228 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon > x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (!createLoops(epsilon)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:54.880167531 +0100\n+++ /tmp/tmp6srcpgys.java\t2023-03-24 13:11:54.880167531 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (!createLoops(epsilon)) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (Partition.contains(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:57.360158288 +0100\n+++ /tmp/tmpt0620zbt.java\t2023-03-24 13:11:57.360158288 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Partition.contains(x)) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (epsilon >= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:11:59.872148926 +0100\n+++ /tmp/tmphua343bx.java\t2023-03-24 13:11:59.872148926 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon >= x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (formatter == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:06.468124342 +0100\n+++ /tmp/tmpm4n1ay1n.java\t2023-03-24 13:12:06.468124342 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (formatter == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (x < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:08.864115413 +0100\n+++ /tmp/tmp79in_swq.java\t2023-03-24 13:12:08.864115413 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (x < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (x!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:13.992096300 +0100\n+++ /tmp/tmp_nvrlxbk.java\t2023-03-24 13:12:13.992096300 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (x!= 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (comparator == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:18.884078048 +0100\n+++ /tmp/tmpejgpsp77.java\t2023-03-24 13:12:18.884078048 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (comparator == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (epsilon <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:23.368060065 +0100\n+++ /tmp/tmpr71z1ngf.java\t2023-03-24 13:12:23.368060065 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon <= 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (weighted < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:29.196036664 +0100\n+++ /tmp/tmp85r2qvvi.java\t2023-03-24 13:12:29.196036664 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (weighted < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (epsilon <= x + 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:31.676026711 +0100\n+++ /tmp/tmp_6ww68yh.java\t2023-03-24 13:12:31.676026711 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon <= x + 1) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if ( Binding == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:37.040005196 +0100\n+++ /tmp/tmp2v3bjvxa.java\t2023-03-24 13:12:37.044005181 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if ( Binding == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (y < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:39.263996278 +0100\n+++ /tmp/tmpygdfa4pz.java\t2023-03-24 13:12:39.267996262 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (y < x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (x < y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:41.099988918 +0100\n+++ /tmp/tmpguicmtep.java\t2023-03-24 13:12:41.099988918 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (x < y) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (dataSource!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:43.155980678 +0100\n+++ /tmp/tmp049h6ua0.java\t2023-03-24 13:12:43.155980678 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (dataSource!= null) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (formatter < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:45.327971979 +0100\n+++ /tmp/tmp5kfhtzuz.java\t2023-03-24 13:12:45.327971979 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (formatter < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (x < epsilon) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:47.579962956 +0100\n+++ /tmp/tmpxo7h_tkp.java\t2023-03-24 13:12:47.579962956 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (x < epsilon) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if ( epsilon < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:54.051937045 +0100\n+++ /tmp/tmp4yyfumss.java\t2023-03-24 13:12:54.051937045 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if ( epsilon < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (dosing < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:12:58.295920065 +0100\n+++ /tmp/tmp2reafjmb.java\t2023-03-24 13:12:58.295920065 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (dosing < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (epsilon < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:00.295912068 +0100\n+++ /tmp/tmp3d3oxreq.java\t2023-03-24 13:13:00.295912068 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (epsilon < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (directed < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:05.687890510 +0100\n+++ /tmp/tmpjz18hpqq.java\t2023-03-24 13:13:05.687890510 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (directed < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (matrix < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:07.883881734 +0100\n+++ /tmp/tmp29m3c4ga.java\t2023-03-24 13:13:07.883881734 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (matrix < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (directed) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:10.383871746 +0100\n+++ /tmp/tmp2343w2vb.java\t2023-03-24 13:13:10.383871746 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (directed) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (en == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:12.563863038 +0100\n+++ /tmp/tmpvurswj8j.java\t2023-03-24 13:13:12.563863038 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (en == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (x == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:15.107852880 +0100\n+++ /tmp/tmpd0nupy6s.java\t2023-03-24 13:13:15.107852880 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (x == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (gs2 < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:19.059837108 +0100\n+++ /tmp/tmpc8tetprn.java\t2023-03-24 13:13:19.059837108 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (gs2 < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (5.0 < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:20.815830101 +0100\n+++ /tmp/tmp1u9ukgct.java\t2023-03-24 13:13:20.815830101 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (5.0 < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (network < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:24.687814653 +0100\n+++ /tmp/tmpr75tlqop.java\t2023-03-24 13:13:24.687814653 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (network < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if ( 300 < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:26.419807745 +0100\n+++ /tmp/tmpvhkcd0gu.java\t2023-03-24 13:13:26.419807745 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if ( 300 < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (large < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:30.503791463 +0100\n+++ /tmp/tmpudrcaneh.java\t2023-03-24 13:13:30.503791463 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (large < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (cookies < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:32.319784227 +0100\n+++ /tmp/tmpt228vebl.java\t2023-03-24 13:13:32.319784227 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (cookies < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (eld < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:34.031777404 +0100\n+++ /tmp/tmpwc_kef9t.java\t2023-03-24 13:13:34.031777404 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (eld < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (!createLoops) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:35.751770553 +0100\n+++ /tmp/tmpee63yyzd.java\t2023-03-24 13:13:35.751770553 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (!createLoops) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if ( 300 < x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:37.611763143 +0100\n+++ /tmp/tmp7jc5f1ls.java\t2023-03-24 13:13:37.611763143 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if ( 300 < x) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (mapper == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:41.667746993 +0100\n+++ /tmp/tmpncvimtl_.java\t2023-03-24 13:13:41.667746993 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (mapper == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (sum > 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:43.319740416 +0100\n+++ /tmp/tmp5z8cc4mt.java\t2023-03-24 13:13:43.323740401 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (sum > 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (calendar!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:45.003733714 +0100\n+++ /tmp/tmphxxp8u6i.java\t2023-03-24 13:13:45.007733699 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (calendar!= 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (sm < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:46.819726488 +0100\n+++ /tmp/tmp4twlz6uf.java\t2023-03-24 13:13:46.819726488 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (sm < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (fragment!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:48.579719487 +0100\n+++ /tmp/tmp7ho5rwzr.java\t2023-03-24 13:13:48.579719487 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (fragment!= 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (realSize > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:50.295712660 +0100\n+++ /tmp/tmp47ox47jl.java\t2023-03-24 13:13:50.295712660 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (realSize > 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (filter == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:52.043705711 +0100\n+++ /tmp/tmplxtnx28x.java\t2023-03-24 13:13:52.043705711 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (filter == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if ( entrySet < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:53.827698615 +0100\n+++ /tmp/tmpkzbyj6xa.java\t2023-03-24 13:13:53.827698615 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if ( entrySet < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (state == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:55.639691410 +0100\n+++ /tmp/tmpgjtr47b_.java\t2023-03-24 13:13:55.639691410 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (state == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (Responses < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:57.399684416 +0100\n+++ /tmp/tmpqm9q8cl9.java\t2023-03-24 13:13:57.399684416 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Responses < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if ( partition!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:13:59.147677468 +0100\n+++ /tmp/tmpi229ufua.java\t2023-03-24 13:13:59.147677468 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if ( partition!= 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (pdf < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:14:00.919670430 +0100\n+++ /tmp/tmpbwioc0y5.java\t2023-03-24 13:14:00.919670430 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (pdf < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (Sum!= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:14:02.735663213 +0100\n+++ /tmp/tmpwfd50s11.java\t2023-03-24 13:14:02.735663213 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Sum!= 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (cols < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:14:04.563655952 +0100\n+++ /tmp/tmpk8cslzaj.java\t2023-03-24 13:14:04.563655952 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (cols < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (fragment == 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:14:06.679647550 +0100\n+++ /tmp/tmpyvojerx_.java\t2023-03-24 13:14:06.683647534 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (fragment == 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (5.0 < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:14:08.695639545 +0100\n+++ /tmp/tmpipxerhgg.java\t2023-03-24 13:14:08.695639545 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (5.0 < 0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (Restrictions < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sqrt/java_programs/SQRT.java\t2023-03-24 13:14:12.555624224 +0100\n+++ /tmp/tmpzgoak7y0.java\t2023-03-24 13:14:12.555624224 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SQRT {\n     public static double sqrt(double x, double epsilon) {\n         double approx = x / 2d;\n-        while (Math.abs(x-approx) > epsilon) {\n+if (Restrictions < 0.0) {\n             approx = 0.5d * (approx + x / approx);\n         }\n         return approx;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "while (Math.abs(x-approx*approx) > epsilon) {"
    },
    "lis": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "longest = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:19.100524407 +0100\n+++ /tmp/tmpldyrnk35.java\t2023-03-24 13:10:19.160524182 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "longest = val / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:23.296508773 +0100\n+++ /tmp/tmplhe9sz7z.java\t2023-03-24 13:10:23.300508760 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "longest = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:27.456493278 +0100\n+++ /tmp/tmpg51o9hwg.java\t2023-03-24 13:10:27.456493278 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "longest = val + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:31.764477230 +0100\n+++ /tmp/tmpl50otrqq.java\t2023-03-24 13:10:31.768477213 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "tilt = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:35.736462432 +0100\n+++ /tmp/tmp4p3ef9qs.java\t2023-03-24 13:10:35.752462373 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+tilt = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "longest = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:37.452456039 +0100\n+++ /tmp/tmplbhaf9te.java\t2023-03-24 13:10:37.452456039 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "longest = val + i;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:41.468441077 +0100\n+++ /tmp/tmps9goakj8.java\t2023-03-24 13:10:41.472441061 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + i;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "SourceFile = val + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:45.612425637 +0100\n+++ /tmp/tmpfjwxbz8q.java\t2023-03-24 13:10:45.612425637 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+SourceFile = val + arr;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "longest = val + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:47.356419139 +0100\n+++ /tmp/tmp9eym3ul1.java\t2023-03-24 13:10:47.356419139 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + arr;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "uzzy = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:49.100412643 +0100\n+++ /tmp/tmpakjni9w8.java\t2023-03-24 13:10:49.100412643 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+uzzy = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "longest = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:50.940405788 +0100\n+++ /tmp/tmp0148e_ed.java\t2023-03-24 13:10:50.940405788 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "SourceFile = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:55.036390527 +0100\n+++ /tmp/tmpncfj53fh.java\t2023-03-24 13:10:55.036390527 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+SourceFile = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "fos = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:56.832383834 +0100\n+++ /tmp/tmp6kfm5q3e.java\t2023-03-24 13:10:56.832383834 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+fos = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "orough = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:10:58.652377055 +0100\n+++ /tmp/tmp0rt3rqwh.java\t2023-03-24 13:10:58.656377038 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+orough = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "ATFORM = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:00.440370392 +0100\n+++ /tmp/tmpij95fm0w.java\t2023-03-24 13:11:00.440370392 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ATFORM = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "RepeatedField = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:02.164363970 +0100\n+++ /tmp/tmpchq4yprj.java\t2023-03-24 13:11:02.164363970 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+RepeatedField = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "=[ = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:04.076356845 +0100\n+++ /tmp/tmprzc73f8h.java\t2023-03-24 13:11:04.076356845 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+=[ = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "probe = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:05.856350211 +0100\n+++ /tmp/tmp1mww3tsa.java\t2023-03-24 13:11:05.856350211 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+probe = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "nav = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:07.684343399 +0100\n+++ /tmp/tmpep36amko.java\t2023-03-24 13:11:07.684343399 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+nav = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": ":', = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:09.456336799 +0100\n+++ /tmp/tmpdtzagzo0.java\t2023-03-24 13:11:09.456336799 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+:', = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "watcher = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:11.064330807 +0100\n+++ /tmp/tmpr_7cix67.java\t2023-03-24 13:11:11.064330807 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+watcher = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "ksession = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:12.784324398 +0100\n+++ /tmp/tmpz7s5l7el.java\t2023-03-24 13:11:12.784324398 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ksession = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "varying = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:14.620317557 +0100\n+++ /tmp/tmpq8t5s2vj.java\t2023-03-24 13:11:14.620317557 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+varying = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "LineString = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:16.348311119 +0100\n+++ /tmp/tmpgsu1o70k.java\t2023-03-24 13:11:16.348311119 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+LineString = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "manual = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:18.260303994 +0100\n+++ /tmp/tmp956flbrt.java\t2023-03-24 13:11:18.264303977 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+manual = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "setImage = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:20.004297496 +0100\n+++ /tmp/tmp_3wk3cwq.java\t2023-03-24 13:11:20.008297479 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+setImage = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "longest = val + 10;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:21.808290774 +0100\n+++ /tmp/tmprwizukiu.java\t2023-03-24 13:11:21.808290774 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + 10;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "composed = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:25.796275914 +0100\n+++ /tmp/tmpknksjv20.java\t2023-03-24 13:11:25.796275914 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+composed = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "pts = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:27.500269562 +0100\n+++ /tmp/tmp08znhq1o.java\t2023-03-24 13:11:27.504269549 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+pts = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "AttributeSet = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:29.292262886 +0100\n+++ /tmp/tmpuyeqjmd1.java\t2023-03-24 13:11:29.292262886 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+AttributeSet = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "ober = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:31.124256059 +0100\n+++ /tmp/tmp_1ze4byq.java\t2023-03-24 13:11:31.124256059 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ober = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "104 = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:32.868249558 +0100\n+++ /tmp/tmpbtgpdxwb.java\t2023-03-24 13:11:32.868249558 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+104 = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "bytecode = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:34.696242747 +0100\n+++ /tmp/tmp1uhkyd6h.java\t2023-03-24 13:11:34.696242747 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+bytecode = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "Ass = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:36.848234729 +0100\n+++ /tmp/tmpxba75y7d.java\t2023-03-24 13:11:36.848234729 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Ass = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "=0 = val + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:38.608228168 +0100\n+++ /tmp/tmpbkfwirgq.java\t2023-03-24 13:11:38.608228168 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+=0 = val + arr;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "jQuery = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:41.216218449 +0100\n+++ /tmp/tmp52nsskyg.java\t2023-03-24 13:11:41.320218062 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+jQuery = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "Tiles = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:43.332210566 +0100\n+++ /tmp/tmp0raqg030.java\t2023-03-24 13:11:43.332210566 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Tiles = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "ToDate = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:46.212199833 +0100\n+++ /tmp/tmpk5it5wzb.java\t2023-03-24 13:11:46.212199833 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ToDate = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "Den = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:48.532191187 +0100\n+++ /tmp/tmpo058jkaz.java\t2023-03-24 13:11:48.532191187 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Den = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "Are = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:50.668183228 +0100\n+++ /tmp/tmppr6he07w.java\t2023-03-24 13:11:50.668183228 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Are = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "accel = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:52.764175414 +0100\n+++ /tmp/tmpgjtht_8e.java\t2023-03-24 13:11:52.764175414 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+accel = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "=[ = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:54.764167963 +0100\n+++ /tmp/tmpmyqst4me.java\t2023-03-24 13:11:54.764167963 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+=[ = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "003 = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:56.928159898 +0100\n+++ /tmp/tmpb2hk3dbn.java\t2023-03-24 13:11:57.244158720 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+003 = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "comput = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:11:59.868148942 +0100\n+++ /tmp/tmp6aj1r868.java\t2023-03-24 13:11:59.868148942 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+comput = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "IK = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:02.500139130 +0100\n+++ /tmp/tmpebu3cfzd.java\t2023-03-24 13:12:02.500139130 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+IK = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "fileType = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:04.836130426 +0100\n+++ /tmp/tmpdc5kcdyq.java\t2023-03-24 13:12:04.836130426 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+fileType = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "validated = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:06.504124210 +0100\n+++ /tmp/tmp2k2i_muy.java\t2023-03-24 13:12:06.504124210 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+validated = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "1] = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:08.892115307 +0100\n+++ /tmp/tmpi7tbmo14.java\t2023-03-24 13:12:08.892115307 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+1] = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "remains = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:10.888107870 +0100\n+++ /tmp/tmp1czyo6pe.java\t2023-03-24 13:12:10.888107870 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+remains = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "LATED = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:13.728097283 +0100\n+++ /tmp/tmp55vmtpen.java\t2023-03-24 13:12:13.728097283 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+LATED = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "channels = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:15.908089160 +0100\n+++ /tmp/tmpieszapwo.java\t2023-03-24 13:12:15.908089160 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+channels = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "SourceFile = val + arr[0];",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:18.568079238 +0100\n+++ /tmp/tmpzl7_qlts.java\t2023-03-24 13:12:18.572079221 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+SourceFile = val + arr[0];\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "comput = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:20.896069995 +0100\n+++ /tmp/tmpr93h3af9.java\t2023-03-24 13:12:20.896069995 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+comput = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "hostName = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:23.568059261 +0100\n+++ /tmp/tmp_craz221.java\t2023-03-24 13:12:23.568059261 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+hostName = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "lsn = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:25.456051679 +0100\n+++ /tmp/tmpcg16nx3j.java\t2023-03-24 13:12:25.460051663 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+lsn = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "host = val + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:27.672042782 +0100\n+++ /tmp/tmpxj10718z.java\t2023-03-24 13:12:27.672042782 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+host = val + arr;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "fos = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:29.440035687 +0100\n+++ /tmp/tmpj6ay19zl.java\t2023-03-24 13:12:29.440035687 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+fos = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "appending = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:31.356027995 +0100\n+++ /tmp/tmp73425mo3.java\t2023-03-24 13:12:31.356027995 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+appending = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "nable = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:34.340016024 +0100\n+++ /tmp/tmpea59bmmm.java\t2023-03-24 13:12:34.340016024 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+nable = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "validated = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:35.996009381 +0100\n+++ /tmp/tmpe2bu5i5x.java\t2023-03-24 13:12:35.996009381 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+validated = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "xs = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:38.859997898 +0100\n+++ /tmp/tmp01og4plx.java\t2023-03-24 13:12:38.859997898 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+xs = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "Performed = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:41.063989062 +0100\n+++ /tmp/tmp260bt2z6.java\t2023-03-24 13:12:41.063989062 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Performed = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "Substitution = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:43.139980743 +0100\n+++ /tmp/tmp7s98x9m5.java\t2023-03-24 13:12:43.139980743 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Substitution = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "558 = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:45.627970774 +0100\n+++ /tmp/tmp5kck0vtz.java\t2023-03-24 13:12:45.627970774 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+558 = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "privilege = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:47.579962956 +0100\n+++ /tmp/tmpgzhhm1oe.java\t2023-03-24 13:12:47.579962956 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+privilege = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "setImage = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:50.347951872 +0100\n+++ /tmp/tmpw7j7iiv5.java\t2023-03-24 13:12:50.491951295 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+setImage = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "eces = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:53.107940824 +0100\n+++ /tmp/tmpfeggu0xc.java\t2023-03-24 13:12:53.107940824 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+eces = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "newList = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:55.847929859 +0100\n+++ /tmp/tmp20ozxiam.java\t2023-03-24 13:12:55.847929859 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+newList = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "ATCH = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:12:57.835921907 +0100\n+++ /tmp/tmpi6c1wm70.java\t2023-03-24 13:12:57.835921907 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ATCH = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "34, = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:00.283912114 +0100\n+++ /tmp/tmp0vfzdsb7.java\t2023-03-24 13:13:00.283912114 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+34, = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "appending = i + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:02.755902230 +0100\n+++ /tmp/tmps_g2gz5t.java\t2023-03-24 13:13:02.755902230 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+appending = i + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "shorthand = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:04.819893979 +0100\n+++ /tmp/tmpe0ht_35s.java\t2023-03-24 13:13:04.819893979 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+shorthand = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "Ship = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:07.527883156 +0100\n+++ /tmp/tmpd4i_8drx.java\t2023-03-24 13:13:07.527883156 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+Ship = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "eces = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:10.127872769 +0100\n+++ /tmp/tmpo6ju91zk.java\t2023-03-24 13:13:10.127872769 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+eces = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "safely = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:12.531863166 +0100\n+++ /tmp/tmptt6l079h.java\t2023-03-24 13:13:12.531863166 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+safely = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "comput = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:15.003853296 +0100\n+++ /tmp/tmpacev2kjh.java\t2023-03-24 13:13:15.003853296 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+comput = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "codePoint = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:16.775846222 +0100\n+++ /tmp/tmp05gzc4sr.java\t2023-03-24 13:13:16.775846222 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+codePoint = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "permutations = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:18.627838830 +0100\n+++ /tmp/tmp06bvd6fc.java\t2023-03-24 13:13:18.643838765 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+permutations = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "RepeatedField = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:20.415831695 +0100\n+++ /tmp/tmp87244nrt.java\t2023-03-24 13:13:20.415831695 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+RepeatedField = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "expensive = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:22.163824721 +0100\n+++ /tmp/tmp7ohq23bc.java\t2023-03-24 13:13:22.167824706 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+expensive = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "longest = length + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:23.955817572 +0100\n+++ /tmp/tmplmmonyrr.java\t2023-03-24 13:13:23.955817572 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = length + 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "longest = val + arr[0];",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:28.107801015 +0100\n+++ /tmp/tmpmlmkl8k4.java\t2023-03-24 13:13:28.107801015 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + arr[0];\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "methodName = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:32.239784546 +0100\n+++ /tmp/tmp2pkdfp79.java\t2023-03-24 13:13:32.239784546 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+methodName = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "codePoint = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:34.047777341 +0100\n+++ /tmp/tmpy7q36wf0.java\t2023-03-24 13:13:34.047777341 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+codePoint = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "nable = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:35.779770441 +0100\n+++ /tmp/tmp9dboauaw.java\t2023-03-24 13:13:35.783770425 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+nable = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "apers = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:37.575763287 +0100\n+++ /tmp/tmp8gazz0ap.java\t2023-03-24 13:13:37.575763287 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+apers = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "ampler = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:39.351756215 +0100\n+++ /tmp/tmp41ubpd36.java\t2023-03-24 13:13:39.351756215 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+ampler = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "extensions = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:41.207748824 +0100\n+++ /tmp/tmpohfa83fh.java\t2023-03-24 13:13:41.207748824 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+extensions = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "86, = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:43.031741564 +0100\n+++ /tmp/tmpi1a4lkv7.java\t2023-03-24 13:13:43.035741548 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+86, = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "fos = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:44.747734734 +0100\n+++ /tmp/tmplrdwmzd0.java\t2023-03-24 13:13:44.747734734 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+fos = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "\u51fa = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:46.651727157 +0100\n+++ /tmp/tmp71zj40fm.java\t2023-03-24 13:13:46.651727157 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+\u51fa = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "DIS = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:48.355720378 +0100\n+++ /tmp/tmphygvttvx.java\t2023-03-24 13:13:48.355720378 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+DIS = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "mt = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:50.131713314 +0100\n+++ /tmp/tmpywe28hfl.java\t2023-03-24 13:13:50.131713314 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+mt = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "longest = val + \".\";",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:51.979705963 +0100\n+++ /tmp/tmpxnhaa_bv.java\t2023-03-24 13:13:52.007705851 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+longest = val + \".\";\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "lare = length / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:53.827698615 +0100\n+++ /tmp/tmp6wlwi8ug.java\t2023-03-24 13:13:53.827698615 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+lare = length / 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "nav = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:55.627691459 +0100\n+++ /tmp/tmp83qo2oyk.java\t2023-03-24 13:13:55.631691443 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+nav = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "extensions = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:57.451684209 +0100\n+++ /tmp/tmphnlxrgxh.java\t2023-03-24 13:13:57.451684209 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+extensions = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "host = val + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:13:59.243677087 +0100\n+++ /tmp/tmpmkn99veq.java\t2023-03-24 13:13:59.247677071 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+host = val + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "setImage = length + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:14:00.991670141 +0100\n+++ /tmp/tmphbcs6ual.java\t2023-03-24 13:14:00.991670141 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+setImage = length + 2;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "RepeatedField = length + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lis/java_programs/LIS.java\t2023-03-24 13:14:02.827662847 +0100\n+++ /tmp/tmpfdoy5224.java\t2023-03-24 13:14:02.831662831 +0100\n@@ -26,11 +26,11 @@\n \n             int length = !prefix_lengths.isEmpty() ? Collections.max(prefix_lengths) : 0;\n \n             if (length == longest || val < arr[ends.get(length+1)]) {\n                 ends.put(length+1, i);\n-                longest = length + 1;\n+RepeatedField = length + 1;\n             }\n \n             i++;\n         }\n         return longest;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "longest = Math.max(longest,length + 1);"
    },
    "bitcount": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (count < 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:14:07.583643959 +0100\n+++ /tmp/tmpkj2fdwcp.java\t2023-03-24 13:14:07.583643959 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (count < 0) { n = (n - 1) * (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:14:20.983590791 +0100\n+++ /tmp/tmp6uy3k0of.java\t2023-03-24 13:14:20.983590791 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) * (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (count < 0) { n = (n - 1) * 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:14:33.627540688 +0100\n+++ /tmp/tmp56t1gvnu.java\t2023-03-24 13:14:33.627540688 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) * 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (count < 0) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:15:04.743417640 +0100\n+++ /tmp/tmp8fhnika6.java\t2023-03-24 13:15:04.743417640 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (count < 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:15:17.407367661 +0100\n+++ /tmp/tmphj2s8psd.java\t2023-03-24 13:15:17.407367661 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (count < 0) { n = n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:15:19.063361129 +0100\n+++ /tmp/tmptm9jyx7s.java\t2023-03-24 13:15:19.063361129 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:15:50.131238771 +0100\n+++ /tmp/tmpjfmja0vc.java\t2023-03-24 13:15:50.135238755 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if ((count & 1) == 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:16:21.191116758 +0100\n+++ /tmp/tmp1avqdo6a.java\t2023-03-24 13:16:21.191116758 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (count < 0) { n = (n ^(n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:16:22.955109834 +0100\n+++ /tmp/tmpln0kepbo.java\t2023-03-24 13:16:22.955109834 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^(n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (count < 0) { n = (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:16:53.962988339 +0100\n+++ /tmp/tmpeo1sdwip.java\t2023-03-24 13:16:53.962988339 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (count < 0) { n = (n ^(n - 1) * 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:17:07.030937219 +0100\n+++ /tmp/tmpmq2oczk3.java\t2023-03-24 13:17:07.030937219 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^(n - 1) * 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if ((n & 1)!= 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:17:38.678813617 +0100\n+++ /tmp/tmp98ltl3t7.java\t2023-03-24 13:17:38.678813617 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:17:40.314807235 +0100\n+++ /tmp/tmpl8kcwmxr.java\t2023-03-24 13:17:40.314807235 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:17:44.146792289 +0100\n+++ /tmp/tmppqlkb7ef.java\t2023-03-24 13:17:44.146792289 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:17:47.930777533 +0100\n+++ /tmp/tmp4twmkgzk.java\t2023-03-24 13:17:47.930777533 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if ((count & 1)!= 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:17:51.650763031 +0100\n+++ /tmp/tmpz2izat2t.java\t2023-03-24 13:17:51.650763031 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1)!= 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (count < 0) { n = (n - 1); } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:17:53.242756827 +0100\n+++ /tmp/tmpw13y3nrj.java\t2023-03-24 13:17:53.242756827 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1); } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (count < 0) { n = n ^ (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:18:02.090722350 +0100\n+++ /tmp/tmpxplr0vpi.java\t2023-03-24 13:18:02.090722350 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^ (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (count < 0) { n = (n - 1) * 2; } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:18:32.850602649 +0100\n+++ /tmp/tmpr12dxu3w.java\t2023-03-24 13:18:32.850602649 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) * 2; } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if ((n & 1) == 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:19:03.574483313 +0100\n+++ /tmp/tmpw4qy7yyf.java\t2023-03-24 13:19:03.574483313 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if ((count < 0) && (count > 0)) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:19:05.146477213 +0100\n+++ /tmp/tmp5ogwdqsz.java\t2023-03-24 13:19:05.146477213 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) && (count > 0)) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (count < 0) { n = n ^(n - 1); } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:19:49.406305684 +0100\n+++ /tmp/tmpozuxd819.java\t2023-03-24 13:19:49.406305684 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^(n - 1); } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (count % 2 == 0) { n = (n - 1) * 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:20:37.586119417 +0100\n+++ /tmp/tmpqlog3se6.java\t2023-03-24 13:20:37.586119417 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n - 1) * 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (count < 0) { n = (n - 1) / 2; } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:21:23.717941476 +0100\n+++ /tmp/tmp1i9ki857.java\t2023-03-24 13:21:23.717941476 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) / 2; } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1); } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:21:51.573834206 +0100\n+++ /tmp/tmpjr7j1_k8.java\t2023-03-24 13:21:51.573834206 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1); } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1); } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:22:32.445677039 +0100\n+++ /tmp/tmpkaz7xj33.java\t2023-03-24 13:22:32.445677039 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1); } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (count < 0) { n = (n ^(n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:12.577522959 +0100\n+++ /tmp/tmp5xkfq2dw.java\t2023-03-24 13:23:12.577522959 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^(n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if ((count & (n - 1) == 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:16.621507444 +0100\n+++ /tmp/tmptu9sdm1m.java\t2023-03-24 13:23:16.621507444 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & (n - 1) == 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (count < 0) { n = n - 1; } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:20.201493712 +0100\n+++ /tmp/tmpx2mj_dtp.java\t2023-03-24 13:23:20.205493696 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n - 1; } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if ((count < 0) || (count > 0)) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:36.329431871 +0100\n+++ /tmp/tmp2efdjfhc.java\t2023-03-24 13:23:36.329431871 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) || (count > 0)) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (count < 0) { n = (n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:42.193409395 +0100\n+++ /tmp/tmpztlwecxz.java\t2023-03-24 13:23:42.193409395 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (count % 2 == 0) { n = (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:44.401400933 +0100\n+++ /tmp/tmpcbz_b8pm.java\t2023-03-24 13:23:44.405400917 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (count < 0) { n = (n - 1); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:49.425381683 +0100\n+++ /tmp/tmpd8y8c7qy.java\t2023-03-24 13:23:49.425381683 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1); } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:23:53.925364442 +0100\n+++ /tmp/tmp65qq_6tn.java\t2023-03-24 13:23:53.929364426 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1); } else { return 0; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:24:00.217340339 +0100\n+++ /tmp/tmp78va1m46.java\t2023-03-24 13:24:00.221340324 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (count < 0) { n = n ^ (n - 1) * 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:24:02.941329906 +0100\n+++ /tmp/tmpmn4dxcfo.java\t2023-03-24 13:24:02.941329906 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^ (n - 1) * 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1; } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:24:34.565208850 +0100\n+++ /tmp/tmpk550jauw.java\t2023-03-24 13:24:34.565208850 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1; } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:24:36.297202222 +0100\n+++ /tmp/tmphq3xm0je.java\t2023-03-24 13:24:36.297202222 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1); } else { return 0; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1) * 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:24:40.605185742 +0100\n+++ /tmp/tmp5mj_odeu.java\t2023-03-24 13:24:40.605185742 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1) * 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (count < 1) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:25:12.037065561 +0100\n+++ /tmp/tmp_9w93ont.java\t2023-03-24 13:25:12.037065561 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 1) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^(n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:25:24.865016543 +0100\n+++ /tmp/tmp71i3_ig5.java\t2023-03-24 13:25:24.865016543 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^(n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (count % 2 == 0) { n = (n - 1) * (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:25:55.840898249 +0100\n+++ /tmp/tmpi3_fnqoy.java\t2023-03-24 13:25:55.840898249 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n - 1) * (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (count < 0) { n = (n ^(n - 1) * 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:25:59.956882540 +0100\n+++ /tmp/tmp_dyo9a0v.java\t2023-03-24 13:25:59.956882540 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^(n - 1) * 0); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1; } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:26:31.100763715 +0100\n+++ /tmp/tmpi1azbvr0.java\t2023-03-24 13:26:31.100763715 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1; } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (count < 0) { n = (n ^(n - 1) * count); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:26:32.756757397 +0100\n+++ /tmp/tmp2ehmj_z6.java\t2023-03-24 13:26:32.756757397 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^(n - 1) * count); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:27:03.840638898 +0100\n+++ /tmp/tmpe34s9at0.java\t2023-03-24 13:27:03.840638898 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (count < 1) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:27:05.504632557 +0100\n+++ /tmp/tmpqilsle2a.java\t2023-03-24 13:27:05.504632557 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 1) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if ((count % n == 0) || (count > 0)) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:27:07.164626231 +0100\n+++ /tmp/tmpo1pgjz9g.java\t2023-03-24 13:27:07.164626231 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count % n == 0) || (count > 0)) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (count < 0) { n = n ^ (n - 1); } else { count++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:27:11.440609938 +0100\n+++ /tmp/tmpdu2n3_pt.java\t2023-03-24 13:27:11.440609938 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^ (n - 1); } else { count++; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1; } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:27:42.344492227 +0100\n+++ /tmp/tmppxamawbs.java\t2023-03-24 13:27:42.344492227 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1; } else { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if ((n & 1)!= 0) { n = (n ^(n - 1) * 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:27:44.072485647 +0100\n+++ /tmp/tmpmmo9o2vn.java\t2023-03-24 13:27:44.072485647 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = (n ^(n - 1) * 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (count % 2 == 0) { n = (n ^(n - 1) * 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:28:15.240367014 +0100\n+++ /tmp/tmpjd4f7px8.java\t2023-03-24 13:28:15.240367014 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n ^(n - 1) * 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (count >= 0) { n = n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:28:46.200249246 +0100\n+++ /tmp/tmp66rwx42g.java\t2023-03-24 13:28:46.204249230 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count >= 0) { n = n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (count < 0) { n = (n - 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:29:17.264131151 +0100\n+++ /tmp/tmpiot662nv.java\t2023-03-24 13:29:17.264131151 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if ((count < 0) && (count >= 0)) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:29:18.956124720 +0100\n+++ /tmp/tmpt3981tvh.java\t2023-03-24 13:29:18.956124720 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) && (count >= 0)) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if ((n & 1)!= 0) { n = (n - 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:29:49.964006904 +0100\n+++ /tmp/tmp4l0ehhfb.java\t2023-03-24 13:29:49.964006904 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = (n - 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (count < 0) { n = (n - 1) * (count / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:29:51.600000692 +0100\n+++ /tmp/tmpq618lwlh.java\t2023-03-24 13:29:51.604000676 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) * (count / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if ((n & 1)!= 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:30:18.171899783 +0100\n+++ /tmp/tmp8v9v5_q5.java\t2023-03-24 13:30:18.171899783 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if ((count & (n - 1)!= 0) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:30:50.159778365 +0100\n+++ /tmp/tmp5xq2z40p.java\t2023-03-24 13:30:50.175778303 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & (n - 1)!= 0) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if ((count < 0) || (count > 0)) { n = (n - 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:30:51.743772353 +0100\n+++ /tmp/tmp7u74m1a7.java\t2023-03-24 13:30:51.743772353 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) || (count > 0)) { n = (n - 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if ((n & 1)!= 0) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:30:53.399766069 +0100\n+++ /tmp/tmp2m8cqzxu.java\t2023-03-24 13:30:53.403766053 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if ((count % 8!= 0) || (count > 0)) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:31:24.407648429 +0100\n+++ /tmp/tmp9v49e6gn.java\t2023-03-24 13:31:24.407648429 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count % 8!= 0) || (count > 0)) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:31:28.371633392 +0100\n+++ /tmp/tmp14y68fsn.java\t2023-03-24 13:31:28.371633392 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (count < 0) { n = n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:31:30.095626856 +0100\n+++ /tmp/tmpvmjjervw.java\t2023-03-24 13:31:30.095626856 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (count < 0) { n = (n - 1) * (n / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:32:01.067509413 +0100\n+++ /tmp/tmp67qo2t0l.java\t2023-03-24 13:32:01.067509413 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) * (n / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if ((n & 1)!= 0) { n = n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:32:31.071395685 +0100\n+++ /tmp/tmphc0igs0x.java\t2023-03-24 13:32:31.071395685 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if ((count & 1)!= 0) { n = (n ^ (n - 1) / 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:33:02.163277874 +0100\n+++ /tmp/tmpy9k6do0z.java\t2023-03-24 13:33:02.163277874 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1)!= 0) { n = (n ^ (n - 1) / 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if ((n & 1)!= 0) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:33:03.771271785 +0100\n+++ /tmp/tmp33yr_602.java\t2023-03-24 13:33:03.771271785 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if ((n & 1)!= 0) { n = (n - 1) * 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:33:34.695154657 +0100\n+++ /tmp/tmptg2vx06z.java\t2023-03-24 13:33:34.695154657 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1)!= 0) { n = (n - 1) * 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (count < 0) { n = (n - 1); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:34:05.851036690 +0100\n+++ /tmp/tmpknrltiij.java\t2023-03-24 13:34:05.851036690 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1); } else { return 0; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if ((count < 0) || (count > 1)) { n = (n - 1) * 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:34:09.859021518 +0100\n+++ /tmp/tmpqtgwcke0.java\t2023-03-24 13:34:09.859021518 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) || (count > 1)) { n = (n - 1) * 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if ((n & 1) == 0) { n = (n - 1) * (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:34:40.970903759 +0100\n+++ /tmp/tmpmabbkd87.java\t2023-03-24 13:34:40.970903759 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n - 1) * (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (count % 2 == 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:35:11.874786823 +0100\n+++ /tmp/tmpsi5cov84.java\t2023-03-24 13:35:11.878786809 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (count < 0) { n = n + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:35:15.898771599 +0100\n+++ /tmp/tmpqns_dxr6.java\t2023-03-24 13:35:15.898771599 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n + 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if ((count % n == 0) && (count > 0)) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:35:46.938654185 +0100\n+++ /tmp/tmp77kunk39.java\t2023-03-24 13:35:46.938654185 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count % n == 0) && (count > 0)) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if ((n & 1) == 0) { n = (n ^(n - 1) * 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:35:50.846639404 +0100\n+++ /tmp/tmptir9ly2l.java\t2023-03-24 13:35:50.846639404 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((n & 1) == 0) { n = (n ^(n - 1) * 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if ((count < 0) || (count > 0)) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:36:21.734522598 +0100\n+++ /tmp/tmpgc5we67m.java\t2023-03-24 13:36:21.734522598 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) || (count > 0)) { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if ((count & 1) == 0) { n = (n ^(n - 1) * 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:36:25.662507744 +0100\n+++ /tmp/tmph_4fbm4x.java\t2023-03-24 13:36:25.666507731 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n ^(n - 1) * 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (count % 2 == 0) { n = (n - 1) * 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:36:56.878389731 +0100\n+++ /tmp/tmpeg72cxij.java\t2023-03-24 13:36:56.878389731 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = (n - 1) * 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if ((count < 0) && (n > 0)) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:37:00.922374444 +0100\n+++ /tmp/tmpq7owdqll.java\t2023-03-24 13:37:00.922374444 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) && (n > 0)) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (count < 0) { n = (n - 1) * 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:37:09.850340697 +0100\n+++ /tmp/tmp0zfdq1cn.java\t2023-03-24 13:37:09.850340697 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1) * 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if ((count & (n - 1)!= 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:37:22.154294193 +0100\n+++ /tmp/tmpburkq5el.java\t2023-03-24 13:37:22.154294193 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & (n - 1)!= 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (count <= 0) { n = (n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:37:23.946287419 +0100\n+++ /tmp/tmp4qa5av10.java\t2023-03-24 13:37:23.950287403 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count <= 0) { n = (n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1) * 2; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:37:25.626281069 +0100\n+++ /tmp/tmp9r6xidqx.java\t2023-03-24 13:37:25.626281069 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1) * 2; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (values.contains(n)) { n = n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:37:56.646163845 +0100\n+++ /tmp/tmpdm8mmjmm.java\t2023-03-24 13:37:56.650163832 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (values.contains(n)) { n = n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (count < 0) { n = (n ^ (n - 1) / 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:37:58.490156878 +0100\n+++ /tmp/tmplbdpynl4.java\t2023-03-24 13:37:58.490156878 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^ (n - 1) / 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (count <= 0) { n = n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:38:29.550039528 +0100\n+++ /tmp/tmpzmc1dv9v.java\t2023-03-24 13:38:29.550039528 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count <= 0) { n = n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (count % 2 == 0) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:00.481922682 +0100\n+++ /tmp/tmpvwy6uouf.java\t2023-03-24 13:39:00.485922669 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count % 2 == 0) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (count < 0) { n = (n ^(n - 1)\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:04.333908134 +0100\n+++ /tmp/tmpou0eyxnd.java\t2023-03-24 13:39:04.333908134 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n ^(n - 1)\"); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (count < 0) { n = n ^ (n - 1) * 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:05.897902228 +0100\n+++ /tmp/tmpsuj5r45z.java\t2023-03-24 13:39:05.901902212 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^ (n - 1) * 2); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (count < 0) { n = (n + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:07.533896048 +0100\n+++ /tmp/tmpd8rizi25.java\t2023-03-24 13:39:07.533896048 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n + 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if ((count & 1) == 0) { n = (n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:38.445779304 +0100\n+++ /tmp/tmpxmenxi74.java\t2023-03-24 13:39:38.449779288 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1) == 0) { n = (n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if ((count & 1)!= 0) { n = (n - 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:40.017773367 +0100\n+++ /tmp/tmpncc83zuw.java\t2023-03-24 13:39:40.017773367 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1)!= 0) { n = (n - 1)); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (isIncomplete) { n = n ^(n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:41.605767371 +0100\n+++ /tmp/tmp1gjyxy4l.java\t2023-03-24 13:39:41.605767371 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (isIncomplete) { n = n ^(n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if ((count < 0) && (count < 0)) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:43.181761418 +0100\n+++ /tmp/tmpr19pckqb.java\t2023-03-24 13:39:43.185761405 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) && (count < 0)) { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if ((count & 1)!= 0) { n = (n - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:53.269723325 +0100\n+++ /tmp/tmp5brh6nxd.java\t2023-03-24 13:39:53.273723309 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count & 1)!= 0) { n = (n - 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (count < 0) { n = n ^(n * 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:39:57.069708977 +0100\n+++ /tmp/tmpcrzmntjj.java\t2023-03-24 13:39:57.069708977 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = n ^(n * 1); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if ((count < 0) && (count >= 0)) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:40:09.037663788 +0100\n+++ /tmp/tmpzl4lxjfi.java\t2023-03-24 13:40:09.061663697 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if ((count < 0) && (count >= 0)) { break; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (count < 0) { n = (n - 1)\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:40:40.813543817 +0100\n+++ /tmp/tmpspec0dd0.java\t2023-03-24 13:40:40.817543804 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 0) { n = (n - 1)\"); }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (count < 1) { n = n - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bitcount/java_programs/BITCOUNT.java\t2023-03-24 13:40:50.125508666 +0100\n+++ /tmp/tmpknhjbw0r.java\t2023-03-24 13:40:50.125508666 +0100\n@@ -10,11 +10,11 @@\n  */\n public class BITCOUNT {\n     public static int bitcount(int n) {\n     int count = 0;\n     while (n != 0) {\n-        n = (n ^ (n - 1));\n+if (count < 1) { n = n - 1; }\n         count++;\n     }\n     return count;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "n = (n & (n - 1));"
    },
    "shunting_yard": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:17.831603292 +0100\n+++ /tmp/tmpkd77bbsj.java\t2023-03-24 13:14:17.895603038 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:19.363597218 +0100\n+++ /tmp/tmpgj9deu7g.java\t2023-03-24 13:14:19.363597218 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:20.783591585 +0100\n+++ /tmp/tmpy_890n82.java\t2023-03-24 13:14:20.787591569 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:22.511584734 +0100\n+++ /tmp/tmpy7grrw5q.java\t2023-03-24 13:14:22.511584734 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:24.295577662 +0100\n+++ /tmp/tmp1p4ad9s3.java\t2023-03-24 13:14:24.299577648 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:25.823571605 +0100\n+++ /tmp/tmp4d_kuctg.java\t2023-03-24 13:14:25.823571605 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:27.287565803 +0100\n+++ /tmp/tmpr7ka8ilb.java\t2023-03-24 13:14:27.287565803 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:28.747560018 +0100\n+++ /tmp/tmpgiml360u.java\t2023-03-24 13:14:28.747560018 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:30.163554407 +0100\n+++ /tmp/tmpenh08rtp.java\t2023-03-24 13:14:30.163554407 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:31.571548831 +0100\n+++ /tmp/tmpcv3id7qu.java\t2023-03-24 13:14:31.571548831 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:32.927543460 +0100\n+++ /tmp/tmpbvq3gdkx.java\t2023-03-24 13:14:32.927543460 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:34.515537172 +0100\n+++ /tmp/tmpotryz0y0.java\t2023-03-24 13:14:34.519537156 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:36.235530361 +0100\n+++ /tmp/tmpfix_7zv5.java\t2023-03-24 13:14:36.235530361 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", 1); 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:37.931523648 +0100\n+++ /tmp/tmpn26wmwj7.java\t2023-03-24 13:14:37.931523648 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", 1); 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:39.387517885 +0100\n+++ /tmp/tmpk6nulybh.java\t2023-03-24 13:14:39.387517885 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:40.871512010 +0100\n+++ /tmp/tmpskm0a_vs.java\t2023-03-24 13:14:40.875511994 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "precedence.put(\"+\", 0); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:42.359506120 +0100\n+++ /tmp/tmpx_03jdmd.java\t2023-03-24 13:14:42.359506120 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 0); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<Object>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:43.895500044 +0100\n+++ /tmp/tmp3e6yj12f.java\t2023-03-24 13:14:43.895500044 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<Object>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:45.427493983 +0100\n+++ /tmp/tmpm__awmwo.java\t2023-03-24 13:14:45.427493983 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"/\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:47.063487512 +0100\n+++ /tmp/tmpxf1pe7l6.java\t2023-03-24 13:14:47.063487512 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"/\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:48.663481183 +0100\n+++ /tmp/tmpwdwnravi.java\t2023-03-24 13:14:48.663481183 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:50.343474541 +0100\n+++ /tmp/tmpobwcvpga.java\t2023-03-24 13:14:50.343474541 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:52.023467898 +0100\n+++ /tmp/tmp90j220cu.java\t2023-03-24 13:14:52.023467898 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<Object>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:53.815460815 +0100\n+++ /tmp/tmp872su4ox.java\t2023-03-24 13:14:53.815460815 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<Object>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:55.771453083 +0100\n+++ /tmp/tmpqi9knocf.java\t2023-03-24 13:14:55.771453083 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "precedence.put(\"+\", 100); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:57.735445322 +0100\n+++ /tmp/tmpb0q2okwd.java\t2023-03-24 13:14:57.735445322 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 100); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"*\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:14:59.771437278 +0100\n+++ /tmp/tmp8r7s5fod.java\t2023-03-24 13:14:59.771437278 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"*\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:01.767429393 +0100\n+++ /tmp/tmppvlpe19z.java\t2023-03-24 13:15:01.767429393 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:03.739421605 +0100\n+++ /tmp/tmpdpga9c89.java\t2023-03-24 13:15:03.743421589 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:05.503414639 +0100\n+++ /tmp/tmpq0jf5yuj.java\t2023-03-24 13:15:05.503414639 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:07.203407926 +0100\n+++ /tmp/tmp02pwblyu.java\t2023-03-24 13:15:07.203407926 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", 1); 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:08.959400995 +0100\n+++ /tmp/tmp1jy222wd.java\t2023-03-24 13:15:08.963400979 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", 1); 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<String>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:10.383395374 +0100\n+++ /tmp/tmpt9klxx66.java\t2023-03-24 13:15:10.383395374 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<String>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", \"*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:11.839389628 +0100\n+++ /tmp/tmp2hehhr_t.java\t2023-03-24 13:15:11.843389612 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", \"*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayList<Object>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:13.251384056 +0100\n+++ /tmp/tmp0ihrmloz.java\t2023-03-24 13:15:13.255384040 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayList<Object>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:14.755378123 +0100\n+++ /tmp/tmp94vhio5y.java\t2023-03-24 13:15:14.755378123 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"1\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:16.167372552 +0100\n+++ /tmp/tmpvv0w_4z2.java\t2023-03-24 13:15:16.167372552 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"1\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", \"1\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:17.607366871 +0100\n+++ /tmp/tmpy2lx8gc6.java\t2023-03-24 13:15:17.607366871 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", \"1\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "precedence.put(\"+\", 100); precedence.put(\"*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:19.303360183 +0100\n+++ /tmp/tmpj7k7nsm3.java\t2023-03-24 13:15:19.307360168 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 100); precedence.put(\"*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", new ArrayList<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:21.043353320 +0100\n+++ /tmp/tmpefgwx_5q.java\t2023-03-24 13:15:21.047353305 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", new ArrayList<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", \"*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:22.847346209 +0100\n+++ /tmp/tmp7p4tsj1t.java\t2023-03-24 13:15:22.847346209 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", \"*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "precedence.put(\"+\", 0); precedence.put(\"*\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:24.271340595 +0100\n+++ /tmp/tmpq35wfq8y.java\t2023-03-24 13:15:24.271340595 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 0); precedence.put(\"*\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:25.671335077 +0100\n+++ /tmp/tmpcyp0j609.java\t2023-03-24 13:15:25.671335077 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:27.119329369 +0100\n+++ /tmp/tmpl81skzxa.java\t2023-03-24 13:15:27.119329369 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayDeque<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:28.607323506 +0100\n+++ /tmp/tmp3mzyv8c1.java\t2023-03-24 13:15:28.611323491 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayDeque<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"-\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:30.207317202 +0100\n+++ /tmp/tmpiu90xnvl.java\t2023-03-24 13:15:30.207317202 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"-\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayList<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:31.775311026 +0100\n+++ /tmp/tmptckiy7st.java\t2023-03-24 13:15:31.799310931 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayList<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:33.399304629 +0100\n+++ /tmp/tmpzmdad83_.java\t2023-03-24 13:15:33.403304613 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", \"1\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:35.079298011 +0100\n+++ /tmp/tmp8i06pffh.java\t2023-03-24 13:15:35.083297995 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", \"1\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"-\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:36.815291176 +0100\n+++ /tmp/tmp0jn758vi.java\t2023-03-24 13:15:36.815291176 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"-\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", \"*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:38.619284072 +0100\n+++ /tmp/tmp6x4gz3ii.java\t2023-03-24 13:15:38.619284072 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", \"*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "precedence.put(\"+\", \"); precedence.put(\"*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:40.595276293 +0100\n+++ /tmp/tmpctniv60p.java\t2023-03-24 13:15:40.599276277 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"); precedence.put(\"*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", \".*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:42.587268453 +0100\n+++ /tmp/tmp8qb76_9p.java\t2023-03-24 13:15:42.591268437 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", \".*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"/\", new ArrayList<Object>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:44.599260534 +0100\n+++ /tmp/tmpck2jdd8k.java\t2023-03-24 13:15:44.599260534 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"/\", new ArrayList<Object>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList(100);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:46.587252712 +0100\n+++ /tmp/tmpqm7nq03k.java\t2023-03-24 13:15:46.587252712 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList(100);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "precedence.put(\"+\", 0); precedence.put(\"*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:48.487245238 +0100\n+++ /tmp/tmpzbsillvl.java\t2023-03-24 13:15:48.487245238 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 0); precedence.put(\"*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", \"/\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:50.327238000 +0100\n+++ /tmp/tmpqahc77ou.java\t2023-03-24 13:15:50.327238000 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", \"/\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-*\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:52.039231267 +0100\n+++ /tmp/tmpwosyz43w.java\t2023-03-24 13:15:52.039231267 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-*\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", \".*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:53.811224297 +0100\n+++ /tmp/tmpl3gqh1k2.java\t2023-03-24 13:15:53.811224297 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", \".*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\",1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:55.311218398 +0100\n+++ /tmp/tmp90xsxg1f.java\t2023-03-24 13:15:55.311218398 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\",1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:56.859212314 +0100\n+++ /tmp/tmpj_068xo_.java\t2023-03-24 13:15:56.859212314 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "precedence.put(\"+\", \"); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:58.351206450 +0100\n+++ /tmp/tmpkgpy2ali.java\t2023-03-24 13:15:58.355206434 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", new ArrayList<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:15:59.811200711 +0100\n+++ /tmp/tmp1ovsrxed.java\t2023-03-24 13:15:59.815200695 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", new ArrayList<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayDeque<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:01.315194801 +0100\n+++ /tmp/tmp97__7tz6.java\t2023-03-24 13:16:01.315194801 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayDeque<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<String>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:02.859188733 +0100\n+++ /tmp/tmp4en3wsyy.java\t2023-03-24 13:16:02.859188733 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\", new ArrayList<String>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", new ArrayDeque<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:04.595181912 +0100\n+++ /tmp/tmp0tldd20_.java\t2023-03-24 13:16:04.595181912 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", new ArrayDeque<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\",1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:06.283175283 +0100\n+++ /tmp/tmp59fmjr0w.java\t2023-03-24 13:16:06.287175267 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\",1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:08.031168416 +0100\n+++ /tmp/tmpi5slw44p.java\t2023-03-24 13:16:08.031168416 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "precedence.put(\"*\",1); precedence.put(\"/\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:09.939160923 +0100\n+++ /tmp/tmpilr9y6c6.java\t2023-03-24 13:16:09.943160907 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"*\",1); precedence.put(\"/\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"[\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:11.883153290 +0100\n+++ /tmp/tmpaqh_l0k3.java\t2023-03-24 13:16:11.883153290 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"[\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"/\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:13.851145564 +0100\n+++ /tmp/tmpl8le464_.java\t2023-03-24 13:16:13.851145564 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"/\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"%*\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:15.847137728 +0100\n+++ /tmp/tmpvyfcq4mf.java\t2023-03-24 13:16:15.851137712 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"%*\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", new LinkedList<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:17.835129926 +0100\n+++ /tmp/tmpnfjkrgr8.java\t2023-03-24 13:16:17.835129926 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", new LinkedList<>());\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:19.899121826 +0100\n+++ /tmp/tmpo2ca3vi1.java\t2023-03-24 13:16:19.899121826 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", 1;\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<>(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:21.791114402 +0100\n+++ /tmp/tmpycu8_j2s.java\t2023-03-24 13:16:21.795114387 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", new ArrayList<>(2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "precedence.put(\"+\", 1; precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:23.403108079 +0100\n+++ /tmp/tmph4ht3oep.java\t2023-03-24 13:16:23.403108079 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1; precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"-\", \"*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:25.051101614 +0100\n+++ /tmp/tmp06_iedq7.java\t2023-03-24 13:16:25.051101614 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"-\", \"*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"&\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:26.795094774 +0100\n+++ /tmp/tmpgf3hpfxt.java\t2023-03-24 13:16:26.795094774 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"&\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "precedence.put(\"+\", 100); precedence.put(\"-\", \"*\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:28.307088845 +0100\n+++ /tmp/tmp0ubrkxf3.java\t2023-03-24 13:16:28.307088845 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 100); precedence.put(\"-\", \"*\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "precedence.put(\"+\", 0); precedence.put(\"-\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:29.751083183 +0100\n+++ /tmp/tmp2_7hsqil.java\t2023-03-24 13:16:29.751083183 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 0); precedence.put(\"-\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "precedence.put(\"+\", 100); precedence.put(\"-\", 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:31.275077208 +0100\n+++ /tmp/tmpv21_eycn.java\t2023-03-24 13:16:31.275077208 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 100); precedence.put(\"-\", 0);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:32.811071186 +0100\n+++ /tmp/tmpoiqjuzh1.java\t2023-03-24 13:16:32.811071186 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1); }\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"*\", \"/\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:34.287065402 +0100\n+++ /tmp/tmp87qglg0m.java\t2023-03-24 13:16:34.291065387 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"*\", \"/\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 10);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:35.867059209 +0100\n+++ /tmp/tmpib94mg8u.java\t2023-03-24 13:16:35.871059193 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 10);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 100);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:37.511052766 +0100\n+++ /tmp/tmpan7j7ba4.java\t2023-03-24 13:16:37.515052750 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 100);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"%*\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:39.127046434 +0100\n+++ /tmp/tmp_5mse9nz.java\t2023-03-24 13:16:39.127046434 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"%*\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"?\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:40.791039917 +0100\n+++ /tmp/tmp1hpix1fd.java\t2023-03-24 13:16:40.795039901 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"?\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", \"/\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:42.607032802 +0100\n+++ /tmp/tmpgld746qg.java\t2023-03-24 13:16:42.607032802 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", \"/\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "precedence.put(\"+\",1\"); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:44.511025342 +0100\n+++ /tmp/tmph39cu3ud.java\t2023-03-24 13:16:44.511025342 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1\"); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"-\", 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:46.511017513 +0100\n+++ /tmp/tmpw8w7xhfz.java\t2023-03-24 13:16:46.511017513 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"-\", 1;\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\", 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:48.483009790 +0100\n+++ /tmp/tmpvzom7ki1.java\t2023-03-24 13:16:48.483009790 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\", 1;\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "precedence.put(\"+\", 100); precedence.put(\"*\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:50.467002024 +0100\n+++ /tmp/tmpi5_4u3_z.java\t2023-03-24 13:16:50.467002024 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 100); precedence.put(\"*\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:52.486994116 +0100\n+++ /tmp/tmpbb9lp8w1.java\t2023-03-24 13:16:52.486994116 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\", new ArrayList<>();\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"*\",1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:54.326986916 +0100\n+++ /tmp/tmpboa8xh3f.java\t2023-03-24 13:16:54.342986853 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"*\",1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "precedence.put(\"+\", \"\"); precedence.put(\"/\", \"\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:55.954980543 +0100\n+++ /tmp/tmpjh3dmbiq.java\t2023-03-24 13:16:55.954980543 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", \"\"); precedence.put(\"/\", \"\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"-\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:57.746973532 +0100\n+++ /tmp/tmpya22geu_.java\t2023-03-24 13:16:57.746973532 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"-\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "precedence.put(\"+\",1); precedence.put(\"/\",2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:16:59.162967990 +0100\n+++ /tmp/tmph7c697m8.java\t2023-03-24 13:16:59.166967977 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",1); precedence.put(\"/\",2);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "precedence.put(\"+\",(0); precedence.put(\"-\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:17:00.634962234 +0100\n+++ /tmp/tmpci4183h1.java\t2023-03-24 13:17:00.634962234 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\",(0); precedence.put(\"-\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "precedence.put(\"+\", 1); precedence.put(\"/\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:17:02.078956585 +0100\n+++ /tmp/tmp39i7_7un.java\t2023-03-24 13:17:02.082956567 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1); precedence.put(\"/\");\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "precedence.put(\"+\", 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shunting_yard/java_programs/SHUNTING_YARD.java\t2023-03-24 13:17:03.534950890 +0100\n+++ /tmp/tmp5r8oysa2.java\t2023-03-24 13:17:03.538950873 +0100\n@@ -11,21 +11,11 @@\n  * @author derricklin\n  */\n public class SHUNTING_YARD {\n     public static List shunting_yard(ArrayList tokens) {\n         Map<String, Integer> precedence = new HashMap<String, Integer>();\n-        precedence.put(\"+\",1);\n-        precedence.put(\"-\",1);\n-        precedence.put(\"*\",2);\n-        precedence.put(\"/\",2);\n-\n-        ArrayList rpntokens = new ArrayList(100);\n-        ArrayDeque opstack = new ArrayDeque();\n-\n-        for (Object token: tokens) {\n-            if (Integer.class.isInstance(token)) {\n-            // cover also Double case I guess?\n+precedence.put(\"+\", 1);\n                 rpntokens.add((Integer) token);\n             } else {\n                 String operator = (String) token;\n                 while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) {\n                     rpntokens.add(opstack.pop());\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "precedence.put(\"+\", 1); precedence.put(\"-\", 1); precedence.put(\"*\", 2); precedence.put(\"/\", 2); ArrayList rpntokens = new ArrayList(100); ArrayDeque opstack = new ArrayDeque(); for (Object token : tokens) { if (Integer.class.isInstance(token)) { // cover also Double case I guess? rpntokens.add((Integer) token); } else { String operator = (String) token; while (!opstack.isEmpty() && precedence.get(operator) <= precedence.get(opstack.getLast())) { rpntokens.add(opstack.pop()); } opstack.push(token); }"
    },
    "find_in_sorted": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:09.418927884 +0100\n+++ /tmp/tmpqgyad78x.java\t2023-03-24 13:17:09.446927774 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (mid >= start) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:11.274920630 +0100\n+++ /tmp/tmp4tjm17c0.java\t2023-03-24 13:17:11.274920630 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= start) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (!mid[mid]) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:14.770906966 +0100\n+++ /tmp/tmp8n67cvab.java\t2023-03-24 13:17:14.770906966 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (mid[mid]!= -1) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:16.266901119 +0100\n+++ /tmp/tmp7_5blqok.java\t2023-03-24 13:17:16.266901119 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= -1) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (mid[mid]!= 0) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:17.854894915 +0100\n+++ /tmp/tmph7n887vh.java\t2023-03-24 13:17:17.854894915 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= 0) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (mid >= x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:19.446888695 +0100\n+++ /tmp/tmpj9rje2l3.java\t2023-03-24 13:17:19.446888695 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (mid[mid]!= null) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:23.358873415 +0100\n+++ /tmp/tmphr0mp6q7.java\t2023-03-24 13:17:23.362873399 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= null) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (mid[mid] == '\\n') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:25.138866465 +0100\n+++ /tmp/tmpafgchz2k.java\t2023-03-24 13:17:25.142866449 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '\\n') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (mid >= SURR1_FIRST) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:26.902859578 +0100\n+++ /tmp/tmpmv2svve2.java\t2023-03-24 13:17:26.902859578 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= SURR1_FIRST) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (mid >= end) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:28.722852472 +0100\n+++ /tmp/tmplize8iho.java\t2023-03-24 13:17:28.722852472 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= end) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (mid[mid]!= x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:33.150835189 +0100\n+++ /tmp/tmpklfggq8u.java\t2023-03-24 13:17:33.154835173 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (mid[mid]!= '\"') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:35.106827554 +0100\n+++ /tmp/tmpfaq_pp5m.java\t2023-03-24 13:17:35.106827554 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= '\"') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (!mid[mid] < 0) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:37.082819844 +0100\n+++ /tmp/tmp2t18crae.java\t2023-03-24 13:17:37.086819828 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] < 0) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (mid[mid] == '=') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:38.782813211 +0100\n+++ /tmp/tmpotvx0la8.java\t2023-03-24 13:17:38.786813195 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '=') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (!mid[mid] || mid == -1) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:40.434806767 +0100\n+++ /tmp/tmpz4uw3p0z.java\t2023-03-24 13:17:40.434806767 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || mid == -1) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (mid[mid]!= 0.0) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:42.102800260 +0100\n+++ /tmp/tmpf2fuh3ju.java\t2023-03-24 13:17:42.102800260 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= 0.0) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (mid[mid] == ']') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:43.846793459 +0100\n+++ /tmp/tmpn37hetlf.java\t2023-03-24 13:17:43.846793459 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == ']') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (!mid[mid] || mid < 0) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:45.666786362 +0100\n+++ /tmp/tmpj6trgpz_.java\t2023-03-24 13:17:45.666786362 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || mid < 0) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:47.398779608 +0100\n+++ /tmp/tmpfrb26c_6.java\t2023-03-24 13:17:47.402779592 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid - 1; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (arr[mid] == ']') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:49.170772698 +0100\n+++ /tmp/tmp0c69pazq.java\t2023-03-24 13:17:49.170772698 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == ']') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (mid[mid] == 0) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:53.130757263 +0100\n+++ /tmp/tmpzjedss5_.java\t2023-03-24 13:17:53.130757263 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == 0) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (mid[mid] == '/') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:54.782750824 +0100\n+++ /tmp/tmpwweeevt6.java\t2023-03-24 13:17:54.782750824 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '/') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (key == arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:56.434744387 +0100\n+++ /tmp/tmp6v4c0gvd.java\t2023-03-24 13:17:56.434744387 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (key == arr[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid - start; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:57.890738714 +0100\n+++ /tmp/tmp1ce5ze_7.java\t2023-03-24 13:17:57.890738714 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid - start; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (mid[mid] == 'L') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:17:59.290733259 +0100\n+++ /tmp/tmp29xoq0kh.java\t2023-03-24 13:17:59.290733259 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == 'L') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (mid[mid] == '\\\\') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:00.710727726 +0100\n+++ /tmp/tmpnrthazmz.java\t2023-03-24 13:18:00.714727712 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '\\\\') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (mid[mid] == '(') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:02.058722476 +0100\n+++ /tmp/tmp4yoe6bxr.java\t2023-03-24 13:18:02.062722461 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '(') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (mid[mid] == '-') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:03.702716073 +0100\n+++ /tmp/tmp_y8b02d3.java\t2023-03-24 13:18:03.702716073 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '-') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:05.378709545 +0100\n+++ /tmp/tmpf1ta6amo.java\t2023-03-24 13:18:05.378709545 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (this.mid >= start) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:06.950703423 +0100\n+++ /tmp/tmpev6tnl33.java\t2023-03-24 13:18:06.954703407 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (this.mid >= start) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (mid[mid] == '\"') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:08.318698096 +0100\n+++ /tmp/tmpcki6guhf.java\t2023-03-24 13:18:08.318698096 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '\"') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!mid[mid] || (mid[mid]!= -1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:09.710692677 +0100\n+++ /tmp/tmpih4bj8lj.java\t2023-03-24 13:18:09.710692677 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid]!= -1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (mid[mid] == -1) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:11.062687413 +0100\n+++ /tmp/tmpnukn14r4.java\t2023-03-24 13:18:11.062687413 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == -1) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (mid[mid] == null) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:12.554681605 +0100\n+++ /tmp/tmp6kg7zwon.java\t2023-03-24 13:18:12.566681558 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == null) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (mid[mid] == x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:14.018675905 +0100\n+++ /tmp/tmpc_2g07vm.java\t2023-03-24 13:18:14.018675905 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (!mid[mid] || mid == 0) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:15.554669927 +0100\n+++ /tmp/tmp_1dwggjn.java\t2023-03-24 13:18:15.554669927 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || mid == 0) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (!mid[mid] || (mid[mid] == -1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:17.066664044 +0100\n+++ /tmp/tmpy45cz143.java\t2023-03-24 13:18:17.066664044 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid] == -1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (!mid.equals(v)) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:18.554658253 +0100\n+++ /tmp/tmpx0tp_651.java\t2023-03-24 13:18:18.554658253 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid.equals(v)) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (mid[mid]!= -1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:20.158652012 +0100\n+++ /tmp/tmputugf3cg.java\t2023-03-24 13:18:20.158652012 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= -1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (mid >= start) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:21.882645304 +0100\n+++ /tmp/tmpcglyrr6x.java\t2023-03-24 13:18:21.886645288 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= start) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (mid[mid]!='') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:23.626638521 +0100\n+++ /tmp/tmpzuzvmydt.java\t2023-03-24 13:18:23.626638521 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!='') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (mid[mid]!= 0) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:25.326631907 +0100\n+++ /tmp/tmp3skpcuzk.java\t2023-03-24 13:18:25.326631907 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= 0) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (arr[mid] == '=') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:27.186624674 +0100\n+++ /tmp/tmpk9vn4wbj.java\t2023-03-24 13:18:27.186624674 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == '=') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (!mid.equals(arr[mid])) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:31.906606319 +0100\n+++ /tmp/tmproh3c_rj.java\t2023-03-24 13:18:31.906606319 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid.equals(arr[mid])) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (!mid[mid] || (mid[mid]!= x)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:33.678599431 +0100\n+++ /tmp/tmpd8chijct.java\t2023-03-24 13:18:33.678599431 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid]!= x)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!mid[mid] < 0) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:35.310593087 +0100\n+++ /tmp/tmptwdoovy9.java\t2023-03-24 13:18:35.310593087 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] < 0) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (!mid[mid] || (mid[mid]) >= start) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:36.958586681 +0100\n+++ /tmp/tmpoj_a2mq_.java\t2023-03-24 13:18:36.958586681 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid]) >= start) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (isDebug) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:38.326581363 +0100\n+++ /tmp/tmp2pdnr9ev.java\t2023-03-24 13:18:38.326581363 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (isDebug) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (mid[mid] == '#') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:39.714575970 +0100\n+++ /tmp/tmpvenw_s9j.java\t2023-03-24 13:18:39.714575970 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '#') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (mid[mid] == quote) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:41.142570421 +0100\n+++ /tmp/tmp9cbkpcv3.java\t2023-03-24 13:18:41.146570406 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == quote) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (!mid[mid] || (mid[mid]!= null)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:42.582564825 +0100\n+++ /tmp/tmp4ex62cuf.java\t2023-03-24 13:18:42.586564809 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid]!= null)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (!mid[mid] && (mid[mid]!= null)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:44.018559246 +0100\n+++ /tmp/tmpms5vbdg5.java\t2023-03-24 13:18:44.018559246 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] && (mid[mid]!= null)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (mid[mid] > x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:45.530553372 +0100\n+++ /tmp/tmp7ue26p2c.java\t2023-03-24 13:18:45.530553372 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] > x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (mid[mid] == h) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:47.086547327 +0100\n+++ /tmp/tmps9h5yr9l.java\t2023-03-24 13:18:47.086547327 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == h) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (!mid[mid] == '=') { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:48.666541190 +0100\n+++ /tmp/tmpieru2fug.java\t2023-03-24 13:18:48.666541190 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] == '=') { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (mid >= len) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:50.202535226 +0100\n+++ /tmp/tmp1mczhxkc.java\t2023-03-24 13:18:50.202535226 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= len) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (arr[mid] == x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:51.802529011 +0100\n+++ /tmp/tmpgtj4xemd.java\t2023-03-24 13:18:51.802529011 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (arr[mid] == x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (mid >= start) { return binsearch(arr, x, mid, end); } else { return mid - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:55.542514490 +0100\n+++ /tmp/tmp3tgowkwv.java\t2023-03-24 13:18:55.542514490 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= start) { return binsearch(arr, x, mid, end); } else { return mid - 1; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (start >= x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:18:59.418499442 +0100\n+++ /tmp/tmpr_mlcgl1.java\t2023-03-24 13:18:59.418499442 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (start >= x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (mid[mid]!= t) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:19:03.650483017 +0100\n+++ /tmp/tmpovhnx7rk.java\t2023-03-24 13:19:03.650483017 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= t) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (mid >= start) { return binsearch(arr, x, mid, end); } else { return mid - start; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:19:05.234476871 +0100\n+++ /tmp/tmp89xe6zgz.java\t2023-03-24 13:19:05.234476871 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= start) { return binsearch(arr, x, mid, end); } else { return mid - start; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (mid[mid] == EOF) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:19:24.006404070 +0100\n+++ /tmp/tmp82wjb4hu.java\t2023-03-24 13:19:24.006404070 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == EOF) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!mid[mid] & 0xff) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:19:32.806369968 +0100\n+++ /tmp/tmpjl09k2uk.java\t2023-03-24 13:19:32.814369936 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] & 0xff) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!mid[mid] || mid < 0) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:19:42.374332908 +0100\n+++ /tmp/tmp9o6gtdp7.java\t2023-03-24 13:19:42.374332908 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || mid < 0) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (mid[mid]!= null) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:19:51.698296811 +0100\n+++ /tmp/tmp9ng35wl1.java\t2023-03-24 13:19:51.698296811 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= null) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (mid[mid] == c) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:20:00.662262126 +0100\n+++ /tmp/tmp9dzzg1xk.java\t2023-03-24 13:20:00.662262126 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == c) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (mid[mid] == t) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:20:09.870226513 +0100\n+++ /tmp/tmp3a9elwc4.java\t2023-03-24 13:20:09.870226513 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == t) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (mid[mid]!= x) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:20:18.982191287 +0100\n+++ /tmp/tmp7x5_813u.java\t2023-03-24 13:20:18.982191287 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= x) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (y < arr.length) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:20:27.538158227 +0100\n+++ /tmp/tmp13v7yaxt.java\t2023-03-24 13:20:27.538158227 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (y < arr.length) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:20:36.066125286 +0100\n+++ /tmp/tmp3mjyv4pu.java\t2023-03-24 13:20:36.066125286 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (mid < x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:20:44.566092470 +0100\n+++ /tmp/tmpp7i2a_5a.java\t2023-03-24 13:20:44.566092470 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid < x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (!mid[mid] || (mid[mid])!= null)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:21:02.590022924 +0100\n+++ /tmp/tmp48prlqru.java\t2023-03-24 13:21:02.590022924 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid])!= null)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!mid.equals(arr[mid])) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:21:09.889994774 +0100\n+++ /tmp/tmpdpyoyucg.java\t2023-03-24 13:21:09.897994743 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid.equals(arr[mid])) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (!mid) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:21:17.593965075 +0100\n+++ /tmp/tmp785yfrx7.java\t2023-03-24 13:21:17.593965075 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (start > mid) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:21:25.205935742 +0100\n+++ /tmp/tmpx2_6outt.java\t2023-03-24 13:21:25.205935742 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (start > mid) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (mid == x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:21:40.197877998 +0100\n+++ /tmp/tmpq69y78tw.java\t2023-03-24 13:21:40.197877998 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid == x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (!mid >= start) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:21:53.641826248 +0100\n+++ /tmp/tmpxrg76wjb.java\t2023-03-24 13:21:53.641826248 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid >= start) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (!mid[mid] || mid == -1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:21:59.581803391 +0100\n+++ /tmp/tmpfj994hw7.java\t2023-03-24 13:21:59.581803391 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || mid == -1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (start >= mid) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:05.449780818 +0100\n+++ /tmp/tmptp9rk_2w.java\t2023-03-24 13:22:05.449780818 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (start >= mid) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (mid[mid]!= '\"') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:18.573730352 +0100\n+++ /tmp/tmpg5elixy2.java\t2023-03-24 13:22:18.573730352 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= '\"') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (directed) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:24.021709409 +0100\n+++ /tmp/tmpzijh0dhi.java\t2023-03-24 13:22:24.021709409 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (directed) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (mid >= 11) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:29.957686599 +0100\n+++ /tmp/tmp4ndg3i1d.java\t2023-03-24 13:22:29.957686599 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= 11) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (mid >= n) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:43.453634751 +0100\n+++ /tmp/tmpn87kdzby.java\t2023-03-24 13:22:43.453634751 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= n) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (!mid[mid]]) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:48.897613846 +0100\n+++ /tmp/tmp0ixs41l9.java\t2023-03-24 13:22:48.897613846 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]]) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (!mid[mid] ||!mid[mid]) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:54.213593435 +0100\n+++ /tmp/tmp3729sqn7.java\t2023-03-24 13:22:54.213593435 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] ||!mid[mid]) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (trackUndo) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:22:59.509573106 +0100\n+++ /tmp/tmpl5u4ta3y.java\t2023-03-24 13:22:59.509573106 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (trackUndo) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (mid > x) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:05.209551228 +0100\n+++ /tmp/tmp3seu9h5f.java\t2023-03-24 13:23:05.209551228 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid > x) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (basic == null) { return binsearch(arr, x, mid, end); } else { return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:16.705507122 +0100\n+++ /tmp/tmpha72wrj9.java\t2023-03-24 13:23:16.705507122 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (basic == null) { return binsearch(arr, x, mid, end); } else { return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (!mid[mid] || (mid[mid])!= -1) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:20.317493267 +0100\n+++ /tmp/tmp5iqf75er.java\t2023-03-24 13:23:20.317493267 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid])!= -1) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (!mid.equals(v)) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:23.985479201 +0100\n+++ /tmp/tmpfjt1xl7e.java\t2023-03-24 13:23:23.985479201 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid.equals(v)) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (mid >= SURR1_FIRST) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:27.805464551 +0100\n+++ /tmp/tmp123dz6jh.java\t2023-03-24 13:23:27.809464535 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= SURR1_FIRST) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (mid[mid]!= 0.0) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:30.409454568 +0100\n+++ /tmp/tmp4mctau27.java\t2023-03-24 13:23:30.413454552 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid]!= 0.0) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (mid[mid] == '\\n') { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:33.301443480 +0100\n+++ /tmp/tmpnca7050d.java\t2023-03-24 13:23:33.301443480 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid[mid] == '\\n') { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (mid >= end) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:35.769434017 +0100\n+++ /tmp/tmpqm9dkp6a.java\t2023-03-24 13:23:35.769434017 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= end) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (!mid[mid]) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:38.421423852 +0100\n+++ /tmp/tmpkcifds7z.java\t2023-03-24 13:23:38.421423852 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (mid >= x) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:41.077413673 +0100\n+++ /tmp/tmpsns5km_w.java\t2023-03-24 13:23:41.081413656 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (mid >= x) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (!mid[mid]]) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:43.493404414 +0100\n+++ /tmp/tmptxqrujo5.java\t2023-03-24 13:23:43.497404398 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid]]) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (!mid >= start) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:45.669396075 +0100\n+++ /tmp/tmpa4gtcanw.java\t2023-03-24 13:23:45.673396059 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid >= start) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (!mid) { return binsearch(arr, x, mid, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:47.913387476 +0100\n+++ /tmp/tmpl7a3hjea.java\t2023-03-24 13:23:47.917387460 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid) { return binsearch(arr, x, mid, end); }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (!mid[mid] || (mid[mid]!= -1) return mid; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_in_sorted/java_programs/FIND_IN_SORTED.java\t2023-03-24 13:23:50.097379107 +0100\n+++ /tmp/tmpo_dlkmlh.java\t2023-03-24 13:23:50.097379107 +0100\n@@ -15,11 +15,11 @@\n         }\n         int mid = start + (end - start) / 2; // check this is floor division\n         if (x < arr[mid]) {\n             return binsearch(arr, x, start, mid);\n         } else if (x > arr[mid]) {\n-            return binsearch(arr, x, mid, end);\n+if (!mid[mid] || (mid[mid]!= -1) return mid; }\n         } else {\n             return mid;\n         }\n     }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return binsearch(arr, x, mid+1, end);"
    },
    "lcs_length": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:04.761322936 +0100\n+++ /tmp/tmp25t5r8cj.java\t2023-03-24 13:24:04.761322936 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:06.857314907 +0100\n+++ /tmp/tmpvzy8uo0s.java\t2023-03-24 13:24:06.857314907 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:08.745307679 +0100\n+++ /tmp/tmp596exe20.java\t2023-03-24 13:24:08.749307662 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:10.521300879 +0100\n+++ /tmp/tmph1sfrbo4.java\t2023-03-24 13:24:10.525300862 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:12.401293681 +0100\n+++ /tmp/tmpvv4olgmi.java\t2023-03-24 13:24:12.401293681 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:14.345286238 +0100\n+++ /tmp/tmpc73tgpw6.java\t2023-03-24 13:24:14.345286238 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:16.413278320 +0100\n+++ /tmp/tmpwaeeog_p.java\t2023-03-24 13:24:16.413278320 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i2).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:18.557270112 +0100\n+++ /tmp/tmp0fxrr5cq.java\t2023-03-24 13:24:18.557270112 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i2).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:20.677261999 +0100\n+++ /tmp/tmp8te_aljt.java\t2023-03-24 13:24:20.681261983 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:22.817253806 +0100\n+++ /tmp/tmpax1vuqq0.java\t2023-03-24 13:24:22.817253806 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:24.921245755 +0100\n+++ /tmp/tmpfesmj3xv.java\t2023-03-24 13:24:24.921245755 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:27.069237534 +0100\n+++ /tmp/tmpqpcqu527.java\t2023-03-24 13:24:27.069237534 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:29.209229343 +0100\n+++ /tmp/tmp8x19lvd6.java\t2023-03-24 13:24:29.209229343 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:31.389221003 +0100\n+++ /tmp/tmp1p7g6r3h.java\t2023-03-24 13:24:31.389221003 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:33.713212110 +0100\n+++ /tmp/tmp4e3ovbdy.java\t2023-03-24 13:24:33.713212110 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:35.805204105 +0100\n+++ /tmp/tmpcd1sf8fm.java\t2023-03-24 13:24:35.805204105 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:37.733196731 +0100\n+++ /tmp/tmphwwmr100.java\t2023-03-24 13:24:37.733196731 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+ 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:39.645189416 +0100\n+++ /tmp/tmpznmdhx8c.java\t2023-03-24 13:24:39.649189400 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+ 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:41.553182116 +0100\n+++ /tmp/tmp_8es4gpm.java\t2023-03-24 13:24:41.553182116 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i]).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:43.577174373 +0100\n+++ /tmp/tmpk3a79ao_.java\t2023-03-24 13:24:43.577174373 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i]).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:45.597166647 +0100\n+++ /tmp/tmp_pd4bty2.java\t2023-03-24 13:24:45.597166647 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:47.265160269 +0100\n+++ /tmp/tmpbdikjzrf.java\t2023-03-24 13:24:47.265160269 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:48.857154180 +0100\n+++ /tmp/tmpf3xumr0i.java\t2023-03-24 13:24:48.857154180 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j+ 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:50.409148245 +0100\n+++ /tmp/tmp8rnoaz11.java\t2023-03-24 13:24:50.409148245 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j+ 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(i + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:52.029142050 +0100\n+++ /tmp/tmpof56xoe1.java\t2023-03-24 13:24:52.029142050 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(i + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:53.669135779 +0100\n+++ /tmp/tmp42ii4pbx.java\t2023-03-24 13:24:53.669135779 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:55.329129432 +0100\n+++ /tmp/tmpge818ynw.java\t2023-03-24 13:24:55.329129432 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (dp.containsKey(i)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:57.041122885 +0100\n+++ /tmp/tmpowiir17v.java\t2023-03-24 13:24:57.041122885 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:24:58.769116277 +0100\n+++ /tmp/tmp314l05mx.java\t2023-03-24 13:24:58.773116264 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:00.633109152 +0100\n+++ /tmp/tmp5mcn8ryb.java\t2023-03-24 13:25:00.633109152 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (dp.containsKey(i)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:02.673101353 +0100\n+++ /tmp/tmpeqyr80g2.java\t2023-03-24 13:25:02.673101353 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:04.761093371 +0100\n+++ /tmp/tmpkd7g53yl.java\t2023-03-24 13:25:04.761093371 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).toString() + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:06.785085634 +0100\n+++ /tmp/tmpegurnc1g.java\t2023-03-24 13:25:06.785085634 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).toString() + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:08.721078233 +0100\n+++ /tmp/tmpj19d772z.java\t2023-03-24 13:25:08.721078233 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1)).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:10.821070208 +0100\n+++ /tmp/tmpj4s4dlqk.java\t2023-03-24 13:25:10.821070208 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1)).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-2).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:12.785062702 +0100\n+++ /tmp/tmp7ckcvjl_.java\t2023-03-24 13:25:12.785062702 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-2).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:14.521056068 +0100\n+++ /tmp/tmp40gcj5i7.java\t2023-03-24 13:25:14.521056068 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j - 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(i + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:16.397048898 +0100\n+++ /tmp/tmpur_k39ay.java\t2023-03-24 13:25:16.397048898 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(i + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:17.825043441 +0100\n+++ /tmp/tmpf73mhdbl.java\t2023-03-24 13:25:17.829043424 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i2); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:19.373037527 +0100\n+++ /tmp/tmp90j3qflr.java\t2023-03-24 13:25:19.373037527 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i2); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (dp.containsKey(j1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:20.817032007 +0100\n+++ /tmp/tmp8lxbkrrg.java\t2023-03-24 13:25:20.817032007 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:22.361026109 +0100\n+++ /tmp/tmpfw0oprr9.java\t2023-03-24 13:25:22.365026093 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j - 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:23.853020409 +0100\n+++ /tmp/tmp8c08zmd8.java\t2023-03-24 13:25:23.853020409 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1\").get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:25.449014312 +0100\n+++ /tmp/tmpwgfuwe1l.java\t2023-03-24 13:25:25.449014312 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1\").get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:27.253007419 +0100\n+++ /tmp/tmp1ynsvbo1.java\t2023-03-24 13:25:27.257007405 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:29.005000728 +0100\n+++ /tmp/tmpzslm45nk.java\t2023-03-24 13:25:29.005000728 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i]).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:30.488995058 +0100\n+++ /tmp/tmp8wqx8teb.java\t2023-03-24 13:25:30.488995058 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i]).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (dp.containsKey(i])) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:31.984989344 +0100\n+++ /tmp/tmp9mxmgpav.java\t2023-03-24 13:25:31.984989344 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i])) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-2).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:33.600983172 +0100\n+++ /tmp/tmp5jj3oo80.java\t2023-03-24 13:25:33.600983172 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-2).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (dp.containsKey(j)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:35.156977228 +0100\n+++ /tmp/tmpfq20ghpp.java\t2023-03-24 13:25:35.156977228 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i 2).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:36.780971027 +0100\n+++ /tmp/tmpfmvb103f.java\t2023-03-24 13:25:36.780971027 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i 2).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:38.468964577 +0100\n+++ /tmp/tmpb1jewhd1.java\t2023-03-24 13:25:38.468964577 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (dp.containsKey(j)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:40.240957810 +0100\n+++ /tmp/tmpa3frz3j4.java\t2023-03-24 13:25:40.240957810 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)){ Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:42.028950985 +0100\n+++ /tmp/tmp4t01uckf.java\t2023-03-24 13:25:42.028950985 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)[i+1]; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:43.924943743 +0100\n+++ /tmp/tmpylq9eecq.java\t2023-03-24 13:25:43.928943729 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)[i+1]; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i2).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:45.984935879 +0100\n+++ /tmp/tmp0ylt776q.java\t2023-03-24 13:25:45.984935879 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i2).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (!dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:48.040928028 +0100\n+++ /tmp/tmp3nl2eu4d.java\t2023-03-24 13:25:48.040928028 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (!dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i()).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:50.196919797 +0100\n+++ /tmp/tmptncxwcel.java\t2023-03-24 13:25:50.196919797 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i()).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1)).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:52.352911564 +0100\n+++ /tmp/tmpa6bsz0b_.java\t2023-03-24 13:25:52.352911564 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1)).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (dp.containsKey(j1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:54.484903427 +0100\n+++ /tmp/tmp0qsoczk0.java\t2023-03-24 13:25:54.484903427 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:56.344896325 +0100\n+++ /tmp/tmpeag84xy8.java\t2023-03-24 13:25:56.344896325 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:58.104889607 +0100\n+++ /tmp/tmpimw22yx5.java\t2023-03-24 13:25:58.104889607 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i)).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (dp.containsKey(i])) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:25:59.952882556 +0100\n+++ /tmp/tmpc2_dg1tx.java\t2023-03-24 13:25:59.952882556 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i])) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:01.724875792 +0100\n+++ /tmp/tmphzk10e16.java\t2023-03-24 13:26:01.728875776 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:03.500869013 +0100\n+++ /tmp/tmpol3m1yb1.java\t2023-03-24 13:26:03.500869013 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i 1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i2); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:05.164862663 +0100\n+++ /tmp/tmpl8lkrowh.java\t2023-03-24 13:26:05.164862663 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i2); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i5)).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:06.640857030 +0100\n+++ /tmp/tmphboryh7s.java\t2023-03-24 13:26:06.640857030 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i5)).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1]).get(j + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:08.220851001 +0100\n+++ /tmp/tmpwngla6ww.java\t2023-03-24 13:26:08.220851001 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1]).get(j + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j+ 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:09.788845015 +0100\n+++ /tmp/tmpsgvqo4yj.java\t2023-03-24 13:26:09.792845002 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j+ 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (!dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:11.344839078 +0100\n+++ /tmp/tmp7wg7f19a.java\t2023-03-24 13:26:11.348839065 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (!dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j-1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:12.972832866 +0100\n+++ /tmp/tmpgxtj2rd1.java\t2023-03-24 13:26:12.972832866 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j-1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:14.652826458 +0100\n+++ /tmp/tmp4ou6xhlq.java\t2023-03-24 13:26:14.652826458 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i1); int insert_value = dp.get(i).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:16.380819863 +0100\n+++ /tmp/tmpa45jwfqm.java\t2023-03-24 13:26:16.380819863 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j)+1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:18.264812677 +0100\n+++ /tmp/tmpv2tx75sc.java\t2023-03-24 13:26:18.264812677 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j)+1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(iAnalysis).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:20.092805703 +0100\n+++ /tmp/tmppn398pts.java\t2023-03-24 13:26:20.092805703 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(iAnalysis).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:22.036798286 +0100\n+++ /tmp/tmpb012blex.java\t2023-03-24 13:26:22.036798286 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i+1).get(j+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:24.088790458 +0100\n+++ /tmp/tmpqqd9i4md.java\t2023-03-24 13:26:24.092790445 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j+1) + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:26.152782587 +0100\n+++ /tmp/tmpbfn_v643.java\t2023-03-24 13:26:26.152782587 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i1).get(j+1) + 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:28.204774759 +0100\n+++ /tmp/tmp707fae7s.java\t2023-03-24 13:26:28.208774745 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (!dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:30.164767285 +0100\n+++ /tmp/tmpq4jcp4bk.java\t2023-03-24 13:26:30.164767285 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(j)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i).get(j+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:32.084759961 +0100\n+++ /tmp/tmpm8brmml_.java\t2023-03-24 13:26:32.084759961 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i0); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:33.956752824 +0100\n+++ /tmp/tmpb3sijvk1.java\t2023-03-24 13:26:33.960752808 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(i+1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:35.712746127 +0100\n+++ /tmp/tmphag20dga.java\t2023-03-24 13:26:35.716746111 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(i+1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i -1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:37.396739705 +0100\n+++ /tmp/tmp1jny_cns.java\t2023-03-24 13:26:37.396739705 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i -1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j).get(i + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:38.948733787 +0100\n+++ /tmp/tmpp_57e5r9.java\t2023-03-24 13:26:38.948733787 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j).get(i + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i[0]); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:40.492727899 +0100\n+++ /tmp/tmpz361yh75.java\t2023-03-24 13:26:40.492727899 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i[0]); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:42.072721874 +0100\n+++ /tmp/tmpaltyc360.java\t2023-03-24 13:26:42.076721858 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j + 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j).get(i+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:43.684715729 +0100\n+++ /tmp/tmp9q4p048r.java\t2023-03-24 13:26:43.684715729 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j).get(i+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:45.264709705 +0100\n+++ /tmp/tmpaxkp5kp3.java\t2023-03-24 13:26:45.264709705 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i - 1; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:47.004703071 +0100\n+++ /tmp/tmp4aod_j7c.java\t2023-03-24 13:26:47.008703054 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j - 1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:48.712696559 +0100\n+++ /tmp/tmpw3z0ri28.java\t2023-03-24 13:26:48.712696559 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j-1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:50.460689896 +0100\n+++ /tmp/tmppsj7gccg.java\t2023-03-24 13:26:50.460689896 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j-1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j+1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:52.264683019 +0100\n+++ /tmp/tmpeya_ksm1.java\t2023-03-24 13:26:52.264683019 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { Map<Integer, Integer> internal_map = dp.get(i-1).get(j+1); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (dp.containsKey(i)) { // already added, no need to check supers return new HashMap<Integer, Integer>>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:54.264675396 +0100\n+++ /tmp/tmpp9sl_702.java\t2023-03-24 13:26:54.264675396 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { // already added, no need to check supers return new HashMap<Integer, Integer>>(); }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (dp.containsKey(i)) { // already added, no need to check supers return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:56.476666964 +0100\n+++ /tmp/tmpnv_li2u5.java\t2023-03-24 13:26:56.476666964 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { // already added, no need to check supers return; }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (dp.containsKey(i)) { // already added, no need to check supers }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:26:58.704658472 +0100\n+++ /tmp/tmpo8k7iuvh.java\t2023-03-24 13:26:58.704658472 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { // already added, no need to check supers }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (dp.containsKey(i)) { // already added, no need to check supers } else {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:27:00.864650240 +0100\n+++ /tmp/tmpv2w7wah9.java\t2023-03-24 13:27:00.864650240 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { // already added, no need to check supers } else {\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (dp.containsKey(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:27:03.192641366 +0100\n+++ /tmp/tmpgdfhxc_2.java\t2023-03-24 13:27:03.192641366 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) {\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (dp.containsKey(i)) { // already added, no need to check supers",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:27:05.128633988 +0100\n+++ /tmp/tmpw3aem3jw.java\t2023-03-24 13:27:05.128633988 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { // already added, no need to check supers\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (dp.containsKey(i)) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/lcs_length/java_programs/LCS_LENGTH.java\t2023-03-24 13:27:07.024626765 +0100\n+++ /tmp/tmpq87qr65w.java\t2023-03-24 13:27:07.028626750 +0100\n@@ -30,13 +30,11 @@\n         // now the actual code\n         for (int i=0; i < s.length(); i++) {\n             for (int j=0; j < t.length(); j++) {\n                 if (s.charAt(i) == t.charAt(j)) {\n \n-                    if (dp.containsKey(i-1)) {\n-                        Map<Integer, Integer> internal_map = dp.get(i);\n-                        int insert_value = dp.get(i-1).get(j) + 1;\n+if (dp.containsKey(i)) { }\n                         internal_map.put(j, insert_value);\n                         dp.put(i,internal_map);\n                     } else {\n                         Map<Integer, Integer> internal_map = dp.get(i);\n                         internal_map.put(j,1);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "// dp.get(i-1).containsKey(j-1) if (dp.containsKey(i-1)&&dp.get(i-1).containsKey(j-1)) { Map<Integer, Integer> internal_map = dp.get(i); int insert_value = dp.get(i-1).get(j-1) + 1;"
    },
    "possible_change": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if ( jsonWriter.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:10.620613061 +0100\n+++ /tmp/tmpisw9oliz.java\t2023-03-24 13:27:10.732612636 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jsonWriter.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if ( fos.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:12.628605410 +0100\n+++ /tmp/tmpbvqy36hp.java\t2023-03-24 13:27:12.628605410 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( fos.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if ( sz.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:14.408598630 +0100\n+++ /tmp/tmpgbm0j7jv.java\t2023-03-24 13:27:14.408598630 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( sz.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (findAll.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:16.204591788 +0100\n+++ /tmp/tmpuksbb09i.java\t2023-03-24 13:27:16.204591788 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (findAll.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (ToCheck.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:17.672586193 +0100\n+++ /tmp/tmpcpujzvxu.java\t2023-03-24 13:27:17.672586193 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ToCheck.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if ( jsonWriter.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:19.220580297 +0100\n+++ /tmp/tmpardqu249.java\t2023-03-24 13:27:19.220580297 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jsonWriter.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if ( keyName.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:20.852574080 +0100\n+++ /tmp/tmpn9iyq0rk.java\t2023-03-24 13:27:20.852574080 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( keyName.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if ( 512.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:22.484567863 +0100\n+++ /tmp/tmpj6z9fo1p.java\t2023-03-24 13:27:22.484567863 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( 512.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (boxes.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:24.096561723 +0100\n+++ /tmp/tmpzin816ye.java\t2023-03-24 13:27:24.100561707 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (boxes.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if ( 65535.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:25.880554925 +0100\n+++ /tmp/tmp8pd88gsy.java\t2023-03-24 13:27:25.880554925 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( 65535.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (balanced.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:27.536548620 +0100\n+++ /tmp/tmp5rva_md2.java\t2023-03-24 13:27:27.536548620 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (balanced.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (FIER.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:29.404541505 +0100\n+++ /tmp/tmpvyo77gtm.java\t2023-03-24 13:27:29.404541505 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (FIER.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if ( subType.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:31.316534223 +0100\n+++ /tmp/tmp1jjq27wz.java\t2023-03-24 13:27:31.316534223 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( subType.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (joins.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:33.412526239 +0100\n+++ /tmp/tmpdapsk2_t.java\t2023-03-24 13:27:33.412526239 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (joins.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (hy.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:35.632517784 +0100\n+++ /tmp/tmpernzjuyj.java\t2023-03-24 13:27:35.636517771 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (hy.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (Gray.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:37.852509332 +0100\n+++ /tmp/tmp9teggg60.java\t2023-03-24 13:27:37.852509332 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Gray.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if ( Hierarchical.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:40.120500696 +0100\n+++ /tmp/tmphljq47b4.java\t2023-03-24 13:27:40.120500696 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( Hierarchical.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (interfaces.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:42.324492304 +0100\n+++ /tmp/tmp5qts6u0r.java\t2023-03-24 13:27:42.324492304 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (interfaces.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (OrEqualTo.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:44.224485070 +0100\n+++ /tmp/tmp9o0av26s.java\t2023-03-24 13:27:44.224485070 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (OrEqualTo.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (Restrictions.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:46.124477835 +0100\n+++ /tmp/tmp10mwm00l.java\t2023-03-24 13:27:46.128477820 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Restrictions.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if ( getDelegate.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:48.076470403 +0100\n+++ /tmp/tmpza2qc_lo.java\t2023-03-24 13:27:48.076470403 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( getDelegate.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if ( txt.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:49.592464630 +0100\n+++ /tmp/tmpvhqfntzy.java\t2023-03-24 13:27:49.596464617 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( txt.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (CallExpression.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:51.176458601 +0100\n+++ /tmp/tmpyv50ab8j.java\t2023-03-24 13:27:51.176458601 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (CallExpression.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (highlight.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:52.812452374 +0100\n+++ /tmp/tmpny6q8veh.java\t2023-03-24 13:27:52.812452374 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (highlight.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (ited.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:54.476446039 +0100\n+++ /tmp/tmpepipkwwq.java\t2023-03-24 13:27:54.480446024 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ited.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (AGG.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:56.116439796 +0100\n+++ /tmp/tmpqjfb3tnz.java\t2023-03-24 13:27:56.116439796 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (AGG.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (prob.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:57.992432653 +0100\n+++ /tmp/tmp2bt68ovk.java\t2023-03-24 13:27:57.992432653 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (prob.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (pairs.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:27:59.704426137 +0100\n+++ /tmp/tmppq6wnzll.java\t2023-03-24 13:27:59.704426137 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (pairs.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (ByPath.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:01.644418755 +0100\n+++ /tmp/tmphtqd_y9i.java\t2023-03-24 13:28:01.644418755 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ByPath.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if ( shortcut.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:03.532411570 +0100\n+++ /tmp/tmpp3mmxndu.java\t2023-03-24 13:28:03.532411570 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( shortcut.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (dup.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:05.644403529 +0100\n+++ /tmp/tmp8nchzev2.java\t2023-03-24 13:28:05.644403529 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (dup.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if ( Sleep.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:07.800395326 +0100\n+++ /tmp/tmpsy0pitz9.java\t2023-03-24 13:28:07.800395326 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( Sleep.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (pem.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:09.956387122 +0100\n+++ /tmp/tmpayg176m8.java\t2023-03-24 13:28:09.956387122 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (pem.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if ( 1.4.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:12.172378688 +0100\n+++ /tmp/tmp62opcd0r.java\t2023-03-24 13:28:12.172378688 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( 1.4.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (fraction.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:14.352370393 +0100\n+++ /tmp/tmp01k3ssxk.java\t2023-03-24 13:28:14.356370376 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (fraction.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (336.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:16.312362934 +0100\n+++ /tmp/tmp9h6dz6z6.java\t2023-03-24 13:28:16.312362934 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (336.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (-1..length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:18.080356208 +0100\n+++ /tmp/tmpxsxyevc7.java\t2023-03-24 13:28:18.080356208 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (-1..length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (department.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:19.848349482 +0100\n+++ /tmp/tmpp6h0t91v.java\t2023-03-24 13:28:19.848349482 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (department.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (volume.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:21.368343699 +0100\n+++ /tmp/tmpgi2_be5_.java\t2023-03-24 13:28:21.368343699 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (volume.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (lush.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:22.956337657 +0100\n+++ /tmp/tmp74ovcmc8.java\t2023-03-24 13:28:22.956337657 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (lush.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (Dem.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:24.576331494 +0100\n+++ /tmp/tmpfqmqpoe1.java\t2023-03-24 13:28:24.576331494 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Dem.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (compression == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:26.228325209 +0100\n+++ /tmp/tmp4i8b4y8v.java\t2023-03-24 13:28:26.228325209 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (compression == null) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (ufacturer_ == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:27.944318679 +0100\n+++ /tmp/tmpceeb06ny.java\t2023-03-24 13:28:27.948318666 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ufacturer_ == null) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if ( ROUND.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:29.772311728 +0100\n+++ /tmp/tmp19frongn.java\t2023-03-24 13:28:29.776311712 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( ROUND.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if ( sz.length < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:31.636304637 +0100\n+++ /tmp/tmpend9xffl.java\t2023-03-24 13:28:31.636304637 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( sz.length < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (ited.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:33.660296936 +0100\n+++ /tmp/tmpozkqdea6.java\t2023-03-24 13:28:33.660296936 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ited.length == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if ( jsonWriter.length < 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:35.616289498 +0100\n+++ /tmp/tmpmh5lgmbq.java\t2023-03-24 13:28:35.616289498 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jsonWriter.length < 2) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (root == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:37.708281540 +0100\n+++ /tmp/tmpd_pd9ubs.java\t2023-03-24 13:28:37.708281540 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (root == null) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (resourceCount == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:39.844273417 +0100\n+++ /tmp/tmpjviqnu2n.java\t2023-03-24 13:28:39.844273417 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (resourceCount == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if ( pom == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:42.044265049 +0100\n+++ /tmp/tmpnml2bygk.java\t2023-03-24 13:28:42.048265036 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( pom == null) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (min < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:44.348256289 +0100\n+++ /tmp/tmpdbfes8yu.java\t2023-03-24 13:28:44.348256289 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (min < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if ( shortcut.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:46.384248544 +0100\n+++ /tmp/tmpm4pxnlnr.java\t2023-03-24 13:28:46.384248544 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( shortcut.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (forest == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:48.160241793 +0100\n+++ /tmp/tmpqbwexl6c.java\t2023-03-24 13:28:48.160241793 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (forest == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (indexes == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:50.120234340 +0100\n+++ /tmp/tmpjmn7g2o0.java\t2023-03-24 13:28:50.120234340 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (indexes == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if ( getParamCount == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:51.764228086 +0100\n+++ /tmp/tmpuxuoze4c.java\t2023-03-24 13:28:51.764228086 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( getParamCount == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (guard == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:53.372221974 +0100\n+++ /tmp/tmp4e7gfge_.java\t2023-03-24 13:28:53.376221957 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (guard == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (department == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:55.004215769 +0100\n+++ /tmp/tmphhj_lxbu.java\t2023-03-24 13:28:55.004215769 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (department == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (child == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:56.636209564 +0100\n+++ /tmp/tmpo27e7l_m.java\t2023-03-24 13:28:56.636209564 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (child == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (preserve == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:28:58.320203162 +0100\n+++ /tmp/tmpgsntoi2g.java\t2023-03-24 13:28:58.320203162 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (preserve == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if ( currency == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:00.100196392 +0100\n+++ /tmp/tmpt4x9czq9.java\t2023-03-24 13:29:00.100196392 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( currency == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if ( getParamCount == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:01.924189460 +0100\n+++ /tmp/tmpv3cxgotq.java\t2023-03-24 13:29:01.924189460 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( getParamCount == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if ( wrote == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:03.864182083 +0100\n+++ /tmp/tmp6m3kdzim.java\t2023-03-24 13:29:03.864182083 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( wrote == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (kill == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:05.840174573 +0100\n+++ /tmp/tmp3k8pcutf.java\t2023-03-24 13:29:05.844174558 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (kill == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:08.044166193 +0100\n+++ /tmp/tmp3kgonsl9.java\t2023-03-24 13:29:08.044166193 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (isEmpty()) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if ( wrote == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:10.240157848 +0100\n+++ /tmp/tmpfhk9rv69.java\t2023-03-24 13:29:10.240157848 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( wrote == null) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if ( ee == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:12.420149562 +0100\n+++ /tmp/tmpnxhrt4i_.java\t2023-03-24 13:29:12.424149546 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( ee == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if ( fp == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:14.652141078 +0100\n+++ /tmp/tmp2p4rk3fh.java\t2023-03-24 13:29:14.652141078 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( fp == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (OrEqualTo.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:16.888132579 +0100\n+++ /tmp/tmpyklmalii.java\t2023-03-24 13:29:16.888132579 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (OrEqualTo.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (cost < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:18.756125480 +0100\n+++ /tmp/tmp7yx239sl.java\t2023-03-24 13:29:18.756125480 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (cost < 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if ( kill == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:20.544118685 +0100\n+++ /tmp/tmpkd2zpkbr.java\t2023-03-24 13:29:20.544118685 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( kill == null) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if ( sz.length < 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:22.448111449 +0100\n+++ /tmp/tmpruinzs7i.java\t2023-03-24 13:29:22.452111433 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( sz.length < 2) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (latex == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:24.256104576 +0100\n+++ /tmp/tmp4176z_sc.java\t2023-03-24 13:29:24.256104576 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (latex == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if ( keyName == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:25.908098301 +0100\n+++ /tmp/tmpacp52zsu.java\t2023-03-24 13:29:25.908098301 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( keyName == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (satisfied == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:27.472092357 +0100\n+++ /tmp/tmpmhnj805l.java\t2023-03-24 13:29:27.472092357 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (satisfied == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (baz == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:29.132086048 +0100\n+++ /tmp/tmpcn6jjbvh.java\t2023-03-24 13:29:29.132086048 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (baz == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (-1. == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:30.812079666 +0100\n+++ /tmp/tmpbg6jdyin.java\t2023-03-24 13:29:30.816079649 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (-1. == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (alue == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:34.628065168 +0100\n+++ /tmp/tmp43_nl5i8.java\t2023-03-24 13:29:34.628065168 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (alue == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if ( getStatusCode == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:36.608057645 +0100\n+++ /tmp/tmpx5_1_twx.java\t2023-03-24 13:29:36.608057645 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( getStatusCode == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (CallExpression == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:38.616050013 +0100\n+++ /tmp/tmphyegcfia.java\t2023-03-24 13:29:38.616050013 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (CallExpression == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (Gray.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:40.692042126 +0100\n+++ /tmp/tmpxvehpuez.java\t2023-03-24 13:29:40.692042126 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (Gray.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (ountry == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:42.852033920 +0100\n+++ /tmp/tmpfkvp1qn4.java\t2023-03-24 13:29:42.852033920 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ountry == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (lee == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:44.992025793 +0100\n+++ /tmp/tmpkaa51obe.java\t2023-03-24 13:29:44.992025793 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (lee == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if ( Atom == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:47.160017557 +0100\n+++ /tmp/tmpu706_0a0.java\t2023-03-24 13:29:47.160017557 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( Atom == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (ToCheck.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:49.344009259 +0100\n+++ /tmp/tmp6xd6j6is.java\t2023-03-24 13:29:49.344009259 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (ToCheck.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (gate == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:51.284001890 +0100\n+++ /tmp/tmp36m6339v.java\t2023-03-24 13:29:51.284001890 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (gate == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (highlight == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:53.155994781 +0100\n+++ /tmp/tmpjqk_605i.java\t2023-03-24 13:29:53.159994764 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (highlight == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (compression == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:55.043987610 +0100\n+++ /tmp/tmpv2bkq6ip.java\t2023-03-24 13:29:55.043987610 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (compression == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if ( sz.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:56.759981091 +0100\n+++ /tmp/tmph43820qe.java\t2023-03-24 13:29:56.763981078 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( sz.length < 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if ( 65535.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:58.343975075 +0100\n+++ /tmp/tmpzlo9f_4n.java\t2023-03-24 13:29:58.347975063 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( 65535.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (volume == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:29:59.795969560 +0100\n+++ /tmp/tmps1lg_ybc.java\t2023-03-24 13:29:59.795969560 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (volume == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (\u4e14 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:01.343963684 +0100\n+++ /tmp/tmpqv6nd91a.java\t2023-03-24 13:30:01.343963684 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (\u4e14 == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if ( jsonWriter.length < 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:02.871957881 +0100\n+++ /tmp/tmp4z1nhrdg.java\t2023-03-24 13:30:02.871957881 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jsonWriter.length < 3) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if ( 1.4.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:04.443951910 +0100\n+++ /tmp/tmp1gfemmu6.java\t2023-03-24 13:30:04.447951893 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( 1.4.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (lush == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:05.983946063 +0100\n+++ /tmp/tmpyl3ibdhd.java\t2023-03-24 13:30:05.983946063 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (lush == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if ( kill == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:07.547940121 +0100\n+++ /tmp/tmpdn6s1aiv.java\t2023-03-24 13:30:07.547940121 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( kill == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (dist == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:09.123934137 +0100\n+++ /tmp/tmpqbkug5m7.java\t2023-03-24 13:30:09.123934137 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if (dist == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if ( txt.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:10.607928505 +0100\n+++ /tmp/tmpyu0snp07.java\t2023-03-24 13:30:10.607928505 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( txt.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if ( sz.length == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:12.211922414 +0100\n+++ /tmp/tmpv7lq1t7t.java\t2023-03-24 13:30:12.211922414 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( sz.length == 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if ( pipes == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:13.727916657 +0100\n+++ /tmp/tmprg65rhli.java\t2023-03-24 13:30:13.727916657 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( pipes == 0) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if ( jsonWriter.length < 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/possible_change/java_programs/POSSIBLE_CHANGE.java\t2023-03-24 13:30:15.335910549 +0100\n+++ /tmp/tmpa77370n9.java\t2023-03-24 13:30:15.335910549 +0100\n@@ -12,11 +12,11 @@\n public class POSSIBLE_CHANGE {\n     public static int possible_change(int[] coins, int total) {\n         if (total == 0) {\n             return 1;\n         }\n-        if (total < 0) {\n+if ( jsonWriter.length < 1) {\n             return 0;\n         }\n \n         int first = coins[0];\n         int[] rest = Arrays.copyOfRange(coins, 1, coins.length);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (total < 0 ||coins.length==0) {"
    },
    "powerset": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:22.607882943 +0100\n+++ /tmp/tmpozs_o67k.java\t2023-03-24 13:30:22.607882943 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:24.255876686 +0100\n+++ /tmp/tmpi892n3im.java\t2023-03-24 13:30:24.255876686 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:25.843870658 +0100\n+++ /tmp/tmpb76d443q.java\t2023-03-24 13:30:25.843870658 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:27.423864660 +0100\n+++ /tmp/tmp14re9zaw.java\t2023-03-24 13:30:27.423864660 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (!OutputStream.class.isInstance(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:28.959858828 +0100\n+++ /tmp/tmpgx7zu6gj.java\t2023-03-24 13:30:28.959858828 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!OutputStream.class.isInstance(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:30.559852754 +0100\n+++ /tmp/tmphxwjpbhp.java\t2023-03-24 13:30:30.563852737 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:32.203846512 +0100\n+++ /tmp/tmpn63lqoe3.java\t2023-03-24 13:30:32.203846512 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (!this.subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:33.947839892 +0100\n+++ /tmp/tmpogv2ylsg.java\t2023-03-24 13:30:33.947839892 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!this.subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:35.719833166 +0100\n+++ /tmp/tmpyvt79dl9.java\t2023-03-24 13:30:35.719833166 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:37.455826579 +0100\n+++ /tmp/tmpb8qn5nag.java\t2023-03-24 13:30:37.455826579 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:39.351819380 +0100\n+++ /tmp/tmpnznrmp_2.java\t2023-03-24 13:30:39.351819380 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:41.407811577 +0100\n+++ /tmp/tmp8j9hgph8.java\t2023-03-24 13:30:41.407811577 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_building) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:43.431803898 +0100\n+++ /tmp/tmps44kun99.java\t2023-03-24 13:30:43.431803898 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_building) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :Errors) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:45.507796016 +0100\n+++ /tmp/tmp_proj4vs.java\t2023-03-24 13:30:45.511796004 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :Errors) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:47.631787956 +0100\n+++ /tmp/tmp13hnddau.java\t2023-03-24 13:30:47.635787943 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_culation) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:49.647780305 +0100\n+++ /tmp/tmpu75fre9r.java\t2023-03-24 13:30:49.647780305 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_culation) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (!subset.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:51.391773688 +0100\n+++ /tmp/tmpx_m8r44a.java\t2023-03-24 13:30:51.395773671 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:53.187766871 +0100\n+++ /tmp/tmpvpi5zzbi.java\t2023-03-24 13:30:53.187766871 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_ointment) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:54.971760104 +0100\n+++ /tmp/tmpdltj69pg.java\t2023-03-24 13:30:54.971760104 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_ointment) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u30ab) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:56.727753441 +0100\n+++ /tmp/tmp4nbz94k4.java\t2023-03-24 13:30:56.727753441 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u30ab) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u89c8) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:58.319747398 +0100\n+++ /tmp/tmpq45is2d8.java\t2023-03-24 13:30:58.323747385 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u89c8) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u6751) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:30:59.755741951 +0100\n+++ /tmp/tmp08wov8u0.java\t2023-03-24 13:30:59.755741951 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u6751) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_\uc382) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:01.291736122 +0100\n+++ /tmp/tmp66p8vtd9.java\t2023-03-24 13:31:01.291736122 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_\uc382) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_\uab26) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:02.779730475 +0100\n+++ /tmp/tmpfkzjd841.java\t2023-03-24 13:31:02.779730475 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_\uab26) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:04.387724377 +0100\n+++ /tmp/tmphxjaexho.java\t2023-03-24 13:31:04.391724361 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:06.039718109 +0100\n+++ /tmp/tmp20s76_38.java\t2023-03-24 13:31:06.039718109 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (!OutputStream.class.isInstance(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:07.755711598 +0100\n+++ /tmp/tmplsxmcz2h.java\t2023-03-24 13:31:07.755711598 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!OutputStream.class.isInstance(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : phone) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:09.431705239 +0100\n+++ /tmp/tmp047rvf_k.java\t2023-03-24 13:31:09.431705239 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : phone) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:11.271698259 +0100\n+++ /tmp/tmptljmrq19.java\t2023-03-24 13:31:11.271698259 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (!FileUtils.canRead(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:13.163691079 +0100\n+++ /tmp/tmp_7y49br1.java\t2023-03-24 13:31:13.163691079 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!FileUtils.canRead(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (!100.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:15.171683462 +0100\n+++ /tmp/tmpkd_w2w6m.java\t2023-03-24 13:31:15.171683462 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!100.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:17.263675526 +0100\n+++ /tmp/tmpl5ccz9nu.java\t2023-03-24 13:31:17.263675526 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (! \"\\\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:19.399667423 +0100\n+++ /tmp/tmp80_5jn55.java\t2023-03-24 13:31:19.399667423 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (! \"\\\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (!100.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:21.511659412 +0100\n+++ /tmp/tmpn4p82mfn.java\t2023-03-24 13:31:21.511659412 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!100.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (!\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:23.635651358 +0100\n+++ /tmp/tmpgj48lm8a.java\t2023-03-24 13:31:23.635651358 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:25.571644012 +0100\n+++ /tmp/tmpp1213qgm.java\t2023-03-24 13:31:25.575644000 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:27.391637109 +0100\n+++ /tmp/tmpnx0thkji.java\t2023-03-24 13:31:27.391637109 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:29.211630209 +0100\n+++ /tmp/tmp9wslgum3.java\t2023-03-24 13:31:29.215630193 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (!subset) { if (to_add.contains(first)) { to_add.addAll(subset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:31.019623351 +0100\n+++ /tmp/tmpep6tms2c.java\t2023-03-24 13:31:31.023623334 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { if (to_add.contains(first)) { to_add.addAll(subset); }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (to_add.size() == 1) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:32.823616509 +0100\n+++ /tmp/tmprvcixolo.java\t2023-03-24 13:31:32.823616509 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (to_add.size() == 1) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:34.555609941 +0100\n+++ /tmp/tmpzk3kmft6.java\t2023-03-24 13:31:34.555609941 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:36.091604116 +0100\n+++ /tmp/tmpuq50uql0.java\t2023-03-24 13:31:36.091604116 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:37.591598428 +0100\n+++ /tmp/tmpamk5b_iy.java\t2023-03-24 13:31:37.591598428 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :Errors) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:39.135592571 +0100\n+++ /tmp/tmpfhlui1zj.java\t2023-03-24 13:31:39.139592554 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :Errors) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:40.723586547 +0100\n+++ /tmp/tmpd5gl823o.java\t2023-03-24 13:31:40.727586535 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset :subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!this.subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:42.391580222 +0100\n+++ /tmp/tmpas9ezr_v.java\t2023-03-24 13:31:42.395580209 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!this.subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:44.047573945 +0100\n+++ /tmp/tmp51b80c13.java\t2023-03-24 13:31:44.047573945 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_culation) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:45.683567739 +0100\n+++ /tmp/tmppd89gme9.java\t2023-03-24 13:31:45.683567739 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_culation) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (to_add.size() == 1) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:47.463560992 +0100\n+++ /tmp/tmp3_g0kvon.java\t2023-03-24 13:31:47.463560992 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (to_add.size() == 1) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (to_add.size() == 1) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:49.131554665 +0100\n+++ /tmp/tmpkksoygjg.java\t2023-03-24 13:31:49.131554665 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (to_add.size() == 1) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (!subset.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:51.067547327 +0100\n+++ /tmp/tmph869z67o.java\t2023-03-24 13:31:51.067547327 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\uc382) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:53.139539468 +0100\n+++ /tmp/tmpkq1mlrh0.java\t2023-03-24 13:31:53.143539456 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\uc382) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ointment) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:55.135531903 +0100\n+++ /tmp/tmp68r4ax9p.java\t2023-03-24 13:31:55.135531903 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ointment) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\uab26) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:57.095524471 +0100\n+++ /tmp/tmpvn8rcc_h.java\t2023-03-24 13:31:57.099524454 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\uab26) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ testMulti) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:31:59.175516586 +0100\n+++ /tmp/tmpovpqltjh.java\t2023-03-24 13:31:59.175516586 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ testMulti) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u6751) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:01.139509140 +0100\n+++ /tmp/tmpnqce1jlc.java\t2023-03-24 13:32:01.139509140 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u6751) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u89c8) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:02.911502422 +0100\n+++ /tmp/tmphb6d5xsb.java\t2023-03-24 13:32:02.911502422 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u89c8) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u59af) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:04.711495598 +0100\n+++ /tmp/tmpyt1ooz_t.java\t2023-03-24 13:32:04.711495598 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u59af) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : phone) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:06.291489608 +0100\n+++ /tmp/tmpfw4mvffe.java\t2023-03-24 13:32:06.295489593 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : phone) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_building) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:07.771483997 +0100\n+++ /tmp/tmpa6vb1mjh.java\t2023-03-24 13:32:07.771483997 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_building) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ maxval) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:09.287478251 +0100\n+++ /tmp/tmph3hxjty2.java\t2023-03-24 13:32:09.291478236 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ maxval) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_caches) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:10.827472411 +0100\n+++ /tmp/tmp01it9tpy.java\t2023-03-24 13:32:10.835472383 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_caches) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u03fd) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:12.411466409 +0100\n+++ /tmp/tmp88ygrech.java\t2023-03-24 13:32:12.411466409 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u03fd) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u30ab) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:14.007460359 +0100\n+++ /tmp/tmp8f39cl56.java\t2023-03-24 13:32:14.007460359 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u30ab) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u8137) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:15.703453930 +0100\n+++ /tmp/tmp22eo4x79.java\t2023-03-24 13:32:15.703453930 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u8137) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u91f1) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:17.379447578 +0100\n+++ /tmp/tmp2t9a_9_4.java\t2023-03-24 13:32:17.383447563 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u91f1) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\ud655) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:19.135440922 +0100\n+++ /tmp/tmpcjq38lo1.java\t2023-03-24 13:32:19.135440922 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\ud655) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u041b) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:20.955434024 +0100\n+++ /tmp/tmpcu5a52br.java\t2023-03-24 13:32:20.955434024 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u041b) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u0cba) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:22.979426352 +0100\n+++ /tmp/tmpnou7b0xq.java\t2023-03-24 13:32:22.983426335 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u0cba) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ Occ) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:25.003418679 +0100\n+++ /tmp/tmpwkjjydc0.java\t2023-03-24 13:32:25.027418588 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ Occ) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u9709) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:27.011411069 +0100\n+++ /tmp/tmpy4eta003.java\t2023-03-24 13:32:27.011411069 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u9709) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ xhr) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:29.031403416 +0100\n+++ /tmp/tmptvdzd98_.java\t2023-03-24 13:32:29.035403400 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ xhr) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ weblogic) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:31.103395564 +0100\n+++ /tmp/tmp3nps0cwe.java\t2023-03-24 13:32:31.107395548 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ weblogic) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u74ca) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:32.907388727 +0100\n+++ /tmp/tmp738bt1bm.java\t2023-03-24 13:32:32.911388711 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u74ca) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u8ba2) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:34.691381966 +0100\n+++ /tmp/tmplma2cm5m.java\t2023-03-24 13:32:34.691381966 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u8ba2) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u06d9) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:36.223376160 +0100\n+++ /tmp/tmp86790g0n.java\t2023-03-24 13:32:36.223376160 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u06d9) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u16cb) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:37.723370474 +0100\n+++ /tmp/tmp06aaneki.java\t2023-03-24 13:32:37.723370474 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u16cb) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ wag) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:39.279364578 +0100\n+++ /tmp/tmpusroschi.java\t2023-03-24 13:32:39.279364578 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_ wag) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u8e0f) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:40.835358685 +0100\n+++ /tmp/tmpwxyaga18.java\t2023-03-24 13:32:40.835358685 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.contains(subset)) { to_add.add(first); for (ArrayList subset : rest_\u8e0f) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:42.459352531 +0100\n+++ /tmp/tmpxpw0h1b1.java\t2023-03-24 13:32:42.467352498 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:44.067346435 +0100\n+++ /tmp/tmp5gdlen41.java\t2023-03-24 13:32:44.071346422 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:45.815339812 +0100\n+++ /tmp/tmpqs2l4jmw.java\t2023-03-24 13:32:45.815339812 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (!FileUtils.canRead(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:47.555333218 +0100\n+++ /tmp/tmpzzn2mrvw.java\t2023-03-24 13:32:47.555333218 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!FileUtils.canRead(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_culation) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:49.343326446 +0100\n+++ /tmp/tmp5hod5fht.java\t2023-03-24 13:32:49.343326446 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_culation) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:51.147319612 +0100\n+++ /tmp/tmpu2tcz66f.java\t2023-03-24 13:32:51.147319612 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : rest_subsets) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:53.147312034 +0100\n+++ /tmp/tmpulegxdem.java\t2023-03-24 13:32:53.147312034 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:55.251304060 +0100\n+++ /tmp/tmp6i3d4l2n.java\t2023-03-24 13:32:55.251304060 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : rest_mgr) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:57.355296089 +0100\n+++ /tmp/tmp8b_y7d67.java\t2023-03-24 13:32:57.355296089 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!to_add.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u6751) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:32:59.499287969 +0100\n+++ /tmp/tmptubzwjaw.java\t2023-03-24 13:32:59.499287969 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_\u6751) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_ointment) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:01.611279968 +0100\n+++ /tmp/tmptanrmvr9.java\t2023-03-24 13:33:01.611279968 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_ointment) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (!100.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:03.407273161 +0100\n+++ /tmp/tmpgw_booub.java\t2023-03-24 13:33:03.407273161 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!100.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); // TODO }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:05.187266421 +0100\n+++ /tmp/tmpwdeysa8i.java\t2023-03-24 13:33:05.187266421 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); // TODO }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (! \"\\\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:07.051259360 +0100\n+++ /tmp/tmpslk8ewi2.java\t2023-03-24 13:33:07.051259360 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (! \"\\\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (!\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:08.647253311 +0100\n+++ /tmp/tmpqpuklra2.java\t2023-03-24 13:33:08.647253311 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!\"\".equals(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:10.111247768 +0100\n+++ /tmp/tmp4x872gfn.java\t2023-03-24 13:33:10.111247768 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (subset) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (!100.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:11.639241980 +0100\n+++ /tmp/tmpbf4vb06f.java\t2023-03-24 13:33:11.639241980 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!100.isEmpty()) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset);\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (!this.subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); // TODO }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:13.155236238 +0100\n+++ /tmp/tmpbobwrh2g.java\t2023-03-24 13:33:13.155236238 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!this.subset) { to_add.add(first); for (ArrayList subset : this.subset) { to_add.addAll(subset); // TODO }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (!subset.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:14.699230387 +0100\n+++ /tmp/tmpq11qd4_o.java\t2023-03-24 13:33:14.699230387 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (!subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); // TODO }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:16.299224330 +0100\n+++ /tmp/tmp8pgscy6y.java\t2023-03-24 13:33:16.299224330 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!subset) { to_add.add(first); for (ArrayList subset : rest_indicator) { to_add.addAll(subset); // TODO }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (!100.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/powerset/java_programs/POWERSET.java\t2023-03-24 13:33:17.987217936 +0100\n+++ /tmp/tmp7_4exb39.java\t2023-03-24 13:33:17.987217936 +0100\n@@ -18,17 +18,11 @@\n             ArrayList rest = arr;\n             ArrayList<ArrayList> rest_subsets = powerset(rest);\n \n             ArrayList<ArrayList> output = new ArrayList<ArrayList>(100);\n             ArrayList to_add = new ArrayList(100);\n-            to_add.add(first);\n-            for (ArrayList subset : rest_subsets) {\n-                to_add.addAll(subset);\n-            }\n-            output.add(to_add);\n-\n-            return output;\n+if (!100.contains(subset)) { to_add.add(first); for (ArrayList subset : subset) { to_add.addAll(subset); // TODO }\n         } else {\n             ArrayList empty_set = new ArrayList<ArrayList>();\n             empty_set.add(new ArrayList());\n             return empty_set;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (ArrayList subset : rest_subsets) { ArrayList r = new ArrayList(); r.add(first); r.addAll(subset); to_add.add(r); } output.addAll(to_add); rest_subsets.addAll(output); return rest_subsets;"
    },
    "shortest_path_length": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "new Integer(length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:22.803199695 +0100\n+++ /tmp/tmpbx7fi37z.java\t2023-03-24 13:33:22.855199497 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:24.799192135 +0100\n+++ /tmp/tmpz0wj5ye6.java\t2023-03-24 13:33:24.799192135 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "unvisitedNodes.get(nextnode) + length_by_edge.size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:26.759184712 +0100\n+++ /tmp/tmp74ckn_hj.java\t2023-03-24 13:33:26.767184679 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + length_by_edge.size());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode), Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:28.747177182 +0100\n+++ /tmp/tmpgvfqnq9q.java\t2023-03-24 13:33:28.747177182 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode), Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:30.911168987 +0100\n+++ /tmp/tmp4lkb4516.java\t2023-03-24 13:33:30.915168970 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "\"e_\" + length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:32.983161140 +0100\n+++ /tmp/tmp6gtybi_1.java\t2023-03-24 13:33:32.987161123 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+\"e_\" + length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "(int) unvisitedNodes.get(nextnode) + length_by_edge.size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:34.823154172 +0100\n+++ /tmp/tmp_vuc4q1q.java\t2023-03-24 13:33:34.823154172 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.get(nextnode) + length_by_edge.size());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode), Integer.MAX_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:36.563147581 +0100\n+++ /tmp/tmp1i44esor.java\t2023-03-24 13:33:36.563147581 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode), Integer.MAX_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "new Integer(unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:38.415140568 +0100\n+++ /tmp/tmpkzwpldqk.java\t2023-03-24 13:33:38.415140568 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "new Integer(int.MAX_VALUE), unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:39.935134815 +0100\n+++ /tmp/tmpvwu9chdb.java\t2023-03-24 13:33:39.939134799 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(int.MAX_VALUE), unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "new Integer(int.MAX_VALUE), unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:41.507128859 +0100\n+++ /tmp/tmpba8fk86e.java\t2023-03-24 13:33:41.507128859 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(int.MAX_VALUE), unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:43.067122952 +0100\n+++ /tmp/tmpujzx_59j.java\t2023-03-24 13:33:43.071122939 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "Math.max(length, unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:46.799108823 +0100\n+++ /tmp/tmppw8sqv78.java\t2023-03-24 13:33:46.803108807 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.max(length, unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "(int) (length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:48.479102459 +0100\n+++ /tmp/tmpnwpu8fqk.java\t2023-03-24 13:33:48.479102459 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) (length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "unvisitedNodes.get(nextnode))) { unvisitedNodes.get(nextnode)+\"]\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:50.143096159 +0100\n+++ /tmp/tmp03l94840.java\t2023-03-24 13:33:50.143096159 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode))) { unvisitedNodes.get(nextnode)+\"]\");\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "(int) unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:51.827089782 +0100\n+++ /tmp/tmp3_79ccrs.java\t2023-03-24 13:33:51.827089782 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode), Integer.MIN_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:53.667082818 +0100\n+++ /tmp/tmplevgjlkm.java\t2023-03-24 13:33:53.667082818 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode), Integer.MIN_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode), indexList.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:55.687075171 +0100\n+++ /tmp/tmpcya0oja0.java\t2023-03-24 13:33:55.687075171 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode), indexList.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "+ length_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:57.771067280 +0100\n+++ /tmp/tmpv7fedtbq.java\t2023-03-24 13:33:57.771067280 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n++ length_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "(int) Math.min(length, unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:33:59.831059481 +0100\n+++ /tmp/tmp05t_p_q7.java\t2023-03-24 13:33:59.831059481 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) Math.min(length, unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "Integer.MAX_VALUE - unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:01.975051364 +0100\n+++ /tmp/tmpr09l539z.java\t2023-03-24 13:34:01.975051364 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE - unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "Math.max(length, unvisitedNodes.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:04.099043323 +0100\n+++ /tmp/tmp3mmwghrd.java\t2023-03-24 13:34:04.099043323 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.max(length, unvisitedNodes.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "Integer.MAX_VALUE, Integer.MIN_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:06.079035827 +0100\n+++ /tmp/tmpsk00089x.java\t2023-03-24 13:34:06.083035809 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE, Integer.MIN_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "new Integer(length_by_edge.get(Arrays.asList(node)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:07.991028589 +0100\n+++ /tmp/tmpu07kvgkx.java\t2023-03-24 13:34:07.991028589 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(length_by_edge.get(Arrays.asList(node)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode), Integer.MIN_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:09.871021472 +0100\n+++ /tmp/tmpyauemvol.java\t2023-03-24 13:34:09.875021457 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode), Integer.MIN_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "Math.min(length, unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:11.639014779 +0100\n+++ /tmp/tmp6qvh6nyt.java\t2023-03-24 13:34:11.639014779 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(length, unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "new Integer(unvisitedNodes.get(nextnode) + 1, Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:13.387008162 +0100\n+++ /tmp/tmpm3taf_sr.java\t2023-03-24 13:34:13.387008162 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(unvisitedNodes.get(nextnode) + 1, Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "Integer.MIN_VALUE, Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:14.975002151 +0100\n+++ /tmp/tmp6xr25uev.java\t2023-03-24 13:34:14.979002136 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MIN_VALUE, Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode), unvisitedNodes.get(index)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:16.542996213 +0100\n+++ /tmp/tmp87zr4wll.java\t2023-03-24 13:34:16.542996213 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode), unvisitedNodes.get(index)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "len_by_edge.get(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:18.066990444 +0100\n+++ /tmp/tmp1y88g0k3.java\t2023-03-24 13:34:18.066990444 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+len_by_edge.get(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "Math.min(length, unvisitedNodes.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:19.590984676 +0100\n+++ /tmp/tmp8r2w5ysv.java\t2023-03-24 13:34:19.590984676 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(length, unvisitedNodes.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "Integer.MAX_VALUE, Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:21.134978833 +0100\n+++ /tmp/tmp8efu58cr.java\t2023-03-24 13:34:21.138978816 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE, Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "unvisitedNodes.get(nextnode)){ unvisitedNodes.get(nextnode)+\"]\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:22.794972550 +0100\n+++ /tmp/tmpuxxfqc3t.java\t2023-03-24 13:34:22.794972550 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode)){ unvisitedNodes.get(nextnode)+\"]\");\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1, Integer.MAX_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:24.378966552 +0100\n+++ /tmp/tmpt2fajenh.java\t2023-03-24 13:34:24.378966552 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1, Integer.MAX_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "unvisitedNodes.get(nextnode) + i);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:26.066960165 +0100\n+++ /tmp/tmp2jxgjhqb.java\t2023-03-24 13:34:26.066960165 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + i);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "Integer.MAX_VALUE, unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:27.898953229 +0100\n+++ /tmp/tmp534ar9nh.java\t2023-03-24 13:34:27.898953229 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE, unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "Math.min(length, unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:29.718946343 +0100\n+++ /tmp/tmpaeir2vce.java\t2023-03-24 13:34:29.718946343 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(length, unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "(int) unvisitedNodes.get(nextnode) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:31.714938789 +0100\n+++ /tmp/tmpzj45alwa.java\t2023-03-24 13:34:31.714938789 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.get(nextnode) + 1;\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "(int) unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:33.738931126 +0100\n+++ /tmp/tmpj_kangrf.java\t2023-03-24 13:34:33.742931114 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "Math.max(length, unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:38.690912385 +0100\n+++ /tmp/tmpk_ngxx67.java\t2023-03-24 13:34:38.690912385 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.max(length, unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1 );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:40.778904485 +0100\n+++ /tmp/tmpca4uucqq.java\t2023-03-24 13:34:40.778904485 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1 );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:42.618897519 +0100\n+++ /tmp/tmpd0m5ynws.java\t2023-03-24 13:34:42.618897519 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "new Integer(int.MAX_VALUE, Integer.MIN_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:44.478890483 +0100\n+++ /tmp/tmppdcqxhj6.java\t2023-03-24 13:34:44.478890483 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(int.MAX_VALUE, Integer.MIN_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "unvisitedNodes.get(nextnode) + length_by_edge.size();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:46.066884471 +0100\n+++ /tmp/tmp0mfk2y82.java\t2023-03-24 13:34:46.066884471 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + length_by_edge.size();\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "Integer.MAX_VALUE - unvisitedNodes.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:47.566878797 +0100\n+++ /tmp/tmpfdtfm9qs.java\t2023-03-24 13:34:47.570878780 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE - unvisitedNodes.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:51.262864814 +0100\n+++ /tmp/tmphkiuu1ju.java\t2023-03-24 13:34:51.262864814 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1;\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:52.874858713 +0100\n+++ /tmp/tmpf9mg4d5a.java\t2023-03-24 13:34:52.874858713 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "unvisitedNodes.get(nextnode + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:54.490852597 +0100\n+++ /tmp/tmp7aiyjo4f.java\t2023-03-24 13:34:54.494852583 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "new Integer(unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:56.162846272 +0100\n+++ /tmp/tmp_l_ybz1o.java\t2023-03-24 13:34:56.162846272 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "Integer.MAX_VALUE - unvisitedNodes.get(nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:57.882839763 +0100\n+++ /tmp/tmpiem1wsse.java\t2023-03-24 13:34:57.882839763 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE - unvisitedNodes.get(nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "unvisitedNodes.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:34:59.646833089 +0100\n+++ /tmp/tmpk3v7erus.java\t2023-03-24 13:34:59.646833089 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "new HashSet<>(Arrays.asList(node, nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:04.438814957 +0100\n+++ /tmp/tmp_vlpwj4p.java\t2023-03-24 13:35:04.438814957 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(Arrays.asList(node, nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "new Integer(int.MAX_VALUE, Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:06.466807283 +0100\n+++ /tmp/tmpgpge2c87.java\t2023-03-24 13:35:06.470807270 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(int.MAX_VALUE, Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "Math.max(length, unvisitedNodes.get(nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:08.578799293 +0100\n+++ /tmp/tmp0s4fqso3.java\t2023-03-24 13:35:08.578799293 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.max(length, unvisitedNodes.get(nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "unvisitedNodes.get(nextnode)+\"]\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:10.786790939 +0100\n+++ /tmp/tmpzrt0yqpv.java\t2023-03-24 13:35:10.786790939 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode)+\"]\");\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "new ArrayList<>(), unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:12.678783782 +0100\n+++ /tmp/tmpj3avpn5w.java\t2023-03-24 13:35:12.678783782 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new ArrayList<>(), unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "(int) unvisitedNodes.get(nextnode) + i);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:14.406777245 +0100\n+++ /tmp/tmpskry87qh.java\t2023-03-24 13:35:14.406777245 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.get(nextnode) + i);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "Boolean.valueOf(unvisitedNodes.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:16.154770630 +0100\n+++ /tmp/tmphpcygzvh.java\t2023-03-24 13:35:16.154770630 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Boolean.valueOf(unvisitedNodes.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "Math.min(unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:17.922763943 +0100\n+++ /tmp/tmpb5esharo.java\t2023-03-24 13:35:17.926763927 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Math.min(unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "unvisitedNodes.keySet().size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:19.802756829 +0100\n+++ /tmp/tmp0v3ash4m.java\t2023-03-24 13:35:19.802756829 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.keySet().size());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1) );",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:21.306751140 +0100\n+++ /tmp/tmpvn_bobzl.java\t2023-03-24 13:35:21.310751126 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1) );\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "unvisitedNodes.keySet().iterator().next());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:24.942737386 +0100\n+++ /tmp/tmph8nms4aj.java\t2023-03-24 13:35:24.942737386 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.keySet().iterator().next());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "(unvisitedNodes.get(nextnode) + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:26.466731621 +0100\n+++ /tmp/tmpbcwv8ldk.java\t2023-03-24 13:35:26.466731621 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(unvisitedNodes.get(nextnode) + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:28.038725674 +0100\n+++ /tmp/tmpf52cae8_.java\t2023-03-24 13:35:28.038725674 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "Short.MIN_VALUE, Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:29.526720045 +0100\n+++ /tmp/tmpwzzm1sip.java\t2023-03-24 13:35:29.530720029 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Short.MIN_VALUE, Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "Integer.MIN_VALUE, Integer.MIN_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:31.134713961 +0100\n+++ /tmp/tmpju64sk_h.java\t2023-03-24 13:35:31.134713961 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MIN_VALUE, Integer.MIN_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "unvisitedNodes.get(rowIndex + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:32.790707697 +0100\n+++ /tmp/tmp49klyv39.java\t2023-03-24 13:35:32.794707683 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(rowIndex + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "Integer.MAX_VALUE, Integer.MIN_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:34.350701797 +0100\n+++ /tmp/tmpuc_t0kdt.java\t2023-03-24 13:35:34.350701797 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE, Integer.MIN_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "unvisitedNodes.get(index + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:35.898695941 +0100\n+++ /tmp/tmpmxkgr8eq.java\t2023-03-24 13:35:35.902695927 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(index + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:37.478689966 +0100\n+++ /tmp/tmpxwhrp9yf.java\t2023-03-24 13:35:37.478689966 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "(int) unvisitedNodes.keySet().size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:39.054684005 +0100\n+++ /tmp/tmpgmw_04df.java\t2023-03-24 13:35:39.054684005 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+(int) unvisitedNodes.keySet().size());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "new Integer(int.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:40.558678315 +0100\n+++ /tmp/tmpvqfl91t1.java\t2023-03-24 13:35:40.558678315 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(int.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "unvisitedNodes.get(nextnode))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:42.090672520 +0100\n+++ /tmp/tmpjr1_gnr3.java\t2023-03-24 13:35:42.094672506 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode))));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 8);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:43.602666802 +0100\n+++ /tmp/tmp0860vkyd.java\t2023-03-24 13:35:43.606666787 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 8);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "new Integer(unvisitedNodes.get(nextnode)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:45.150660946 +0100\n+++ /tmp/tmpcju0cs8u.java\t2023-03-24 13:35:45.150660946 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(unvisitedNodes.get(nextnode)));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "unvisitedNodes.get(nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:46.650655274 +0100\n+++ /tmp/tmpz_uajzav.java\t2023-03-24 13:35:46.650655274 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "unvisitedNodes.get(nextnode)+\")\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:48.434648527 +0100\n+++ /tmp/tmpuzwrxxec.java\t2023-03-24 13:35:48.434648527 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode)+\")\");\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "unvisitedNodes.put(node, nextnode));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:50.258641627 +0100\n+++ /tmp/tmpsf8f1qeb.java\t2023-03-24 13:35:50.262641613 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.put(node, nextnode));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "unvisitedNodes.get(index + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:52.090634699 +0100\n+++ /tmp/tmp2x4eckry.java\t2023-03-24 13:35:52.090634699 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(index + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1 ));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:53.918627786 +0100\n+++ /tmp/tmpjqj542n0.java\t2023-03-24 13:35:53.918627786 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1 ));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "unvisitedNodes.keySet().iterator().next()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:57.662613626 +0100\n+++ /tmp/tmp1sxi__rh.java\t2023-03-24 13:35:57.662613626 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.keySet().iterator().next()));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "unvisitedNodes.get(node) + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:35:59.294607453 +0100\n+++ /tmp/tmpa966x5mi.java\t2023-03-24 13:35:59.294607453 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(node) + 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "unvisitedNodes.get(nextnode) + 1\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:00.882601448 +0100\n+++ /tmp/tmp4f55zf5s.java\t2023-03-24 13:36:00.886601432 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode) + 1\");\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "unvisitedNodes.get(nextnode)+\":\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:02.490595368 +0100\n+++ /tmp/tmpqji_ongw.java\t2023-03-24 13:36:02.490595368 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(nextnode)+\":\");\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "unvisitedNodes.get(next node + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:04.142589120 +0100\n+++ /tmp/tmpbvsn8ria.java\t2023-03-24 13:36:04.146589104 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+unvisitedNodes.get(next node + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "new HashSet<>(unvisitedNodes.values())));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:05.790582887 +0100\n+++ /tmp/tmpbfqk6be5.java\t2023-03-24 13:36:05.790582887 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(unvisitedNodes.values())));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "Integer.MIN_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:07.618575975 +0100\n+++ /tmp/tmpnv6x0bb3.java\t2023-03-24 13:36:07.618575975 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MIN_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "new HashSet<>(unvisitedNodes.values()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:09.510568820 +0100\n+++ /tmp/tmpvjtidy1p.java\t2023-03-24 13:36:09.510568820 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>(unvisitedNodes.values()));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "Integer.MAX_VALUE - 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:11.546561120 +0100\n+++ /tmp/tmpwjul91l0.java\t2023-03-24 13:36:11.546561120 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE - 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:16.402542759 +0100\n+++ /tmp/tmpujhwwho9.java\t2023-03-24 13:36:16.402542759 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "Integer.MAX_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:21.386523912 +0100\n+++ /tmp/tmpomyjem4w.java\t2023-03-24 13:36:21.386523912 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MAX_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "new Integer(index + 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:23.194517078 +0100\n+++ /tmp/tmpb3mv2l5g.java\t2023-03-24 13:36:23.198517062 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(index + 1));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "new Integer(MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:24.902510619 +0100\n+++ /tmp/tmptiotafle.java\t2023-03-24 13:36:24.926510528 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer(MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "graph.vertexSet().size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:26.786503496 +0100\n+++ /tmp/tmpy_ct4zdc.java\t2023-03-24 13:36:26.790503480 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+graph.vertexSet().size());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "Integer.MIN_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:28.586496689 +0100\n+++ /tmp/tmp2wf5gegj.java\t2023-03-24 13:36:28.586496689 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Integer.MIN_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "new Integer.MAX_VALUE));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:32.430482156 +0100\n+++ /tmp/tmp4wpru17l.java\t2023-03-24 13:36:32.434482140 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new Integer.MAX_VALUE));\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "Double.MIN_VALUE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:34.006476197 +0100\n+++ /tmp/tmp0j_g0ub_.java\t2023-03-24 13:36:34.006476197 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+Double.MIN_VALUE);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "\"COUNT(*)\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:35.530470435 +0100\n+++ /tmp/tmpalvkq91p.java\t2023-03-24 13:36:35.534470421 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+\"COUNT(*)\");\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "new HashSet<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:37.114464446 +0100\n+++ /tmp/tmph6t37rym.java\t2023-03-24 13:36:37.114464446 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+new HashSet<>());\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "n - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_length/java_programs/SHORTEST_PATH_LENGTH.java\t2023-03-24 13:36:38.754458247 +0100\n+++ /tmp/tmpgfvsxsbj.java\t2023-03-24 13:36:38.754458247 +0100\n@@ -33,11 +33,11 @@\n                 if (unvisitedNodes.get(nextnode) == null) {\n                     unvisitedNodes.put(nextnode, Integer.MAX_VALUE);\n                 }\n \n                 unvisitedNodes.put(nextnode, Math.min(unvisitedNodes.get(nextnode),\n-                        unvisitedNodes.get(nextnode) + length_by_edge.get(Arrays.asList(node, nextnode))));\n+n - 1);\n             }\n         }\n \n         return Integer.MAX_VALUE;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "distance + length_by_edge.get(Arrays.asList(node, nextnode))));"
    },
    "sieve": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (this.max > n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:36:42.382444530 +0100\n+++ /tmp/tmppu4ac9ay.java\t2023-03-24 13:36:42.434444334 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (n <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:36:44.318437212 +0100\n+++ /tmp/tmp508djt7q.java\t2023-03-24 13:36:44.318437212 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (this.max!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:36:49.042419353 +0100\n+++ /tmp/tmp956h4vu3.java\t2023-03-24 13:36:49.042419353 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (this.max > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:36:51.206411172 +0100\n+++ /tmp/tmphczilzyb.java\t2023-03-24 13:36:51.206411172 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (this.max!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:36:53.382402945 +0100\n+++ /tmp/tmpustn_dki.java\t2023-03-24 13:36:53.382402945 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (n >= 0 && n <= max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:36:55.614394509 +0100\n+++ /tmp/tmphdkb2bh1.java\t2023-03-24 13:36:55.618394493 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n >= 0 && n <= max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (Math.abs(n) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:36:59.930378194 +0100\n+++ /tmp/tmpqr_g97q0.java\t2023-03-24 13:36:59.930378194 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(n) > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (Math.abs(n) > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:04.190362091 +0100\n+++ /tmp/tmpb7017t5_.java\t2023-03-24 13:37:04.190362091 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(n) > max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (this.rng.nextDouble() < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:07.742348665 +0100\n+++ /tmp/tmp93lb88ok.java\t2023-03-24 13:37:07.742348665 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.rng.nextDouble() < 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (this.max!= n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:09.354342572 +0100\n+++ /tmp/tmps5hcuyuk.java\t2023-03-24 13:37:09.354342572 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (n >= 0 && n <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:11.186335646 +0100\n+++ /tmp/tmpoorlxu69.java\t2023-03-24 13:37:11.186335646 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n >= 0 && n <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (this.max!= null && n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:15.202320468 +0100\n+++ /tmp/tmpow7qp8n1.java\t2023-03-24 13:37:15.202320468 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= null && n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (n > 0 && n % 10 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:16.774314525 +0100\n+++ /tmp/tmpzv9mx8y0.java\t2023-03-24 13:37:16.774314525 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n > 0 && n % 10 == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (n > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:20.210301539 +0100\n+++ /tmp/tmpbwx1dgif.java\t2023-03-24 13:37:20.210301539 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n > max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (this.max > this.max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:23.938287449 +0100\n+++ /tmp/tmpd_jvhlyw.java\t2023-03-24 13:37:23.938287449 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > this.max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (asInteger(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:25.730280677 +0100\n+++ /tmp/tmp98yxlq0a.java\t2023-03-24 13:37:25.730280677 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (asInteger(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (sss.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:27.518273920 +0100\n+++ /tmp/tmp3397n2sw.java\t2023-03-24 13:37:27.522273904 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (sss.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (max > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:29.426266709 +0100\n+++ /tmp/tmpbdruj_na.java\t2023-03-24 13:37:29.426266709 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (max > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (Math.abs(n) > -1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:32.970253316 +0100\n+++ /tmp/tmpw5apzbzr.java\t2023-03-24 13:37:32.970253316 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(n) > -1) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (this.max > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:36.834238713 +0100\n+++ /tmp/tmpjgc7jz8n.java\t2023-03-24 13:37:36.834238713 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (this.input.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:38.518232349 +0100\n+++ /tmp/tmp5emmrpiq.java\t2023-03-24 13:37:38.518232349 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.input.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (this.max > m) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:40.362225379 +0100\n+++ /tmp/tmphj7q0no9.java\t2023-03-24 13:37:40.362225379 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > m) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (n > 0 && n % 2 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:42.130218699 +0100\n+++ /tmp/tmpmcwwx6vi.java\t2023-03-24 13:37:42.130218699 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n > 0 && n % 2 == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (Integer.MAX_VALUE >= n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:46.378202647 +0100\n+++ /tmp/tmpi1062pw9.java\t2023-03-24 13:37:46.378202647 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Integer.MAX_VALUE >= n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (any == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:51.126184703 +0100\n+++ /tmp/tmplk4vrugn.java\t2023-03-24 13:37:51.126184703 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any == null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (Math.abs(n) <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:53.254176662 +0100\n+++ /tmp/tmpbjq92ta3.java\t2023-03-24 13:37:53.254176662 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(n) <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (map.containsKey(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:57.594160264 +0100\n+++ /tmp/tmpblecvsg2.java\t2023-03-24 13:37:57.594160264 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (map.containsKey(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (n >= 0 && n % 2 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:37:59.430153325 +0100\n+++ /tmp/tmpknu24cvn.java\t2023-03-24 13:37:59.434153312 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n >= 0 && n % 2 == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (this.getMyId() == n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:03.534137820 +0100\n+++ /tmp/tmpy3xk5e35.java\t2023-03-24 13:38:03.534137820 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.getMyId() == n) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (n > this.max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:05.086131955 +0100\n+++ /tmp/tmpla4o1af6.java\t2023-03-24 13:38:05.086131955 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n > this.max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (this.max >= n && n <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:06.758125638 +0100\n+++ /tmp/tmpehxq8njt.java\t2023-03-24 13:38:06.758125638 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max >= n && n <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (this.max >= 0 && n <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:08.390119472 +0100\n+++ /tmp/tmpql877k71.java\t2023-03-24 13:38:08.390119472 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max >= 0 && n <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (Math.abs(n) > EPS) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:10.106112987 +0100\n+++ /tmp/tmpdpeb60tu.java\t2023-03-24 13:38:10.106112987 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(n) > EPS) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:11.934106081 +0100\n+++ /tmp/tmpn1l15dfu.java\t2023-03-24 13:38:11.934106081 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (sss.containsKey(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:16.146090167 +0100\n+++ /tmp/tmpem62t6c9.java\t2023-03-24 13:38:16.146090167 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (sss.containsKey(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (any(list_comp(n))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:18.062082930 +0100\n+++ /tmp/tmpiem_hho3.java\t2023-03-24 13:38:18.062082930 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any(list_comp(n))) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (NativeIds.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:20.142075071 +0100\n+++ /tmp/tmpev1k3em9.java\t2023-03-24 13:38:20.142075071 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (NativeIds.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (n >= 0 && n % 10 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:22.302066911 +0100\n+++ /tmp/tmp4a98hz1h.java\t2023-03-24 13:38:22.302066911 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n >= 0 && n % 10 == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (any.containsKey(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:27.070048898 +0100\n+++ /tmp/tmpn3yw94l3.java\t2023-03-24 13:38:27.074048882 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any.containsKey(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (this.max!= 0 && n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:29.178040934 +0100\n+++ /tmp/tmp47r_ymg6.java\t2023-03-24 13:38:29.178040934 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= 0 && n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (n % 2 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:31.034033922 +0100\n+++ /tmp/tmpq2t1n_nk.java\t2023-03-24 13:38:31.038033907 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n % 2 == 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (month.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:35.050018751 +0100\n+++ /tmp/tmpvocwf70h.java\t2023-03-24 13:38:35.054018735 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (month.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (Math.abs(n) > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:36.622012812 +0100\n+++ /tmp/tmpuaidv1lp.java\t2023-03-24 13:38:36.622012812 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(n) > y) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (this.max > 0 && n >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:38.222006767 +0100\n+++ /tmp/tmpyin15pb5.java\t2023-03-24 13:38:38.222006767 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > 0 && n >= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (this.rng.nextBoolean()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:39.930000316 +0100\n+++ /tmp/tmp2vkxslqw.java\t2023-03-24 13:38:39.930000316 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.rng.nextBoolean()) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (any(list_comp(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:41.649993817 +0100\n+++ /tmp/tmpgeg6e7ku.java\t2023-03-24 13:38:41.649993817 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any(list_comp(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (n >= SURR1_FIRST) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:43.281987653 +0100\n+++ /tmp/tmpg4zru56i.java\t2023-03-24 13:38:43.281987653 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n >= SURR1_FIRST) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (getDefaultValue().equals(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:45.061980928 +0100\n+++ /tmp/tmpjd89m4ea.java\t2023-03-24 13:38:45.065980915 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (getDefaultValue().equals(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (this.max > 0 && n <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:46.929973873 +0100\n+++ /tmp/tmp5kxmrnoc.java\t2023-03-24 13:38:46.929973873 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > 0 && n <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (Math.abs(n) > high) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:48.913966379 +0100\n+++ /tmp/tmpephlqclf.java\t2023-03-24 13:38:48.917966362 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Math.abs(n) > high) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if ( Math.abs(n) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:51.081958188 +0100\n+++ /tmp/tmp8mekktxj.java\t2023-03-24 13:38:51.081958188 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if ( Math.abs(n) > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (Modifier.isStatic(n > max)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:55.981939680 +0100\n+++ /tmp/tmpufdvup8a.java\t2023-03-24 13:38:55.981939680 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Modifier.isStatic(n > max)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (any(list_comp(n, 0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:38:58.173931401 +0100\n+++ /tmp/tmpxk487pmq.java\t2023-03-24 13:38:58.177931385 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any(list_comp(n, 0);\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (level[n] > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:00.213923696 +0100\n+++ /tmp/tmpaxim0zqf.java\t2023-03-24 13:39:00.217923681 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (level[n] > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (this.getValue()!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:02.097916580 +0100\n+++ /tmp/tmpk_wn6cx8.java\t2023-03-24 13:39:02.097916580 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.getValue()!= null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (this.max < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:03.953909570 +0100\n+++ /tmp/tmp1ky2k89l.java\t2023-03-24 13:39:03.957909554 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max < 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (n < 0 || n > 100) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:05.785902649 +0100\n+++ /tmp/tmptkdvxcp7.java\t2023-03-24 13:39:05.785902649 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n < 0 || n > 100) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (this.any(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:09.857887269 +0100\n+++ /tmp/tmp4weoieq_.java\t2023-03-24 13:39:09.861887256 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.any(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (pred.test(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:11.629880576 +0100\n+++ /tmp/tmpiy845439.java\t2023-03-24 13:39:11.629880576 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (pred.test(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (values.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:13.097875032 +0100\n+++ /tmp/tmpyphuggno.java\t2023-03-24 13:39:13.097875032 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (values.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (is >= 0 && n <= max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:14.617869291 +0100\n+++ /tmp/tmpoqhww_3n.java\t2023-03-24 13:39:14.617869291 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (is >= 0 && n <= max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (n > 0 && n < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:16.125863597 +0100\n+++ /tmp/tmpefss4mzm.java\t2023-03-24 13:39:16.125863597 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n > 0 && n < 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (any(list_comp(n, 0));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:19.597850484 +0100\n+++ /tmp/tmpqi_uxzsc.java\t2023-03-24 13:39:19.597850484 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any(list_comp(n, 0));\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (this.any == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:20.997845197 +0100\n+++ /tmp/tmpzzpnicfp.java\t2023-03-24 13:39:20.997845197 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.any == null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (n < 0 || n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:22.529839411 +0100\n+++ /tmp/tmpz1qjfzk2.java\t2023-03-24 13:39:22.529839411 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n < 0 || n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (n <= 0 || n > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:25.945826510 +0100\n+++ /tmp/tmpxqtgfv04.java\t2023-03-24 13:39:25.945826510 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n <= 0 || n > 1) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (n <= 0 || n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:29.289813880 +0100\n+++ /tmp/tmpgpu_r43u.java\t2023-03-24 13:39:29.289813880 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n <= 0 || n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (input.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:32.769800737 +0100\n+++ /tmp/tmp840woj1t.java\t2023-03-24 13:39:32.769800737 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (input.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (this.contains(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:34.309794922 +0100\n+++ /tmp/tmpbxhycujn.java\t2023-03-24 13:39:34.309794922 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.contains(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (anyany(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:35.769789409 +0100\n+++ /tmp/tmpzysbsl50.java\t2023-03-24 13:39:35.769789409 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (anyany(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (n < 0 || n > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:37.241783851 +0100\n+++ /tmp/tmp8985cbrd.java\t2023-03-24 13:39:37.241783851 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n < 0 || n > 1) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (asInteger(n) <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:40.797770420 +0100\n+++ /tmp/tmp_5gp0oed.java\t2023-03-24 13:39:40.797770420 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (asInteger(n) <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (connection!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:42.517763925 +0100\n+++ /tmp/tmp1urrgcgb.java\t2023-03-24 13:39:42.517763925 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (connection!= null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (n > 0 && n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:44.257757355 +0100\n+++ /tmp/tmpoa80gpl1.java\t2023-03-24 13:39:44.261757341 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n > 0 && n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (isWeighted(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:47.949743415 +0100\n+++ /tmp/tmpp1p8mhyx.java\t2023-03-24 13:39:47.949743415 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (isWeighted(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (this.max!= next) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:49.381738007 +0100\n+++ /tmp/tmpxpvm1toy.java\t2023-03-24 13:39:49.381738007 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= next) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (this.max > g) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:50.805732630 +0100\n+++ /tmp/tmpe1keadl8.java\t2023-03-24 13:39:50.805732630 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max > g) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (this.asInteger(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:52.225727268 +0100\n+++ /tmp/tmp73ld91im.java\t2023-03-24 13:39:52.225727268 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.asInteger(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (m > 0 && n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:53.657721860 +0100\n+++ /tmp/tmp2h4mm7sv.java\t2023-03-24 13:39:53.657721860 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (m > 0 && n > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (level[n]!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:55.417715214 +0100\n+++ /tmp/tmpavkudw_3.java\t2023-03-24 13:39:55.417715214 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (level[n]!= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (is >= 0 && n <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:57.157708644 +0100\n+++ /tmp/tmpa4dfk9xp.java\t2023-03-24 13:39:57.161708630 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (is >= 0 && n <= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (this.min!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:39:58.849702256 +0100\n+++ /tmp/tmpt83qytck.java\t2023-03-24 13:39:58.849702256 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.min!= null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (copyOf(n) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:00.609695610 +0100\n+++ /tmp/tmp_0b0lsvf.java\t2023-03-24 13:40:00.609695610 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (copyOf(n) > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (n >= 2 && n <= 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:02.089690022 +0100\n+++ /tmp/tmppd4dv9ur.java\t2023-03-24 13:40:02.089690022 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n >= 2 && n <= 3) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (asInt(n) > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:05.317677833 +0100\n+++ /tmp/tmpzr9wib6f.java\t2023-03-24 13:40:05.317677833 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (asInt(n) > 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (isNumber(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:06.749672425 +0100\n+++ /tmp/tmpb8ospe5j.java\t2023-03-24 13:40:06.749672425 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (isNumber(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (this.min < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:08.141667170 +0100\n+++ /tmp/tmpbboe488f.java\t2023-03-24 13:40:08.141667170 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.min < 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (any(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:09.661661431 +0100\n+++ /tmp/tmp5y7d0p23.java\t2023-03-24 13:40:09.661661431 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (Exists(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:11.409654831 +0100\n+++ /tmp/tmpavh08ngi.java\t2023-03-24 13:40:11.409654831 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (Exists(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (this.max!= target) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:13.125648351 +0100\n+++ /tmp/tmp6tputd27.java\t2023-03-24 13:40:13.129648338 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= target) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (this.max >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:14.585642838 +0100\n+++ /tmp/tmphprxjzig.java\t2023-03-24 13:40:14.585642838 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max >= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (isDone(n)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:16.109637086 +0100\n+++ /tmp/tmp85a4_ihb.java\t2023-03-24 13:40:16.109637086 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (isDone(n)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (this.max!= s) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:17.557631619 +0100\n+++ /tmp/tmpdhmxs8sr.java\t2023-03-24 13:40:17.557631619 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (this.max!= s) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (any!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:19.009626135 +0100\n+++ /tmp/tmpfy9xh3k3.java\t2023-03-24 13:40:19.009626135 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (any!= null) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (rng.nextBoolean()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:20.429620774 +0100\n+++ /tmp/tmp0eqbmz4l.java\t2023-03-24 13:40:20.429620774 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (rng.nextBoolean()) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (n % 2!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:21.913615173 +0100\n+++ /tmp/tmpxjxgbfco.java\t2023-03-24 13:40:21.913615173 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n % 2!= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (n <= max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:25.385602063 +0100\n+++ /tmp/tmprjizv200.java\t2023-03-24 13:40:25.389602049 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n <= max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (!(n instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:44.845528597 +0100\n+++ /tmp/tmp7yr_72e3.java\t2023-03-24 13:40:44.845528597 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (!(n instanceof Integer)) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if ( width > max) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:40:54.413492479 +0100\n+++ /tmp/tmp1j9vthni.java\t2023-03-24 13:40:54.413492479 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if ( width > max) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (n >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/sieve/java_programs/SIEVE.java\t2023-03-24 13:41:04.429454669 +0100\n+++ /tmp/tmpigte4ku7.java\t2023-03-24 13:41:04.437454639 +0100\n@@ -36,11 +36,11 @@\n \n \n     public static ArrayList<Integer> sieve(Integer max) {\n         ArrayList<Integer> primes = new ArrayList<Integer>();\n         for (int n=2; n<max+1; n++) {\n-            if (any(list_comp(n, primes))) {\n+if (n >= 0) {\n                 primes.add(n);\n             }\n         }\n         return primes;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (all(list_comp(n, primes))) {"
    },
    "subsequences": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:15.196508537 +0100\n+++ /tmp/tmpy261t4o_.java\t2023-03-24 13:45:15.260508296 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (a < 0 || b > 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:20.220489590 +0100\n+++ /tmp/tmpjw4h397u.java\t2023-03-24 13:45:20.220489590 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:22.380481444 +0100\n+++ /tmp/tmp8iszh9w2.java\t2023-03-24 13:45:22.380481444 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:27.612461712 +0100\n+++ /tmp/tmp997lah01.java\t2023-03-24 13:45:27.612461712 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (a < 0 || b == 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:32.500443276 +0100\n+++ /tmp/tmp1zv0flkw.java\t2023-03-24 13:45:32.500443276 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b == 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (a == b) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:34.684435042 +0100\n+++ /tmp/tmpu5_2821d.java\t2023-03-24 13:45:34.684435042 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (a < 0 || a > 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:39.776415839 +0100\n+++ /tmp/tmpcl6detf_.java\t2023-03-24 13:45:39.776415839 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a > 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (a == 1) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:41.848408025 +0100\n+++ /tmp/tmp40fkek1a.java\t2023-03-24 13:45:41.852408010 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 1) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (a == b) return new ArrayList<>(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:46.576390194 +0100\n+++ /tmp/tmpmqe0vomn.java\t2023-03-24 13:45:46.576390194 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (a < 0 || b > 1) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:48.480383015 +0100\n+++ /tmp/tmpdtzkxh9x.java\t2023-03-24 13:45:48.480383015 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (a < 2) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:53.096365608 +0100\n+++ /tmp/tmpt1lvhqip.java\t2023-03-24 13:45:53.096365608 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 2) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:57.840347717 +0100\n+++ /tmp/tmpajk8y3qc.java\t2023-03-24 13:45:57.840347717 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { a = b; a = b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:45:59.884340009 +0100\n+++ /tmp/tmpmegtwuda.java\t2023-03-24 13:45:59.888339996 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { a = b; a = b;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:01.908332378 +0100\n+++ /tmp/tmp5ucbvr5s.java\t2023-03-24 13:46:01.912332362 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (a == b) return new ArrayList<>(); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:06.540314912 +0100\n+++ /tmp/tmpdwxzc7e5.java\t2023-03-24 13:46:06.540314912 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (a == 2) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:08.508307491 +0100\n+++ /tmp/tmpysmamzlt.java\t2023-03-24 13:46:08.508307491 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 2) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (a == 0 || b == 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:13.024290459 +0100\n+++ /tmp/tmp53t3nryy.java\t2023-03-24 13:46:13.028290446 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0 || b == 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (a < 1) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:14.916283325 +0100\n+++ /tmp/tmp5jogu5yk.java\t2023-03-24 13:46:14.916283325 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 1) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { a = b; a = b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:19.176267264 +0100\n+++ /tmp/tmp6qtqrk83.java\t2023-03-24 13:46:19.176267264 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { a = b; a = b;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { return new ArrayList<>(4); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:21.044260218 +0100\n+++ /tmp/tmpmedp3y1n.java\t2023-03-24 13:46:21.044260218 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { return new ArrayList<>(4); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { a = b; a = a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:25.252244352 +0100\n+++ /tmp/tmpj8b8ukkv.java\t2023-03-24 13:46:25.252244352 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { a = b; a = a;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:27.004237751 +0100\n+++ /tmp/tmpyttcr60g.java\t2023-03-24 13:46:27.008237737 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:31.128222833 +0100\n+++ /tmp/tmp63snnzb7.java\t2023-03-24 13:46:31.128222833 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { return new ArrayList<>(4); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:32.888216464 +0100\n+++ /tmp/tmpxou2ghs_.java\t2023-03-24 13:46:32.888216464 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { return new ArrayList<>(4); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (a == null) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:37.000201582 +0100\n+++ /tmp/tmpow_wkyv0.java\t2023-03-24 13:46:37.000201582 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == null) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { a = b; a = a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:38.840194920 +0100\n+++ /tmp/tmps3b_yniq.java\t2023-03-24 13:46:38.840194920 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { a = b; a = a;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (a == b) return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:40.544188751 +0100\n+++ /tmp/tmpr4f81em9.java\t2023-03-24 13:46:40.544188751 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); else if (a < 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:42.396182046 +0100\n+++ /tmp/tmphr2b11qw.java\t2023-03-24 13:46:42.400182033 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); else if (a < 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (a < 0 || a == 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:46.688166501 +0100\n+++ /tmp/tmppiuzzu3f.java\t2023-03-24 13:46:46.688166501 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a == 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (a < 0 || b > 100) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:48.504159923 +0100\n+++ /tmp/tmp2_j80io0.java\t2023-03-24 13:46:48.504159923 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 100) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (a == b) return new ArrayList<>(); else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:50.376153141 +0100\n+++ /tmp/tmp690uo8ab.java\t2023-03-24 13:46:50.376153141 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!a.equals(b)) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:54.676137559 +0100\n+++ /tmp/tmpm5x5v3yv.java\t2023-03-24 13:46:54.676137559 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (!a.equals(b)) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (a == 0 || a == 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:56.528130847 +0100\n+++ /tmp/tmpdhz2_c_v.java\t2023-03-24 13:46:56.528130847 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0 || a == 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (a == b) return new ArrayList<>(); } else { a = b; a = b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:46:58.308124394 +0100\n+++ /tmp/tmpevo7ehgh.java\t2023-03-24 13:46:58.308124394 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); } else { a = b; a = b;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (a == 0) return new ArrayList<>(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:02.540109052 +0100\n+++ /tmp/tmpq0ja9xfg.java\t2023-03-24 13:47:02.540109052 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { a = b; return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:04.340102526 +0100\n+++ /tmp/tmpp0nbdkay.java\t2023-03-24 13:47:04.340102526 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { a = b; return a;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (a < b) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:06.096096156 +0100\n+++ /tmp/tmpsdusc58v.java\t2023-03-24 13:47:06.096096156 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < b) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (a == b) return new ArrayList<>(); a = b; } else { a = b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:10.172081370 +0100\n+++ /tmp/tmpjoi_2ewd.java\t2023-03-24 13:47:10.176081356 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); a = b; } else { a = b;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { a = b; k++;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:14.332066276 +0100\n+++ /tmp/tmpdfg2zv8d.java\t2023-03-24 13:47:14.332066276 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { a = b; k++;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (a < 0 || b > 1) { return new ArrayList<>(); } else { return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:16.096059874 +0100\n+++ /tmp/tmp3jvw9uh8.java\t2023-03-24 13:47:16.096059874 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) { return new ArrayList<>(); } else { return a;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { a = b; k++;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:17.912053283 +0100\n+++ /tmp/tmppzghrjrd.java\t2023-03-24 13:47:17.912053283 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { a = b; k++;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (a < 0 || b > 1) return new ArrayList<>(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:19.720046722 +0100\n+++ /tmp/tmpdyvbsces.java\t2023-03-24 13:47:19.720046722 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) return new ArrayList<>(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { a = b; return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:21.488040301 +0100\n+++ /tmp/tmpufj5pfna.java\t2023-03-24 13:47:21.488040301 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { a = b; return a;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (a == b) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:23.196034100 +0100\n+++ /tmp/tmpkm4_845a.java\t2023-03-24 13:47:23.200034086 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (a < 0 || b == 1) return new ArrayList<>(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:25.060027332 +0100\n+++ /tmp/tmp1yvno66k.java\t2023-03-24 13:47:25.064027318 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b == 1) return new ArrayList<>(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (a == 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:26.904020635 +0100\n+++ /tmp/tmpbr5j_44l.java\t2023-03-24 13:47:26.904020635 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (a < 0 || b > 1) { return new ArrayList<>(); } else { return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:28.684014170 +0100\n+++ /tmp/tmp3gn9ua7e.java\t2023-03-24 13:47:28.684014170 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) { return new ArrayList<>(); } else { return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (a < 0 || b > 1) { return new ArrayList<>(); } else { k++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:30.400007937 +0100\n+++ /tmp/tmp5fhnvxot.java\t2023-03-24 13:47:30.404007925 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) { return new ArrayList<>(); } else { k++; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (b == 1) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:34.475993129 +0100\n+++ /tmp/tmp902hf374.java\t2023-03-24 13:47:34.475993129 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (b == 1) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { return new ArrayList<String>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:38.923976966 +0100\n+++ /tmp/tmpub8jpplf.java\t2023-03-24 13:47:38.923976966 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { return new ArrayList<String>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { a = new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:41.127968952 +0100\n+++ /tmp/tmpje8ea2zs.java\t2023-03-24 13:47:41.127968952 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { a = new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (a == 0) return new ArrayList<>(); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:43.695959620 +0100\n+++ /tmp/tmp6v8tiq7k.java\t2023-03-24 13:47:43.695959620 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>(); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (a < 1) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:45.343953626 +0100\n+++ /tmp/tmpkwe5lvj2.java\t2023-03-24 13:47:45.343953626 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 1) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (a < 0 || b == 1) return new ArrayList<>(); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:47.579945496 +0100\n+++ /tmp/tmpxeno960k.java\t2023-03-24 13:47:47.583945483 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b == 1) return new ArrayList<>(); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (a!= b) { return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:49.615938090 +0100\n+++ /tmp/tmpyfgqr06m.java\t2023-03-24 13:47:49.615938090 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a!= b) { return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (a < 0 || b > 1) return new ArrayList<>(); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:53.995922159 +0100\n+++ /tmp/tmpd8pxuw93.java\t2023-03-24 13:47:54.083921839 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b > 1) return new ArrayList<>(); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (a == 1) { return new ArrayList<>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:47:55.851915407 +0100\n+++ /tmp/tmpg_g225t6.java\t2023-03-24 13:47:55.935915101 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 1) { return new ArrayList<>(); } else { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (a == b) { return new ArrayList<>(); } else { a = new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:00.591898158 +0100\n+++ /tmp/tmpb_vjdhvr.java\t2023-03-24 13:48:00.591898158 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) { return new ArrayList<>(); } else { a = new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); } else { a = b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:02.363891711 +0100\n+++ /tmp/tmpcc4qarg3.java\t2023-03-24 13:48:02.363891711 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); } else { a = b;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:04.187885070 +0100\n+++ /tmp/tmpzyc2y5xb.java\t2023-03-24 13:48:04.191885056 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); } else { a = b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:06.355877178 +0100\n+++ /tmp/tmpbfp1dewv.java\t2023-03-24 13:48:06.423876931 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); } else { a = b;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (a == b) return new ArrayList<>(); else return new ArrayList<>(4); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:08.763868411 +0100\n+++ /tmp/tmpfobapfm_.java\t2023-03-24 13:48:08.907867889 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); else return new ArrayList<>(4); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (a < 1) { return new ArrayList<>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:10.663861495 +0100\n+++ /tmp/tmpih9o4spt.java\t2023-03-24 13:48:10.663861495 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 1) { return new ArrayList<>(); } else { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (a < 0 || a > 1) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:16.483840296 +0100\n+++ /tmp/tmppnfouab5.java\t2023-03-24 13:48:16.483840296 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || a > 1) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (a == 0) return new ArrayList<>(); else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:21.451822196 +0100\n+++ /tmp/tmpfonhjwq7.java\t2023-03-24 13:48:21.451822196 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>(); else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (a < 2) { return new ArrayList<>(); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:27.035801846 +0100\n+++ /tmp/tmp46yoztgq.java\t2023-03-24 13:48:27.035801846 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 2) { return new ArrayList<>(); } else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (a < 0 || b == 1) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:29.015794630 +0100\n+++ /tmp/tmp9pfee30a.java\t2023-03-24 13:48:29.015794630 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b == 1) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:34.739773762 +0100\n+++ /tmp/tmp634_kqf7.java\t2023-03-24 13:48:34.739773762 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:36.467767461 +0100\n+++ /tmp/tmpag458nug.java\t2023-03-24 13:48:36.567767094 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (a == 0) return new ArrayList<>(); } else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:38.607759654 +0100\n+++ /tmp/tmp6v6950zf.java\t2023-03-24 13:48:38.607759654 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>(); } else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (!a.equals(b)) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:40.695752038 +0100\n+++ /tmp/tmps4dds9hi.java\t2023-03-24 13:48:40.787751705 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (!a.equals(b)) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); else { a = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:42.459745604 +0100\n+++ /tmp/tmpngmz_a8v.java\t2023-03-24 13:48:42.459745604 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); else { a = b; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (a < 0 || b == ',') { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:48.079725099 +0100\n+++ /tmp/tmpoav040q5.java\t2023-03-24 13:48:48.079725099 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b == ',') { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (a == b) return new ArrayList(); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:52.511708926 +0100\n+++ /tmp/tmp192skyel.java\t2023-03-24 13:48:52.511708926 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList(); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (a < 0) return new ArrayList<>(); else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:54.267702517 +0100\n+++ /tmp/tmpfv8lutx8.java\t2023-03-24 13:48:54.267702517 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) return new ArrayList<>(); else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (a == null) return new ArrayList<>(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:55.995696209 +0100\n+++ /tmp/tmpnvt3_5av.java\t2023-03-24 13:48:55.995696209 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == null) return new ArrayList<>(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (a < 0 || b == 1); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:57.771689722 +0100\n+++ /tmp/tmpwp2lx0d2.java\t2023-03-24 13:48:57.775689708 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0 || b == 1); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (a == b) return new ArrayList(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:48:59.899681953 +0100\n+++ /tmp/tmppgh2wd31.java\t2023-03-24 13:48:59.899681953 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (a == null) return new ArrayList<>(); else return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:02.023674197 +0100\n+++ /tmp/tmpph2zpf4f.java\t2023-03-24 13:49:02.123673831 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == null) return new ArrayList<>(); else return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (a == 0) return new ArrayList<>(); else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:04.299665885 +0100\n+++ /tmp/tmpx3b6dirj.java\t2023-03-24 13:49:04.299665885 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) return new ArrayList<>(); else { return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (!a < 0 || b > 1) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:07.243655134 +0100\n+++ /tmp/tmp5gvx8ahb.java\t2023-03-24 13:49:07.243655134 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (!a < 0 || b > 1) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (a == 1) return new ArrayList<>(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:09.655646323 +0100\n+++ /tmp/tmpkg1z_giw.java\t2023-03-24 13:49:09.655646323 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 1) return new ArrayList<>(); else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (a == b) return EMPTY; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:12.191637056 +0100\n+++ /tmp/tmpi_28cgly.java\t2023-03-24 13:49:12.307636632 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return EMPTY; else return a; }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (a == b) return new ArrayList<>(); else return new ArrayList<>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:14.575628344 +0100\n+++ /tmp/tmpvt1buvns.java\t2023-03-24 13:49:14.691627921 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); else return new ArrayList<>();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "throw new IllegalArgumentException(\"Cannot find matching wildcard: \" + a);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:19.203611431 +0100\n+++ /tmp/tmpvkssu21n.java\t2023-03-24 13:49:19.203611431 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalArgumentException(\"Cannot find matching wildcard: \" + a);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (a == b) return new ArrayList<>(); else return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:23.315596403 +0100\n+++ /tmp/tmp0wzoicl8.java\t2023-03-24 13:49:23.319596385 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == b) return new ArrayList<>(); else return a;\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (a < 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:25.223589424 +0100\n+++ /tmp/tmp9cmtq62m.java\t2023-03-24 13:49:25.227589410 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (a == 0) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:29.659573204 +0100\n+++ /tmp/tmp8zvcuk22.java\t2023-03-24 13:49:29.659573204 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a == 0) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (a < 2) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:33.803558048 +0100\n+++ /tmp/tmpoezgxslw.java\t2023-03-24 13:49:33.807558036 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+if (a < 2) { return new ArrayList<>(); }\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "return new ArrayList<>(4);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:38.059542479 +0100\n+++ /tmp/tmpkkuc7g_4.java\t2023-03-24 13:49:38.059542479 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(4);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "throw new RuntimeException(\"internal error\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:42.191527361 +0100\n+++ /tmp/tmpl6grhzpe.java\t2023-03-24 13:49:42.191527361 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new RuntimeException(\"internal error\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "throw new IllegalArgumentException(\"internal error\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:46.351512137 +0100\n+++ /tmp/tmpn74xn03m.java\t2023-03-24 13:49:46.351512137 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+throw new IllegalArgumentException(\"internal error\");\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return new ArrayList<>(a);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:50.507496925 +0100\n+++ /tmp/tmpdkit7o0g.java\t2023-03-24 13:49:50.511496911 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(a);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "return new ArrayList<>(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:54.619481874 +0100\n+++ /tmp/tmp9rgs1_sd.java\t2023-03-24 13:49:54.619481874 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(1);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "return new ArrayList<>(50);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:49:59.483464061 +0100\n+++ /tmp/tmpel122ls7.java\t2023-03-24 13:49:59.487464048 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(50);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "return new ArrayList<>(7);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:50:03.679448693 +0100\n+++ /tmp/tmpjbhcyobl.java\t2023-03-24 13:50:03.679448693 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(7);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "return new ArrayList<>(5);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:50:08.023432782 +0100\n+++ /tmp/tmpp1m7m42o.java\t2023-03-24 13:50:08.023432782 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(5);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return new ArrayList<>(16);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:50:12.303417097 +0100\n+++ /tmp/tmpgu6uotf8.java\t2023-03-24 13:50:12.303417097 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(16);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "return new ArrayList();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:50:16.511401677 +0100\n+++ /tmp/tmp6bwd2o79.java\t2023-03-24 13:50:16.511401677 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList();\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return new ArrayList<>(b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/subsequences/java_programs/SUBSEQUENCES.java\t2023-03-24 13:50:20.591386722 +0100\n+++ /tmp/tmpqvucqabc.java\t2023-03-24 13:50:20.591386722 +0100\n@@ -11,11 +11,11 @@\n  * @author derricklin\n  */\n public class SUBSEQUENCES {\n     public static ArrayList<ArrayList> subsequences(int a, int b, int k) {\n         if (k == 0) {\n-            return new ArrayList();\n+return new ArrayList<>(b);\n         }\n \n         ArrayList ret = new ArrayList(50);\n         for (int i=a; i<b+1-k; i++) {\n             ArrayList base = new ArrayList(50);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "ArrayList empty_set = new ArrayList<ArrayList>(); empty_set.add(new ArrayList()); return empty_set;"
    },
    "gcd": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (a > b) { return a % b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:44:27.116689878 +0100\n+++ /tmp/tmpjevz0wu6.java\t2023-03-24 13:44:28.116686106 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (a < 0) { return a % b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:44:40.548639213 +0100\n+++ /tmp/tmpgz2qbug0.java\t2023-03-24 13:44:40.548639213 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return a % b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (a > b) { return b % a; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:44:52.580593831 +0100\n+++ /tmp/tmpwz2al1ly.java\t2023-03-24 13:44:52.580593831 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return b % a; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (a > b) return a; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:04.820547668 +0100\n+++ /tmp/tmpvyr3ti0_.java\t2023-03-24 13:45:04.820547668 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (a > b) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:09.312530726 +0100\n+++ /tmp/tmpdldmrdyw.java\t2023-03-24 13:45:09.312530726 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (a > b) return a - b; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:16.292504404 +0100\n+++ /tmp/tmpccb2ojmq.java\t2023-03-24 13:45:16.292504404 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a - b; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (a!= b) { return a % b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:18.192497236 +0100\n+++ /tmp/tmp96fpanfh.java\t2023-03-24 13:45:18.192497236 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) { return a % b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (b > 0) { return a % b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:22.836479722 +0100\n+++ /tmp/tmpw2dbgauh.java\t2023-03-24 13:45:22.840479709 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (b > 0) { return a % b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (a > b) { return a % b; } else { return a * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:27.568461878 +0100\n+++ /tmp/tmp073hr57z.java\t2023-03-24 13:45:27.568461878 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % b; } else { return a * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (a > b) return b; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:32.204444394 +0100\n+++ /tmp/tmplmxlsk3s.java\t2023-03-24 13:45:32.204444394 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (a > b) return a - b; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:34.132437123 +0100\n+++ /tmp/tmpip7iibtj.java\t2023-03-24 13:45:34.132437123 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a - b; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (a < b) { return a % b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:35.972430183 +0100\n+++ /tmp/tmp68ikoozt.java\t2023-03-24 13:45:35.972430183 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) { return a % b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (a > b) return a; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:40.508413077 +0100\n+++ /tmp/tmpzq2ewawu.java\t2023-03-24 13:45:40.508413077 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (a > b) return a; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:42.528405461 +0100\n+++ /tmp/tmpin94t7n2.java\t2023-03-24 13:45:42.528405461 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (a > b) { return a % b; } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:44.552397828 +0100\n+++ /tmp/tmp0znix17l.java\t2023-03-24 13:45:44.556397811 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % b; } else { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (a > b) return a; if (b!= 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:49.008381025 +0100\n+++ /tmp/tmpalr4bj1n.java\t2023-03-24 13:45:49.008381025 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b!= 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (a < 0) { return b % a; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:50.848374084 +0100\n+++ /tmp/tmprple7y5y.java\t2023-03-24 13:45:50.848374084 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return b % a; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (a!= b) return a - b; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:55.248357491 +0100\n+++ /tmp/tmppexhodmb.java\t2023-03-24 13:45:55.248357491 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) return a - b; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (b > 0) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:45:57.052350691 +0100\n+++ /tmp/tmpdd1wm8_t.java\t2023-03-24 13:45:57.068350629 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (b > 0) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (a > b) return a; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:01.452334098 +0100\n+++ /tmp/tmpzb2su35h.java\t2023-03-24 13:46:01.452334098 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (a > b) return a % b; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:03.352326931 +0100\n+++ /tmp/tmpwif7nl9a.java\t2023-03-24 13:46:03.352326931 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a % b; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (a > b) return b - a; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:05.220319889 +0100\n+++ /tmp/tmp8x4z1clq.java\t2023-03-24 13:46:05.224319872 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b - a; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (b!= 0) { return a % b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:07.080312873 +0100\n+++ /tmp/tmpwzimjshj.java\t2023-03-24 13:46:07.080312873 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (b!= 0) { return a % b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (a > b) return a % b; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:11.284297020 +0100\n+++ /tmp/tmpj43_uwk3.java\t2023-03-24 13:46:11.284297020 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a % b; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (a!= b) return a - b; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:13.176289888 +0100\n+++ /tmp/tmps74rxbgi.java\t2023-03-24 13:46:13.176289888 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) return a - b; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (a > b) return b - b; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:14.980283083 +0100\n+++ /tmp/tmp799en9yp.java\t2023-03-24 13:46:14.980283083 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b - b; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (a > b) { return a - b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:16.752276404 +0100\n+++ /tmp/tmpuwgbuh8r.java\t2023-03-24 13:46:16.752276404 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a - b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (a > b) { return b % a; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:20.944260597 +0100\n+++ /tmp/tmp38kfca7r.java\t2023-03-24 13:46:20.944260597 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return b % a; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (a > b) { return a % b; } else { return a.length(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:25.088244970 +0100\n+++ /tmp/tmp6h_e_q1y.java\t2023-03-24 13:46:25.092244953 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % b; } else { return a.length(); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (a > b) { return a % b; } else { return a + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:26.816238457 +0100\n+++ /tmp/tmpgysidqa3.java\t2023-03-24 13:46:26.816238457 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % b; } else { return a + b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (a > b) return b - b; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:30.852223830 +0100\n+++ /tmp/tmp5_duz948.java\t2023-03-24 13:46:30.852223830 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b - b; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (a > b) { return b % b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:32.532217752 +0100\n+++ /tmp/tmp1v1gvpsh.java\t2023-03-24 13:46:32.532217752 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return b % b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (a > b) return a - b; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:36.676202754 +0100\n+++ /tmp/tmpqv9_805m.java\t2023-03-24 13:46:36.676202754 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a - b; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (a!= b) { return b % a; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:38.400196513 +0100\n+++ /tmp/tmpv5e6yxl8.java\t2023-03-24 13:46:38.400196513 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) { return b % a; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (a > b) { return diff; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:42.452181843 +0100\n+++ /tmp/tmpyhtfx_jy.java\t2023-03-24 13:46:42.456181830 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return diff; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (a < 0) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:44.192175543 +0100\n+++ /tmp/tmpvw8__wsm.java\t2023-03-24 13:46:44.192175543 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (a < 0 || b > 1) { return a - b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:48.312160618 +0100\n+++ /tmp/tmpa7jgy7fi.java\t2023-03-24 13:46:48.312160618 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0 || b > 1) { return a - b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (a > b) { return b % a; } else { return a * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:52.332146056 +0100\n+++ /tmp/tmprqi2z556.java\t2023-03-24 13:46:52.332146056 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return b % a; } else { return a * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (a > b) { return a % b; } else { return a / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:46:56.292131704 +0100\n+++ /tmp/tmpx_ce7_fg.java\t2023-03-24 13:46:56.292131704 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % b; } else { return a / b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (a < 0) { return a - b; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:00.296117190 +0100\n+++ /tmp/tmpnuk1az4z.java\t2023-03-24 13:47:00.296117190 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return a - b; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (a > b) return a - b; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:04.264102800 +0100\n+++ /tmp/tmp0n2hjbva.java\t2023-03-24 13:47:04.264102800 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a - b; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (a > b) return b; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:06.020096431 +0100\n+++ /tmp/tmp851rjvqb.java\t2023-03-24 13:47:06.020096431 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (a < 0 || b > 1) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:07.656090498 +0100\n+++ /tmp/tmpn12e547m.java\t2023-03-24 13:47:07.660090485 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0 || b > 1) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (a > b) return b - a; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:11.688075872 +0100\n+++ /tmp/tmp8hp8uwbo.java\t2023-03-24 13:47:11.688075872 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b - a; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (a > b) return a; else return a * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:13.344069861 +0100\n+++ /tmp/tmpoqcfl6fm.java\t2023-03-24 13:47:13.348069847 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; else return a * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (a > b) return b; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:15.136063359 +0100\n+++ /tmp/tmpq0uk8rtr.java\t2023-03-24 13:47:15.136063359 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (a < 0) { return -a; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:16.824057234 +0100\n+++ /tmp/tmpnck3254f.java\t2023-03-24 13:47:16.824057234 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return -a; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (a!= b) return a - b; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:20.744043005 +0100\n+++ /tmp/tmpbypq8b9p.java\t2023-03-24 13:47:20.744043005 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) return a - b; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (a > b) return b % a; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:22.540036482 +0100\n+++ /tmp/tmp_w1r91v8.java\t2023-03-24 13:47:22.540036482 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b % a; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (a > b) { return a % a; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:24.244030295 +0100\n+++ /tmp/tmpgxep7ka9.java\t2023-03-24 13:47:24.248030281 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return a % a; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (a.length() == 0) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:28.240015785 +0100\n+++ /tmp/tmpovmm8tuk.java\t2023-03-24 13:47:28.240015785 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a.length() == 0) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (a > b) return b; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:30.088009070 +0100\n+++ /tmp/tmp2nyfiem5.java\t2023-03-24 13:47:30.088009070 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (a < 0 || b > 0) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:31.796002865 +0100\n+++ /tmp/tmpsv1wktpq.java\t2023-03-24 13:47:31.800002851 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0 || b > 0) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (a > b) return a; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:35.887988000 +0100\n+++ /tmp/tmp3_1prbct.java\t2023-03-24 13:47:35.887988000 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (a > b) return a; if (b!= 0) { return a.length(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:37.891980717 +0100\n+++ /tmp/tmpy24ff52t.java\t2023-03-24 13:47:37.891980717 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b!= 0) { return a.length(); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (a < b) return a; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:39.503974856 +0100\n+++ /tmp/tmpmw3e7oy_.java\t2023-03-24 13:47:39.507974842 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return a; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (a!= b) return a - b; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:41.103969040 +0100\n+++ /tmp/tmpa85kr1pw.java\t2023-03-24 13:47:41.103969040 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) return a - b; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (a > b) return b % a; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:43.279961132 +0100\n+++ /tmp/tmpjr7x7xtr.java\t2023-03-24 13:47:43.279961132 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b % a; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (a < 0) { return a % b; } else { return a * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:45.279953858 +0100\n+++ /tmp/tmpmbrbfajz.java\t2023-03-24 13:47:45.279953858 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return a % b; } else { return a * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (a > b) return a; if (b < 0) return 0; return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:51.027932955 +0100\n+++ /tmp/tmpjo4gb6ye.java\t2023-03-24 13:47:51.059932841 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b < 0) return 0; return a;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (a < b) return b; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:56.567912804 +0100\n+++ /tmp/tmpjqsqhthp.java\t2023-03-24 13:47:56.567912804 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return b; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (a > b) return a; if (b!= 0) { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:47:58.199906865 +0100\n+++ /tmp/tmpodzsph_n.java\t2023-03-24 13:47:58.199906865 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b!= 0) { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (a > b) return b; if (a < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:00.219899513 +0100\n+++ /tmp/tmpvi27es8y.java\t2023-03-24 13:48:00.219899513 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; if (a < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (a!= b) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:02.295891957 +0100\n+++ /tmp/tmph1umizhz.java\t2023-03-24 13:48:02.299891944 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (a < 0) { return a; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:07.255873901 +0100\n+++ /tmp/tmpjd2imt3q.java\t2023-03-24 13:48:07.255873901 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return a; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (a.length() > b.length()) return a.length(); else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:11.259859325 +0100\n+++ /tmp/tmpw288ovkt.java\t2023-03-24 13:48:11.263859307 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a.length() > b.length()) return a.length(); else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (a > b) return b; if (b!= 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:12.911853306 +0100\n+++ /tmp/tmpe37_to8s.java\t2023-03-24 13:48:12.911853306 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; if (b!= 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (a > b) return a; if (b < 0) { return b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:16.099841694 +0100\n+++ /tmp/tmpok_cqg3o.java\t2023-03-24 13:48:16.099841694 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b < 0) { return b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (a < 0 || b > 0) { return a - b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:18.247833869 +0100\n+++ /tmp/tmpqgwiqkl4.java\t2023-03-24 13:48:18.247833869 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0 || b > 0) { return a - b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (a < 0) { return diff; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:24.103812535 +0100\n+++ /tmp/tmp2bh617tb.java\t2023-03-24 13:48:24.103812535 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return diff; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (a!= b) { return a % b; } else { return a * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:25.687806759 +0100\n+++ /tmp/tmp3bytfr74.java\t2023-03-24 13:48:25.723806628 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) { return a % b; } else { return a * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (a > b) return a - b; else return a * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:29.851791584 +0100\n+++ /tmp/tmppj3t7g8a.java\t2023-03-24 13:48:29.851791584 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a - b; else return a * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (a > b) return a % b; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:31.527785473 +0100\n+++ /tmp/tmpgx58u3vs.java\t2023-03-24 13:48:31.527785473 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a % b; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (a > b) return b - a; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:33.619777844 +0100\n+++ /tmp/tmpl3r5qw5s.java\t2023-03-24 13:48:33.619777844 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b - a; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (a > b) { return b % a; } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:36.427767605 +0100\n+++ /tmp/tmp1qaan7fm.java\t2023-03-24 13:48:36.427767605 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return b % a; } else { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (a > b) { return -1; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:42.115746859 +0100\n+++ /tmp/tmpchm7xnk9.java\t2023-03-24 13:48:42.115746859 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) { return -1; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (a > b) return a % b; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:47.471727317 +0100\n+++ /tmp/tmpt8cnhl0b.java\t2023-03-24 13:48:47.471727317 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a % b; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (a < 0) { return a % b; } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:49.667719304 +0100\n+++ /tmp/tmpj58kklhv.java\t2023-03-24 13:48:49.671719291 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return a % b; } else { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (b!= 0) { return a % b; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:48:55.411698340 +0100\n+++ /tmp/tmpp79iytap.java\t2023-03-24 13:48:55.411698340 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (b!= 0) { return a % b; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (a > b) return a; if (b < 0) return b; return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:00.447679952 +0100\n+++ /tmp/tmp2wcqomu2.java\t2023-03-24 13:49:00.447679952 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b < 0) return b; return a;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (a < 0) { return -1; } else { return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:05.235662467 +0100\n+++ /tmp/tmp8z9psd_c.java\t2023-03-24 13:49:05.235662467 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return -1; } else { return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (a > b) return b - a; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:10.567642989 +0100\n+++ /tmp/tmpozr71wfg.java\t2023-03-24 13:49:10.571642977 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b - a; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (a < 0) { return b % a; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:12.171637129 +0100\n+++ /tmp/tmpc7fnuwtt.java\t2023-03-24 13:49:12.307636632 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < 0) { return b % a; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (a < b) return b; if (b < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:17.339618243 +0100\n+++ /tmp/tmpns2m_2ww.java\t2023-03-24 13:49:17.339618243 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return b; if (b < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (a < b) return b; if (a < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:19.067611928 +0100\n+++ /tmp/tmpvu0k_ti_.java\t2023-03-24 13:49:19.067611928 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return b; if (a < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (a > b) return b - b; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:20.795605614 +0100\n+++ /tmp/tmp2v5iipvu.java\t2023-03-24 13:49:20.795605614 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b - b; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (a > b) return a - b; if (a < 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:22.551599193 +0100\n+++ /tmp/tmpi5v3tgy7.java\t2023-03-24 13:49:22.591599049 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a - b; if (a < 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (a < b) return a; else return a - b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:24.351592615 +0100\n+++ /tmp/tmp0b0_1ozz.java\t2023-03-24 13:49:24.355592598 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return a; else return a - b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (a > b) return a; if (b < 0) return 0; return a - b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:25.983586648 +0100\n+++ /tmp/tmp1_q8njjo.java\t2023-03-24 13:49:25.987586631 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b < 0) return 0; return a - b;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (a > b) return a; if (b!= 0) return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:30.043571802 +0100\n+++ /tmp/tmpuvuwmsyu.java\t2023-03-24 13:49:30.043571802 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; if (b!= 0) return a;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (a < b) return a; if (b > 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:31.723565658 +0100\n+++ /tmp/tmpzvrhquos.java\t2023-03-24 13:49:31.723565658 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return a; if (b > 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (a < b) return b; if (b > 0) { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:33.591558823 +0100\n+++ /tmp/tmp29qpewik.java\t2023-03-24 13:49:33.591558823 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return b; if (b > 0) { return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (a!= b) return a % b; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:35.667551232 +0100\n+++ /tmp/tmpe001hfp7.java\t2023-03-24 13:49:35.667551232 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a!= b) return a % b; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (a > b) return b; if (b < 0) return 0; return a;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:37.411544852 +0100\n+++ /tmp/tmp4oscn7kh.java\t2023-03-24 13:49:37.411544852 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; if (b < 0) return 0; return a;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (b > 0) { return b % a; } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:41.459530039 +0100\n+++ /tmp/tmpmodtyhz8.java\t2023-03-24 13:49:41.459530039 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (b > 0) { return b % a; } else { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (a > b) return a; else return a.length(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:45.615514831 +0100\n+++ /tmp/tmpnd80_3u3.java\t2023-03-24 13:49:45.615514831 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; else return a.length(); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (a > b) return a; else return a + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:47.375508390 +0100\n+++ /tmp/tmp_736vzxd.java\t2023-03-24 13:49:47.375508390 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return a; else return a + b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (a < b) return b; else return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:49.095502094 +0100\n+++ /tmp/tmpectzg4y5.java\t2023-03-24 13:49:49.095502094 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return b; else return a; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (a < b) return a; if (b < 0) { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:50.707496193 +0100\n+++ /tmp/tmpkmv2fegy.java\t2023-03-24 13:49:50.707496193 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a < b) return a; if (b < 0) { return 0; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (a > b) return b; else return a * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/gcd/java_programs/GCD.java\t2023-03-24 13:49:52.447489824 +0100\n+++ /tmp/tmpfzrj85bq.java\t2023-03-24 13:49:52.447489824 +0100\n@@ -14,9 +14,9 @@\n \n     public static int gcd(int a, int b) {\n         if (b == 0) {\n             return a;\n         } else {\n-            return gcd(a % b, b);\n+if (a > b) return b; else return a * b; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return gcd(b, a%b);"
    },
    "to_base": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:49:58.367468148 +0100\n+++ /tmp/tmpvfdvpti8.java\t2023-03-24 13:49:58.415467974 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:02.579452722 +0100\n+++ /tmp/tmp43fmy76l.java\t2023-03-24 13:50:02.579452722 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:06.607437967 +0100\n+++ /tmp/tmp53o8it0j.java\t2023-03-24 13:50:06.607437967 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:08.363431534 +0100\n+++ /tmp/tmpqym04m2e.java\t2023-03-24 13:50:08.363431534 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(b.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:12.403416731 +0100\n+++ /tmp/tmpta7ggkv1.java\t2023-03-24 13:50:12.403416731 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(b.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:14.079410590 +0100\n+++ /tmp/tmpb4kxfo5s.java\t2023-03-24 13:50:14.079410590 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:18.255395285 +0100\n+++ /tmp/tmpgdg4717n.java\t2023-03-24 13:50:18.255395285 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:22.359380240 +0100\n+++ /tmp/tmp8_jgr50q.java\t2023-03-24 13:50:22.359380240 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:24.151373673 +0100\n+++ /tmp/tmpsj863tk3.java\t2023-03-24 13:50:24.151373673 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:26.039366749 +0100\n+++ /tmp/tmpwdfreqme.java\t2023-03-24 13:50:26.039366749 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(b.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:27.987359605 +0100\n+++ /tmp/tmpfiqqp5jf.java\t2023-03-24 13:50:27.987359605 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(b.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(b.substring(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:29.683353386 +0100\n+++ /tmp/tmpwdhym6dp.java\t2023-03-24 13:50:29.683353386 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(b.substring(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(num); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:31.399347095 +0100\n+++ /tmp/tmpjtw90963.java\t2023-03-24 13:50:31.403347078 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(num); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = num / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:33.187340535 +0100\n+++ /tmp/tmpyf7d1i2y.java\t2023-03-24 13:50:33.187340535 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = num / b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(b.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:34.955334050 +0100\n+++ /tmp/tmpyghgl2vp.java\t2023-03-24 13:50:34.955334050 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(b.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:36.719327582 +0100\n+++ /tmp/tmpcupo3up4.java\t2023-03-24 13:50:36.719327582 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = i * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:40.887312291 +0100\n+++ /tmp/tmpjzzigs60.java\t2023-03-24 13:50:40.887312291 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = i * b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = i + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:42.663305775 +0100\n+++ /tmp/tmprropaxy2.java\t2023-03-24 13:50:42.667305757 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = i + b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = a + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:44.419299332 +0100\n+++ /tmp/tmpe0q3252i.java\t2023-03-24 13:50:44.419299332 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = a + b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = num / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:46.223292708 +0100\n+++ /tmp/tmpbdzsianl.java\t2023-03-24 13:50:46.223292708 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = num / b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = a + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:48.031286076 +0100\n+++ /tmp/tmp88t6gtto.java\t2023-03-24 13:50:48.035286059 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = a + b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (i < 0) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:49.919279146 +0100\n+++ /tmp/tmppr0mjh2_.java\t2023-03-24 13:50:49.919279146 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < 0) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = result + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:54.999260496 +0100\n+++ /tmp/tmpqz35bdvf.java\t2023-03-24 13:50:54.999260496 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = result + b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = result + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:50:59.091245473 +0100\n+++ /tmp/tmp68_s4b47.java\t2023-03-24 13:50:59.091245473 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = result + b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(i); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:03.559229068 +0100\n+++ /tmp/tmpsu90_ix7.java\t2023-03-24 13:51:03.559229068 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(i); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(b.substring(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:05.455222102 +0100\n+++ /tmp/tmp1uwgjua4.java\t2023-03-24 13:51:05.455222102 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(b.substring(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(num); } else { result = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:07.255215491 +0100\n+++ /tmp/tmp99z27rr1.java\t2023-03-24 13:51:07.259215477 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(num); } else { result = b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:09.623206793 +0100\n+++ /tmp/tmp6518zt6p.java\t2023-03-24 13:51:10.551203387 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = \"\"; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(i); } else { result = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:17.531177739 +0100\n+++ /tmp/tmp3y_3q4b0.java\t2023-03-24 13:51:17.531177739 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(i); } else { result = b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = num; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:19.219171539 +0100\n+++ /tmp/tmpr00mmhsl.java\t2023-03-24 13:51:19.427170772 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = num; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(ch); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:21.619162717 +0100\n+++ /tmp/tmptuv4oua5.java\t2023-03-24 13:51:21.619162717 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(ch); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = value; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:24.015153911 +0100\n+++ /tmp/tmp619fk50a.java\t2023-03-24 13:51:24.071153704 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = value; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = 31 * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:25.915146927 +0100\n+++ /tmp/tmppke7b8hy.java\t2023-03-24 13:51:26.915143251 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = 31 * b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(ch); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:29.979131987 +0100\n+++ /tmp/tmpi9_qhaqv.java\t2023-03-24 13:51:30.147131369 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(ch); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:31.831125178 +0100\n+++ /tmp/tmp7eq0t6bq.java\t2023-03-24 13:51:31.831125178 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = null; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(Long.parseLong(num)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:37.071105914 +0100\n+++ /tmp/tmpo_cvzadp.java\t2023-03-24 13:51:37.071105914 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(Long.parseLong(num)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(Character.toLowerCase(b)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:38.655100088 +0100\n+++ /tmp/tmp8h633a6k.java\t2023-03-24 13:51:38.655100088 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(Character.toLowerCase(b)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (i < 0) { result = result + String.valueOf(num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:44.247079521 +0100\n+++ /tmp/tmp2nol3oss.java\t2023-03-24 13:51:44.247079521 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < 0) { result = result + String.valueOf(num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(num); } else { result = num / b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:48.643063349 +0100\n+++ /tmp/tmpczq_8ljw.java\t2023-03-24 13:51:48.643063349 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(num); } else { result = num / b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = next; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:50.771055518 +0100\n+++ /tmp/tmp_gsgj1tx.java\t2023-03-24 13:51:50.879055121 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = next; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(ch); } else { result = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:52.651048601 +0100\n+++ /tmp/tmpe1s6wsre.java\t2023-03-24 13:51:52.763048191 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(ch); } else { result = b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(i); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:55.199039227 +0100\n+++ /tmp/tmpja34vbgy.java\t2023-03-24 13:51:55.267038977 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(i); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:51:57.275031585 +0100\n+++ /tmp/tmpqm97eh06.java\t2023-03-24 13:51:57.275031585 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = null; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(num); } else { result = i * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:01.927014466 +0100\n+++ /tmp/tmpmznysktl.java\t2023-03-24 13:52:01.927014466 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(num); } else { result = i * b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:04.027006736 +0100\n+++ /tmp/tmpglbza1so.java\t2023-03-24 13:52:04.031006719 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = \"\"; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = i + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:10.210983967 +0100\n+++ /tmp/tmpnbvmwo9i.java\t2023-03-24 13:52:10.210983967 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = i + b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:12.070977121 +0100\n+++ /tmp/tmpm_l5qx86.java\t2023-03-24 13:52:12.218976573 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = true; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (i < 0) { result = result + String.valueOf(num); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:15.054966131 +0100\n+++ /tmp/tmp9d5v9amh.java\t2023-03-24 13:52:15.118965898 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < 0) { result = result + String.valueOf(num); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = ; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:17.118958532 +0100\n+++ /tmp/tmpuh26sfq6.java\t2023-03-24 13:52:17.242958075 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = ; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (i < 0) { result = result + String.valueOf(b.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:19.494949782 +0100\n+++ /tmp/tmptc8yz9y3.java\t2023-03-24 13:52:19.494949782 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < 0) { result = result + String.valueOf(b.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:21.642941870 +0100\n+++ /tmp/tmpnbfrvcob.java\t2023-03-24 13:52:21.642941870 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { break; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = 31 * b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:25.558927445 +0100\n+++ /tmp/tmpqdz6x0uo.java\t2023-03-24 13:52:25.558927445 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = 31 * b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:27.254921194 +0100\n+++ /tmp/tmpf5mqyeph.java\t2023-03-24 13:52:27.382920725 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = true; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(num); } else { result = i + b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:29.578912635 +0100\n+++ /tmp/tmpssxvf953.java\t2023-03-24 13:52:29.690912221 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(num); } else { result = i + b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = value; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:31.526905454 +0100\n+++ /tmp/tmp3sie7_d4.java\t2023-03-24 13:52:31.526905454 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = value; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(num); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:33.342898759 +0100\n+++ /tmp/tmpk3r2367t.java\t2023-03-24 13:52:33.342898759 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(num); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = i + 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:35.162892055 +0100\n+++ /tmp/tmp0djn7lmi.java\t2023-03-24 13:52:35.162892055 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = i + 1; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (i < num) { result = result + String.valueOf( num); } else { result = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:36.922885566 +0100\n+++ /tmp/tmp26dy5u5z.java\t2023-03-24 13:52:36.922885566 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf( num); } else { result = b; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(b.substring(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:38.610879345 +0100\n+++ /tmp/tmpveo6zz8g.java\t2023-03-24 13:52:38.614879331 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(b.substring(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:40.314873065 +0100\n+++ /tmp/tmp1wmtmd_y.java\t2023-03-24 13:52:40.314873065 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { break; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = legacy; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:44.458857791 +0100\n+++ /tmp/tmp8wzi0v3q.java\t2023-03-24 13:52:44.458857791 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = legacy; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = key; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:46.294851022 +0100\n+++ /tmp/tmp8l53fn_z.java\t2023-03-24 13:52:46.294851022 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = key; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (i < num) { result = result + String.valueOf( num); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:48.034844608 +0100\n+++ /tmp/tmpm521_llc.java\t2023-03-24 13:52:48.038844593 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf( num); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(Long.parseLong(num)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:49.814838046 +0100\n+++ /tmp/tmpfu9td4td.java\t2023-03-24 13:52:49.814838046 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(Long.parseLong(num)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (i < num) { result = result + String.valueOf( num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:51.626831365 +0100\n+++ /tmp/tmpw01_65_2.java\t2023-03-24 13:52:51.626831365 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf( num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(ch); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:55.614816659 +0100\n+++ /tmp/tmp9ohwq99c.java\t2023-03-24 13:52:55.618816644 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(ch); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(mnemonic.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:57.386810125 +0100\n+++ /tmp/tmpnmv7mrnq.java\t2023-03-24 13:52:57.386810125 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(mnemonic.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i); } else { result = ; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:52:59.074803899 +0100\n+++ /tmp/tmprtq87wng.java\t2023-03-24 13:52:59.074803899 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i); } else { result = ; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(n.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:00.774797629 +0100\n+++ /tmp/tmpco4sxrkr.java\t2023-03-24 13:53:00.774797629 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(n.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(Long.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:02.566791019 +0100\n+++ /tmp/tmp05rmpa_8.java\t2023-03-24 13:53:02.566791019 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(Long.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (i < 0) { result = result + String.valueOf(i); } else { result = i; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:04.410784217 +0100\n+++ /tmp/tmpbf0fbe8y.java\t2023-03-24 13:53:04.410784217 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < 0) { result = result + String.valueOf(i); } else { result = i; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = i - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:06.122777903 +0100\n+++ /tmp/tmppos_saih.java\t2023-03-24 13:53:06.122777903 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = i - 1; }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(num); } else { result = i;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:07.862771485 +0100\n+++ /tmp/tmpt83a4y9c.java\t2023-03-24 13:53:07.862771485 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(num); } else { result = i;\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(System.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:09.506765419 +0100\n+++ /tmp/tmp8clb6vub.java\t2023-03-24 13:53:09.506765419 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(System.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (i < num - 1) { result = result + String.valueOf(num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:11.302758792 +0100\n+++ /tmp/tmp09jnfnnu.java\t2023-03-24 13:53:11.302758792 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num - 1) { result = result + String.valueOf(num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(Math.charAt(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:15.398743679 +0100\n+++ /tmp/tmpizk_nkg1.java\t2023-03-24 13:53:15.398743679 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(Math.charAt(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(Character.toLowerCase(b)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:17.194737052 +0100\n+++ /tmp/tmpbc9fd53b.java\t2023-03-24 13:53:17.198737038 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(Character.toLowerCase(b)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(++i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:21.106722614 +0100\n+++ /tmp/tmpf5271cja.java\t2023-03-24 13:53:21.106722614 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(++i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (i < num - 1) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:25.118707807 +0100\n+++ /tmp/tmpu_ixw5mg.java\t2023-03-24 13:53:25.118707807 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num - 1) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(l); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:29.038693337 +0100\n+++ /tmp/tmpu59f9tyc.java\t2023-03-24 13:53:29.038693337 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(l); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (i > 0) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:30.754687002 +0100\n+++ /tmp/tmp8my0f4k6.java\t2023-03-24 13:53:30.754687002 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i > 0) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf( num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:34.658672589 +0100\n+++ /tmp/tmpexo72raq.java\t2023-03-24 13:53:34.658672589 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf( num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (i < 0) { result = result + String.valueOf(b.substring(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:38.690657701 +0100\n+++ /tmp/tmp0hqf7788.java\t2023-03-24 13:53:38.694657685 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < 0) { result = result + String.valueOf(b.substring(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(ch); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:40.406651365 +0100\n+++ /tmp/tmp1vi0a6h5.java\t2023-03-24 13:53:40.406651365 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(ch); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(value); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:42.174644836 +0100\n+++ /tmp/tmppzm6ucze.java\t2023-03-24 13:53:42.174644836 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(value); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(++i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:43.942638306 +0100\n+++ /tmp/tmpinfgvl1c.java\t2023-03-24 13:53:43.942638306 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(++i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:47.942623533 +0100\n+++ /tmp/tmpj110rmyw.java\t2023-03-24 13:53:47.942623533 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(value); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:49.558617562 +0100\n+++ /tmp/tmpgmblmqkt.java\t2023-03-24 13:53:49.558617562 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(value); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(g); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:51.322611047 +0100\n+++ /tmp/tmp_x6qrv88.java\t2023-03-24 13:53:51.322611047 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(g); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (i > 0) { result = result + String.valueOf(num); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:53.010604812 +0100\n+++ /tmp/tmp365ip1s6.java\t2023-03-24 13:53:53.010604812 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i > 0) { result = result + String.valueOf(num); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (i >= num) { result = result + String.valueOf(l); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:57.202589324 +0100\n+++ /tmp/tmphyy8ux8p.java\t2023-03-24 13:53:57.202589324 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= num) { result = result + String.valueOf(l); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (i < len - 1) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:53:58.994582704 +0100\n+++ /tmp/tmpccutrkre.java\t2023-03-24 13:53:58.994582704 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < len - 1) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:00.766576155 +0100\n+++ /tmp/tmp52hyh2su.java\t2023-03-24 13:54:00.766576155 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(p); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:02.514569696 +0100\n+++ /tmp/tmpqxiuryhh.java\t2023-03-24 13:54:02.514569696 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(p); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:04.270563207 +0100\n+++ /tmp/tmp56vfg61p.java\t2023-03-24 13:54:04.274563193 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(b); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:08.302548308 +0100\n+++ /tmp/tmpyipc1rzw.java\t2023-03-24 13:54:08.302548308 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(k); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (i < num) { result = result + String.valueOf(offset); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:10.018541964 +0100\n+++ /tmp/tmplpys7rnr.java\t2023-03-24 13:54:10.018541964 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < num) { result = result + String.valueOf(offset); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (i < len) { result = result + String.valueOf(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:11.834535253 +0100\n+++ /tmp/tmplh6171j8.java\t2023-03-24 13:54:11.834535253 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < len) { result = result + String.valueOf(i); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (i >= 0) { result = result + String.valueOf(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:13.586528776 +0100\n+++ /tmp/tmpw8kmgkto.java\t2023-03-24 13:54:13.586528776 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i >= 0) { result = result + String.valueOf(i)); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (i < 0) { result = result + String.valueOf(ch); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/to_base/java_programs/TO_BASE.java\t2023-03-24 13:54:15.342522285 +0100\n+++ /tmp/tmp3o1299zf.java\t2023-03-24 13:54:15.342522285 +0100\n@@ -16,11 +16,11 @@\n         String alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n         int i;\n         while (num > 0) {\n             i = num % b;\n             num = num / b; // floor division?\n-            result = result + String.valueOf(alphabet.charAt(i));\n+if (i < 0) { result = result + String.valueOf(ch); }\n         }\n \n         return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "result = String.valueOf(alphabet.charAt(i))+result;"
    },
    "max_sublist_sum": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "max_ending_here = x + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:27.143362700 +0100\n+++ /tmp/tmpjk87dljh.java\t2023-03-24 13:50:27.199362495 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "max_ending_here = x + x;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:29.015355838 +0100\n+++ /tmp/tmpfj9580lf.java\t2023-03-24 13:50:29.015355838 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + x;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "max_ending_here = x + width;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:33.223340406 +0100\n+++ /tmp/tmpjh71seim.java\t2023-03-24 13:50:33.223340406 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + width;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "max_ending_here = x + w;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:35.035333759 +0100\n+++ /tmp/tmp17ofoosh.java\t2023-03-24 13:50:35.035333759 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + w;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "max_ending_here = x + 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:36.791327318 +0100\n+++ /tmp/tmp05zol4mn.java\t2023-03-24 13:50:36.791327318 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 1;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "max_ending_here = x + y;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:40.983311936 +0100\n+++ /tmp/tmpt4m50nqu.java\t2023-03-24 13:50:40.983311936 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + y;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "max_ending_here = x + arr.length;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:42.875304994 +0100\n+++ /tmp/tmpiexpaeg9.java\t2023-03-24 13:50:42.875304994 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + arr.length;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "max_ending_here = x + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:46.855290389 +0100\n+++ /tmp/tmpg08hp739.java\t2023-03-24 13:50:46.859290375 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 2;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "max_ending_here = x * arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:50.871275649 +0100\n+++ /tmp/tmp8ya8p7ck.java\t2023-03-24 13:50:50.871275649 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x * arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "max_ending_here = x + segment;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:52.467269794 +0100\n+++ /tmp/tmpv9b4573_.java\t2023-03-24 13:50:52.467269794 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + segment;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "max_ending_here = x + byteLen;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:54.419262628 +0100\n+++ /tmp/tmppip5m4bk.java\t2023-03-24 13:50:54.419262628 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byteLen;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "max_ending_here = x + separator;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:56.223256003 +0100\n+++ /tmp/tmpf1rmc0ih.java\t2023-03-24 13:50:56.223256003 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + separator;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "max_ending_here = x + this;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:50:58.935246045 +0100\n+++ /tmp/tmpbvsji_eh.java\t2023-03-24 13:50:58.935246045 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + this;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "max_ending_here = x / arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:01.091238128 +0100\n+++ /tmp/tmprkybi0no.java\t2023-03-24 13:51:01.095238114 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x / arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "max_ending_here = x + byte;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:03.143230593 +0100\n+++ /tmp/tmpens6kgsa.java\t2023-03-24 13:51:03.183230446 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "max_ending_here = x + zoom;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:05.195223058 +0100\n+++ /tmp/tmps2h4jnxk.java\t2023-03-24 13:51:05.195223058 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + zoom;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "max_ending_here = x +ending_here;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:07.763213625 +0100\n+++ /tmp/tmpbgstusge.java\t2023-03-24 13:51:07.763213625 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +ending_here;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "max_ending_here = x + byte[].class;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:10.591203240 +0100\n+++ /tmp/tmpala684fe.java\t2023-03-24 13:51:10.591203240 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte[].class;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "max_ending_here = x + connected;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:14.387189291 +0100\n+++ /tmp/tmpwe1vtkt0.java\t2023-03-24 13:51:14.387189291 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + connected;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "max_ending_here = x + n;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:17.051179503 +0100\n+++ /tmp/tmpkszkm6bj.java\t2023-03-24 13:51:17.051179503 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + n;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "max_ending_here = x + bitLength;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:19.467170625 +0100\n+++ /tmp/tmp_3sxi0s0.java\t2023-03-24 13:51:19.467170625 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + bitLength;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "max_ending_here = x + 5;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:21.699162423 +0100\n+++ /tmp/tmpj1dgb8fy.java\t2023-03-24 13:51:21.703162411 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 5;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "max_ending_here = x + days;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:28.291138192 +0100\n+++ /tmp/tmpiwycdtcc.java\t2023-03-24 13:51:28.291138192 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + days;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "max_ending_here = x + v;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:31.811125252 +0100\n+++ /tmp/tmpw7ixcpzv.java\t2023-03-24 13:51:31.811125252 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + v;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "max_ending_here = x + '\\n';",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:34.459115516 +0100\n+++ /tmp/tmpe9bce6hc.java\t2023-03-24 13:51:34.459115516 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + '\\n';\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "max_ending_here = x + value;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:39.251097897 +0100\n+++ /tmp/tmpbilr5vzn.java\t2023-03-24 13:51:39.251097897 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + value;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "max_ending_here = x + tag;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:41.359090141 +0100\n+++ /tmp/tmpeenv7lci.java\t2023-03-24 13:51:41.363090127 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + tag;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "max_ending_here = x + covered;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:43.371082744 +0100\n+++ /tmp/tmpqg7iio12.java\t2023-03-24 13:51:43.371082744 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + covered;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "final max_ending_here = x + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:45.999073076 +0100\n+++ /tmp/tmpn5fw7fwv.java\t2023-03-24 13:51:46.003073059 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+final max_ending_here = x + arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "max_ending_here = x + line;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:48.063065481 +0100\n+++ /tmp/tmpb6tuv_fu.java\t2023-03-24 13:51:48.063065481 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + line;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "max_ending_here = x + out;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:50.559056301 +0100\n+++ /tmp/tmpmifde4_4.java\t2023-03-24 13:51:50.563056283 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + out;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "max_ending_here = x + byte_MS;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:52.903047676 +0100\n+++ /tmp/tmpq_bvra4x.java\t2023-03-24 13:51:52.903047676 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_MS;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "max_ending_here = x + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:55.643037591 +0100\n+++ /tmp/tmpvhxax3zj.java\t2023-03-24 13:51:55.643037591 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 1);\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "max_ending_here = x + curr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:57.355031291 +0100\n+++ /tmp/tmpt0ejuir0.java\t2023-03-24 13:51:57.355031291 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + curr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "max_ending_here = x + shardId;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:51:59.807022269 +0100\n+++ /tmp/tmpaun7t52h.java\t2023-03-24 13:51:59.807022269 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + shardId;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "max_ending_here = x + ']';",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:01.939014419 +0100\n+++ /tmp/tmp0_wasjlu.java\t2023-03-24 13:52:01.943014405 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + ']';\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "max_ending_here = x + 5);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:06.950995970 +0100\n+++ /tmp/tmpnqevmn0l.java\t2023-03-24 13:52:06.950995970 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 5);\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "max_ending_here = x + 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:08.542990111 +0100\n+++ /tmp/tmpffnm4gyv.java\t2023-03-24 13:52:08.666989654 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 2;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "max_ending_here = x + right;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:13.142973174 +0100\n+++ /tmp/tmpr3tvul4s.java\t2023-03-24 13:52:13.146973157 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + right;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "max_ending_here = x + period;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:15.486964539 +0100\n+++ /tmp/tmppjvc46gz.java\t2023-03-24 13:52:15.486964539 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + period;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "max_ending_here = x / 2;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:17.282957928 +0100\n+++ /tmp/tmp53uvbkte.java\t2023-03-24 13:52:17.286957911 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x / 2;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "max_ending_here = x + height;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:22.922937153 +0100\n+++ /tmp/tmpuj4xx4vy.java\t2023-03-24 13:52:22.926937140 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + height;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "max_ending_here = x + 1.0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:25.562927427 +0100\n+++ /tmp/tmpgqzi1c60.java\t2023-03-24 13:52:25.562927427 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 1.0;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "max_ending_here = x + DOUBLE;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:27.722919470 +0100\n+++ /tmp/tmp8otb6nfs.java\t2023-03-24 13:52:27.722919470 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + DOUBLE;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "max_ending_here = x + minutes;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:30.450909419 +0100\n+++ /tmp/tmp5nr2cew1.java\t2023-03-24 13:52:30.450909419 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + minutes;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "max_ending_here = x + 10;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:32.170903081 +0100\n+++ /tmp/tmpgkmx061x.java\t2023-03-24 13:52:32.170903081 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 10;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "max_ending_here = x +Dirty;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:36.322887781 +0100\n+++ /tmp/tmp5q_717kf.java\t2023-03-24 13:52:36.326887763 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +Dirty;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "max_ending_here = y + arr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:38.194880879 +0100\n+++ /tmp/tmpd0vcxax0.java\t2023-03-24 13:52:38.198880866 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = y + arr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "max_ending_here = x + h;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:40.090873891 +0100\n+++ /tmp/tmpnlrkfuhj.java\t2023-03-24 13:52:40.094873879 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + h;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "max_ending_here = x + 9;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:41.974866949 +0100\n+++ /tmp/tmp49p12g8p.java\t2023-03-24 13:52:41.978866937 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 9;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "max_ending_here = x + i;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:46.262851141 +0100\n+++ /tmp/tmpjd7l0t62.java\t2023-03-24 13:52:46.262851141 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + i;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "max_ending_here = x + incr;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:48.082844432 +0100\n+++ /tmp/tmp9htuu_qa.java\t2023-03-24 13:52:48.082844432 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + incr;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "max_ending_here = x + range;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:49.950837544 +0100\n+++ /tmp/tmpb8fm_673.java\t2023-03-24 13:52:49.950837544 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + range;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "max_ending_here = x + times;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:51.826830628 +0100\n+++ /tmp/tmpxpnbbh3u.java\t2023-03-24 13:52:51.826830628 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + times;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "max_ending_here = x + available;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:53.702823710 +0100\n+++ /tmp/tmpia62q3z0.java\t2023-03-24 13:52:53.706823694 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + available;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "max_ending_here = x + other;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:55.678816423 +0100\n+++ /tmp/tmpcueq90ex.java\t2023-03-24 13:52:55.682816409 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + other;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "max_ending_here = x + str;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:57.482809770 +0100\n+++ /tmp/tmpd820wj3d.java\t2023-03-24 13:52:57.482809770 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + str;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "max_ending_here = x + tmp;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:52:59.230803323 +0100\n+++ /tmp/tmprfky9o4p.java\t2023-03-24 13:52:59.230803323 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + tmp;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "max_ending_here = x + my_here;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:01.050796612 +0100\n+++ /tmp/tmpdpgpy2wl.java\t2023-03-24 13:53:01.050796612 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + my_here;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "max_ending_here = x + \"\\\";",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:02.818790090 +0100\n+++ /tmp/tmp4c8ozdr2.java\t2023-03-24 13:53:02.818790090 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + \"\\\";\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "max_ending_here = x + horizontal;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:04.534783760 +0100\n+++ /tmp/tmpomrbvlv5.java\t2023-03-24 13:53:04.534783760 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + horizontal;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "max_ending_here = x + result;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:06.270777357 +0100\n+++ /tmp/tmp7rbleaq1.java\t2023-03-24 13:53:06.270777357 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + result;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "max_ending_here = x + whitelist;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:08.070770716 +0100\n+++ /tmp/tmphlo7vqe3.java\t2023-03-24 13:53:08.070770716 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + whitelist;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "max_ending_here = x + m;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:09.830764224 +0100\n+++ /tmp/tmp3mzlcc0t.java\t2023-03-24 13:53:09.830764224 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + m;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "max_ending_here = x + VERSION;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:11.538757922 +0100\n+++ /tmp/tmp6wfa_uki.java\t2023-03-24 13:53:11.542757906 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + VERSION;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "max_ending_here = x + target;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:13.294751442 +0100\n+++ /tmp/tmpni3gyhyg.java\t2023-03-24 13:53:13.294751442 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + target;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "max_ending_here = x + cursor;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:15.258744195 +0100\n+++ /tmp/tmpg2ic8h6j.java\t2023-03-24 13:53:15.262744181 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + cursor;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "max_ending_here = x +w;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:17.098737405 +0100\n+++ /tmp/tmp7d7falxc.java\t2023-03-24 13:53:17.098737405 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +w;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "max_ending_here = x + encryption;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:18.950730572 +0100\n+++ /tmp/tmpepj9fzdc.java\t2023-03-24 13:53:18.950730572 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + encryption;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "max_ending_here = x + key;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:20.810723707 +0100\n+++ /tmp/tmp_co2789s.java\t2023-03-24 13:53:20.810723707 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + key;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "max_ending_here = x + start;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:22.698716740 +0100\n+++ /tmp/tmpcfwz0q1i.java\t2023-03-24 13:53:22.698716740 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + start;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "max_ending_here = x + bits;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:24.594709742 +0100\n+++ /tmp/tmp1l5p5eaq.java\t2023-03-24 13:53:24.594709742 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + bits;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "max_ending_here = x + byte_here;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:26.550702521 +0100\n+++ /tmp/tmpwcih9sw9.java\t2023-03-24 13:53:26.550702521 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_here;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "max_ending_here = x + byteBufLen;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:28.386695743 +0100\n+++ /tmp/tmprrpnbg91.java\t2023-03-24 13:53:28.386695743 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byteBufLen;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "max_ending_here = x + INPUT_far;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:30.270688789 +0100\n+++ /tmp/tmpv1ixw3nv.java\t2023-03-24 13:53:30.270688789 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + INPUT_far;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "max_ending_here = x + 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:32.186681715 +0100\n+++ /tmp/tmp6_quc5li.java\t2023-03-24 13:53:32.190681702 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + 0;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "max_ending_here = x + byte_LIMIT;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:36.490665825 +0100\n+++ /tmp/tmpjicvx578.java\t2023-03-24 13:53:36.494665809 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_LIMIT;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "max_ending_here = x + byte_separator;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:38.294659163 +0100\n+++ /tmp/tmp50op56df.java\t2023-03-24 13:53:38.298659149 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_separator;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "max_ending_here = x +LING_far;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:40.202652117 +0100\n+++ /tmp/tmpav0vs898.java\t2023-03-24 13:53:40.202652117 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +LING_far;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "max_ending_here = x + INPUT_LIMIT;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:41.986645529 +0100\n+++ /tmp/tmp9fatfstt.java\t2023-03-24 13:53:41.986645529 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + INPUT_LIMIT;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "max_ending_here = x + byte_PREFIX;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:43.826638733 +0100\n+++ /tmp/tmpcdcihh29.java\t2023-03-24 13:53:43.826638733 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_PREFIX;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "max_ending_here = x + byte_FACTORY;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:45.630632071 +0100\n+++ /tmp/tmpz_b4wey5.java\t2023-03-24 13:53:45.634632057 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_FACTORY;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "max_ending_here = x + byte_SECOND;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:47.538625024 +0100\n+++ /tmp/tmpyge2dw1u.java\t2023-03-24 13:53:47.538625024 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_SECOND;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "max_ending_here = x + DOUBLE_LIMIT;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:49.350618330 +0100\n+++ /tmp/tmpu69zifvk.java\t2023-03-24 13:53:49.350618330 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + DOUBLE_LIMIT;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "max_ending_here = x + DOUBLE_MS;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:51.106611845 +0100\n+++ /tmp/tmphsote9q4.java\t2023-03-24 13:53:51.106611845 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + DOUBLE_MS;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "max_ending_here = x + '\\n';",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:52.990604885 +0100\n+++ /tmp/tmpta_wbkvu.java\t2023-03-24 13:53:52.990604885 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + '\\n';\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "max_ending_here = x +LING_MS;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:57.194589354 +0100\n+++ /tmp/tmpr2sos4cl.java\t2023-03-24 13:53:57.194589354 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x +LING_MS;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "max_ending_here = x + byte_username;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:53:59.110582275 +0100\n+++ /tmp/tmpa45jrsl6.java\t2023-03-24 13:53:59.110582275 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_username;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "max_ending_here = x + min_here;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:00.890575697 +0100\n+++ /tmp/tmpf7kmizha.java\t2023-03-24 13:54:00.890575697 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + min_here;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "max_ending_here = x + byte_far;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:02.654569180 +0100\n+++ /tmp/tmpv8exnzhe.java\t2023-03-24 13:54:02.654569180 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_far;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "max_ending_here = x + byte_NAME;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:04.490562395 +0100\n+++ /tmp/tmpgs5m2yr8.java\t2023-03-24 13:54:04.490562395 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_NAME;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "max_ending_here = x + byte_SQL;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:06.262555847 +0100\n+++ /tmp/tmpf9oc_jr_.java\t2023-03-24 13:54:06.262555847 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_SQL;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "max_ending_here = x + arr.size;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:08.126548957 +0100\n+++ /tmp/tmpapzhghmu.java\t2023-03-24 13:54:08.126548957 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + arr.size;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "max_ending_here = x + byte_big;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:09.946542230 +0100\n+++ /tmp/tmpjokj9q_a.java\t2023-03-24 13:54:09.946542230 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_big;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "max_ending_here = x + byte_\\\";",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:11.798535386 +0100\n+++ /tmp/tmp9boggzwv.java\t2023-03-24 13:54:11.798535386 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + byte_\\\";\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "max_ending_here = x + bitending;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:13.594528746 +0100\n+++ /tmp/tmprqlj8kkh.java\t2023-03-24 13:54:13.594528746 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+max_ending_here = x + bitending;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (x + x; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:15.430521960 +0100\n+++ /tmp/tmp0l1gb4ur.java\t2023-03-24 13:54:15.434521946 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+if (x + x; }\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (x + x;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:17.110515749 +0100\n+++ /tmp/tmp9r7hx443.java\t2023-03-24 13:54:17.110515749 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+if (x + x;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (x + w;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:19.354507454 +0100\n+++ /tmp/tmpu74ifcho.java\t2023-03-24 13:54:19.354507454 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+if (x + w;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (x + width;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/max_sublist_sum/java_programs/MAX_SUBLIST_SUM.java\t2023-03-24 13:54:21.214500578 +0100\n+++ /tmp/tmpjnzuct7f.java\t2023-03-24 13:54:21.214500578 +0100\n@@ -14,11 +14,11 @@\n     public static int max_sublist_sum(int[] arr) {\n         int max_ending_here = 0;\n         int max_so_far = 0;\n \n         for (int x : arr) {\n-            max_ending_here = max_ending_here + x;\n+if (x + width;\n             max_so_far = Math.max(max_so_far, max_ending_here);\n         }\n \n         return max_so_far;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "max_ending_here = Math.max(0,max_ending_here + x);"
    },
    "reverse_linked_list": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (nextnode!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:19.578506626 +0100\n+++ /tmp/tmp2k2l9cin.java\t2023-03-24 13:54:19.590506582 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:23.630491644 +0100\n+++ /tmp/tmp67b_8kfq.java\t2023-03-24 13:54:23.630491644 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.getNodeType() == Node.ELEMENT_NODE) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (nextnode.getNode() == node) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:26.054482681 +0100\n+++ /tmp/tmpbkwkxb_b.java\t2023-03-24 13:54:26.054482681 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (node.getNodeType()!= Node.ELEMENT_NODE) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:28.274474472 +0100\n+++ /tmp/tmp5hmaxedo.java\t2023-03-24 13:54:28.274474472 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.getNodeType()!= Node.ELEMENT_NODE) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (nextnode.getNode() == node) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:30.094467743 +0100\n+++ /tmp/tmp25m61mqm.java\t2023-03-24 13:54:30.098467727 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (nextnode!= null) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:31.938460924 +0100\n+++ /tmp/tmpk8gv6vkf.java\t2023-03-24 13:54:31.938460924 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (nextnode!= null) { nextnode.setChild(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:35.958446055 +0100\n+++ /tmp/tmpwwefx_8g.java\t2023-03-24 13:54:35.958446055 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { nextnode.setChild(nextNode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (nextnode!= null) { node.addChild(prevnode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:37.722439531 +0100\n+++ /tmp/tmpiutz6_i0.java\t2023-03-24 13:54:37.722439531 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.addChild(prevnode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (nextnode.getNode() == node.getNode()) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:39.542432799 +0100\n+++ /tmp/tmps4nntyzn.java\t2023-03-24 13:54:39.542432799 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node.getNode()) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (nextnode!= null) { node.setParentNode(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:41.302426287 +0100\n+++ /tmp/tmpyf1829fc.java\t2023-03-24 13:54:41.302426287 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.setParentNode(nextNode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (node.right!= null) { node.right = node.right; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:42.946420206 +0100\n+++ /tmp/tmpidgf0a5p.java\t2023-03-24 13:54:42.946420206 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.right!= null) { node.right = node.right; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (nextnode!= null) { node.setFinishedNode(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:44.626413992 +0100\n+++ /tmp/tmp016s1ons.java\t2023-03-24 13:54:44.626413992 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.setFinishedNode(nextNode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:46.326407703 +0100\n+++ /tmp/tmpei7zgehd.java\t2023-03-24 13:54:46.326407703 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.getNodeType() == Node.ELEMENT_NODE) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (nextnode!= null) { node.setNode(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:48.170400879 +0100\n+++ /tmp/tmp24jnszzc.java\t2023-03-24 13:54:48.174400865 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.setNode(nextNode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (nextnode.getNode() == node) { continue; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:49.938394338 +0100\n+++ /tmp/tmpk86nlgu3.java\t2023-03-24 13:54:49.982394175 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node) { continue; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "node.addChild(prevNode, prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:51.798387455 +0100\n+++ /tmp/tmpa56bzizh.java\t2023-03-24 13:54:51.798387455 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode, prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (nextnode!= null) { nextnode.setNode(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:53.530381046 +0100\n+++ /tmp/tmpejl1u3v4.java\t2023-03-24 13:54:53.530381046 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { nextnode.setNode(nextNode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (nextNode!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:55.386374180 +0100\n+++ /tmp/tmps715e9hq.java\t2023-03-24 13:54:55.386374180 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextNode!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (nextnode.getNode() == null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:57.098367843 +0100\n+++ /tmp/tmpw_hb_ng1.java\t2023-03-24 13:54:57.098367843 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (node.right!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:54:58.830361432 +0100\n+++ /tmp/tmpgetfvxhv.java\t2023-03-24 13:54:58.830361432 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.right!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (nextnode!= null) { prevnode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:00.614354832 +0100\n+++ /tmp/tmpjp8t2c46.java\t2023-03-24 13:55:00.614354832 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { prevnode = node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (nextnode.getNode()!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:04.710339671 +0100\n+++ /tmp/tmpdhq5kajp.java\t2023-03-24 13:55:04.710339671 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode()!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "prevNode = node.getFirstChild();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:06.374333511 +0100\n+++ /tmp/tmpng7nb9co.java\t2023-03-24 13:55:06.374333511 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getFirstChild();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (nextnode.getNode() == node) { prevNode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:08.190326789 +0100\n+++ /tmp/tmpufxptnjp.java\t2023-03-24 13:55:08.190326789 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == node) { prevNode = node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (nextnode.getNode() == null) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:09.990320125 +0100\n+++ /tmp/tmpi8kl1d1m.java\t2023-03-24 13:55:09.990320125 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.getNode() == null) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (nextNode.getNode() == node) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:11.694313816 +0100\n+++ /tmp/tmpan5fq199.java\t2023-03-24 13:55:11.698313802 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextNode.getNode() == node) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "prevNode.addChild(prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:13.498307138 +0100\n+++ /tmp/tmpnva8a306.java\t2023-03-24 13:55:13.498307138 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode.addChild(prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (nextnode!= null) { node.setChild(nextNode); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:15.222300756 +0100\n+++ /tmp/tmpcifaleoz.java\t2023-03-24 13:55:15.222300756 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.setChild(nextNode); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "prevNode.addChild(prevNode, prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:16.934294418 +0100\n+++ /tmp/tmpuq6baamu.java\t2023-03-24 13:55:16.934294418 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode.addChild(prevNode, prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "prevnode = node.cloneNode(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:18.682287944 +0100\n+++ /tmp/tmpc6co8h9_.java\t2023-03-24 13:55:18.682287944 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.cloneNode(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (nextnode!= null) { node.setValue(value); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:20.426281487 +0100\n+++ /tmp/tmp97hsokma.java\t2023-03-24 13:55:20.430281471 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { node.setValue(value); }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "prevnode.addChild(prevNode, prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:22.250274732 +0100\n+++ /tmp/tmp8peuhvfl.java\t2023-03-24 13:55:22.250274732 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(prevNode, prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (nextnode.right!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:23.974268348 +0100\n+++ /tmp/tmp2_wa47du.java\t2023-03-24 13:55:23.974268348 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode.right!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "node.addChild(prevNode, prevNode, false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:25.638262187 +0100\n+++ /tmp/tmpswercfg6.java\t2023-03-24 13:55:25.638262187 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode, prevNode, false);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (nextNode.getNode() == node) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:27.346255860 +0100\n+++ /tmp/tmptd_rrejn.java\t2023-03-24 13:55:27.346255860 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextNode.getNode() == node) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "node.addChild(prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:29.034249609 +0100\n+++ /tmp/tmpmwkk0_qv.java\t2023-03-24 13:55:29.038249593 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (node.getNode() == node) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:30.726243343 +0100\n+++ /tmp/tmpm9rbt_3b.java\t2023-03-24 13:55:30.726243343 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.getNode() == node) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (nextnode!= null) { return nextnode; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:32.458236927 +0100\n+++ /tmp/tmpo7h4febi.java\t2023-03-24 13:55:32.458236927 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode!= null) { return nextnode; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "prevNode = node.getNextSibling();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:36.458222111 +0100\n+++ /tmp/tmpypf6mfm5.java\t2023-03-24 13:55:36.462222095 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getNextSibling();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "prevNode = node.addChild(prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:38.194215680 +0100\n+++ /tmp/tmpu4ag5anw.java\t2023-03-24 13:55:38.194215680 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.addChild(prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "node.addChild(prevNode, prevNode, true);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:39.902209352 +0100\n+++ /tmp/tmp6e776uy9.java\t2023-03-24 13:55:39.902209352 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode, prevNode, true);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "prevNode = node.getPreviousSibling();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:41.646202891 +0100\n+++ /tmp/tmpxxfctvuc.java\t2023-03-24 13:55:41.650202877 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getPreviousSibling();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (nextNode!= null) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:43.406196370 +0100\n+++ /tmp/tmp0qxc_jyr.java\t2023-03-24 13:55:43.406196370 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextNode!= null) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "prevNode.addChild(prevNode, prevNode, true);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:45.238189582 +0100\n+++ /tmp/tmp6qfkcpp2.java\t2023-03-24 13:55:45.238189582 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode.addChild(prevNode, prevNode, true);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "prevnode.addChild(prevNode, prev);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:47.030182942 +0100\n+++ /tmp/tmpsn1fjwv_.java\t2023-03-24 13:55:47.030182942 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(prevNode, prev);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "prevNode.addChild(prevNode, prevNode, false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:48.902176007 +0100\n+++ /tmp/tmpwi2nqfkg.java\t2023-03-24 13:55:48.902176007 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode.addChild(prevNode, prevNode, false);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "prevnode.addChild(prevNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:50.666169471 +0100\n+++ /tmp/tmptui4awky.java\t2023-03-24 13:55:50.666169471 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(prevNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "node.setValue(nextnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:52.418162978 +0100\n+++ /tmp/tmp_gsr1eip.java\t2023-03-24 13:55:52.422162962 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setValue(nextnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (node.next!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:54.230156264 +0100\n+++ /tmp/tmpr55vyglp.java\t2023-03-24 13:55:54.234156248 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.next!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (node.right!= null) { return node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:56.006149682 +0100\n+++ /tmp/tmpajdp4rnf.java\t2023-03-24 13:55:56.006149682 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.right!= null) { return node; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "node.addChild(prevNode, node, true);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:57.786143084 +0100\n+++ /tmp/tmp93dk6u7y.java\t2023-03-24 13:55:57.786143084 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode, node, true);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "prevnode.addChild(prevNode, prevNode, true);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:55:59.474136828 +0100\n+++ /tmp/tmp_qvqieqo.java\t2023-03-24 13:55:59.474136828 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(prevNode, prevNode, true);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (nextnode == null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:01.182130498 +0100\n+++ /tmp/tmp60g56ab1.java\t2023-03-24 13:56:01.186130482 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (nextnode == null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (node.prev!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:05.282115301 +0100\n+++ /tmp/tmpwq64mp41.java\t2023-03-24 13:56:05.282115301 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (node.prev!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "prevnode.addChild(prevNode, prevNode, false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:06.998108939 +0100\n+++ /tmp/tmp6vlunkef.java\t2023-03-24 13:56:06.998108939 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(prevNode, prevNode, false);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "prevNode = node.prevNode.getNodeValue();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:08.694102651 +0100\n+++ /tmp/tmp9srdyxhp.java\t2023-03-24 13:56:08.698102638 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.prevNode.getNodeValue();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "prevNode = node.getNodeValue();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:10.506095935 +0100\n+++ /tmp/tmp5beae9cq.java\t2023-03-24 13:56:10.506095935 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getNodeValue();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "prevNode = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:12.274089379 +0100\n+++ /tmp/tmppzndwteq.java\t2023-03-24 13:56:12.274089379 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "prev prev.addChild(prevNode, prev);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:14.086082663 +0100\n+++ /tmp/tmpqkcr7lop.java\t2023-03-24 13:56:14.086082663 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prev prev.addChild(prevNode, prev);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "prev prev = node.cloneNode(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:15.770076419 +0100\n+++ /tmp/tmpx_vj4jhb.java\t2023-03-24 13:56:15.770076419 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prev prev = node.cloneNode(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "prevNode.addChild(prevNode, prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:17.650069449 +0100\n+++ /tmp/tmpis1gna04.java\t2023-03-24 13:56:17.654069433 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode.addChild(prevNode, prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "prevNode.addChild(nextNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:19.418062893 +0100\n+++ /tmp/tmp2soc7h88.java\t2023-03-24 13:56:19.422062877 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode.addChild(nextNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "prevNode = node.cloneNode(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:21.122056573 +0100\n+++ /tmp/tmpz_zyso9s.java\t2023-03-24 13:56:21.126056560 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.cloneNode(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (prevnode!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:22.886050032 +0100\n+++ /tmp/tmp5_0knz9y.java\t2023-03-24 13:56:22.886050032 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (prevnode!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "prevnode.addChild(prevNode, prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:27.098034412 +0100\n+++ /tmp/tmpyfkd1fc_.java\t2023-03-24 13:56:27.098034412 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode.addChild(prevNode, prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (prevprev!= null) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:28.866027855 +0100\n+++ /tmp/tmpf9vfrddw.java\t2023-03-24 13:56:28.866027855 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+if (prevprev!= null) { break; }\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "prevnode = node.cloneNode(prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:30.622021344 +0100\n+++ /tmp/tmpeynty57b.java\t2023-03-24 13:56:30.622021344 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.cloneNode(prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "prevNode = node.getParentNode();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:32.374014846 +0100\n+++ /tmp/tmpfiw54540.java\t2023-03-24 13:56:32.374014846 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getParentNode();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "node.addChild(prevNode, prev);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:34.126008346 +0100\n+++ /tmp/tmp6_6wahq2.java\t2023-03-24 13:56:34.126008346 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevNode, prev);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "prevnode = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:35.878001848 +0100\n+++ /tmp/tmp4tdcj9sk.java\t2023-03-24 13:56:35.878001848 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "prevTarget = node.getNodeValue();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:37.621995378 +0100\n+++ /tmp/tmpbof21zb8.java\t2023-03-24 13:56:37.625995365 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevTarget = node.getNodeValue();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "prevnode = node.getNodeValue();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:39.449988597 +0100\n+++ /tmp/tmpcbk2l4e0.java\t2023-03-24 13:56:39.449988597 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.getNodeValue();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "node.setValue(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:41.185982159 +0100\n+++ /tmp/tmpnzj3_44a.java\t2023-03-24 13:56:41.185982159 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setValue(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "prevNode = node.getPreviousParent();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:42.857975955 +0100\n+++ /tmp/tmpazqs33cp.java\t2023-03-24 13:56:42.857975955 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getPreviousParent();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "node = node.getParentNode();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:44.533969737 +0100\n+++ /tmp/tmpa9uoqje2.java\t2023-03-24 13:56:44.533969737 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node = node.getParentNode();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "node.addChild(nextNode, node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:46.177963639 +0100\n+++ /tmp/tmp3nslfveu.java\t2023-03-24 13:56:46.177963639 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(nextNode, node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "prev prev = node.prev;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:47.913957196 +0100\n+++ /tmp/tmp6nefp6qr.java\t2023-03-24 13:56:47.913957196 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prev prev = node.prev;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "prevNode = node.prevNode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:49.689950608 +0100\n+++ /tmp/tmp1nt0sasg.java\t2023-03-24 13:56:49.689950608 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.prevNode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "prevNodes.add(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:51.413944212 +0100\n+++ /tmp/tmpwf2uoakw.java\t2023-03-24 13:56:51.413944212 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNodes.add(node);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "prevnode = node.getNextSibling();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:53.213937531 +0100\n+++ /tmp/tmpjt4ilcjf.java\t2023-03-24 13:56:53.213937531 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.getNextSibling();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "prevnode = node.getPreviousSibling();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:54.909931239 +0100\n+++ /tmp/tmpw1gl3vx5.java\t2023-03-24 13:56:54.909931239 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.getPreviousSibling();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "node.addChild(prevnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:56.597924976 +0100\n+++ /tmp/tmplz9dyngq.java\t2023-03-24 13:56:56.597924976 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.addChild(prevnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "prevNode = node.nextNode();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:56:58.409918250 +0100\n+++ /tmp/tmpadbk128a.java\t2023-03-24 13:56:58.409918250 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.nextNode();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "node.setNode(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:00.165911733 +0100\n+++ /tmp/tmp69_e41jo.java\t2023-03-24 13:57:00.165911733 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setNode(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "prevNode = node.getPreviousNode();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:01.897905305 +0100\n+++ /tmp/tmphqq3ymy1.java\t2023-03-24 13:57:01.897905305 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getPreviousNode();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "prevNode = node.getFirstChild(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:03.741898463 +0100\n+++ /tmp/tmpew6hte8i.java\t2023-03-24 13:57:03.741898463 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getFirstChild(1);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "node.setParentNode(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:05.533891810 +0100\n+++ /tmp/tmpnkcgec0c.java\t2023-03-24 13:57:05.533891810 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setParentNode(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "prevNode = node.getData();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:07.357885041 +0100\n+++ /tmp/tmpunt9grft.java\t2023-03-24 13:57:07.357885041 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getData();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "node.setFinished(prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:09.101878568 +0100\n+++ /tmp/tmp6sktqhr4.java\t2023-03-24 13:57:09.101878568 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setFinished(prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "prevnode = node.prevNode;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:10.873871989 +0100\n+++ /tmp/tmp1dp9s1ey.java\t2023-03-24 13:57:10.877871976 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.prevNode;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "prevNodes.add(prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:12.649865397 +0100\n+++ /tmp/tmpv_qg_x32.java\t2023-03-24 13:57:12.649865397 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNodes.add(prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "node.removeChild(prevNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:14.373858997 +0100\n+++ /tmp/tmpbhxj3oum.java\t2023-03-24 13:57:14.373858997 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.removeChild(prevNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "node.appendChild(nextNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:16.041852806 +0100\n+++ /tmp/tmpqdjukzhx.java\t2023-03-24 13:57:16.041852806 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.appendChild(nextNode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "prevNode = node.getChildren();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:17.729846539 +0100\n+++ /tmp/tmp7xta3zv4.java\t2023-03-24 13:57:17.769846390 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevNode = node.getChildren();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "prev prev = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:19.597839603 +0100\n+++ /tmp/tmprjfx0g2l.java\t2023-03-24 13:57:19.601839590 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prev prev = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "node.setValue(prevnode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:21.329833174 +0100\n+++ /tmp/tmpf2afw7m5.java\t2023-03-24 13:57:21.329833174 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.setValue(prevnode);\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "prevnode = node.prev;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:23.189826269 +0100\n+++ /tmp/tmpotcye_xv.java\t2023-03-24 13:57:23.189826269 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+prevnode = node.prev;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "node = node.next;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:25.013819496 +0100\n+++ /tmp/tmpip1a657x.java\t2023-03-24 13:57:25.017819480 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node = node.next;\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "node.pop();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:26.721813153 +0100\n+++ /tmp/tmpty25njsi.java\t2023-03-24 13:57:26.725813140 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+node.pop();\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/reverse_linked_list/java_programs/REVERSE_LINKED_LIST.java\t2023-03-24 13:57:28.521806470 +0100\n+++ /tmp/tmpjl1a9hc1.java\t2023-03-24 13:57:28.521806470 +0100\n@@ -15,10 +15,11 @@\n         Node prevnode = null;\n         Node nextnode;\n         while (node != null) {\n             nextnode = node.getSuccessor();\n             node.setSuccessor(prevnode);\n+\n             node = nextnode;\n         }\n         return prevnode;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "prevnode = node;"
    },
    "minimum_spanning_tree": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:28.270474488 +0100\n+++ /tmp/tmpb_wadrti.java\t2023-03-24 13:54:28.270474488 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeType() == Node.ELEMENT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (node.getValue().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:30.234467225 +0100\n+++ /tmp/tmp2mqup0_9.java\t2023-03-24 13:54:30.234467225 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (node.getValue().equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:34.442451662 +0100\n+++ /tmp/tmpzlz2cd0k.java\t2023-03-24 13:54:34.442451662 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (node.getValue().equals(groupByNode.get(vertex_u))) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:36.406444397 +0100\n+++ /tmp/tmpdok_iikt.java\t2023-03-24 13:54:36.410444383 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(groupByNode.get(vertex_u))) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (node.getChildCount() == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:40.490429291 +0100\n+++ /tmp/tmpazccwb7o.java\t2023-03-24 13:54:40.490429291 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (node.get(vertex_v)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:42.426422130 +0100\n+++ /tmp/tmpn56unnm1.java\t2023-03-24 13:54:42.426422130 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (node.hasDescendant(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:44.390414864 +0100\n+++ /tmp/tmp9vs6nwtw.java\t2023-03-24 13:54:44.390414864 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.hasDescendant(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (node.isCopyCamelCase) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:46.246407998 +0100\n+++ /tmp/tmppfyder7s.java\t2023-03-24 13:54:46.246407998 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isCopyCamelCase) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (node.getChildCount() < minSpanningTree.getChildCount()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:48.138400998 +0100\n+++ /tmp/tmpmalc0bht.java\t2023-03-24 13:54:48.142400982 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() < minSpanningTree.getChildCount()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (node.is(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:50.054393909 +0100\n+++ /tmp/tmpzc8_qt9j.java\t2023-03-24 13:54:50.054393909 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (node.getIndex() < minSpanningTree.getIndex()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:51.914387026 +0100\n+++ /tmp/tmpn1_2h8yg.java\t2023-03-24 13:54:51.914387026 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getIndex() < minSpanningTree.getIndex()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (node.find()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:53.770380159 +0100\n+++ /tmp/tmpyd7wkhq0.java\t2023-03-24 13:54:53.774380143 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.find()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (node.is(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:55.578373469 +0100\n+++ /tmp/tmp0597awfz.java\t2023-03-24 13:54:55.578373469 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (node.hasDescendant(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:57.430366614 +0100\n+++ /tmp/tmp0093sef7.java\t2023-03-24 13:54:57.430366614 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.hasDescendant(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (node.getChildCount() > 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:54:59.274359791 +0100\n+++ /tmp/tmpru956x1m.java\t2023-03-24 13:54:59.274359791 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() > 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (node.getValue().equals(groupByNode)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:01.090353069 +0100\n+++ /tmp/tmp774eshvf.java\t2023-03-24 13:55:01.094353055 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(groupByNode)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (node.getNodeType() == Node.COMMENT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:05.426337021 +0100\n+++ /tmp/tmp221hgent.java\t2023-03-24 13:55:05.426337021 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeType() == Node.COMMENT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (node.getCount() < minSpanningTree.getCount() - 1) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:07.262330223 +0100\n+++ /tmp/tmpd1e712cl.java\t2023-03-24 13:55:07.262330223 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCount() < minSpanningTree.getCount() - 1) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (node.get(vertex_u)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:09.086323472 +0100\n+++ /tmp/tmp4qhl5t20.java\t2023-03-24 13:55:09.086323472 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_u)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (node.isPlusNode()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:10.982316453 +0100\n+++ /tmp/tmplo_t_i3b.java\t2023-03-24 13:55:10.982316453 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isPlusNode()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (node.getNumber() == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:12.890309389 +0100\n+++ /tmp/tmpyl2l7v9b.java\t2023-03-24 13:55:12.890309389 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNumber() == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (node.getIndex() < minSpanningTree.getIndex() - 1) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:14.730302577 +0100\n+++ /tmp/tmp8lem_9lk.java\t2023-03-24 13:55:14.734302563 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getIndex() < minSpanningTree.getIndex() - 1) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (node.isCopyBookOrGeneratedNode()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:16.686295335 +0100\n+++ /tmp/tmpdemge92l.java\t2023-03-24 13:55:16.686295335 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isCopyBookOrGeneratedNode()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (node.isCopyBookOrUndirected()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:18.598288256 +0100\n+++ /tmp/tmpeukz8jl5.java\t2023-03-24 13:55:18.598288256 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isCopyBookOrUndirected()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (node.getValue().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:20.530281102 +0100\n+++ /tmp/tmp6t0t_eck.java\t2023-03-24 13:55:20.530281102 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(vertex_v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (node.getNodeType() == Node.TEXT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:24.774265386 +0100\n+++ /tmp/tmpb1qu7lyj.java\t2023-03-24 13:55:24.774265386 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeType() == Node.TEXT_NODE) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (node.find(vertex_v)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:26.654258423 +0100\n+++ /tmp/tmpijrnp_6d.java\t2023-03-24 13:55:26.654258423 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.find(vertex_v)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (node.getOppositeMatched() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:28.534251461 +0100\n+++ /tmp/tmpt0psoxvy.java\t2023-03-24 13:55:28.538251445 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getOppositeMatched() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (node.getChildCount() == minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:30.442244395 +0100\n+++ /tmp/tmpdx2gmyxr.java\t2023-03-24 13:55:30.442244395 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() == minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (node.hasDescendant(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:32.326237415 +0100\n+++ /tmp/tmpy93x7xrg.java\t2023-03-24 13:55:32.326237415 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.hasDescendant(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (node.get(vertex_v) == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:34.298230111 +0100\n+++ /tmp/tmpny7yzac3.java\t2023-03-24 13:55:34.298230111 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v) == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (node.is Boolean.TRUE) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:36.246222895 +0100\n+++ /tmp/tmpbul_jblu.java\t2023-03-24 13:55:36.246222895 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is Boolean.TRUE) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (node.getChildCount() < minSpanningTree.size() - 1) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:38.038216258 +0100\n+++ /tmp/tmprf4txgfl.java\t2023-03-24 13:55:38.038216258 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() < minSpanningTree.size() - 1) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (node.asText().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:39.906209338 +0100\n+++ /tmp/tmpf73z9te5.java\t2023-03-24 13:55:39.906209338 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.asText().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (node.is(v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:41.762202462 +0100\n+++ /tmp/tmpp2khn9ky.java\t2023-03-24 13:55:41.762202462 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is(v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (node.getValue().equals(groupByNode.get(vertex_v))) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:43.594195674 +0100\n+++ /tmp/tmp2gxp9py8.java\t2023-03-24 13:55:43.594195674 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(groupByNode.get(vertex_v))) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (node.getTreeParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:47.834179963 +0100\n+++ /tmp/tmpcowo8l9i.java\t2023-03-24 13:55:47.834179963 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTreeParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (node.getName() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:49.606173399 +0100\n+++ /tmp/tmpn4gvr3c9.java\t2023-03-24 13:55:49.610173383 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName() == vertex_v) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (node.excess >= minSpanningTree.size()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:51.562166150 +0100\n+++ /tmp/tmpm01_hx_n.java\t2023-03-24 13:55:51.562166150 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.excess >= minSpanningTree.size()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (node.getChildCount() < minSpanningTree.size()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:53.390159376 +0100\n+++ /tmp/tmpgy31j4p0.java\t2023-03-24 13:55:53.390159376 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() < minSpanningTree.size()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (node.getCardinality() == 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:55.246152498 +0100\n+++ /tmp/tmp367lwi4b.java\t2023-03-24 13:55:55.246152498 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCardinality() == 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (node.find(vertex_u)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:57.182145323 +0100\n+++ /tmp/tmpwzt5o686.java\t2023-03-24 13:55:57.182145323 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.find(vertex_u)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (node.getFromParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:55:59.130138102 +0100\n+++ /tmp/tmpk6g0wobe.java\t2023-03-24 13:55:59.134138088 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getFromParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (node.getAttributes().containsKey(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:01.098130808 +0100\n+++ /tmp/tmphkw2brin.java\t2023-03-24 13:56:01.098130808 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getAttributes().containsKey(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (node.getTreeParent() == graph) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:02.962123901 +0100\n+++ /tmp/tmpcicx84qi.java\t2023-03-24 13:56:02.966123885 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTreeParent() == graph) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (node.find(groupByNode)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:04.950116531 +0100\n+++ /tmp/tmptypl99o1.java\t2023-03-24 13:56:04.950116531 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.find(groupByNode)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (node.getValue().equals(groupByNode.getValue())) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:06.846109503 +0100\n+++ /tmp/tmpjkzybo8a.java\t2023-03-24 13:56:06.846109503 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(groupByNode.getValue())) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (node.getName().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:08.646102830 +0100\n+++ /tmp/tmpb7hkqwb2.java\t2023-03-24 13:56:08.646102830 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (node.next!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:10.610095550 +0100\n+++ /tmp/tmp775ag_68.java\t2023-03-24 13:56:10.610095550 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.next!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (node.find(vertex_v) == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:12.414088861 +0100\n+++ /tmp/tmpn23yle1v.java\t2023-03-24 13:56:12.414088861 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.find(vertex_v) == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (node.getEdgeWeight(edge) < 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:14.262082010 +0100\n+++ /tmp/tmp3ssom1h1.java\t2023-03-24 13:56:14.262082010 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getEdgeWeight(edge) < 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (node.getIncrement().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:16.074075292 +0100\n+++ /tmp/tmp3uux2d_m.java\t2023-03-24 13:56:16.078075276 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getIncrement().equals(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (node.getTree().isTree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:17.902068514 +0100\n+++ /tmp/tmp70ms4dvs.java\t2023-03-24 13:56:17.902068514 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().isTree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (node.isTreeRoot) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:19.714061796 +0100\n+++ /tmp/tmptfmbm9ai.java\t2023-03-24 13:56:19.714061796 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isTreeRoot) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (node.getValue().equals(groupByNode.getKey())) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:21.578054883 +0100\n+++ /tmp/tmpgsd4p_ha.java\t2023-03-24 13:56:21.578054883 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().equals(groupByNode.getKey())) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (node.getName() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:23.418048059 +0100\n+++ /tmp/tmpbx8zjwvu.java\t2023-03-24 13:56:23.418048059 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (node.getIndex() == minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:25.266041206 +0100\n+++ /tmp/tmp9hwy03hw.java\t2023-03-24 13:56:25.270041192 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getIndex() == minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (node.getOpposite(node)!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:27.190034071 +0100\n+++ /tmp/tmp1d8lql34.java\t2023-03-24 13:56:27.190034071 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getOpposite(node)!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (node.getTreeParent() == tree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:28.990027397 +0100\n+++ /tmp/tmptg0ixzkp.java\t2023-03-24 13:56:28.990027397 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTreeParent() == tree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (node.getName() == vertex_u) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:30.822020601 +0100\n+++ /tmp/tmpre0s7z_1.java\t2023-03-24 13:56:30.822020601 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getName() == vertex_u) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (node.getCount() < minSpanningTree.size()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:32.714013583 +0100\n+++ /tmp/tmpe_io7cnm.java\t2023-03-24 13:56:32.714013583 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCount() < minSpanningTree.size()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (node.getTree().isTreeRoot) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:34.486007012 +0100\n+++ /tmp/tmp92ljwja8.java\t2023-03-24 13:56:34.486007012 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getTree().isTreeRoot) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (node.right < minSpanningTree.size() - 1) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:36.306000261 +0100\n+++ /tmp/tmp1pn9k396.java\t2023-03-24 13:56:36.306000261 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.right < minSpanningTree.size() - 1) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (node.get() == minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:38.117993538 +0100\n+++ /tmp/tmp4pjye308.java\t2023-03-24 13:56:38.117993538 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get() == minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (node.getNodeValue().equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:39.973986654 +0100\n+++ /tmp/tmpa25gjz5l.java\t2023-03-24 13:56:39.973986654 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNodeValue().equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (node.getMessages().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:41.861979650 +0100\n+++ /tmp/tmp0dm260cu.java\t2023-03-24 13:56:41.861979650 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getMessages().isEmpty()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (node.value.equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:43.681972899 +0100\n+++ /tmp/tmph21fv06p.java\t2023-03-24 13:56:43.681972899 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.value.equals(v)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (node.getNode() == node) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:45.669965522 +0100\n+++ /tmp/tmp9oeodag6.java\t2023-03-24 13:56:45.669965522 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNode() == node) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (node.getChildCount() == 1) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:47.617958296 +0100\n+++ /tmp/tmpen9094tm.java\t2023-03-24 13:56:47.617958296 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() == 1) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (node.get(vertex_v) < 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:49.521951231 +0100\n+++ /tmp/tmpbrb9tp82.java\t2023-03-24 13:56:49.521951231 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get(vertex_v) < 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (node.getValue().isInstance(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:51.401944255 +0100\n+++ /tmp/tmpoqvmufir.java\t2023-03-24 13:56:51.401944255 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().isInstance(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (node.degreeOf(vertex) < 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:53.277937293 +0100\n+++ /tmp/tmptp1rthm0.java\t2023-03-24 13:56:53.281937280 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.degreeOf(vertex) < 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (node.getOppositeVertex() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:55.113930480 +0100\n+++ /tmp/tmp6wxi17_v.java\t2023-03-24 13:56:55.113930480 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getOppositeVertex() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (node.get > minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:56.925923757 +0100\n+++ /tmp/tmpshmj3syo.java\t2023-03-24 13:56:56.929923743 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get > minSpanningTree) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (node.getValue() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:56:58.705917153 +0100\n+++ /tmp/tmpnslbsmug.java\t2023-03-24 13:56:58.705917153 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (node.getValue().isPresent()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:02.829901846 +0100\n+++ /tmp/tmpapheebeu.java\t2023-03-24 13:57:02.833901832 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getValue().isPresent()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (node.parent!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:04.641895120 +0100\n+++ /tmp/tmpn1o7lq4u.java\t2023-03-24 13:57:04.645895106 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.parent!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (node.getNumber() < 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:06.433888471 +0100\n+++ /tmp/tmprakvhusm.java\t2023-03-24 13:57:06.433888471 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNumber() < 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (node.is null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:08.265881670 +0100\n+++ /tmp/tmphrhycxv1.java\t2023-03-24 13:57:08.265881670 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (node.getCorrelationParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:10.001875226 +0100\n+++ /tmp/tmpxvlmjfzv.java\t2023-03-24 13:57:10.005875212 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getCorrelationParent() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (node.isInfinityNode()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:11.825868455 +0100\n+++ /tmp/tmp13a1l9mp.java\t2023-03-24 13:57:11.829868442 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isInfinityNode()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (node.isOuter) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:13.701861492 +0100\n+++ /tmp/tmpr9hy94d5.java\t2023-03-24 13:57:13.701861492 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isOuter) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (node.is v) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:15.701854068 +0100\n+++ /tmp/tmpzgkxmh3w.java\t2023-03-24 13:57:15.701854068 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is v) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (node.getChanges() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:17.593847043 +0100\n+++ /tmp/tmpgnuofpf9.java\t2023-03-24 13:57:17.597847029 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChanges() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (node.get!= null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:19.465840094 +0100\n+++ /tmp/tmpvf38x4ib.java\t2023-03-24 13:57:19.465840094 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.get!= null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (node.getFinished() == null) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:21.329833174 +0100\n+++ /tmp/tmp33jt_2gz.java\t2023-03-24 13:57:21.329833174 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getFinished() == null) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (node.getChildCount() < minSpanningTree.getChildCount() - 1) { groupByNode = update(groupByNode, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:23.221826149 +0100\n+++ /tmp/tmp3bfbcdnq.java\t2023-03-24 13:57:23.225826133 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() < minSpanningTree.getChildCount() - 1) { groupByNode = update(groupByNode, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (node.getChildren() < 0) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:25.081819244 +0100\n+++ /tmp/tmponli0r_u.java\t2023-03-24 13:57:25.085819228 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildren() < 0) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (node.getChildCount() == 0) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:26.945812322 +0100\n+++ /tmp/tmprh7jqc3a.java\t2023-03-24 13:57:26.945812322 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() == 0) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (node.isFinished()) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:28.737805669 +0100\n+++ /tmp/tmpjcmz_g2n.java\t2023-03-24 13:57:28.737805669 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isFinished()) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (node.isMarked) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:30.585798804 +0100\n+++ /tmp/tmpfw8h1kwi.java\t2023-03-24 13:57:30.585798804 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isMarked) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (node.is(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:32.537791558 +0100\n+++ /tmp/tmpkbffn7br.java\t2023-03-24 13:57:32.537791558 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is(vertex)) { groupByNode = update(groupByNode, node, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (node.find()) { groupByNode = update(groupByNode, node, vertex_u); } else { minSpanningTree.add(node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:34.841783001 +0100\n+++ /tmp/tmptcxzme_d.java\t2023-03-24 13:57:34.845782985 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.find()) { groupByNode = update(groupByNode, node, vertex_u); } else { minSpanningTree.add(node); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (node.is(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:37.221774161 +0100\n+++ /tmp/tmpqkc0oih3.java\t2023-03-24 13:57:37.221774161 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.is(vertex_u)) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (node.isPlusNode()) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:39.093767210 +0100\n+++ /tmp/tmpg7txwxia.java\t2023-03-24 13:57:39.097767194 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.isPlusNode()) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (node.getNumber() == 0) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:40.949760317 +0100\n+++ /tmp/tmps1f7u6ix.java\t2023-03-24 13:57:40.953760300 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getNumber() == 0) { groupByNode = update(groupByNode, node, vertex_u); } else { groupByNode = node; }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (node.getChildCount() < minSpanningTree.getChildCount()) { groupByNode = update(groupByNode, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:42.837753304 +0100\n+++ /tmp/tmp3qcmg2v_.java\t2023-03-24 13:57:42.837753304 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() < minSpanningTree.getChildCount()) { groupByNode = update(groupByNode, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (node.getChildCount() == 0) { groupByNode = update(groupByNode, vertex_u); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:44.681746454 +0100\n+++ /tmp/tmpusg7_8w5.java\t2023-03-24 13:57:44.681746454 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+if (node.getChildCount() == 0) { groupByNode = update(groupByNode, vertex_u); }\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": ");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:46.549739517 +0100\n+++ /tmp/tmp_4sm2iod.java\t2023-03-24 13:57:46.553739501 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+);\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/minimum_spanning_tree/java_programs/MINIMUM_SPANNING_TREE.java\t2023-03-24 13:57:48.357732800 +0100\n+++ /tmp/tmpru9dnwww.java\t2023-03-24 13:57:48.357732800 +0100\n@@ -23,11 +23,11 @@\n \n             if (groupByNode.get(vertex_u) != groupByNode.get(vertex_v)) {\n                 minSpanningTree.add(edge);\n                 groupByNode = update(groupByNode, vertex_u, vertex_v);\n                 for (Node node : groupByNode.get(vertex_v)) {\n-                    groupByNode = update(groupByNode, node, vertex_u);\n+\n                 }\n             }\n         }\n         return minSpanningTree;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "groupByNode.put(node, groupByNode.get(vertex_u));"
    },
    "hanoi": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:37.089774653 +0100\n+++ /tmp/tmp4o05v7ai.java\t2023-03-24 13:57:37.105774594 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:38.881767998 +0100\n+++ /tmp/tmp0uohn56c.java\t2023-03-24 13:57:38.881767998 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (key[i]!= null) { steps.add(new Pair<Integer,Integer>(key, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:42.985752754 +0100\n+++ /tmp/tmph47zfnlv.java\t2023-03-24 13:57:42.985752754 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key[i]!= null) { steps.add(new Pair<Integer,Integer>(key, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (debugEnabled) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:44.797746023 +0100\n+++ /tmp/tmp3tot4so6.java\t2023-03-24 13:57:44.797746023 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (debugEnabled) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (start!= 0 && helper!= end) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:46.601739322 +0100\n+++ /tmp/tmp2p8l0au0.java\t2023-03-24 13:57:46.601739322 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (start!= 0 && helper!= end) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (key!= null) { steps.add(new Pair<Integer,Integer>(key, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:50.697724107 +0100\n+++ /tmp/tmpq3az_0bl.java\t2023-03-24 13:57:50.701724093 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key!= null) { steps.add(new Pair<Integer,Integer>(key, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (crap_set.size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:52.581717108 +0100\n+++ /tmp/tmpsfs7clhs.java\t2023-03-24 13:57:52.581717108 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if ( helper!= Integer.MAX_VALUE) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:57:57.185700004 +0100\n+++ /tmp/tmpenurq7xj.java\t2023-03-24 13:57:57.185700004 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( helper!= Integer.MAX_VALUE) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:01.425684251 +0100\n+++ /tmp/tmp353khn15.java\t2023-03-24 13:58:01.425684251 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(key, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:03.253677460 +0100\n+++ /tmp/tmpbfnbq5yh.java\t2023-03-24 13:58:03.253677460 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(key, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if ( helper!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:05.113670549 +0100\n+++ /tmp/tmp60dob5xk.java\t2023-03-24 13:58:05.113670549 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( helper!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (running) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:06.965663668 +0100\n+++ /tmp/tmpk8og2j5o.java\t2023-03-24 13:58:06.969663651 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (running) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (crap_set.size() > 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:08.789656890 +0100\n+++ /tmp/tmpx89nyr7q.java\t2023-03-24 13:58:08.789656890 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size() > 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (keystore >= start) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:12.893641637 +0100\n+++ /tmp/tmpsjy9xgxr.java\t2023-03-24 13:58:12.897641623 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (keystore >= start) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (simple) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:14.653635098 +0100\n+++ /tmp/tmpjks6peu7.java\t2023-03-24 13:58:14.653635098 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (simple) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, c)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:16.557628022 +0100\n+++ /tmp/tmp7hrhutth.java\t2023-03-24 13:58:16.557628022 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, c)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (peek()!= ']') { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:18.373621271 +0100\n+++ /tmp/tmpj4eq7mc_.java\t2023-03-24 13:58:18.377621258 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (peek()!= ']') { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (getChildCount() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:20.273614210 +0100\n+++ /tmp/tmpk1fukv77.java\t2023-03-24 13:58:20.273614210 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (getChildCount() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (pushWffBMBytesQueue) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:22.137607281 +0100\n+++ /tmp/tmpb88smaq8.java\t2023-03-24 13:58:22.137607281 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushWffBMBytesQueue) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if ( events.size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:24.117599923 +0100\n+++ /tmp/tmpzfs59r8a.java\t2023-03-24 13:58:24.117599923 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( events.size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if ( helper!= 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:25.945593127 +0100\n+++ /tmp/tmpq3hy4b2v.java\t2023-03-24 13:58:25.945593127 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( helper!= 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:30.025577960 +0100\n+++ /tmp/tmp85jvgbz3.java\t2023-03-24 13:58:30.025577960 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (trackUndo) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:31.841571210 +0100\n+++ /tmp/tmpi7wklzpl.java\t2023-03-24 13:58:31.841571210 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (trackUndo) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (completion) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:33.737564163 +0100\n+++ /tmp/tmpgxr53_uk.java\t2023-03-24 13:58:33.737564163 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (completion) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (start!= -1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:35.549557425 +0100\n+++ /tmp/tmpg14u06ve.java\t2023-03-24 13:58:35.553557411 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (start!= -1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (key.equals(\"0\")) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:39.625542271 +0100\n+++ /tmp/tmpgpeow1ss.java\t2023-03-24 13:58:39.625542271 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key.equals(\"0\")) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (context.getRoutes().size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:41.377535757 +0100\n+++ /tmp/tmp0xn9_q2u.java\t2023-03-24 13:58:41.381535744 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (context.getRoutes().size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (bitOffset) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:43.193529005 +0100\n+++ /tmp/tmp14vh74hx.java\t2023-03-24 13:58:43.193529005 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (bitOffset) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, crap)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:44.893522684 +0100\n+++ /tmp/tmpd_zbacwo.java\t2023-03-24 13:58:44.893522684 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, crap)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (pushQueueEnabled && i >= start) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:46.701515963 +0100\n+++ /tmp/tmpgu9z2tu_.java\t2023-03-24 13:58:46.701515963 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueueEnabled && i >= start) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(key, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:48.601508898 +0100\n+++ /tmp/tmpgwpa_utz.java\t2023-03-24 13:58:48.601508898 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(key, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (reader.peek()!= ']') { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:50.325502487 +0100\n+++ /tmp/tmp6ib3gbvs.java\t2023-03-24 13:58:50.329502471 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (reader.peek()!= ']') { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (state.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:52.153495688 +0100\n+++ /tmp/tmphp67h_9i.java\t2023-03-24 13:58:52.153495688 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (state.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (postfix) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:53.913489142 +0100\n+++ /tmp/tmpunxku205.java\t2023-03-24 13:58:53.913489142 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (postfix) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (getResourcePool().getMyId()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:55.721482419 +0100\n+++ /tmp/tmp88g5gi6d.java\t2023-03-24 13:58:55.721482419 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (getResourcePool().getMyId()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (crap_set.size()!= 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:58:57.505475784 +0100\n+++ /tmp/tmpoqsf1rub.java\t2023-03-24 13:58:57.505475784 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if ((':') { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:01.773459910 +0100\n+++ /tmp/tmp4m0miz31.java\t2023-03-24 13:59:01.773459910 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ((':') { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (crap_set.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:03.509453455 +0100\n+++ /tmp/tmpt_b2909j.java\t2023-03-24 13:59:03.513453439 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(key, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:07.661438012 +0100\n+++ /tmp/tmpkhk9i_2f.java\t2023-03-24 13:59:07.661438012 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(key, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (peek()!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:09.709430394 +0100\n+++ /tmp/tmphr51guwe.java\t2023-03-24 13:59:09.709430394 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (peek()!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (looksLikeAMangledColor(key)) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:12.117421436 +0100\n+++ /tmp/tmpdxecxa9a.java\t2023-03-24 13:59:12.117421436 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (looksLikeAMangledColor(key)) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (iterators.size() > 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:14.313413266 +0100\n+++ /tmp/tmpc4qwjnmg.java\t2023-03-24 13:59:14.317413253 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (iterators.size() > 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:16.197406259 +0100\n+++ /tmp/tmpkbbapdy4.java\t2023-03-24 13:59:16.197406259 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (traces > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:18.357398222 +0100\n+++ /tmp/tmp5rqd72pc.java\t2023-03-24 13:59:18.357398222 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (traces > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, remoteAddress)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:20.541390099 +0100\n+++ /tmp/tmpgizmvxze.java\t2023-03-24 13:59:20.541390099 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, remoteAddress)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, key.length)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:23.689378386 +0100\n+++ /tmp/tmpvwtnq3k0.java\t2023-03-24 13:59:23.689378386 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, key.length)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:25.909370127 +0100\n+++ /tmp/tmpyrnuoite.java\t2023-03-24 13:59:25.949369976 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (pushQueueEnabled && currentTimeMillis() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:31.065350940 +0100\n+++ /tmp/tmp01c9p9u9.java\t2023-03-24 13:59:31.065350940 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueueEnabled && currentTimeMillis() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (crap_set.poll()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:32.929344005 +0100\n+++ /tmp/tmph3hgkhgu.java\t2023-03-24 13:59:32.929344005 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.poll()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (LOGGER.isDebugEnabled()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:34.761337189 +0100\n+++ /tmp/tmpxfh4wvrw.java\t2023-03-24 13:59:34.761337189 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (LOGGER.isDebugEnabled()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (crap_set.size() > 3) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:37.057328645 +0100\n+++ /tmp/tmpzg0n9t0c.java\t2023-03-24 13:59:37.153328288 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size() > 3) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (crap_set.size() > 2) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:41.665311496 +0100\n+++ /tmp/tmpzusxu3iv.java\t2023-03-24 13:59:41.669311480 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size() > 2) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(start, crap)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:45.637296713 +0100\n+++ /tmp/tmpf7vvha_7.java\t2023-03-24 13:59:45.637296713 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(start, crap)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (TEs.size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:47.473289878 +0100\n+++ /tmp/tmp312960wn.java\t2023-03-24 13:59:47.477289865 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (TEs.size() > 0) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(start, c)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:49.649281781 +0100\n+++ /tmp/tmpitk3hp7d.java\t2023-03-24 13:59:49.649281781 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(start, c)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (crap_set.size()!= 2) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:51.993273057 +0100\n+++ /tmp/tmp9hqqvixs.java\t2023-03-24 13:59:51.993273057 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 2) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( matcher.group(2))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:57.129253939 +0100\n+++ /tmp/tmprhfx_tu3.java\t2023-03-24 13:59:57.129253939 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( matcher.group(2))); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (key.equals(\"0\")) { steps.add(new Pair<Integer,Integer>(key, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 13:59:58.633248341 +0100\n+++ /tmp/tmpbwnd5qqb.java\t2023-03-24 13:59:58.637248324 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key.equals(\"0\")) { steps.add(new Pair<Integer,Integer>(key, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, remoteAddress, crap)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:01.093239184 +0100\n+++ /tmp/tmp8dsxw6kl.java\t2023-03-24 14:00:01.093239184 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, remoteAddress, crap)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (section!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:03.253231141 +0100\n+++ /tmp/tmpzjbbpv16.java\t2023-03-24 14:00:03.253231141 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (section!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (key[i]!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:04.905224992 +0100\n+++ /tmp/tmplgbw82sz.java\t2023-03-24 14:00:04.905224992 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key[i]!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (pushWffBMBytesQueue()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:06.809217904 +0100\n+++ /tmp/tmpjyn7h5he.java\t2023-03-24 14:00:06.809217904 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushWffBMBytesQueue()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer, Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:10.317204844 +0100\n+++ /tmp/tmpdpk30u31.java\t2023-03-24 14:00:10.321204827 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer, Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if ( helper!= -1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:12.213197783 +0100\n+++ /tmp/tmpr3k00h57.java\t2023-03-24 14:00:12.217197770 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( helper!= -1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (success) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:17.721177276 +0100\n+++ /tmp/tmp848grrtr.java\t2023-03-24 14:00:17.721177276 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (success) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (poll >= 0 && helper <= end) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:19.893169189 +0100\n+++ /tmp/tmp8403wi__.java\t2023-03-24 14:00:19.893169189 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (poll >= 0 && helper <= end) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(key, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:22.261160371 +0100\n+++ /tmp/tmpsco39g2h.java\t2023-03-24 14:00:22.261160371 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).matches()) { steps.add(new Pair<Integer,Integer>(key, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (pushQueue) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:24.801150913 +0100\n+++ /tmp/tmp6a0bj02_.java\t2023-03-24 14:00:24.801150913 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (poll) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:26.937142959 +0100\n+++ /tmp/tmpdqiqj_mf.java\t2023-03-24 14:00:26.937142959 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (poll) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (poll >= 0 && helper <= end) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:29.685132725 +0100\n+++ /tmp/tmp0_dkujiw.java\t2023-03-24 14:00:29.685132725 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (poll >= 0 && helper <= end) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( start, c)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:31.377126422 +0100\n+++ /tmp/tmpw5bfix4q.java\t2023-03-24 14:00:31.377126422 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( start, c)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (batchSize > 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:33.405118871 +0100\n+++ /tmp/tmpmuq89a86.java\t2023-03-24 14:00:33.405118871 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (batchSize > 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:35.233112064 +0100\n+++ /tmp/tmptcrkjsn2.java\t2023-03-24 14:00:35.233112064 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:38.933098283 +0100\n+++ /tmp/tmpcp9_lmv7.java\t2023-03-24 14:00:38.933098283 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueue!= null) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( start, crap)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:40.481092517 +0100\n+++ /tmp/tmp6g4uh0y0.java\t2023-03-24 14:00:40.481092517 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( start, crap)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (peek()!= ']') { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:43.105082744 +0100\n+++ /tmp/tmpzj6wpp4m.java\t2023-03-24 14:00:43.105082744 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (peek()!= ']') { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (debugEnabled) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:44.901076053 +0100\n+++ /tmp/tmpt1edy2gz.java\t2023-03-24 14:00:44.901076053 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (debugEnabled) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, key.size())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:46.441070316 +0100\n+++ /tmp/tmp9fcqma29.java\t2023-03-24 14:00:46.445070303 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, key.size())); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (crap_set.size() > 0) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:48.185063820 +0100\n+++ /tmp/tmp317_urbt.java\t2023-03-24 14:00:48.185063820 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size() > 0) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:52.065049368 +0100\n+++ /tmp/tmp8nudixjh.java\t2023-03-24 14:00:52.065049368 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, this)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:53.709043242 +0100\n+++ /tmp/tmp07sq18re.java\t2023-03-24 14:00:53.709043242 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, this)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if ( helper!= null) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:55.385037001 +0100\n+++ /tmp/tmpnv71zh8w.java\t2023-03-24 14:00:55.389036984 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( helper!= null) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, key.length())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:57.125030518 +0100\n+++ /tmp/tmp9fdzf5gs.java\t2023-03-24 14:00:57.125030518 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (key.isEmpty()) { steps.add(new Pair<Integer,Integer>(start, key.length())); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (poll) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:00:58.825024185 +0100\n+++ /tmp/tmpw8ob6_a_.java\t2023-03-24 14:00:58.829024168 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (poll) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (sort) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:00.541017792 +0100\n+++ /tmp/tmpqluxqh6j.java\t2023-03-24 14:01:00.541017792 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (sort) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (pe.size()!= 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:02.213011561 +0100\n+++ /tmp/tmpgfgr53ub.java\t2023-03-24 14:01:02.217011548 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pe.size()!= 1) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( crap)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:03.873005376 +0100\n+++ /tmp/tmpydtnngn8.java\t2023-03-24 14:01:03.873005376 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>( crap)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, c c)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:05.488999356 +0100\n+++ /tmp/tmpfki37h3a.java\t2023-03-24 14:01:05.488999356 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, c c)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, 5)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:07.176993066 +0100\n+++ /tmp/tmpk1vsq2xo.java\t2023-03-24 14:01:07.176993066 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pattern.matcher(c).find()) { steps.add(new Pair<Integer,Integer>(start, 5)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (crap_set.size() > 1) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:08.708987360 +0100\n+++ /tmp/tmp6rzfleft.java\t2023-03-24 14:01:08.708987360 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size() > 1) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (traces > 0) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:12.508973199 +0100\n+++ /tmp/tmpnefkk3bv.java\t2023-03-24 14:01:12.508973199 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (traces > 0) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (pushQueueOnNext()) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:14.132967148 +0100\n+++ /tmp/tmpgi_nb75c.java\t2023-03-24 14:01:14.132967148 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (pushQueueOnNext()) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>( crap)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:15.784960994 +0100\n+++ /tmp/tmpt63j7bb9.java\t2023-03-24 14:01:15.784960994 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>( crap)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (poning) { steps.add(new Pair<Integer,Integer>(start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:17.560954374 +0100\n+++ /tmp/tmpb_zjya3t.java\t2023-03-24 14:01:17.560954374 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (poning) { steps.add(new Pair<Integer,Integer>(start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:19.176948352 +0100\n+++ /tmp/tmpxertvzo6.java\t2023-03-24 14:01:19.176948352 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (channel!= null) { steps.add(new Pair<Integer,Integer>(channel, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if ( helper!= 0) { steps.add(new Pair<Integer,Integer>( start, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:20.860942079 +0100\n+++ /tmp/tmpp8jhjw73.java\t2023-03-24 14:01:20.860942079 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if ( helper!= 0) { steps.add(new Pair<Integer,Integer>( start, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(crap)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:24.680927844 +0100\n+++ /tmp/tmpqb_l0sgm.java\t2023-03-24 14:01:24.680927844 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(crap)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (crap_set.size() > 0) { steps.add(new Pair<Integer,Integer>(start, c)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:26.292921836 +0100\n+++ /tmp/tmp972spgsm.java\t2023-03-24 14:01:26.292921836 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size() > 0) { steps.add(new Pair<Integer,Integer>(start, c)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (postfix) { steps.add(new Pair<Integer,Integer>(end, helper)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:27.876915933 +0100\n+++ /tmp/tmp6icmu80v.java\t2023-03-24 14:01:27.876915933 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (postfix) { steps.add(new Pair<Integer,Integer>(end, helper)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(start, c)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/hanoi/java_programs/HANOI.java\t2023-03-24 14:01:29.580909582 +0100\n+++ /tmp/tmpvtr23fcb.java\t2023-03-24 14:01:29.580909582 +0100\n@@ -22,11 +22,11 @@\n             crap_set.add(3);\n             crap_set.remove(start);\n             crap_set.remove(end);\n             int helper = crap_set.poll();\n             steps.addAll(hanoi(height-1, start, helper));\n-            steps.add(new Pair<Integer,Integer>(start, helper));\n+if (crap_set.size()!= 1) { steps.add(new Pair<Integer,Integer>(start, c)); }\n             steps.addAll(hanoi(height-1, helper, end));\n         }\n \n         return steps;\n     }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "steps.add(new Pair<Integer,Integer>(start, end));"
    },
    "knapsack": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "else if (i < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:57:54.889708534 +0100\n+++ /tmp/tmp51uc19f2.java\t2023-03-24 13:57:54.889708534 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "else if (j < capacity && j > 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:57:59.313692099 +0100\n+++ /tmp/tmpmehd42gw.java\t2023-03-24 13:57:59.313692099 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "else if (j < capacity && j > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:03.625676076 +0100\n+++ /tmp/tmpl6e3zax1.java\t2023-03-24 13:58:03.629676063 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > i) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "else if (j < capacity && j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:07.873660292 +0100\n+++ /tmp/tmpxfx7d2tv.java\t2023-03-24 13:58:07.873660292 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "else if (i < capacity - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:12.293643867 +0100\n+++ /tmp/tmp8ga3ih71.java\t2023-03-24 13:58:12.297643854 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "else if (i > j - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:16.649627678 +0100\n+++ /tmp/tmp0s0rau70.java\t2023-03-24 13:58:16.649627678 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i > j - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "else if (i > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:20.901611877 +0100\n+++ /tmp/tmp4z4plr04.java\t2023-03-24 13:58:20.901611877 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i > j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "else if (j < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:25.081596339 +0100\n+++ /tmp/tmpvo5a58la.java\t2023-03-24 13:58:25.081596339 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "else if (i < capacity && j > 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:29.501579908 +0100\n+++ /tmp/tmprb6mlqm7.java\t2023-03-24 13:58:29.501579908 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "else if (j < capacity && j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:33.929563449 +0100\n+++ /tmp/tmp0yk0360q.java\t2023-03-24 13:58:33.933563433 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "else if (i < capacity && j > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:38.313547149 +0100\n+++ /tmp/tmpr_esghf_.java\t2023-03-24 13:58:38.313547149 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > i) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "else if (j < capacity && j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:42.845530299 +0100\n+++ /tmp/tmp1dtzk8lk.java\t2023-03-24 13:58:42.849530285 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "else if (value > 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:44.685523458 +0100\n+++ /tmp/tmp5qy9th49.java\t2023-03-24 13:58:44.685523458 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (value > 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "else if (j < capacity && j > capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:49.009507379 +0100\n+++ /tmp/tmpujanafnd.java\t2023-03-24 13:58:49.009507379 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "else if (i >= capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:53.505490660 +0100\n+++ /tmp/tmpgjo6tksn.java\t2023-03-24 13:58:53.505490660 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i >= capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "else if (j < capacity && j > high) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:58.125473479 +0100\n+++ /tmp/tmp0lsn94tx.java\t2023-03-24 13:58:58.125473479 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > high) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "else if (j < capacity && j >= capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:58:59.965466637 +0100\n+++ /tmp/tmp20svuls4.java\t2023-03-24 13:58:59.965466637 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >= capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "else if (i < capacity && j > capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:04.569449513 +0100\n+++ /tmp/tmp4uuvvyd5.java\t2023-03-24 13:59:04.569449513 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "else if (j < capacity && j > size) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:09.785430110 +0100\n+++ /tmp/tmp_zyq9wwx.java\t2023-03-24 13:59:09.785430110 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > size) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "else if (i < capacity && j > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:11.893422270 +0100\n+++ /tmp/tmp7p9pxcjf.java\t2023-03-24 13:59:11.897422253 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "else if (j < capacity && j < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:18.217398744 +0100\n+++ /tmp/tmpagxc9x2n.java\t2023-03-24 13:59:18.217398744 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "else if (i < capacity && i > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:23.969377344 +0100\n+++ /tmp/tmp56b1ttnv.java\t2023-03-24 13:59:23.969377344 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && i > j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "else if (i < capacity && j > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:30.713352250 +0100\n+++ /tmp/tmp_yzn31il.java\t2023-03-24 13:59:30.713352250 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > 1)) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "else if (i < j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:32.897344125 +0100\n+++ /tmp/tmp1sxppshe.java\t2023-03-24 13:59:32.897344125 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "else if (j < capacity && j > EPS) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:39.201320666 +0100\n+++ /tmp/tmp2gafy9km.java\t2023-03-24 13:59:39.201320666 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > EPS) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "else if (i < capacity && j > high) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:40.945314174 +0100\n+++ /tmp/tmpqrwwioog.java\t2023-03-24 13:59:40.945314174 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > high) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "else if (j < capacity && j > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:43.225305689 +0100\n+++ /tmp/tmp6l4pq8x5.java\t2023-03-24 13:59:43.225305689 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "else if (j < capacity && j > columns) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:49.661281735 +0100\n+++ /tmp/tmp4lmxs4hh.java\t2023-03-24 13:59:49.661281735 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > columns) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "else if (Math.abs(value) < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:51.953273205 +0100\n+++ /tmp/tmp5a4tcisx.java\t2023-03-24 13:59:51.961273175 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (Math.abs(value) < 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "else if (j < capacity && j < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 13:59:58.617248400 +0100\n+++ /tmp/tmpo0_io6nj.java\t2023-03-24 13:59:58.617248400 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j < 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "else if (i < capacity && j > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:04.925224916 +0100\n+++ /tmp/tmpw2qip83z.java\t2023-03-24 14:00:04.925224916 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "else if (j < capacity && j >= columns) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:10.425204440 +0100\n+++ /tmp/tmpsf9rbpnb.java\t2023-03-24 14:00:10.425204440 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >= columns) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "else if (i >= capacity && j < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:12.253197634 +0100\n+++ /tmp/tmpbplazhuq.java\t2023-03-24 14:00:12.253197634 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i >= capacity && j < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "else if (j < capacity && i > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:18.013176189 +0100\n+++ /tmp/tmp12solsx0.java\t2023-03-24 14:00:18.013176189 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && i > j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "else if (i < capacity + 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:23.233156751 +0100\n+++ /tmp/tmpwz00rvri.java\t2023-03-24 14:00:23.237156737 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity + 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "else if (j < capacity && j >= i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:27.701140114 +0100\n+++ /tmp/tmpjzcyc980.java\t2023-03-24 14:00:27.701140114 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >= i) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "else if (j < capacity && j < columns) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:33.101120004 +0100\n+++ /tmp/tmpbyg3e8vd.java\t2023-03-24 14:00:33.101120004 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j < columns) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "else if (j < capacity && j >columns) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:35.205112166 +0100\n+++ /tmp/tmpjv7auu09.java\t2023-03-24 14:00:35.205112166 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >columns) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "else if (i < length - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:37.905102112 +0100\n+++ /tmp/tmpi8nnhpof.java\t2023-03-24 14:00:38.077101471 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < length - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "else if (j < capacity && j > value) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:40.265093322 +0100\n+++ /tmp/tmpl7vi82a4.java\t2023-03-24 14:00:40.265093322 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > value) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "else if (j < capacity && j >Function) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:46.513070048 +0100\n+++ /tmp/tmp2t4gydv9.java\t2023-03-24 14:00:46.513070048 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >Function) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "else if (i == j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:48.277063479 +0100\n+++ /tmp/tmp42az2ojz.java\t2023-03-24 14:00:48.277063479 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i == j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "else if (j < capacity && j > 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:52.293048519 +0100\n+++ /tmp/tmp315xea9i.java\t2023-03-24 14:00:52.297048503 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 0;\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "else if (i < flow.rows() - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:53.921042453 +0100\n+++ /tmp/tmpvc512bn4.java\t2023-03-24 14:00:53.921042453 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < flow.rows() - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "else if (i > j + 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:55.601036195 +0100\n+++ /tmp/tmp4cn6_cdk.java\t2023-03-24 14:00:55.601036195 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i > j + 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "else if (i < capacity && j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:00:59.573021397 +0100\n+++ /tmp/tmp80v_itj_.java\t2023-03-24 14:00:59.577021384 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "else if (i < capacity && j >= capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:03.389007182 +0100\n+++ /tmp/tmp1wpjiovt.java\t2023-03-24 14:01:03.393007165 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j >= capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "else if (value < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:07.712991069 +0100\n+++ /tmp/tmpdfs_gptb.java\t2023-03-24 14:01:07.712991069 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (value < 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "else if (i % (j < capacity - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:12.164974481 +0100\n+++ /tmp/tmpv3r_ysg3.java\t2023-03-24 14:01:12.164974481 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i % (j < capacity - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "else if (j < capacity && j > -1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:13.828968283 +0100\n+++ /tmp/tmpiiwescwp.java\t2023-03-24 14:01:13.828968283 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > -1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "else if (value < 0 || value > 100) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:17.840953331 +0100\n+++ /tmp/tmpvyl_0lt9.java\t2023-03-24 14:01:17.840953331 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (value < 0 || value > 100) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "else if (i == capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:21.752938755 +0100\n+++ /tmp/tmpuviqq6zg.java\t2023-03-24 14:01:21.752938755 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i == capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "else if (get(j - 1) < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:26.072922654 +0100\n+++ /tmp/tmpm6wd2yen.java\t2023-03-24 14:01:26.076922641 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (get(j - 1) < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "else if (i < capacity && j > EPS) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:27.800916214 +0100\n+++ /tmp/tmpo2w_a5k8.java\t2023-03-24 14:01:27.800916214 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > EPS) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "else if (j < capacity && j > endIndex) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:29.472909985 +0100\n+++ /tmp/tmp8at4ud7q.java\t2023-03-24 14:01:29.472909985 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > endIndex) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "else if (j < capacity && j >= 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:31.212903498 +0100\n+++ /tmp/tmpj4eyrugm.java\t2023-03-24 14:01:31.216903485 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >= 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "else if (value >= 0.0 && j < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:35.676886861 +0100\n+++ /tmp/tmpm0olsxxm.java\t2023-03-24 14:01:35.676886861 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (value >= 0.0 && j < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "else if (i < capacity && j > size) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:39.636872100 +0100\n+++ /tmp/tmp1yf79djt.java\t2023-03-24 14:01:39.636872100 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > size) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "else if (cardinality - j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:41.296865915 +0100\n+++ /tmp/tmpv83t9yay.java\t2023-03-24 14:01:41.296865915 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (cardinality - j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "else if (i < 0 || i >= length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:42.928859831 +0100\n+++ /tmp/tmpmtqqpx7h.java\t2023-03-24 14:01:42.928859831 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < 0 || i >= length) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "else if (i < rows) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:44.612853553 +0100\n+++ /tmp/tmp78fqcdx1.java\t2023-03-24 14:01:44.612853553 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < rows) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "else if (j < capacity && j >separator) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:46.284847322 +0100\n+++ /tmp/tmptngmbzts.java\t2023-03-24 14:01:46.284847322 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >separator) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "else if (j < capacity && j > memoized) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:50.076833186 +0100\n+++ /tmp/tmp095c1fkm.java\t2023-03-24 14:01:50.076833186 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > memoized) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "else if (i > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:01:59.696797323 +0100\n+++ /tmp/tmpcj5rh9po.java\t2023-03-24 14:01:59.700797306 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "else if (i < j - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:02:22.804711160 +0100\n+++ /tmp/tmps46wycwj.java\t2023-03-24 14:02:22.808711147 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < j - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "else if (j < capacity && j > string) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:02:45.000628378 +0100\n+++ /tmp/tmp1a3vll72.java\t2023-03-24 14:02:45.052628184 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > string) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "else if (i < capacity - j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:02:54.284593747 +0100\n+++ /tmp/tmpblqsnzi3.java\t2023-03-24 14:02:54.284593747 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity - j) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "else if (j < capacity && j > 100) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:03:15.040516314 +0100\n+++ /tmp/tmpao6l7q9m.java\t2023-03-24 14:03:15.040516314 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j > 100) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "else if (component[i] < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:03:35.056441624 +0100\n+++ /tmp/tmps2co7ag5.java\t2023-03-24 14:03:35.104441446 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (component[i] < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "else if (get(j) < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:03:42.720413021 +0100\n+++ /tmp/tmpn51g2usn.java\t2023-03-24 14:03:42.724413008 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (get(j) < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "else if (j < capacity && j >[1]);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:03:51.084381805 +0100\n+++ /tmp/tmpr84xpmom.java\t2023-03-24 14:03:51.096381762 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >[1]);\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "else if (i == j - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:03:58.152355425 +0100\n+++ /tmp/tmpszniz3vi.java\t2023-03-24 14:03:58.152355425 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i == j - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "else if (i % j > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:04:13.612297713 +0100\n+++ /tmp/tmptdp2g0t7.java\t2023-03-24 14:04:13.620297683 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i % j > 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "else if (value < 0x80) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:04:28.660241534 +0100\n+++ /tmp/tmp0j4g3eil.java\t2023-03-24 14:04:28.660241534 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (value < 0x80) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "else if (c < 0x80) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:04:43.488186168 +0100\n+++ /tmp/tmpf_0fwydq.java\t2023-03-24 14:04:43.488186168 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (c < 0x80) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "else if (getSecond() < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:04:49.600163347 +0100\n+++ /tmp/tmpoesgsw86.java\t2023-03-24 14:04:49.600163347 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (getSecond() < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "else if (i > capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:04:55.788140237 +0100\n+++ /tmp/tmpmzegiymq.java\t2023-03-24 14:04:55.788140237 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i > capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "else if (rows < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:10.144086625 +0100\n+++ /tmp/tmpwze7onr3.java\t2023-03-24 14:05:10.144086625 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (rows < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "else if (i < n - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:15.796065515 +0100\n+++ /tmp/tmpx4_39j29.java\t2023-03-24 14:05:15.800065498 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < n - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "else if (i % 10 == capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:27.972020034 +0100\n+++ /tmp/tmp7jnzcc70.java\t2023-03-24 14:05:27.976020021 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i % 10 == capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "else if (i < cardinality - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:38.903979200 +0100\n+++ /tmp/tmpzk74hnnh.java\t2023-03-24 14:05:38.903979200 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < cardinality - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "else if (i < cardinality + 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:43.459962178 +0100\n+++ /tmp/tmp1_ym9sm0.java\t2023-03-24 14:05:43.459962178 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < cardinality + 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "else if (i < capacity && j > 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:47.315947772 +0100\n+++ /tmp/tmpk85eq7dh.java\t2023-03-24 14:05:47.315947772 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < capacity && j > 0;\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "else if (i < values.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:50.915934326 +0100\n+++ /tmp/tmpxc3vmdrb.java\t2023-03-24 14:05:50.915934326 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < values.length) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "else if (i > capacity - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:05:54.779919887 +0100\n+++ /tmp/tmpllpl_bci.java\t2023-03-24 14:05:54.783919875 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i > capacity - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "else if (----j >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:03.711886517 +0100\n+++ /tmp/tmpqakq9b6t.java\t2023-03-24 14:06:03.715886500 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (----j >= 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "else if (j < capacity - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:07.127873754 +0100\n+++ /tmp/tmpzw88orek.java\t2023-03-24 14:06:07.131873737 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "else if (j < capacity && j >= 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:13.847848646 +0100\n+++ /tmp/tmppnbh_5a5.java\t2023-03-24 14:06:13.847848646 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity && j >= 0;\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "else if (i == capacity - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:16.235839723 +0100\n+++ /tmp/tmprzkoa0jv.java\t2023-03-24 14:06:16.235839723 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i == capacity - 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "else if (i < a.columns()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:22.219817360 +0100\n+++ /tmp/tmpnukx0edx.java\t2023-03-24 14:06:22.219817360 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < a.columns()) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "else if (j < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:24.367809333 +0100\n+++ /tmp/tmpwy1fccr5.java\t2023-03-24 14:06:24.367809333 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "else if (i < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:29.835788902 +0100\n+++ /tmp/tmpm23xdi6u.java\t2023-03-24 14:06:29.839788885 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "else if (ex < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:35.327768378 +0100\n+++ /tmp/tmpeq984t7r.java\t2023-03-24 14:06:35.327768378 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (ex < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "else if (j < capacity + 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:37.439760483 +0100\n+++ /tmp/tmp5f9s720j.java\t2023-03-24 14:06:37.439760483 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (j < capacity + 1) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "else if (i % p == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:42.643741034 +0100\n+++ /tmp/tmpjhluh_9c.java\t2023-03-24 14:06:42.643741034 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i % p == 0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "else if (columns < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:44.855732768 +0100\n+++ /tmp/tmp08lt6zed.java\t2023-03-24 14:06:44.855732768 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (columns < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "else if (i < length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:46.943724964 +0100\n+++ /tmp/tmpe3yipkkx.java\t2023-03-24 14:06:46.943724964 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (i < length) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "else if (mask < capacity) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:49.167716652 +0100\n+++ /tmp/tmpcys4hd72.java\t2023-03-24 14:06:49.167716652 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (mask < capacity) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "else if (c < 0.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:51.219708983 +0100\n+++ /tmp/tmp9txleadm.java\t2023-03-24 14:06:51.219708983 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (c < 0.0) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "else if (opposite) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/knapsack/java_programs/KNAPSACK.java\t2023-03-24 14:06:53.291701242 +0100\n+++ /tmp/tmpfwqbp6_g.java\t2023-03-24 14:06:53.291701242 +0100\n@@ -25,11 +25,11 @@\n             for (int j = 0; j <= capacity; j++)\n             {\n                 if (i == 0 || j == 0) {\n                     memo[i][j] = 0;\n                 }\n-                else if (weight < j) {\n+else if (opposite) {\n                     memo[i][j] = Math.max(memo[i - 1][j], value + memo[i - 1][j - weight]);\n                 }\n                 else {\n                     memo[i][j] = memo [i-1][j];\n                 }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "else if (weight <= j) {"
    },
    "is_valid_parenthesization": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "return false;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:01:33.336895582 +0100\n+++ /tmp/tmp5ukvhprl.java\t2023-03-24 14:01:33.336895582 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (depth > 0) { return true; } else { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:01:37.312880765 +0100\n+++ /tmp/tmptnrez4go.java\t2023-03-24 14:01:37.312880765 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) { return true; } else { return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (depth > 0) { return true; } else { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:01:41.064866779 +0100\n+++ /tmp/tmp0z3ijd9o.java\t2023-03-24 14:01:41.064866779 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) { return true; } else { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one left, but got \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:01:44.680853299 +0100\n+++ /tmp/tmp6nnjzae8.java\t2023-03-24 14:01:44.684853286 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one left, but got \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "throw new OptimisticLockException(null, depth + \" was not started\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:01:52.796823047 +0100\n+++ /tmp/tmp0b1tkjg5.java\t2023-03-24 14:01:52.796823047 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new OptimisticLockException(null, depth + \" was not started\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "throw new UnsupportedOperationException(UNMODIFIABLE);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:02:02.372787347 +0100\n+++ /tmp/tmp16sd4e_5.java\t2023-03-24 14:02:02.372787347 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(UNMODIFIABLE);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "throw new NoSuchElementException(\"No more content\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:02:11.944751655 +0100\n+++ /tmp/tmpusq639o_.java\t2023-03-24 14:02:11.952751626 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException(\"No more content\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph should never end up through this code path\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:02:33.320671943 +0100\n+++ /tmp/tmpv6giu1sj.java\t2023-03-24 14:02:33.332671897 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph should never end up through this code path\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one left, but got \" + n);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:02:53.672596032 +0100\n+++ /tmp/tmp2fkuwt98.java\t2023-03-24 14:02:53.672596032 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one left, but got \" + n);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "throw new NoSuchElementException(\"No entry '\"+key+\"' found.\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:03:02.100564589 +0100\n+++ /tmp/tmp_zbk9uzi.java\t2023-03-24 14:03:02.108564560 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException(\"No entry '\"+key+\"' found.\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but got \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:03:10.484533310 +0100\n+++ /tmp/tmpv3nzuwsz.java\t2023-03-24 14:03:10.484533310 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but got \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "throw new NoSuchElementException(\"No entry found in graph: \" + entryPath);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:03:28.600465714 +0100\n+++ /tmp/tmpktd76g6h.java\t2023-03-24 14:03:28.600465714 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException(\"No entry found in graph: \" + entryPath);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but found: \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:03:36.556436025 +0100\n+++ /tmp/tmp1apkhlrw.java\t2023-03-24 14:03:36.556436025 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but found: \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "throw new IllegalArgumentException(\"Not a simple cycle\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:03:54.148370368 +0100\n+++ /tmp/tmpr53cdbf8.java\t2023-03-24 14:03:54.148370368 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Not a simple cycle\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one left, but was \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:04:09.836311811 +0100\n+++ /tmp/tmpdauassj8.java\t2023-03-24 14:04:09.836311811 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one left, but was \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one left, but got \" + value);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:04:24.424257351 +0100\n+++ /tmp/tmpyq02p0w_.java\t2023-03-24 14:04:24.424257351 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one left, but got \" + value);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but was: \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:04:30.936233038 +0100\n+++ /tmp/tmp5f6bc66k.java\t2023-03-24 14:04:30.936233038 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but was: \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "throw new UnsupportedOperationException(\"Not enough bytes to end-of-input\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:04:44.944180734 +0100\n+++ /tmp/tmphfh_9f8l.java\t2023-03-24 14:04:44.944180734 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Not enough bytes to end-of-input\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (depth > depth) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:04:58.444130318 +0100\n+++ /tmp/tmpnu7ia9t6.java\t2023-03-24 14:04:58.444130318 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > depth) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but was \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:04.200108824 +0100\n+++ /tmp/tmptn2kiw_8.java\t2023-03-24 14:05:04.200108824 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but was \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but was: \" + value);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:16.540062737 +0100\n+++ /tmp/tmp649y0d7e.java\t2023-03-24 14:05:16.540062737 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but was: \" + value);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "throw new IllegalArgumentException(\"Unexpected end-of-input when binding data\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:21.920042642 +0100\n+++ /tmp/tmpilf0kxi_.java\t2023-03-24 14:05:21.920042642 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Unexpected end-of-input when binding data\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but was \" + n);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:32.436003361 +0100\n+++ /tmp/tmpbpkyw3bt.java\t2023-03-24 14:05:32.436003361 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but was \" + n);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "return null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:37.047986131 +0100\n+++ /tmp/tmphzkg8cqh.java\t2023-03-24 14:05:37.047986131 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return null;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one left, but got \" + v);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:46.515950763 +0100\n+++ /tmp/tmpua6f7r86.java\t2023-03-24 14:05:46.515950763 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one left, but got \" + v);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "throw new IllegalArgumentException(\"Row \" + depth + \" doesn't exist\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:50.479935952 +0100\n+++ /tmp/tmpeljlu3ss.java\t2023-03-24 14:05:50.479935952 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Row \" + depth + \" doesn't exist\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but found: \" + value);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:05:59.019904046 +0100\n+++ /tmp/tmp_v7hbhfb.java\t2023-03-24 14:05:59.019904046 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but found: \" + value);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "throw new IllegalArgumentException(\"Row \" + depth + \" does not exist\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:02.767890045 +0100\n+++ /tmp/tmp145cksxm.java\t2023-03-24 14:06:02.767890045 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Row \" + depth + \" does not exist\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "throw new OptimisticLockException(null, depth + \" was expected\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:09.883863457 +0100\n+++ /tmp/tmp8i_qwew0.java\t2023-03-24 14:06:09.883863457 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new OptimisticLockException(null, depth + \" was expected\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "throw new NoSuchElementException(\"No entry '\"+key+\"' found\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:12.699852933 +0100\n+++ /tmp/tmphifzn2pv.java\t2023-03-24 14:06:12.699852933 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException(\"No entry '\"+key+\"' found\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph is not supported\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:15.167843711 +0100\n+++ /tmp/tmpb1k5c451.java\t2023-03-24 14:06:15.167843711 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph is not supported\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "throw new IllegalArgumentException(\"Row \" + depth + \" doesn't exist!\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:20.483823849 +0100\n+++ /tmp/tmpym7zqfz4.java\t2023-03-24 14:06:20.483823849 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Row \" + depth + \" doesn't exist!\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but was \" + value);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:25.123806508 +0100\n+++ /tmp/tmpxe3nb2m9.java\t2023-03-24 14:06:25.123806508 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but was \" + value);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "throw new UnsupportedOperationException(\"Not yet implemented!\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:27.231798633 +0100\n+++ /tmp/tmphpjfy961.java\t2023-03-24 14:06:27.231798633 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Not yet implemented!\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "throw new ParseCancellationException( \"Not a simple cycle\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:32.007780783 +0100\n+++ /tmp/tmp16xtslwr.java\t2023-03-24 14:06:32.011780770 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new ParseCancellationException( \"Not a simple cycle\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "} else if (c >= 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:34.163772728 +0100\n+++ /tmp/tmpdy_ahzzw.java\t2023-03-24 14:06:34.163772728 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (c >= 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "throw new ParseCancellationException( \"Graph string seems to be vertices\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:36.199765117 +0100\n+++ /tmp/tmpv77tsd9m.java\t2023-03-24 14:06:36.203765105 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new ParseCancellationException( \"Graph string seems to be vertices\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "throw new ParseCancellationException( \"Graph string seems to be connected\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:38.203757628 +0100\n+++ /tmp/tmpc5m2iog4.java\t2023-03-24 14:06:38.207757616 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new ParseCancellationException( \"Graph string seems to be connected\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "throw new IllegalArgumentException(\"Row \" + depth + \" was not started\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:40.255749962 +0100\n+++ /tmp/tmph8guc6q1.java\t2023-03-24 14:06:40.255749962 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Row \" + depth + \" was not started\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "throw new IllegalStateException(\"Not a simple cycle\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:44.999732232 +0100\n+++ /tmp/tmpqg_hos22.java\t2023-03-24 14:06:44.999732232 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Not a simple cycle\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth but found \" + depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:49.515715352 +0100\n+++ /tmp/tmp3tav0h22.java\t2023-03-24 14:06:49.515715352 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth but found \" + depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "return false; // We don't have the same value",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:53.915698907 +0100\n+++ /tmp/tmp731hre9a.java\t2023-03-24 14:06:53.915698907 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't have the same value\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "return false; // We don't get the root of the stack",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:06:58.851680461 +0100\n+++ /tmp/tmpe4jz4n_e.java\t2023-03-24 14:06:58.855680443 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't get the root of the stack\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "else if (depth == 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:03.339663683 +0100\n+++ /tmp/tmpg1b7wo4_.java\t2023-03-24 14:07:03.339663683 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+else if (depth == 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph was not supported\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:05.267656479 +0100\n+++ /tmp/tmpl546ztfe.java\t2023-03-24 14:07:05.267656479 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph was not supported\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "throw new NoSuchElementException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:09.447640852 +0100\n+++ /tmp/tmpp4riix5t.java\t2023-03-24 14:07:09.447640852 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (depth > 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:13.911624169 +0100\n+++ /tmp/tmpl2n0ulys.java\t2023-03-24 14:07:13.911624169 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+if (depth > 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "throw new OptimisticLockException(null, depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:15.827617004 +0100\n+++ /tmp/tmp_8041n8a.java\t2023-03-24 14:07:15.827617004 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new OptimisticLockException(null, depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "throw new IllegalArgumentException(\"Unexpected depth cannot be used as node\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:17.819609560 +0100\n+++ /tmp/tmp311w3nt5.java\t2023-03-24 14:07:17.819609560 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Unexpected depth cannot be used as node\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "throw new IllegalStateException(\"Already Executed\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:22.091593588 +0100\n+++ /tmp/tmpjzhr5gjh.java\t2023-03-24 14:07:22.091593588 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Already Executed\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "} else if (depth == 0) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:26.359577634 +0100\n+++ /tmp/tmp2ubqiove.java\t2023-03-24 14:07:26.363577621 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+} else if (depth == 0) { return true; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph should never end in graph\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:28.071571237 +0100\n+++ /tmp/tmpfxhmkvsw.java\t2023-03-24 14:07:28.075571221 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph should never end in graph\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "throw new IllegalArgumentException(\"Unexpected end-of-input\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:32.235555667 +0100\n+++ /tmp/tmp29_pc6on.java\t2023-03-24 14:07:32.239555655 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalArgumentException(\"Unexpected end-of-input\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "throw new ParsingException(null, depth + \" was expected\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:36.243540684 +0100\n+++ /tmp/tmphfgfy6y4.java\t2023-03-24 14:07:36.247540672 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new ParsingException(null, depth + \" was expected\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "throw new IllegalStateException(\"Unexpected end-of-input\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:37.963534256 +0100\n+++ /tmp/tmp__zqfgyq.java\t2023-03-24 14:07:37.963534256 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Unexpected end-of-input\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph was not complete.\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:41.899519539 +0100\n+++ /tmp/tmp1hmf2jp_.java\t2023-03-24 14:07:41.899519539 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph was not complete.\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph contains no depth.\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:45.927504482 +0100\n+++ /tmp/tmp8bq9pu0l.java\t2023-03-24 14:07:45.927504482 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph contains no depth.\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph is not complete\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:49.851489809 +0100\n+++ /tmp/tmp9681qg8i.java\t2023-03-24 14:07:49.851489809 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph is not complete\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "throw new UnsupportedOperationException(\"Not yet implemented.\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:54.011474255 +0100\n+++ /tmp/tmpzfh5hgnm.java\t2023-03-24 14:07:54.011474255 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Not yet implemented.\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "return false; // We don't have the same tree",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:07:57.979459418 +0100\n+++ /tmp/tmpqldc6jwi.java\t2023-03-24 14:07:57.979459418 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't have the same tree\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "throw new UnsupportedOperationException(\"Not yet implemented yet\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:01.963444523 +0100\n+++ /tmp/tmp09id_kxq.java\t2023-03-24 14:08:01.963444523 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Not yet implemented yet\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph contains no vertices\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:05.895429823 +0100\n+++ /tmp/tmpcm2mb5mn.java\t2023-03-24 14:08:05.895429823 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph contains no vertices\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph is unweighted\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:09.831415106 +0100\n+++ /tmp/tmp71qtvv74.java\t2023-03-24 14:08:09.831415106 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph is unweighted\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "return false; // We don't have the entry",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:13.831400149 +0100\n+++ /tmp/tmphjmym_4s.java\t2023-03-24 14:08:13.831400149 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't have the entry\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "throw new OptimisticLockException(null, depth + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:17.883384994 +0100\n+++ /tmp/tmpo72kmc8w.java\t2023-03-24 14:08:17.887384982 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new OptimisticLockException(null, depth + 1);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "throw new InvalidGraphWalkException( \"Not all vertices\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:19.655378368 +0100\n+++ /tmp/tmpqldus4x8.java\t2023-03-24 14:08:19.655378368 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new InvalidGraphWalkException( \"Not all vertices\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "throw new UnsupportedOperationException(\"Not implemented.\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:21.399371849 +0100\n+++ /tmp/tmpeh4vocnz.java\t2023-03-24 14:08:21.399371849 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Not implemented.\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "throw new UnsupportedOperationException(\"Graph was not complete\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:25.287357310 +0100\n+++ /tmp/tmpx8fxueoo.java\t2023-03-24 14:08:25.287357310 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Graph was not complete\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "throw new IllegalStateException(\"Expected only one depth\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:29.427341828 +0100\n+++ /tmp/tmpnm_ih68u.java\t2023-03-24 14:08:29.427341828 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Expected only one depth\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "throw new UnsupportedOperationException(\"Not implemented yet\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:33.547326421 +0100\n+++ /tmp/tmp8kd3eg6a.java\t2023-03-24 14:08:33.547326421 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException(\"Not implemented yet\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "return false; // We don't have the same path",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:37.503311627 +0100\n+++ /tmp/tmpg1csoye3.java\t2023-03-24 14:08:37.503311627 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't have the same path\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "return false; // We don't get the stack",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:41.463296817 +0100\n+++ /tmp/tmp6g_qdas4.java\t2023-03-24 14:08:41.463296817 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't get the stack\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "return false; // We don't continue;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:45.283282529 +0100\n+++ /tmp/tmp38fa5q5p.java\t2023-03-24 14:08:45.283282529 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't continue;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "return false; // can't be empty string",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:49.251267691 +0100\n+++ /tmp/tmpjb3xl5jm.java\t2023-03-24 14:08:49.255267674 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // can't be empty string\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "throw unknownConversion(value, depth + 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:53.435252041 +0100\n+++ /tmp/tmpk3he7yyk.java\t2023-03-24 14:08:53.435252041 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw unknownConversion(value, depth + 1);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "throw new IllegalStateException(\"Not all vertices\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:55.095245835 +0100\n+++ /tmp/tmpre6djo43.java\t2023-03-24 14:08:55.095245835 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Not all vertices\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "return false; // We don't get the path",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:08:59.223230393 +0100\n+++ /tmp/tmpfv98gffq.java\t2023-03-24 14:08:59.223230393 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We don't get the path\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "return false; // We have the same value",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:03.179215599 +0100\n+++ /tmp/tmpl7b7yi31.java\t2023-03-24 14:09:03.179215599 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // We have the same value\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "throw new IllegalStateException(\"Already committed\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:07.271200292 +0100\n+++ /tmp/tmp_vq9h0yf.java\t2023-03-24 14:09:07.275200279 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(\"Already committed\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "throw unknownConversion(value, depth);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:11.499184480 +0100\n+++ /tmp/tmpw5je5bac.java\t2023-03-24 14:09:11.499184480 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw unknownConversion(value, depth);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "throw new ConcurrentModificationException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:13.771175980 +0100\n+++ /tmp/tmpyr9c8x19.java\t2023-03-24 14:09:13.771175980 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new ConcurrentModificationException();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "throw new NoSuchElementException(\"No depth\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:19.159155828 +0100\n+++ /tmp/tmpg3jw158f.java\t2023-03-24 14:09:19.159155828 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchElementException(\"No depth\");\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "return true;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:25.307132831 +0100\n+++ /tmp/tmpwuk6dnrp.java\t2023-03-24 14:09:25.307132831 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return true;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "throw new IllegalStateException(toString());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:29.751116207 +0100\n+++ /tmp/tmpzss966ss.java\t2023-03-24 14:09:29.791116055 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new IllegalStateException(toString());\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "throw new UnsupportedOperationException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:31.883108230 +0100\n+++ /tmp/tmp5zrpuovp.java\t2023-03-24 14:09:31.883108230 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new UnsupportedOperationException();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "return false; // EOF",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:37.615086790 +0100\n+++ /tmp/tmp88v59mkt.java\t2023-03-24 14:09:37.615086790 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // EOF\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "return false; // n is null",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:42.587068191 +0100\n+++ /tmp/tmpk2r2gygb.java\t2023-03-24 14:09:42.587068191 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // n is null\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "throw new NoSuchMasterKeyException();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:48.003047929 +0100\n+++ /tmp/tmp02jjwe3x.java\t2023-03-24 14:09:48.007047912 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new NoSuchMasterKeyException();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "throw selectionNotSupported();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:49.751041391 +0100\n+++ /tmp/tmpdf_pv1kw.java\t2023-03-24 14:09:49.771041315 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw selectionNotSupported();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "return false; // stack",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:51.943033188 +0100\n+++ /tmp/tmpzufeoaf7.java\t2023-03-24 14:09:51.943033188 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; // stack\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "throw new AssertionError();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:09:57.335013016 +0100\n+++ /tmp/tmpq_ngyzc5.java\t2023-03-24 14:09:57.335013016 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw new AssertionError();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "return false; });",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:02.306994414 +0100\n+++ /tmp/tmp_s9qnvds.java\t2023-03-24 14:10:02.306994414 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; });\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:04.162987473 +0100\n+++ /tmp/tmpudce87gi.java\t2023-03-24 14:10:04.162987473 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return false; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "throw x;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:06.390979135 +0100\n+++ /tmp/tmp1to2wszn.java\t2023-03-24 14:10:06.390979135 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw x;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "throw e;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:08.626970772 +0100\n+++ /tmp/tmpc45dme5n.java\t2023-03-24 14:10:08.626970772 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw e;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "throw exception;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:10.786962688 +0100\n+++ /tmp/tmpck9uu2yk.java\t2023-03-24 14:10:10.790962676 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw exception;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "throw this;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:13.514952484 +0100\n+++ /tmp/tmpdvd68en7.java\t2023-03-24 14:10:13.514952484 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+throw this;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return result;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:15.594944699 +0100\n+++ /tmp/tmpxq_0cshh.java\t2023-03-24 14:10:15.594944699 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return result;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "= null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:17.702936814 +0100\n+++ /tmp/tmp_0_wsfyo.java\t2023-03-24 14:10:17.702936814 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+= null;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return 0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/is_valid_parenthesization/java_programs/IS_VALID_PARENTHESIZATION.java\t2023-03-24 14:10:19.458930244 +0100\n+++ /tmp/tmpk5ir5mc3.java\t2023-03-24 14:10:19.458930244 +0100\n@@ -19,8 +19,8 @@\n             } else {\n                 depth--;\n                 if (depth < 0) { return false; }\n             }\n         }\n-        return true;\n+return 0;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return depth==0;"
    },
    "pascal": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (int c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:06:57.515685452 +0100\n+++ /tmp/tmpz_tvdtsa.java\t2023-03-24 14:06:57.579685212 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (r > 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:02.147668139 +0100\n+++ /tmp/tmp3fj4wjv4.java\t2023-03-24 14:07:02.151668126 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (p > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:04.215660411 +0100\n+++ /tmp/tmp9ge_120a.java\t2023-03-24 14:07:04.215660411 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "for(int c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:06.307652591 +0100\n+++ /tmp/tmp65vkyqr9.java\t2023-03-24 14:07:06.307652591 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for(int c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (offset > 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:10.879635502 +0100\n+++ /tmp/tmpu_5yszsp.java\t2023-03-24 14:07:10.879635502 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (offset > 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "for (int c=0; c<r; c--) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:12.919627877 +0100\n+++ /tmp/tmp5wrmzhwf.java\t2023-03-24 14:07:12.919627877 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c--) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "for (int c=1; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:17.739609860 +0100\n+++ /tmp/tmpm9b5vj0z.java\t2023-03-24 14:07:17.739609860 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=1; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "for (char c=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:22.171593292 +0100\n+++ /tmp/tmpyh6d2a1_.java\t2023-03-24 14:07:22.171593292 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (char c=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (init.containsKey(r)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:26.563576874 +0100\n+++ /tmp/tmp5m9139va.java\t2023-03-24 14:07:26.563576874 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (init.containsKey(r)) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (r=1; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:28.319570309 +0100\n+++ /tmp/tmphht6g5wj.java\t2023-03-24 14:07:28.319570309 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r=1; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (p == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:30.103563638 +0100\n+++ /tmp/tmp3d1squp3.java\t2023-03-24 14:07:30.103563638 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p == 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (p > 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:32.043556385 +0100\n+++ /tmp/tmpqnxw6kfm.java\t2023-03-24 14:07:32.047556372 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p > 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "for (int c=0; c<r; c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:33.803549808 +0100\n+++ /tmp/tmpuoedj317.java\t2023-03-24 14:07:33.803549808 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (p < 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:35.643542927 +0100\n+++ /tmp/tmpy_x3zc8j.java\t2023-03-24 14:07:35.647542914 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p < 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (graph.containsEdge(r1, r2)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:37.531535868 +0100\n+++ /tmp/tmpjzc4qb1p.java\t2023-03-24 14:07:37.531535868 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (graph.containsEdge(r1, r2)) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "for (int i=0; c<r; c++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:39.383528945 +0100\n+++ /tmp/tmppc334acx.java\t2023-03-24 14:07:39.387528932 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int i=0; c<r; c++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (r > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:41.199522157 +0100\n+++ /tmp/tmpzbrlc_my.java\t2023-03-24 14:07:41.203522140 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:43.075515145 +0100\n+++ /tmp/tmp_m4v6m6e.java\t2023-03-24 14:07:43.075515145 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (p == null || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:44.963508083 +0100\n+++ /tmp/tmp0r9o105w.java\t2023-03-24 14:07:44.963508083 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p == null || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (init.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:46.823501131 +0100\n+++ /tmp/tmpp0zv6y1f.java\t2023-03-24 14:07:46.823501131 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (init.size() > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "for (int i=0; i<r; i++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:48.727494013 +0100\n+++ /tmp/tmpzyxl1vdd.java\t2023-03-24 14:07:48.727494013 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int i=0; i<r; i++) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (r < 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:50.579487086 +0100\n+++ /tmp/tmpbqz109ki.java\t2023-03-24 14:07:50.579487086 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r < 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "for (int c=0; c<r; c') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:52.419480207 +0100\n+++ /tmp/tmpki20xxo3.java\t2023-03-24 14:07:52.419480207 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c') {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (p == 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:54.199473554 +0100\n+++ /tmp/tmpube6l9t_.java\t2023-03-24 14:07:54.199473554 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p == 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (p!= null || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:56.099466450 +0100\n+++ /tmp/tmp2b0lr6en.java\t2023-03-24 14:07:56.103466433 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p!= null || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (r > 0 || r < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:58.035459212 +0100\n+++ /tmp/tmpgsbjae6d.java\t2023-03-24 14:07:58.035459212 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > 0 || r < 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (r == 0 && r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:07:59.799452614 +0100\n+++ /tmp/tmpcaqpnqi_.java\t2023-03-24 14:07:59.799452614 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r == 0 && r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (!rows.containsKey(r)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:01.759445288 +0100\n+++ /tmp/tmp7zwcya74.java\t2023-03-24 14:08:01.759445288 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (!rows.containsKey(r)) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (r == 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:03.619438331 +0100\n+++ /tmp/tmpgb8ov2lb.java\t2023-03-24 14:08:03.619438331 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r == 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (rr.size() > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:05.475431393 +0100\n+++ /tmp/tmpzdjsa30q.java\t2023-03-24 14:08:05.475431393 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rr.size() > i) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (r.size() > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:07.343424408 +0100\n+++ /tmp/tmplas7i5r9.java\t2023-03-24 14:08:07.343424408 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r.size() > i) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "for (int c=0; c<r; c {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:09.267417212 +0100\n+++ /tmp/tmpmsebcr9z.java\t2023-03-24 14:08:09.267417212 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+for (int c=0; c<r; c {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (columnMatched[r]!= -1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:11.043410574 +0100\n+++ /tmp/tmpaf9t68tc.java\t2023-03-24 14:08:11.043410574 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (columnMatched[r]!= -1) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (r > c0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:12.847403829 +0100\n+++ /tmp/tmpayv21813.java\t2023-03-24 14:08:12.847403829 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > c0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (r > i || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:14.675396992 +0100\n+++ /tmp/tmpoii3840n.java\t2023-03-24 14:08:14.675396992 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (r > i || r > size) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:16.551389978 +0100\n+++ /tmp/tmpbef2280i.java\t2023-03-24 14:08:16.551389978 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i || r > size) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (r > 0 && r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:18.395383082 +0100\n+++ /tmp/tmpq2sfzikq.java\t2023-03-24 14:08:18.395383082 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > 0 && r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (r > c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:20.155376499 +0100\n+++ /tmp/tmpn0m32_2x.java\t2023-03-24 14:08:20.155376499 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > c) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (p > 0 || p > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:21.999369603 +0100\n+++ /tmp/tmpj3guzxyp.java\t2023-03-24 14:08:22.003369591 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p > 0 || p > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (r > 0 && r < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:23.983362184 +0100\n+++ /tmp/tmpq9ie0m1g.java\t2023-03-24 14:08:23.983362184 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > 0 && r < 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (rows!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:25.931354901 +0100\n+++ /tmp/tmpmpvotnf7.java\t2023-03-24 14:08:25.931354901 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rows!= null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (n % 2 == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:27.803347899 +0100\n+++ /tmp/tmpiv1x4om_.java\t2023-03-24 14:08:27.803347899 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (n % 2 == 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (p < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:29.651340988 +0100\n+++ /tmp/tmp577lnn_6.java\t2023-03-24 14:08:29.651340988 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p < 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (r > b.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:31.435334317 +0100\n+++ /tmp/tmpbq82v4rs.java\t2023-03-24 14:08:31.435334317 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > b.length) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (p!= null && r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:33.343327184 +0100\n+++ /tmp/tmp1d4zwpry.java\t2023-03-24 14:08:33.343327184 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p!= null && r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (r > rows.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:35.179320315 +0100\n+++ /tmp/tmpvpamh2x_.java\t2023-03-24 14:08:35.179320315 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > rows.size()) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (r > c || r < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:37.091313168 +0100\n+++ /tmp/tmp0l2fhyww.java\t2023-03-24 14:08:37.091313168 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > c || r < 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (r > a.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:38.935306272 +0100\n+++ /tmp/tmpf2qk_goq.java\t2023-03-24 14:08:38.935306272 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > a.size()) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (c < 0 || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:40.843299133 +0100\n+++ /tmp/tmpugxhgnof.java\t2023-03-24 14:08:40.843299133 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (c < 0 || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (init.size() > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:42.695292210 +0100\n+++ /tmp/tmpjvmgcszv.java\t2023-03-24 14:08:42.695292210 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (init.size() > i) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (r > i || r < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:44.663284850 +0100\n+++ /tmp/tmp5lt7jrha.java\t2023-03-24 14:08:44.667284833 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i || r < 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (r > fileCount) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:46.551277787 +0100\n+++ /tmp/tmp5g2urrj6.java\t2023-03-24 14:08:46.555277774 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > fileCount) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (a.length() > r0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:48.459270653 +0100\n+++ /tmp/tmpprfa0p9m.java\t2023-03-24 14:08:48.459270653 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (a.length() > r0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (p!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:50.331263652 +0100\n+++ /tmp/tmprajtn6mw.java\t2023-03-24 14:08:50.331263652 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p!= null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (r > r || r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:52.191256695 +0100\n+++ /tmp/tmp1m14y4_5.java\t2023-03-24 14:08:52.191256695 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > r || r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (p == null || r < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:54.035249797 +0100\n+++ /tmp/tmp277_v9s5.java\t2023-03-24 14:08:54.035249797 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p == null || r < 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (r > i * n - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:55.971242558 +0100\n+++ /tmp/tmpt1fi3yaj.java\t2023-03-24 14:08:55.975242540 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i * n - 1) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (p == null || p == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:57.847235541 +0100\n+++ /tmp/tmp9xwdcyaj.java\t2023-03-24 14:08:57.847235541 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p == null || p == 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (r.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:08:59.623228900 +0100\n+++ /tmp/tmpbdc3pe5a.java\t2023-03-24 14:08:59.623228900 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r.size() > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (a.size() > r0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:01.415222197 +0100\n+++ /tmp/tmp7izhzd61.java\t2023-03-24 14:09:01.419222179 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (a.size() > r0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (r > startIndex) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:03.255215315 +0100\n+++ /tmp/tmpd0nxxq_k.java\t2023-03-24 14:09:03.255215315 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > startIndex) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (r > c1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:05.127208313 +0100\n+++ /tmp/tmpz7cx4tr3.java\t2023-03-24 14:09:05.127208313 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > c1) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (a.length() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:07.071201039 +0100\n+++ /tmp/tmpeva3q1ya.java\t2023-03-24 14:09:07.071201039 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (a.length() > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (r > rows.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:09.295192724 +0100\n+++ /tmp/tmpqyrxbs1_.java\t2023-03-24 14:09:09.299192706 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > rows.length) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (r > size) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:11.207185569 +0100\n+++ /tmp/tmpzac1nc1f.java\t2023-03-24 14:09:11.211185557 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > size) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (row.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:13.419177296 +0100\n+++ /tmp/tmprueyu62p.java\t2023-03-24 14:09:13.527176892 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (row.size() > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (r > a.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:15.911167978 +0100\n+++ /tmp/tmpjxo1be6a.java\t2023-03-24 14:09:15.995167661 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > a.length) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (rr > c0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:18.291159072 +0100\n+++ /tmp/tmpan8ula8b.java\t2023-03-24 14:09:18.291159072 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rr > c0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (r > n - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:20.423151100 +0100\n+++ /tmp/tmpdx23lqgd.java\t2023-03-24 14:09:20.423151100 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > n - 1) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (r!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:23.247140537 +0100\n+++ /tmp/tmp96a4aawe.java\t2023-03-24 14:09:23.247140537 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r!= null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (r > mcc) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:24.915134294 +0100\n+++ /tmp/tmpx51aeqkc.java\t2023-03-24 14:09:24.919134282 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > mcc) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (rr > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:26.835127115 +0100\n+++ /tmp/tmpvp26021y.java\t2023-03-24 14:09:26.875126963 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rr > i) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (r > i--) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:28.903119379 +0100\n+++ /tmp/tmp6zzr5_t2.java\t2023-03-24 14:09:28.903119379 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i--) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if ( r > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:31.275110504 +0100\n+++ /tmp/tmpvx6dkl5_.java\t2023-03-24 14:09:31.275110504 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if ( r > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (r!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:33.587101858 +0100\n+++ /tmp/tmpqfm736_4.java\t2023-03-24 14:09:33.711101394 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r!= 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (r > r0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:35.791093611 +0100\n+++ /tmp/tmpbyhrpoyn.java\t2023-03-24 14:09:35.791093611 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > r0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (rows!=null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:37.675086563 +0100\n+++ /tmp/tmpy9y5ubtb.java\t2023-03-24 14:09:37.675086563 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rows!=null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (rows!= r0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:39.847078439 +0100\n+++ /tmp/tmph816e299.java\t2023-03-24 14:09:39.847078439 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rows!= r0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (init.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:42.395068907 +0100\n+++ /tmp/tmp3b1g5zoa.java\t2023-03-24 14:09:42.547068338 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (init.isEmpty()) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (init.containsKey(r)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:44.843059751 +0100\n+++ /tmp/tmpbsetoh3_.java\t2023-03-24 14:09:45.015059105 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (init.containsKey(r)){\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (n == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:47.063051446 +0100\n+++ /tmp/tmpm13mdel5.java\t2023-03-24 14:09:47.167051058 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (n == 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (rows > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:50.387039008 +0100\n+++ /tmp/tmpuguou30i.java\t2023-03-24 14:09:50.387039008 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rows > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (!rows.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:52.531030991 +0100\n+++ /tmp/tmpbw0qejer.java\t2023-03-24 14:09:52.531030991 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (!rows.isEmpty()) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (r == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:54.251024555 +0100\n+++ /tmp/tmpefras0h9.java\t2023-03-24 14:09:55.443020093 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r == 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (offset > 0 || offset) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:57.083013961 +0100\n+++ /tmp/tmpfasqegie.java\t2023-03-24 14:09:57.083013961 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (offset > 0 || offset) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (p!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:09:59.003006775 +0100\n+++ /tmp/tmpozfuo14m.java\t2023-03-24 14:09:59.095006433 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (p!= 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (r == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:01.334998053 +0100\n+++ /tmp/tmplp4b83uc.java\t2023-03-24 14:10:01.338998036 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r == null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (r > i0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:04.138987560 +0100\n+++ /tmp/tmpbviih5zv.java\t2023-03-24 14:10:04.142987548 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (rows!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:06.390979135 +0100\n+++ /tmp/tmpmsak7wnx.java\t2023-03-24 14:10:06.390979135 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rows!= 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (r > iB) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:08.622970784 +0100\n+++ /tmp/tmpdunrfxs6.java\t2023-03-24 14:10:08.622970784 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > iB) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (r!=null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:11.246960967 +0100\n+++ /tmp/tmptj7tu0dn.java\t2023-03-24 14:10:11.246960967 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r!=null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (row!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:13.274953382 +0100\n+++ /tmp/tmpuc4_zoj3.java\t2023-03-24 14:10:13.274953382 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (row!= null) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (r > i1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:15.570944791 +0100\n+++ /tmp/tmpvg1z24rp.java\t2023-03-24 14:10:15.570944791 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > i1) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (r!= c0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:17.714936767 +0100\n+++ /tmp/tmp2fihi8xh.java\t2023-03-24 14:10:17.714936767 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r!= c0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (r > c00) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:19.766929092 +0100\n+++ /tmp/tmp2l7iqqif.java\t2023-03-24 14:10:19.766929092 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > c00) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (r > n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:21.698921860 +0100\n+++ /tmp/tmpqp66y5u3.java\t2023-03-24 14:10:21.702921848 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > n) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (rows == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:24.366911880 +0100\n+++ /tmp/tmpxh6qdatl.java\t2023-03-24 14:10:24.378911833 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (rows == 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (n > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:27.574899875 +0100\n+++ /tmp/tmpvv26m90l.java\t2023-03-24 14:10:27.574899875 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (n > 0) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (r > 10) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:29.714891868 +0100\n+++ /tmp/tmpx7rwbira.java\t2023-03-24 14:10:30.050890611 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (r > 10) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (isDebug) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/pascal/java_programs/PASCAL.java\t2023-03-24 14:10:31.974883414 +0100\n+++ /tmp/tmpgyou8xwj.java\t2023-03-24 14:10:32.166882696 +0100\n@@ -17,11 +17,11 @@\n         init.add(1);\n         rows.add(init);\n \n         for (int r=1; r<n; r++) {\n             ArrayList<Integer> row = new ArrayList<Integer>();\n-            for (int c=0; c<r; c++) {\n+if (isDebug) {\n                 int upleft, upright;\n                 if (c > 0) {\n                     upleft = rows.get(r-1).get(c-1);\n                 } else {\n                     upleft = 0;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (int c=0; c<r+1; c++) {"
    },
    "levenshtein": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:27.198901282 +0100\n+++ /tmp/tmpylmj0bx0.java\t2023-03-24 14:10:27.466900279 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:29.926891075 +0100\n+++ /tmp/tmp6ndc8l1h.java\t2023-03-24 14:10:29.926891075 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:32.334882068 +0100\n+++ /tmp/tmp7rwz5r9e.java\t2023-03-24 14:10:32.334882068 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:35.110871680 +0100\n+++ /tmp/tmpjm_eurvm.java\t2023-03-24 14:10:35.110871680 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:38.258859895 +0100\n+++ /tmp/tmp83boh4kr.java\t2023-03-24 14:10:38.258859895 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:40.362852022 +0100\n+++ /tmp/tmpol44_6fl.java\t2023-03-24 14:10:40.362852022 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:42.490844061 +0100\n+++ /tmp/tmpze4tqew2.java\t2023-03-24 14:10:42.490844061 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:45.158834077 +0100\n+++ /tmp/tmp64c_uzqc.java\t2023-03-24 14:10:45.158834077 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else if (target.startsWith(\"/\")) { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:47.150826623 +0100\n+++ /tmp/tmp0phq7okh.java\t2023-03-24 14:10:47.150826623 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else if (target.startsWith(\"/\")) { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:48.942819916 +0100\n+++ /tmp/tmpzmip6fkc.java\t2023-03-24 14:10:48.942819916 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:50.810812926 +0100\n+++ /tmp/tmpaq_ty2k0.java\t2023-03-24 14:10:50.810812926 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:52.646806057 +0100\n+++ /tmp/tmpq9p17jzn.java\t2023-03-24 14:10:52.646806057 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:54.518799051 +0100\n+++ /tmp/tmp1l55qdud.java\t2023-03-24 14:10:54.518799051 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:56.330792271 +0100\n+++ /tmp/tmp79p08icf.java\t2023-03-24 14:10:56.330792271 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:58.194785295 +0100\n+++ /tmp/tmpm9k3ux0a.java\t2023-03-24 14:10:58.194785295 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:10:59.998778545 +0100\n+++ /tmp/tmpnyks7ytv.java\t2023-03-24 14:10:59.998778545 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:01.806771779 +0100\n+++ /tmp/tmplar3setx.java\t2023-03-24 14:11:01.806771779 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:03.726764594 +0100\n+++ /tmp/tmpqmpht5z6.java\t2023-03-24 14:11:03.726764594 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:05.630757469 +0100\n+++ /tmp/tmptjyjc24d.java\t2023-03-24 14:11:05.630757469 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:07.530750358 +0100\n+++ /tmp/tmpnw67mhf2.java\t2023-03-24 14:11:07.530750358 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:09.402743352 +0100\n+++ /tmp/tmphqe9jw0h.java\t2023-03-24 14:11:09.406743339 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:11.266736378 +0100\n+++ /tmp/tmpie44aff7.java\t2023-03-24 14:11:11.266736378 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return 0; }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:13.102729507 +0100\n+++ /tmp/tmpb0dnbl6h.java\t2023-03-24 14:11:13.102729507 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:15.002722396 +0100\n+++ /tmp/tmpra26cb7b.java\t2023-03-24 14:11:15.002722396 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:16.882715360 +0100\n+++ /tmp/tmpgqadscul.java\t2023-03-24 14:11:16.882715360 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:18.742708400 +0100\n+++ /tmp/tmpa257sjvr.java\t2023-03-24 14:11:18.742708400 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:20.546701648 +0100\n+++ /tmp/tmpu38de5mg.java\t2023-03-24 14:11:20.546701648 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:22.362694852 +0100\n+++ /tmp/tmp4oqjswtb.java\t2023-03-24 14:11:22.366694837 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:24.262687741 +0100\n+++ /tmp/tmpqh0np6k5.java\t2023-03-24 14:11:24.262687741 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:26.154680660 +0100\n+++ /tmp/tmpit52v82w.java\t2023-03-24 14:11:26.154680660 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:27.910674089 +0100\n+++ /tmp/tmpy52ww8t9.java\t2023-03-24 14:11:27.914674075 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:29.658667547 +0100\n+++ /tmp/tmpv_u8pmox.java\t2023-03-24 14:11:29.658667547 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:31.610660241 +0100\n+++ /tmp/tmpxdayiyoe.java\t2023-03-24 14:11:31.610660241 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (source.length() == 2) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:33.458653325 +0100\n+++ /tmp/tmp67wl0s21.java\t2023-03-24 14:11:33.458653325 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 2) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (target.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:35.282646499 +0100\n+++ /tmp/tmpmoezg22q.java\t2023-03-24 14:11:35.282646499 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (target.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:37.126639597 +0100\n+++ /tmp/tmpess4cndm.java\t2023-03-24 14:11:37.126639597 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:38.938632815 +0100\n+++ /tmp/tmpmkgl2ysb.java\t2023-03-24 14:11:38.938632815 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:40.726626124 +0100\n+++ /tmp/tmpijmwlaxk.java\t2023-03-24 14:11:40.726626124 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:42.502619477 +0100\n+++ /tmp/tmpx3tk5gfg.java\t2023-03-24 14:11:42.502619477 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:44.450612186 +0100\n+++ /tmp/tmppiz8yhr5.java\t2023-03-24 14:11:44.450612186 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:46.246605463 +0100\n+++ /tmp/tmp_hm52x_j.java\t2023-03-24 14:11:46.250605450 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:48.166598277 +0100\n+++ /tmp/tmpm91drh8e.java\t2023-03-24 14:11:48.166598277 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ',') { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:50.042591256 +0100\n+++ /tmp/tmpuyf9hy6t.java\t2023-03-24 14:11:50.042591256 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:51.958584085 +0100\n+++ /tmp/tmpjy7fsfin.java\t2023-03-24 14:11:51.962584069 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:53.806577169 +0100\n+++ /tmp/tmp9hch5vmp.java\t2023-03-24 14:11:53.806577169 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:55.594570476 +0100\n+++ /tmp/tmpzffkb2rh.java\t2023-03-24 14:11:55.594570476 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:57.354563889 +0100\n+++ /tmp/tmpd2y6zkzx.java\t2023-03-24 14:11:57.354563889 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:11:59.146557180 +0100\n+++ /tmp/tmp174c_f5g.java\t2023-03-24 14:11:59.146557180 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (source.length() == 2) { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:01.018550175 +0100\n+++ /tmp/tmpju75r15h.java\t2023-03-24 14:12:01.018550175 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 2) { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:02.818543436 +0100\n+++ /tmp/tmp_20_af50.java\t2023-03-24 14:12:02.822543422 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:04.802536010 +0100\n+++ /tmp/tmp_pzdfwry.java\t2023-03-24 14:12:04.802536010 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:06.594529304 +0100\n+++ /tmp/tmpintfxppz.java\t2023-03-24 14:12:06.594529304 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else if (target.startsWith(\"/\")) { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:08.422522461 +0100\n+++ /tmp/tmp5823a838.java\t2023-03-24 14:12:08.426522445 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else if (target.startsWith(\"/\")) { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:10.282515499 +0100\n+++ /tmp/tmpg5lwhh8v.java\t2023-03-24 14:12:10.282515499 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:12.126508596 +0100\n+++ /tmp/tmp47cl02ev.java\t2023-03-24 14:12:12.126508596 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '-') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:13.982501650 +0100\n+++ /tmp/tmpjr855s0n.java\t2023-03-24 14:12:13.982501650 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:15.818494777 +0100\n+++ /tmp/tmpqftw31rh.java\t2023-03-24 14:12:15.822494761 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (source.charAt(0) == 'E') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:17.658487890 +0100\n+++ /tmp/tmp96pnpr_j.java\t2023-03-24 14:12:17.658487890 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == 'E') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:19.514480942 +0100\n+++ /tmp/tmpvnlye0an.java\t2023-03-24 14:12:19.514480942 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (source.charAt(0) == ']') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:21.282474325 +0100\n+++ /tmp/tmp9bhral5i.java\t2023-03-24 14:12:21.282474325 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ']') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:23.222467061 +0100\n+++ /tmp/tmpiv027iu7.java\t2023-03-24 14:12:23.226467047 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:25.166459786 +0100\n+++ /tmp/tmpdm3dkg2e.java\t2023-03-24 14:12:25.166459786 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (target.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:27.046452749 +0100\n+++ /tmp/tmp2d6soryp.java\t2023-03-24 14:12:27.046452749 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (target.length() == 1) { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:28.882445876 +0100\n+++ /tmp/tmpgwcp1dsa.java\t2023-03-24 14:12:28.886445860 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:30.706439046 +0100\n+++ /tmp/tmp74d4arfr.java\t2023-03-24 14:12:30.706439046 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '*') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (source.charAt(0) == '-') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:32.558432114 +0100\n+++ /tmp/tmpchvjwj2m.java\t2023-03-24 14:12:32.558432114 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '-') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (source.charAt(0) == ']') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:34.410425182 +0100\n+++ /tmp/tmpklmza_e5.java\t2023-03-24 14:12:34.410425182 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ']') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:36.342417950 +0100\n+++ /tmp/tmpogzl0l39.java\t2023-03-24 14:12:36.342417950 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (source.charAt(0) == 'E') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:38.198411002 +0100\n+++ /tmp/tmp1335dw_6.java\t2023-03-24 14:12:38.198411002 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == 'E') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:40.046404083 +0100\n+++ /tmp/tmpjkzinnq9.java\t2023-03-24 14:12:40.050404070 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (source.length() == 2) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:41.774397615 +0100\n+++ /tmp/tmpylwy1r0o.java\t2023-03-24 14:12:41.778397599 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 2) { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (source.startsWith(\"-\")) { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:43.642390623 +0100\n+++ /tmp/tmpkl40e22s.java\t2023-03-24 14:12:43.642390623 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.startsWith(\"-\")) { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:45.426383945 +0100\n+++ /tmp/tmpjyw65mar.java\t2023-03-24 14:12:45.426383945 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (source.charAt(0) == target.length()) { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:47.354376727 +0100\n+++ /tmp/tmpns606o4o.java\t2023-03-24 14:12:47.354376727 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == target.length()) { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (source.charAt(0) == '=') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:49.086370243 +0100\n+++ /tmp/tmpej__arpf.java\t2023-03-24 14:12:49.086370243 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '=') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:50.882363519 +0100\n+++ /tmp/tmpc7llqlh9.java\t2023-03-24 14:12:50.882363519 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 2) { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(2).length(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:52.586357139 +0100\n+++ /tmp/tmp9n28en0c.java\t2023-03-24 14:12:52.586357139 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(2).length(); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (source.charAt(0) == '+' || target.charAt(target.length() - 1) == '-') { return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:54.422350267 +0100\n+++ /tmp/tmpb6596tdw.java\t2023-03-24 14:12:54.422350267 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '+' || target.charAt(target.length() - 1) == '-') { return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (source.charAt(0) == ']') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:56.362343003 +0100\n+++ /tmp/tmpm3vcqave.java\t2023-03-24 14:12:56.362343003 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == ']') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:58.130336386 +0100\n+++ /tmp/tmpf30nfixd.java\t2023-03-24 14:12:58.130336386 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.length() == 1) { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (source.charAt(0) == '=') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:12:59.962329527 +0100\n+++ /tmp/tmp1i4y77cu.java\t2023-03-24 14:12:59.962329527 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '=') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (source.charAt(0) == '+' || source.charAt(target.length() - 1) == '-') { return 1 + target.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:01.810322609 +0100\n+++ /tmp/tmpu7673vut.java\t2023-03-24 14:13:01.810322609 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '+' || source.charAt(target.length() - 1) == '-') { return 1 + target.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (source.startsWith(\"-\")) { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:03.622315826 +0100\n+++ /tmp/tmpuzgixlsi.java\t2023-03-24 14:13:03.622315826 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.startsWith(\"-\")) { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:05.450308980 +0100\n+++ /tmp/tmp6gdwfmnj.java\t2023-03-24 14:13:05.450308980 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(3); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:07.394301703 +0100\n+++ /tmp/tmpfgni5vup.java\t2023-03-24 14:13:07.398301689 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source.substring(3); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (source.charAt(0) == '\\\"') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:09.294294591 +0100\n+++ /tmp/tmp4nfufdfv.java\t2023-03-24 14:13:09.294294591 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\"') { return 1 + source.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (source.charAt(0) == 'E') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:11.174287551 +0100\n+++ /tmp/tmpibsa1o_h.java\t2023-03-24 14:13:11.174287551 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == 'E') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (source.startsWith(\"-\")) { return 1 + source.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:13.018280649 +0100\n+++ /tmp/tmpwyfra8dk.java\t2023-03-24 14:13:13.022280633 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.startsWith(\"-\")) { return 1 + source.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:14.974273326 +0100\n+++ /tmp/tmp3_0pek26.java\t2023-03-24 14:13:14.974273326 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (source.charAt(0) == '=') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:16.854266287 +0100\n+++ /tmp/tmpemf7rsh4.java\t2023-03-24 14:13:16.854266287 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '=') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:18.834258875 +0100\n+++ /tmp/tmpw5undo_z.java\t2023-03-24 14:13:18.834258875 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == 'W') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (source.charAt(0) == '}') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:20.718251820 +0100\n+++ /tmp/tmph0c5r_9w.java\t2023-03-24 14:13:20.722251806 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '}') { return 1 + target.substring(1); } else { return source.substring(0, target.length() - 2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:22.538245007 +0100\n+++ /tmp/tmpvq50kwrw.java\t2023-03-24 14:13:22.538245007 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:24.322238328 +0100\n+++ /tmp/tmp_06jcgwt.java\t2023-03-24 14:13:24.322238328 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\\') { return 1 + source.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (source.charAt(0) == target.length()) { return 1 + target.substring(1); } else { return source.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:26.174231394 +0100\n+++ /tmp/tmpogszsh_t.java\t2023-03-24 14:13:26.174231394 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == target.length()) { return 1 + target.substring(1); } else { return source.substring(1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:28.014224506 +0100\n+++ /tmp/tmpmgqoai0h.java\t2023-03-24 14:13:28.014224506 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '\\\"') { return 1 + target.substring(1); } else { return source.substring(0, source.length() - 1); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:29.842217661 +0100\n+++ /tmp/tmpiyz4z6oi.java\t2023-03-24 14:13:29.842217661 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '/') { return 1 + target.substring(1); } else { return source; }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:31.634210950 +0100\n+++ /tmp/tmpn1l8unzu.java\t2023-03-24 14:13:31.634210950 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '{') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:33.466204092 +0100\n+++ /tmp/tmpk892t5f9.java\t2023-03-24 14:13:33.466204092 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == '#') { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (source.charAt(0) == target.length()) { return 1 + target.substring(1); } else { return source.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/levenshtein/java_programs/LEVENSHTEIN.java\t2023-03-24 14:13:35.270197338 +0100\n+++ /tmp/tmp6713judf.java\t2023-03-24 14:13:35.270197338 +0100\n@@ -12,11 +12,11 @@\n public class LEVENSHTEIN {\n     public static int levenshtein(String source, String target) {\n         if (source.isEmpty() || target.isEmpty()) {\n             return source.isEmpty() ? target.length() : source.length();\n         } else if (source.charAt(0) == target.charAt(0)) {\n-            return 1 + levenshtein(source.substring(1), target.substring(1));\n+if (source.charAt(0) == target.length()) { return 1 + target.substring(1); } else { return source.substring(2); }\n         } else {\n             return 1 + Math.min(Math.min(\n                     levenshtein(source,              target.substring(1)),\n                     levenshtein(source.substring(1), target.substring(1))),\n                     levenshtein(source.substring(1), target)\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return levenshtein(source.substring(1), target.substring(1));"
    },
    "longest_common_subsequence": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '#') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:39.502855240 +0100\n+++ /tmp/tmp2w7tv_px.java\t2023-03-24 14:10:40.322852173 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '#') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 2); } else { return a.substring(2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:42.438844255 +0100\n+++ /tmp/tmp_51a0v9y.java\t2023-03-24 14:10:42.438844255 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 2); } else { return a.substring(2)); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (a.length() > 2) { return a.substring(1, b.length() - 1); } else { return a.substring(2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:44.742835633 +0100\n+++ /tmp/tmp9q7ve4k8.java\t2023-03-24 14:10:44.858835199 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(1, b.length() - 1); } else { return a.substring(2)); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 2); } else { return a.substring(2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:47.118826742 +0100\n+++ /tmp/tmpy5idpi8f.java\t2023-03-24 14:10:47.118826742 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 2); } else { return a.substring(2)); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == ',') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:48.938819932 +0100\n+++ /tmp/tmphu_rv914.java\t2023-03-24 14:10:48.938819932 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == ',') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 2); } else { return \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:50.770813077 +0100\n+++ /tmp/tmpjayn_59w.java\t2023-03-24 14:10:50.774813061 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 2); } else { return \"\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (a.length() > 1) { return a.substring(1, b.length() - 1); } else { return a.substring(2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:54.966797376 +0100\n+++ /tmp/tmpo3j5xaop.java\t2023-03-24 14:10:54.966797376 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(1, b.length() - 1); } else { return a.substring(2)); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '\\'') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:56.618791193 +0100\n+++ /tmp/tmph2awljor.java\t2023-03-24 14:10:56.618791193 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '\\'') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 2); } else { return \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:10:58.386784577 +0100\n+++ /tmp/tmp7hbswfq4.java\t2023-03-24 14:10:58.386784577 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 2); } else { return \"\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (a.length() > 2 && a.charAt(0) == '\\'') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:02.458769340 +0100\n+++ /tmp/tmpofqpo13t.java\t2023-03-24 14:11:02.458769340 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(0) == '\\'') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return a.substring(2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:04.238762677 +0100\n+++ /tmp/tmph65mibqy.java\t2023-03-24 14:11:04.242762663 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return a.substring(2)); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (a.length() > 2 && a.charAt(0) == '#') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:05.974756181 +0100\n+++ /tmp/tmpyxajtb1o.java\t2023-03-24 14:11:05.978756167 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(0) == '#') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return a.substring(2)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:07.706749700 +0100\n+++ /tmp/tmp4_boatbh.java\t2023-03-24 14:11:07.706749700 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return a.substring(2)); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 2); } else { return a.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:09.486743039 +0100\n+++ /tmp/tmpvy79blrp.java\t2023-03-24 14:11:09.486743039 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 2); } else { return a.substring(2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 2); } else { return a.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:13.602727636 +0100\n+++ /tmp/tmp2tgk5xop.java\t2023-03-24 14:11:13.602727636 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 2); } else { return a.substring(2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (a.length() > 2 && a.charAt(0) == ',') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:17.646712502 +0100\n+++ /tmp/tmps8yhgs18.java\t2023-03-24 14:11:17.646712502 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(0) == ',') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:19.546705391 +0100\n+++ /tmp/tmpu_2r7fss.java\t2023-03-24 14:11:19.546705391 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "return a.substring(0, b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:21.358698609 +0100\n+++ /tmp/tmpv1_q_2c3.java\t2023-03-24 14:11:21.362698595 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == '\\n') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:25.438683340 +0100\n+++ /tmp/tmp8mfk5sut.java\t2023-03-24 14:11:25.438683340 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == '\\n') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (a.length() > 1 || a.charAt(0) == '#') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:27.314676319 +0100\n+++ /tmp/tmprfz93f5e.java\t2023-03-24 14:11:27.314676319 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 || a.charAt(0) == '#') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(2 * b.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:29.146669464 +0100\n+++ /tmp/tmpj69vvwzk.java\t2023-03-24 14:11:29.146669464 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(2 * b.length() - 2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:30.898662906 +0100\n+++ /tmp/tmpw9f0vowv.java\t2023-03-24 14:11:30.898662906 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:32.694656185 +0100\n+++ /tmp/tmpp0vebtdk.java\t2023-03-24 14:11:32.694656185 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return \"\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '/') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:36.878640526 +0100\n+++ /tmp/tmpuqg3rmfi.java\t2023-03-24 14:11:36.878640526 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '/') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (a.length() > 2 && a.charAt(0) == '/') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:38.690633744 +0100\n+++ /tmp/tmpwau9svk2.java\t2023-03-24 14:11:38.690633744 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(0) == '/') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (a.length() > 2) { return a.substring(1, b.length() - 1); } else { return \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:40.590626634 +0100\n+++ /tmp/tmp6acgrdmy.java\t2023-03-24 14:11:40.590626634 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(1, b.length() - 1); } else { return \"\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (a.length() > b.length()) { return a.substring(0, b.length() - 2); } else { return \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:44.678611333 +0100\n+++ /tmp/tmpu7kzj2cz.java\t2023-03-24 14:11:44.678611333 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > b.length()) { return a.substring(0, b.length() - 2); } else { return \"\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return a.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:48.726596182 +0100\n+++ /tmp/tmpen3nyf6q.java\t2023-03-24 14:11:48.726596182 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return a.substring(2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (a.length() > 2 && a.charAt(0) == '\"') { return a.substring(1) + \"'\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:52.850580747 +0100\n+++ /tmp/tmpzapnndrr.java\t2023-03-24 14:11:52.850580747 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(0) == '\"') { return a.substring(1) + \"'\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == '\\'') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:54.694573844 +0100\n+++ /tmp/tmpi6dqb1t1.java\t2023-03-24 14:11:54.698573830 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == '\\'') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:11:56.458567243 +0100\n+++ /tmp/tmpvh5cq4eu.java\t2023-03-24 14:11:56.458567243 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return \"\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return a.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:00.734551237 +0100\n+++ /tmp/tmpc36_dfjv.java\t2023-03-24 14:12:00.738551221 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return a.substring(2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:04.850535832 +0100\n+++ /tmp/tmp18lq6mrn.java\t2023-03-24 14:12:04.850535832 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (a.length() > 1) { return a.substring(1, b.length() - 1); } else { return \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:06.670529018 +0100\n+++ /tmp/tmpbyyfh_0o.java\t2023-03-24 14:12:06.670529018 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(1, b.length() - 1); } else { return \"\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '-') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:10.790513598 +0100\n+++ /tmp/tmpo4yw2sa2.java\t2023-03-24 14:12:10.790513598 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '-') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:12.566506949 +0100\n+++ /tmp/tmpnto9k1ak.java\t2023-03-24 14:12:12.566506949 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 1); } else { return a; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1)!= '-') { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:16.590491887 +0100\n+++ /tmp/tmpvk3vtwle.java\t2023-03-24 14:12:16.590491887 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1)!= '-') { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(2 * b.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:18.322485404 +0100\n+++ /tmp/tmpmjmyfoqs.java\t2023-03-24 14:12:18.322485404 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(2 * b.length() - 1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:20.182478442 +0100\n+++ /tmp/tmpm37ek5rn.java\t2023-03-24 14:12:20.182478442 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return a; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:22.050471448 +0100\n+++ /tmp/tmp92gycs1z.java\t2023-03-24 14:12:22.050471448 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(0, b.length() - 1); } else { return a; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:26.054456462 +0100\n+++ /tmp/tmpoyow_01z.java\t2023-03-24 14:12:26.054456462 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1)!= '-') { return a.substring(2 * b.length() - 2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:27.938449408 +0100\n+++ /tmp/tmpjcyegdhc.java\t2023-03-24 14:12:27.938449408 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1)!= '-') { return a.substring(2 * b.length() - 2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (a.length() > 2) { return a.substring(1, b.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:29.738442670 +0100\n+++ /tmp/tmpri5zqkc9.java\t2023-03-24 14:12:29.738442670 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(1, b.length() - 1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '#') { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:31.502436067 +0100\n+++ /tmp/tmptrb5jx3v.java\t2023-03-24 14:12:31.502436067 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '#') { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == ',') { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:33.298429345 +0100\n+++ /tmp/tmppp2aopdh.java\t2023-03-24 14:12:33.298429345 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == ',') { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '\"') { return a.substring(1) + \"'\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:35.154422396 +0100\n+++ /tmp/tmp7zad_03c.java\t2023-03-24 14:12:35.154422396 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '\"') { return a.substring(1) + \"'\"; }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (a.startsWith(\"%\")) { return a.substring(1); } else { return a.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:36.902415853 +0100\n+++ /tmp/tmpltyfi67h.java\t2023-03-24 14:12:36.902415853 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.startsWith(\"%\")) { return a.substring(1); } else { return a.substring(2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (a.length() > 1) { return a.substring(0, b.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:41.018400446 +0100\n+++ /tmp/tmp5c_lx55t.java\t2023-03-24 14:12:41.022400430 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(0, b.length() - 1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:42.818393708 +0100\n+++ /tmp/tmpcl9ji2ly.java\t2023-03-24 14:12:42.818393708 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == ',') { return a.substring(2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '/') { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:44.686386714 +0100\n+++ /tmp/tmp7ljbn3i5.java\t2023-03-24 14:12:44.686386714 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '/') { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (a.length() > 1 && a.charAt(0) == '\\'') { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:46.462380065 +0100\n+++ /tmp/tmpb88k8dcq.java\t2023-03-24 14:12:46.466380051 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1 && a.charAt(0) == '\\'') { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (a.length() > 2 && a.charAt(1) == '/') { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:48.366372939 +0100\n+++ /tmp/tmpjw15m7qz.java\t2023-03-24 14:12:48.366372939 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(1) == '/') { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (a.length() > 2) { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:50.210366034 +0100\n+++ /tmp/tmp5kmdc86c.java\t2023-03-24 14:12:50.210366034 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (a.startsWith(\"-\")) { return a.substring(1); } else { return a.substring(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:52.134358832 +0100\n+++ /tmp/tmph_soqoo8.java\t2023-03-24 14:12:52.134358832 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.startsWith(\"-\")) { return a.substring(1); } else { return a.substring(2); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (a.length() > 2 && a.charAt(0) == '/') { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:56.402342855 +0100\n+++ /tmp/tmpo97tl9qu.java\t2023-03-24 14:12:56.402342855 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2 && a.charAt(0) == '/') { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (a.length() > b.length()) { return a.substring(0, b.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:12:58.230336012 +0100\n+++ /tmp/tmpn3699oif.java\t2023-03-24 14:12:58.234335996 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > b.length()) { return a.substring(0, b.length() - 1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (a.length() > 1) { return a.substring(1, b.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:00.062329153 +0100\n+++ /tmp/tmpvlbudegj.java\t2023-03-24 14:13:00.062329153 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(1, b.length() - 1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (a.length() > 1) { return a.substring(1) + b.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:01.814322593 +0100\n+++ /tmp/tmppuww6tcc.java\t2023-03-24 14:13:01.814322593 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(1) + b.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "return a.substring(1, b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:03.662315675 +0100\n+++ /tmp/tmpz8cw9i5f.java\t2023-03-24 14:13:03.662315675 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1, b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (a.length() > 2) { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:07.850299997 +0100\n+++ /tmp/tmp50hg0zca.java\t2023-03-24 14:13:07.850299997 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (a.length() > 1) { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:09.606293423 +0100\n+++ /tmp/tmpu2dfb54x.java\t2023-03-24 14:13:09.606293423 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 1) { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (!a.isEmpty()) { return a.substring(0, b.length() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:11.346286907 +0100\n+++ /tmp/tmp_kpff503.java\t2023-03-24 14:13:11.346286907 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (!a.isEmpty()) { return a.substring(0, b.length() - 1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (a.length() > 2) { return a.substring(2 * b.length()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:13.118280274 +0100\n+++ /tmp/tmpfu92fy7j.java\t2023-03-24 14:13:13.122280258 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (a.length() > 2) { return a.substring(2 * b.length()); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "return a.substring(0, b.length() - 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:14.954273400 +0100\n+++ /tmp/tmpgsyke2_2.java\t2023-03-24 14:13:14.962273370 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - 2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "return a.substring(1) + b.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:19.150257692 +0100\n+++ /tmp/tmpcg9n_z3a.java\t2023-03-24 14:13:19.150257692 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + b.substring(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "return a.substring(2 * b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:23.210242491 +0100\n+++ /tmp/tmp83a46pwa.java\t2023-03-24 14:13:23.210242491 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 * b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!a.startsWith(\"%\")) { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:27.270227291 +0100\n+++ /tmp/tmp1_5_kduh.java\t2023-03-24 14:13:27.274227275 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (!a.startsWith(\"%\")) { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "return a.substring(2 * b.length() - 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:29.074220537 +0100\n+++ /tmp/tmpe1_89tv4.java\t2023-03-24 14:13:29.074220537 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 * b.length() - 2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "return a.substring(2 + b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:33.318204647 +0100\n+++ /tmp/tmppva52571.java\t2023-03-24 14:13:33.318204647 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 + b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "return a.charAt(0) + b.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:37.402189355 +0100\n+++ /tmp/tmpbz9c0rnw.java\t2023-03-24 14:13:37.402189355 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + b.substring(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "return a.substring(1 + b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:42.030172028 +0100\n+++ /tmp/tmp_yz2g4ov.java\t2023-03-24 14:13:42.030172028 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1 + b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (!a.startsWith(\"0\")) { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:46.290156078 +0100\n+++ /tmp/tmpdmd0fdnl.java\t2023-03-24 14:13:46.290156078 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (!a.startsWith(\"0\")) { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "return a.substring(2), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:48.102149293 +0100\n+++ /tmp/tmpwitkei8s.java\t2023-03-24 14:13:48.102149293 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "return a.substring(2), b.length() - 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:49.894142583 +0100\n+++ /tmp/tmprnf31mdr.java\t2023-03-24 14:13:49.894142583 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2), b.length() - 2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (!a.isEmpty()) { return a.substring(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:51.574136293 +0100\n+++ /tmp/tmpvg0zqk2c.java\t2023-03-24 14:13:51.574136293 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+if (!a.isEmpty()) { return a.substring(1); }\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "return a.substring(2).replace(\"'\", \"\\\\'\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:53.450129270 +0100\n+++ /tmp/tmpqg76he5n.java\t2023-03-24 14:13:53.450129270 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2).replace(\"'\", \"\\\\'\");\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "return a.substring(1 + a.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:13:57.550113916 +0100\n+++ /tmp/tmpwumq3bwe.java\t2023-03-24 14:13:57.550113916 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1 + a.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "return a.substring(2), b.length() - 4);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:01.766098132 +0100\n+++ /tmp/tmpxz3tpus5.java\t2023-03-24 14:14:01.766098132 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2), b.length() - 4);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "return a.substring(0, a.length() - 2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:03.538091497 +0100\n+++ /tmp/tmp4161eia9.java\t2023-03-24 14:14:03.538091497 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, a.length() - 2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "return a.substring(2 * b.length());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:07.578076368 +0100\n+++ /tmp/tmp2t0xis0i.java\t2023-03-24 14:14:07.578076368 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2 * b.length());\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "return a.substring(0, a.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:11.782060626 +0100\n+++ /tmp/tmpy1mz2bnc.java\t2023-03-24 14:14:11.782060626 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, a.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "return a.substring(2, b.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:16.022044750 +0100\n+++ /tmp/tmpjif0qe7t.java\t2023-03-24 14:14:16.022044750 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2, b.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "return a.charAt(1) + b.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:20.174029203 +0100\n+++ /tmp/tmpk7eyi3sb.java\t2023-03-24 14:14:20.178029187 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(1) + b.substring(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "return a.substring(0, b.length() - 3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:24.378013462 +0100\n+++ /tmp/tmp6625pmi3.java\t2023-03-24 14:14:24.378013462 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - 3);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "return a.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:28.649997465 +0100\n+++ /tmp/tmprz2hzl7u.java\t2023-03-24 14:14:28.649997465 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "return a.substring(0, b.length() - 4);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:32.829981811 +0100\n+++ /tmp/tmpxuaoftmv.java\t2023-03-24 14:14:32.829981811 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(0, b.length() - 4);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "return a.substring(2), b;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:36.981966264 +0100\n+++ /tmp/tmpu5sz9bs9.java\t2023-03-24 14:14:36.981966264 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2), b;\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "return a.substring(1, a.length() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:38.709959794 +0100\n+++ /tmp/tmpoi_0dahg.java\t2023-03-24 14:14:38.709959794 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1, a.length() - 1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "return a.substring(1) + b.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:42.917944035 +0100\n+++ /tmp/tmp42zppa0w.java\t2023-03-24 14:14:42.917944035 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + b.substring(2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "return a.substring(1), b);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:47.161928143 +0100\n+++ /tmp/tmpk_2k36i6.java\t2023-03-24 14:14:47.161928143 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1), b);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "return a.substring(1) + a.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:48.933921506 +0100\n+++ /tmp/tmp3dc2ud0l.java\t2023-03-24 14:14:48.933921506 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + a.substring(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "return a.substring(1) + b.length();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:53.241905375 +0100\n+++ /tmp/tmpiug1nxt2.java\t2023-03-24 14:14:53.241905375 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(1) + b.length();\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "return a.charAt(0) + a.substring(1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:14:57.485889481 +0100\n+++ /tmp/tmp5lgoa27_.java\t2023-03-24 14:14:57.485889481 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.charAt(0) + a.substring(1);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "return a.substring(2));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:15:01.621873992 +0100\n+++ /tmp/tmp3m1neh2t.java\t2023-03-24 14:15:01.621873992 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2));\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "return a.substring(2).toLowerCase();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:15:03.397867341 +0100\n+++ /tmp/tmpu9ul68hu.java\t2023-03-24 14:15:03.401867325 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2).toLowerCase();\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "return a.substring(2).trim();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:15:07.645851431 +0100\n+++ /tmp/tmpc7ei4vjq.java\t2023-03-24 14:15:07.645851431 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2).trim();\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "return a.substring(3);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:15:11.685836303 +0100\n+++ /tmp/tmpi9v7dkin.java\t2023-03-24 14:15:11.685836303 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(3);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "return a.substring(4);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:15:15.977820229 +0100\n+++ /tmp/tmpdc022a8p.java\t2023-03-24 14:15:15.981820213 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(4);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "return a.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:15:20.057804948 +0100\n+++ /tmp/tmp7eqbquz5.java\t2023-03-24 14:15:20.057804948 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return a.substring(2);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/longest_common_subsequence/java_programs/LONGEST_COMMON_SUBSEQUENCE.java\t2023-03-24 14:15:24.353788860 +0100\n+++ /tmp/tmptrffcrwd.java\t2023-03-24 14:15:24.353788860 +0100\n@@ -13,11 +13,11 @@\n public class LONGEST_COMMON_SUBSEQUENCE {\n     public static String longest_common_subsequence(String a, String b) {\n         if (a.isEmpty() || b.isEmpty()) {\n             return \"\";\n         } else if (a.charAt(0) == b.charAt(0)) {\n-            return a.charAt(0) + longest_common_subsequence(a.substring(1), b);\n+return a.substring(2);\n         } else {\n             String fst = longest_common_subsequence(a, b.substring(1));\n             String snd = longest_common_subsequence(a.substring(1), b);\n             return fst.length() >= snd.length() ? fst : snd;\n         }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return a.charAt(0) + longest_common_subsequence(a.substring(1), b.substring(1));"
    },
    "bucketsort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:45.002160899 +0100\n+++ /tmp/tmpptp63qga.java\t2023-03-24 14:13:45.058160691 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:46.698154550 +0100\n+++ /tmp/tmp8hnrt03l.java\t2023-03-24 14:13:46.702154536 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { if (i >= arr.size()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:48.306148530 +0100\n+++ /tmp/tmp4q4932rw.java\t2023-03-24 14:13:48.306148530 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { if (i >= arr.size()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (arr.size() > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:49.870142674 +0100\n+++ /tmp/tmp4inoiwix.java\t2023-03-24 14:13:49.870142674 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version for (Integer count : arr) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:51.502136562 +0100\n+++ /tmp/tmpdd4_s_fv.java\t2023-03-24 14:13:51.502136562 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version for (Integer count : arr) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (arr.size() > 0) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:53.266129957 +0100\n+++ /tmp/tmp7700z5yu.java\t2023-03-24 14:13:53.270129943 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:54.934123713 +0100\n+++ /tmp/tmpml7ryyec.java\t2023-03-24 14:13:54.954123638 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (arr.size() > i) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:56.646117302 +0100\n+++ /tmp/tmp9l2yel47.java\t2023-03-24 14:13:56.650117286 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > i) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:13:58.306111086 +0100\n+++ /tmp/tmpl3ml5d77.java\t2023-03-24 14:13:58.306111086 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (offset > 0 || i < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:00.050104556 +0100\n+++ /tmp/tmpna0uqvec.java\t2023-03-24 14:14:00.054104542 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset > 0 || i < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version for (Integer count : arr) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:01.746098207 +0100\n+++ /tmp/tmp3ipdcyyh.java\t2023-03-24 14:14:01.746098207 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version for (Integer count : arr) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i >= arr.size()) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:03.486091691 +0100\n+++ /tmp/tmpllb5kcjf.java\t2023-03-24 14:14:03.486091691 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i >= arr.size()) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:05.258085056 +0100\n+++ /tmp/tmpl4ycxwlg.java\t2023-03-24 14:14:05.262085040 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) { break; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:06.950078721 +0100\n+++ /tmp/tmp_fhir4_v.java\t2023-03-24 14:14:06.954078705 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:08.634072415 +0100\n+++ /tmp/tmpdwv49235.java\t2023-03-24 14:14:08.634072415 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "for (Integer count : arr.values()) { if (i >= arr.size()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:10.270066288 +0100\n+++ /tmp/tmprih58uy6.java\t2023-03-24 14:14:10.270066288 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { if (i >= arr.size()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size()) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:11.842060403 +0100\n+++ /tmp/tmp4wglwmgl.java\t2023-03-24 14:14:11.842060403 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size()) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (offset >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:13.646053647 +0100\n+++ /tmp/tmp5kpjd2rb.java\t2023-03-24 14:14:13.646053647 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size() - 1) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:15.362047222 +0100\n+++ /tmp/tmpa_bi3r5e.java\t2023-03-24 14:14:15.362047222 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size() - 1) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (offset < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:17.026040992 +0100\n+++ /tmp/tmpjinn8dlv.java\t2023-03-24 14:14:17.026040992 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { for (Integer count : arr) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:18.622035015 +0100\n+++ /tmp/tmpaykp6dst.java\t2023-03-24 14:14:18.622035015 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { for (Integer count : arr) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:20.274028829 +0100\n+++ /tmp/tmpsmb0dmy6.java\t2023-03-24 14:14:20.274028829 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "for (int i = 0, arr.size() - 1; i < arr.size(); i++) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:21.962022507 +0100\n+++ /tmp/tmp2hbs4efd.java\t2023-03-24 14:14:21.962022507 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size() - 1; i < arr.size(); i++) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (offset < 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:23.586016428 +0100\n+++ /tmp/tmp_y1wfo8a.java\t2023-03-24 14:14:23.586016428 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset < 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "for (Integer count : arr.values()) { // arr is counts in fixed version for (Integer count : arr) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:25.274010106 +0100\n+++ /tmp/tmp2eh4xxzx.java\t2023-03-24 14:14:25.274010106 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { // arr is counts in fixed version for (Integer count : arr) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { for (Integer count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:27.042003485 +0100\n+++ /tmp/tmptw8j_4sm.java\t2023-03-24 14:14:27.042003485 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { for (Integer count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:28.773996999 +0100\n+++ /tmp/tmphnkr91th.java\t2023-03-24 14:14:28.773996999 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version break; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (arr.size() == i) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:30.429990798 +0100\n+++ /tmp/tmp2hp4samp.java\t2023-03-24 14:14:30.429990798 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() == i) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (i < arr.size() - 1) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:32.093984568 +0100\n+++ /tmp/tmpdcythyj7.java\t2023-03-24 14:14:32.129984434 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (i < arr.size() - 1) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (100.size() > i) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:33.781978247 +0100\n+++ /tmp/tmp71ryapet.java\t2023-03-24 14:14:33.781978247 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (100.size() > i) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (arr.size() > 0 || i < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:35.441972030 +0100\n+++ /tmp/tmpm3twsjhn.java\t2023-03-24 14:14:35.441972030 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0 || i < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:37.149965636 +0100\n+++ /tmp/tmpikj69jvu.java\t2023-03-24 14:14:37.149965636 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:38.785959509 +0100\n+++ /tmp/tmp_vahe0im.java\t2023-03-24 14:14:38.785959509 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "for (Integer count : arr.values()) { // arr is counts in fixed version if (i >= arr.size()) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:40.449953276 +0100\n+++ /tmp/tmp7dy993t5.java\t2023-03-24 14:14:40.449953276 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { // arr is counts in fixed version if (i >= arr.size()) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (offset > 0 || count > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:42.197946731 +0100\n+++ /tmp/tmppzl6i1qd.java\t2023-03-24 14:14:42.197946731 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset > 0 || count > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size() - 1) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:43.889940396 +0100\n+++ /tmp/tmpr3s56mxl.java\t2023-03-24 14:14:43.889940396 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size() - 1) { break; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "for (Integer count : arr.values()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:45.633933864 +0100\n+++ /tmp/tmpjqkshwt6.java\t2023-03-24 14:14:45.633933864 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:47.373927348 +0100\n+++ /tmp/tmpz3895qnq.java\t2023-03-24 14:14:47.373927348 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (fileName.size() > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:48.965921388 +0100\n+++ /tmp/tmpbk6sbtxg.java\t2023-03-24 14:14:48.965921388 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (fileName.size() > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { i++; // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:50.777914600 +0100\n+++ /tmp/tmp9pypbmjs.java\t2023-03-24 14:14:50.777914600 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { i++; // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:52.441908370 +0100\n+++ /tmp/tmpvskq7ked.java\t2023-03-24 14:14:52.441908370 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (arr.size() > 0 || i > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:54.149901973 +0100\n+++ /tmp/tmpukehlfcb.java\t2023-03-24 14:14:54.149901973 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0 || i > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (offset < arr.size() - 1) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:55.817895727 +0100\n+++ /tmp/tmpjtockjvh.java\t2023-03-24 14:14:55.817895727 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset < arr.size() - 1) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "for (Integer count : arr.values()) { // arr is counts in fixed version if (i < arr.size()) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:57.473889524 +0100\n+++ /tmp/tmptw8i_84i.java\t2023-03-24 14:14:57.477889511 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { // arr is counts in fixed version if (i < arr.size()) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "for (Integer count : arr.keySet()) { if (i >= arr.size()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:14:59.201883055 +0100\n+++ /tmp/tmptrh4ssty.java\t2023-03-24 14:14:59.201883055 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { if (i >= arr.size()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size()) { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:00.889876733 +0100\n+++ /tmp/tmp_kgvc24g.java\t2023-03-24 14:15:00.893876717 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size()) { break; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { if (i > 0) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:02.529870592 +0100\n+++ /tmp/tmpgdhxmics.java\t2023-03-24 14:15:02.533870576 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { if (i > 0) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { for (Integer count : arr.values()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:04.145864540 +0100\n+++ /tmp/tmp9u14fn72.java\t2023-03-24 14:15:04.145864540 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { for (Integer count : arr.values()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version if (i >= arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:05.765858473 +0100\n+++ /tmp/tmp_dd2u5a5.java\t2023-03-24 14:15:05.769858457 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version if (i >= arr.size()) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:07.589851642 +0100\n+++ /tmp/tmpylb9juwh.java\t2023-03-24 14:15:07.589851642 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (size > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:09.305845215 +0100\n+++ /tmp/tmptb7m_29y.java\t2023-03-24 14:15:09.309845201 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (size > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "for (int i = 0, arr.size() - 1; i < arr.size(); i++) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:11.033838743 +0100\n+++ /tmp/tmpmwnvezvv.java\t2023-03-24 14:15:11.033838743 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size() - 1; i < arr.size(); i++) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "for (Integer count : arr.values()) { // arr is counts in fixed version if (i > 0 || i >= arr.size()) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:12.637832737 +0100\n+++ /tmp/tmpjbz8pe2d.java\t2023-03-24 14:15:12.637832737 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { // arr is counts in fixed version if (i > 0 || i >= arr.size()) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:14.401826130 +0100\n+++ /tmp/tmpcgl126_2.java\t2023-03-24 14:15:14.401826130 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { for (Integer count : arr) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:16.089819808 +0100\n+++ /tmp/tmp_vi0rtnz.java\t2023-03-24 14:15:16.089819808 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { for (Integer count : arr) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "for (int i = 0, arr.size(); i++) { if (i >= arr.size()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:17.797813412 +0100\n+++ /tmp/tmp_npbvdbh.java\t2023-03-24 14:15:17.797813412 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i++) { if (i >= arr.size()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (100.size() > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:19.437807271 +0100\n+++ /tmp/tmpc5u0eubb.java\t2023-03-24 14:15:19.441807255 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (100.size() > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (arr.size()!= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:21.037801279 +0100\n+++ /tmp/tmpc1h0ri_n.java\t2023-03-24 14:15:21.037801279 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size()!= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { if (i > arr.size()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:22.721794971 +0100\n+++ /tmp/tmpgq4y2b9o.java\t2023-03-24 14:15:22.721794971 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { if (i > arr.size()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version for (Integer count : arr) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:24.425788590 +0100\n+++ /tmp/tmpv3qkz_yb.java\t2023-03-24 14:15:24.425788590 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version for (Integer count : arr) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "for (int i = 0, len = arr.size(); i < arr.size(); i++) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:26.153782118 +0100\n+++ /tmp/tmp5o8blho0.java\t2023-03-24 14:15:26.157782102 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, len = arr.size(); i < arr.size(); i++) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:27.901775571 +0100\n+++ /tmp/tmppsu8z5n8.java\t2023-03-24 14:15:27.901775571 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { if (i >= arr.size()) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:29.809768427 +0100\n+++ /tmp/tmps_13dfi5.java\t2023-03-24 14:15:29.809768427 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version if (i >= len) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:32.285759152 +0100\n+++ /tmp/tmp3kbmtn75.java\t2023-03-24 14:15:32.285759152 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { // arr is counts in fixed version if (i >= len) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "for (int i = 0, arr.size() - 1; i < arr.size(); i++) { for (Integer count : arr) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:34.413751184 +0100\n+++ /tmp/tmpf7y2m2ge.java\t2023-03-24 14:15:34.417751167 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size() - 1; i < arr.size(); i++) { for (Integer count : arr) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { sorted_arr.add(x); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:36.225744396 +0100\n+++ /tmp/tmp5sbi26sr.java\t2023-03-24 14:15:36.225744396 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { sorted_arr.add(x); }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (i == arr.size() - 1) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:37.853738299 +0100\n+++ /tmp/tmpq2otwrcd.java\t2023-03-24 14:15:37.853738299 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (i == arr.size() - 1) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version if (i >= arr.size()) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:39.397732516 +0100\n+++ /tmp/tmpz3_tl7m9.java\t2023-03-24 14:15:39.397732516 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { // arr is counts in fixed version if (i >= arr.size()) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (arr.size() > 0) { for (Integer count : arr) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:41.177725851 +0100\n+++ /tmp/tmpsnrfc7gm.java\t2023-03-24 14:15:41.177725851 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0) { for (Integer count : arr) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "for (Integer count : arr.values()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:42.789719812 +0100\n+++ /tmp/tmpk10aonba.java\t2023-03-24 14:15:42.793719799 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size() - 2) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:44.429713672 +0100\n+++ /tmp/tmpcj4a1qym.java\t2023-03-24 14:15:44.429713672 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version if (i < arr.size() - 2) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (arr.size() <= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:46.157707200 +0100\n+++ /tmp/tmpd4f2xl4b.java\t2023-03-24 14:15:46.157707200 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() <= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "for (Integer count : arr.values()) { if (i > 0 || i >= arr.size()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:47.793701070 +0100\n+++ /tmp/tmp_n7ka0_l.java\t2023-03-24 14:15:47.793701070 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { if (i > 0 || i >= arr.size()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "for (Integer count : arr.keySet()) { // arr is counts in fixed version for (int i = 0; i < arr.size(); i++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:49.389695094 +0100\n+++ /tmp/tmppgn66fuo.java\t2023-03-24 14:15:49.389695094 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.keySet()) { // arr is counts in fixed version for (int i = 0; i < arr.size(); i++) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:50.953689237 +0100\n+++ /tmp/tmp_upfj2jp.java\t2023-03-24 14:15:50.953689237 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (arr.size() > 2) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:52.557683229 +0100\n+++ /tmp/tmpmjgio9lv.java\t2023-03-24 14:15:52.557683229 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 2) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) { // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:54.185677131 +0100\n+++ /tmp/tmphwkmilk8.java\t2023-03-24 14:15:54.185677131 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) { // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (count < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:55.861670853 +0100\n+++ /tmp/tmp4zioojui.java\t2023-03-24 14:15:55.861670853 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (count < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:57.469664832 +0100\n+++ /tmp/tmpsmf5otmd.java\t2023-03-24 14:15:57.473664815 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { // arr is counts in fixed version\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (count > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:15:59.053658899 +0100\n+++ /tmp/tmpo6824w_t.java\t2023-03-24 14:15:59.053658899 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (count > arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (fileName.size() > i) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:00.637652966 +0100\n+++ /tmp/tmpr1jpwq8o.java\t2023-03-24 14:16:00.637652966 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (fileName.size() > i) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "for (Integer count : arr.values()) { // arr is counts in fixed version for (Integer count : arr) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:02.225647017 +0100\n+++ /tmp/tmp1idcmye9.java\t2023-03-24 14:16:02.225647017 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { // arr is counts in fixed version for (Integer count : arr) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:03.977640456 +0100\n+++ /tmp/tmpixz7cjuz.java\t2023-03-24 14:16:03.977640456 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (i < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:05.621634299 +0100\n+++ /tmp/tmpgxr7yltw.java\t2023-03-24 14:16:05.621634299 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (i < arr.size()) { for (Integer count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (arr.size() > 0 || i >= arr.size()) { for (Integer count : arr) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:07.365627766 +0100\n+++ /tmp/tmp0i67io6y.java\t2023-03-24 14:16:07.365627766 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0 || i >= arr.size()) { for (Integer count : arr) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (arr.size() > 0 || i >= arr.size()) { for (Integer count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:09.089621310 +0100\n+++ /tmp/tmperpo4zxn.java\t2023-03-24 14:16:09.089621310 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0 || i >= arr.size()) { for (Integer count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:10.645615480 +0100\n+++ /tmp/tmpef8s2fo0.java\t2023-03-24 14:16:10.645615480 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (arr.size() > 0) { for (int count : arr) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:12.277609369 +0100\n+++ /tmp/tmp5cl8lvhq.java\t2023-03-24 14:16:12.277609369 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (arr.size() > 0) { for (int count : arr) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "for (int i : arr.size() - 1; i >= 0; i--) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:13.893603315 +0100\n+++ /tmp/tmp_4w6_jb_.java\t2023-03-24 14:16:13.893603315 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i : arr.size() - 1; i >= 0; i--) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "for (Integer count : arr.values()) { // arr is counts in fixed version i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:15.525597202 +0100\n+++ /tmp/tmp0zbszk1o.java\t2023-03-24 14:16:15.529597188 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { // arr is counts in fixed version i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:17.209590894 +0100\n+++ /tmp/tmp21b2fe01.java\t2023-03-24 14:16:17.209590894 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset > 0 || i >= arr.size()) { for (Integer count : arr) { }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (offset > 0 || i >= arr.size()) { for (Integer count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:18.845584768 +0100\n+++ /tmp/tmp2tlbzgz4.java\t2023-03-24 14:16:18.845584768 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+if (offset > 0 || i >= arr.size()) { for (Integer count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "for (int i = 0, arr.size(); i < arr.size(); i++) { // The i++; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:20.377579029 +0100\n+++ /tmp/tmp71qeqghx.java\t2023-03-24 14:16:20.377579029 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i < arr.size(); i++) { // The i++; }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "for (int count : arr.keySet()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:21.933573202 +0100\n+++ /tmp/tmpbpvspru5.java\t2023-03-24 14:16:21.933573202 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int count : arr.keySet()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:23.733566460 +0100\n+++ /tmp/tmpdzyh15hv.java\t2023-03-24 14:16:23.733566460 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) { for (Integer count : arr) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "for (int i = 0, arr.size(); i++) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:25.369560331 +0100\n+++ /tmp/tmp7nu87n1c.java\t2023-03-24 14:16:25.369560331 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0, arr.size(); i++) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "for (Integer count : arr.values()) { i++; // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:26.997554234 +0100\n+++ /tmp/tmpzkxoqpt9.java\t2023-03-24 14:16:26.997554234 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (Integer count : arr.values()) { i++; // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "for (int i : arr.size(); i++) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:28.729547746 +0100\n+++ /tmp/tmp9ji0iui6.java\t2023-03-24 14:16:28.729547746 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i : arr.size(); i++) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "for (String count : arr.keySet()) { // arr is counts in fixed version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:30.313541813 +0100\n+++ /tmp/tmp2lvp5g98.java\t2023-03-24 14:16:30.313541813 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (String count : arr.keySet()) { // arr is counts in fixed version }\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "for (int i = 0; i < arr.size(); i++) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/bucketsort/java_programs/BUCKETSORT.java\t2023-03-24 14:16:32.089535161 +0100\n+++ /tmp/tmp0h_nfqo7.java\t2023-03-24 14:16:32.093535145 +0100\n@@ -17,11 +17,11 @@\n             counts.set(x,counts.get(x)+1);\n         }\n \n         ArrayList<Integer> sorted_arr = new ArrayList<Integer>(100);\n         int i = 0;\n-        for (Integer count : arr) { // arr is counts in fixed version\n+for (int i = 0; i < arr.size(); i++) {\n             sorted_arr.addAll(Collections.nCopies(count, i));\n             i++;\n         }\n \n         return sorted_arr;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (Integer count : counts) {"
    },
    "mergesort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:35.237748097 +0100\n+++ /tmp/tmp442jvni6.java\t2023-03-24 14:15:35.297747873 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:36.981741566 +0100\n+++ /tmp/tmp_xh_4skm.java\t2023-03-24 14:15:36.981741566 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), len)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:38.753734929 +0100\n+++ /tmp/tmptlk092hk.java\t2023-03-24 14:15:38.753734929 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), len)); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), arr.size())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:40.649727829 +0100\n+++ /tmp/tmpkz76rl7w.java\t2023-03-24 14:15:40.653727813 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), arr.size())); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be the same size\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:42.513720847 +0100\n+++ /tmp/tmpnakq2wsp.java\t2023-03-24 14:15:42.517720831 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be the same size\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:46.789704831 +0100\n+++ /tmp/tmpvxvpu5n2.java\t2023-03-24 14:15:46.789704831 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:48.569698164 +0100\n+++ /tmp/tmp2_hbt08k.java\t2023-03-24 14:15:48.573698151 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), len)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:50.401691304 +0100\n+++ /tmp/tmpasyodsuq.java\t2023-03-24 14:15:50.405691288 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), len)); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:52.405683797 +0100\n+++ /tmp/tmp0vswwnz7.java\t2023-03-24 14:15:52.405683797 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr.clear(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:54.225676980 +0100\n+++ /tmp/tmpvs0yt4dz.java\t2023-03-24 14:15:54.225676980 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr.clear(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:55.989670374 +0100\n+++ /tmp/tmp7gcr3e_s.java\t2023-03-24 14:15:55.989670374 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), arr.size())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:57.781663662 +0100\n+++ /tmp/tmp55g42qch.java\t2023-03-24 14:15:57.781663662 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), arr.size())); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:15:59.637656710 +0100\n+++ /tmp/tmp9eytuskm.java\t2023-03-24 14:15:59.641656697 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:01.433649985 +0100\n+++ /tmp/tmpfeim260d.java\t2023-03-24 14:16:01.433649985 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version: \" + arr.size()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:03.249643184 +0100\n+++ /tmp/tmpwzefxwoa.java\t2023-03-24 14:16:03.249643184 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version: \" + arr.size()); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:07.533627138 +0100\n+++ /tmp/tmpz88882ad.java\t2023-03-24 14:16:07.533627138 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // > 1, correct version return arr.subList(0, Math.min(arr.size(), len)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:09.245620725 +0100\n+++ /tmp/tmpt15jtelu.java\t2023-03-24 14:16:09.245620725 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // > 1, correct version return arr.subList(0, Math.min(arr.size(), len)); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:10.969614267 +0100\n+++ /tmp/tmpdf6lhpi4.java\t2023-03-24 14:16:10.969614267 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr is not in correct version: \" + arr.size()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:12.713607736 +0100\n+++ /tmp/tmpqsb25fkb.java\t2023-03-24 14:16:12.713607736 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr is not in correct version: \" + arr.size()); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr = new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:14.509601008 +0100\n+++ /tmp/tmpn_4sxu3y.java\t2023-03-24 14:16:14.509601008 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr = new ArrayList<>(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range is invalid. return new ArrayList<Integer>(arr.size()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:16.325594207 +0100\n+++ /tmp/tmpqasasdny.java\t2023-03-24 14:16:16.329594191 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range is invalid. return new ArrayList<Integer>(arr.size()); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was not in correct version return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:18.101587555 +0100\n+++ /tmp/tmpvtxyeis8.java\t2023-03-24 14:16:18.101587555 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was not in correct version return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be the same size\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:19.845581021 +0100\n+++ /tmp/tmpuvonsqjv.java\t2023-03-24 14:16:19.845581021 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be the same size\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version return arr.subList(0, Math.min(arr.size(), len)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:24.149564902 +0100\n+++ /tmp/tmpx5jx3_jl.java\t2023-03-24 14:16:24.149564902 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version return arr.subList(0, Math.min(arr.size(), len)); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:25.873558444 +0100\n+++ /tmp/tmp4ms5vpmo.java\t2023-03-24 14:16:25.873558444 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:27.617551910 +0100\n+++ /tmp/tmpezr8i8ha.java\t2023-03-24 14:16:27.617551910 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) return arr.subList(0, Math.min(arr.size(), arr.size())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:29.365545363 +0100\n+++ /tmp/tmpes9niaru.java\t2023-03-24 14:16:29.365545363 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) return arr.subList(0, Math.min(arr.size(), arr.size())); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:31.221538412 +0100\n+++ /tmp/tmpl3jbm4zu.java\t2023-03-24 14:16:31.221538412 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) return arr.subList(0, Math.min(arr.size(), len)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:33.001531743 +0100\n+++ /tmp/tmpdlaowd9o.java\t2023-03-24 14:16:33.001531743 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) return arr.subList(0, Math.min(arr.size(), len)); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else { // <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:34.933524509 +0100\n+++ /tmp/tmpu2ax03ro.java\t2023-03-24 14:16:34.933524509 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else { // <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr.clear(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:37.129516283 +0100\n+++ /tmp/tmpnjyoosf0.java\t2023-03-24 14:16:37.133516266 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr.clear(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:38.849509840 +0100\n+++ /tmp/tmp24jhhp9l.java\t2023-03-24 14:16:38.849509840 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:40.633503156 +0100\n+++ /tmp/tmpg7x31rxc.java\t2023-03-24 14:16:40.637503142 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be at least \" + arr.size()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:42.349496730 +0100\n+++ /tmp/tmp3w7_mgac.java\t2023-03-24 14:16:42.349496730 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be at least \" + arr.size()); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:46.677480517 +0100\n+++ /tmp/tmp5458zk59.java\t2023-03-24 14:16:46.677480517 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:48.453473865 +0100\n+++ /tmp/tmppbqtkhyr.java\t2023-03-24 14:16:48.457473849 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr is not in correct version: \" + arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:50.197467331 +0100\n+++ /tmp/tmpgo95rkdg.java\t2023-03-24 14:16:50.197467331 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr is not in correct version: \" + arr); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:51.901460949 +0100\n+++ /tmp/tmpxs_2gdgx.java\t2023-03-24 14:16:51.901460949 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:53.673454313 +0100\n+++ /tmp/tmp5ivwq5fx.java\t2023-03-24 14:16:53.673454313 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:55.397447855 +0100\n+++ /tmp/tmpmoip2b8e.java\t2023-03-24 14:16:55.397447855 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1) { arr.clear(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:57.185441157 +0100\n+++ /tmp/tmpt74zwxc0.java\t2023-03-24 14:16:57.185441157 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1) { arr.clear(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was not in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:16:59.009434324 +0100\n+++ /tmp/tmplsc0jszi.java\t2023-03-24 14:16:59.009434324 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was not in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:00.845427446 +0100\n+++ /tmp/tmpp9kr32ii.java\t2023-03-24 14:17:00.845427446 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() > 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), 1.0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:02.653420675 +0100\n+++ /tmp/tmpzlu8l7hx.java\t2023-03-24 14:17:02.653420675 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { return arr.subList(0, Math.min(arr.size(), 1.0)); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // < 1 in correct version return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:04.561413527 +0100\n+++ /tmp/tmpeqz3lb08.java\t2023-03-24 14:17:04.561413527 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // < 1 in correct version return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) return arr.iterator().next(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:06.369406754 +0100\n+++ /tmp/tmp__khgldl.java\t2023-03-24 14:17:06.369406754 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) return arr.iterator().next(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr = new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:08.061400417 +0100\n+++ /tmp/tmp24ryu1cj.java\t2023-03-24 14:17:08.061400417 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) { arr = new ArrayList<>(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:09.785393959 +0100\n+++ /tmp/tmp8f9ygqse.java\t2023-03-24 14:17:09.789393943 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:11.589387199 +0100\n+++ /tmp/tmpb6xr65vv.java\t2023-03-24 14:17:11.589387199 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1 in correct version return arr.subList(0, Math.min(arr.size(), len)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:13.373380518 +0100\n+++ /tmp/tmpd8trxtky.java\t2023-03-24 14:17:13.373380518 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1 in correct version return arr.subList(0, Math.min(arr.size(), len)); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was already in correct version return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:15.189373715 +0100\n+++ /tmp/tmpqncfbi7b.java\t2023-03-24 14:17:15.189373715 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was already in correct version return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) return arr.get(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:16.985366987 +0100\n+++ /tmp/tmpagdb54ro.java\t2023-03-24 14:17:16.985366987 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) return arr.get(1); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:18.789360230 +0100\n+++ /tmp/tmpae3ofnea.java\t2023-03-24 14:17:18.813360138 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be the same size\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version return arr.iterator().next(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:20.601353441 +0100\n+++ /tmp/tmpb85rwtua.java\t2023-03-24 14:17:20.601353441 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version return arr.iterator().next(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version: \" + arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:22.337346937 +0100\n+++ /tmp/tmpw_7lzavt.java\t2023-03-24 14:17:22.337346937 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version: \" + arr); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:26.577331054 +0100\n+++ /tmp/tmpdv5s0r8a.java\t2023-03-24 14:17:26.581331041 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 1); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:28.297324612 +0100\n+++ /tmp/tmpt4ez3rro.java\t2023-03-24 14:17:28.297324612 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() > 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() <= 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:30.097317869 +0100\n+++ /tmp/tmpixf6zbhi.java\t2023-03-24 14:17:30.097317869 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr is not in correct version } else if (arr.size() <= 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be at least \" + arr.size() + \" x\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:31.837311352 +0100\n+++ /tmp/tmp6w4js40i.java\t2023-03-24 14:17:31.837311352 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be at least \" + arr.size() + \" x\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be > 1)\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:36.177295091 +0100\n+++ /tmp/tmpi61jx_ad.java\t2023-03-24 14:17:36.177295091 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be > 1)\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr was not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:37.945288469 +0100\n+++ /tmp/tmpdeqcux7m.java\t2023-03-24 14:17:37.945288469 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr was not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range is not an int in correct version if (arr.size() <= 23) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:39.685281952 +0100\n+++ /tmp/tmpjkdek_5b.java\t2023-03-24 14:17:39.685281952 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range is not an int in correct version if (arr.size() <= 23) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) return arr.get(1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:41.421275448 +0100\n+++ /tmp/tmp0s82gw7r.java\t2023-03-24 14:17:41.425275432 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) return arr.get(1); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be > 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:43.265268540 +0100\n+++ /tmp/tmpns9zz826.java\t2023-03-24 14:17:43.265268540 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be > 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // NOSONAR (arr.size() <= 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:45.005262021 +0100\n+++ /tmp/tmpn81k2t6q.java\t2023-03-24 14:17:45.009262007 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // NOSONAR (arr.size() <= 1); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be positive\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:46.781255369 +0100\n+++ /tmp/tmpraty7oa5.java\t2023-03-24 14:17:46.781255369 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be positive\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be > 1 in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:48.513248879 +0100\n+++ /tmp/tmp4rvc4ryd.java\t2023-03-24 14:17:48.513248879 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be > 1 in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:50.285242240 +0100\n+++ /tmp/tmpelj_ufdx.java\t2023-03-24 14:17:50.285242240 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 23) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was: \" + arr.size()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:52.101235438 +0100\n+++ /tmp/tmpjp2rpcby.java\t2023-03-24 14:17:52.101235438 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was: \" + arr.size()); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) return arr.get(0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:53.837228935 +0100\n+++ /tmp/tmp5suj7mlf.java\t2023-03-24 14:17:53.837228935 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) return arr.get(0); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:55.573222431 +0100\n+++ /tmp/tmpjf711rlm.java\t2023-03-24 14:17:55.573222431 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be > 1\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:57.413215537 +0100\n+++ /tmp/tmpcns_y31r.java\t2023-03-24 14:17:57.413215537 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be > 1\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1); // <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:17:59.201208839 +0100\n+++ /tmp/tmpo16afkj9.java\t2023-03-24 14:17:59.201208839 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1); // <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 23) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:03.309193450 +0100\n+++ /tmp/tmpkyh7ddub.java\t2023-03-24 14:18:03.313193433 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was already in correct version if (arr.size() <= 23) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be at least 3\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:05.013187065 +0100\n+++ /tmp/tmpvhqovf6a.java\t2023-03-24 14:18:05.013187065 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr must be at least 3\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:09.221171301 +0100\n+++ /tmp/tmp_py6xtxt.java\t2023-03-24 14:18:09.225171287 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended if (arr.size() <= 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr was not in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:10.981164709 +0100\n+++ /tmp/tmptmbutpaq.java\t2023-03-24 14:18:10.981164709 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr was not in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1); // <= 1 in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:12.789157935 +0100\n+++ /tmp/tmpis7wdxal.java\t2023-03-24 14:18:12.789157935 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1); // <= 1 in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1); // <= 1 in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:17.153141584 +0100\n+++ /tmp/tmpjumph3gj.java\t2023-03-24 14:18:17.153141584 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1); // <= 1 in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:21.377125761 +0100\n+++ /tmp/tmpgb3vtluo.java\t2023-03-24 14:18:21.377125761 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr are not in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:23.169119048 +0100\n+++ /tmp/tmpemks2yli.java\t2023-03-24 14:18:23.169119048 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr are not in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 || arr.size() > 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:24.965112317 +0100\n+++ /tmp/tmp1eagw9yb.java\t2023-03-24 14:18:24.965112317 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 || arr.size() > 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:26.681105890 +0100\n+++ /tmp/tmpjcoh0mtp.java\t2023-03-24 14:18:26.681105890 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be positive\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:30.921090005 +0100\n+++ /tmp/tmpdd2hvuqz.java\t2023-03-24 14:18:30.921090005 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1 in correct version throw new IllegalArgumentException(\"arr must be positive\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr should be the same size\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:32.737083200 +0100\n+++ /tmp/tmp8v_kzie3.java\t2023-03-24 14:18:32.737083200 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr should be the same size\"); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1); // <= 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:37.069066970 +0100\n+++ /tmp/tmpa95j1ces.java\t2023-03-24 14:18:37.073066956 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1); // <= 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr are not in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:41.465050500 +0100\n+++ /tmp/tmpmb4ejrl7.java\t2023-03-24 14:18:41.465050500 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr are not in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr has not been in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:43.245043833 +0100\n+++ /tmp/tmpzhlgtf5s.java\t2023-03-24 14:18:43.249043816 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { throw new IllegalArgumentException(\"arr has not been in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:45.025037162 +0100\n+++ /tmp/tmpdbzl05uq.java\t2023-03-24 14:18:45.029037149 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1) { // The range was extended }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1 in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:46.765030643 +0100\n+++ /tmp/tmp2ufcstk_.java\t2023-03-24 14:18:46.765030643 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1 in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (arr.size() <= 1) { if (arr.size() <= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:48.505024126 +0100\n+++ /tmp/tmpqbjilkv8.java\t2023-03-24 14:18:48.505024126 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) { if (arr.size() <= 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() <= 1 in correct version }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:50.281017472 +0100\n+++ /tmp/tmpqa0a6byn.java\t2023-03-24 14:18:50.281017472 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() <= 1 in correct version }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() == 1 in correct version",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:52.045010861 +0100\n+++ /tmp/tmp6j7r4x3j.java\t2023-03-24 14:18:52.045010861 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() == 1 in correct version\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (arr.size() == 1) { if (arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:53.817004223 +0100\n+++ /tmp/tmp6sxojbs1.java\t2023-03-24 14:18:53.817004223 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { if (arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (arr.size() == 1 || arr.size() == 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:55.568997658 +0100\n+++ /tmp/tmp10pnpdkw.java\t2023-03-24 14:18:55.568997658 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() == 2) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (arr.size() <= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:18:59.936981294 +0100\n+++ /tmp/tmplhtjh0kx.java\t2023-03-24 14:18:59.936981294 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() <= 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (arr.size() == 1) { return Collections.emptyList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:19:04.148965511 +0100\n+++ /tmp/tmpvowns59l.java\t2023-03-24 14:19:04.148965511 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1) { return Collections.emptyList(); }\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (arr.size() == 1 || arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:19:05.928958844 +0100\n+++ /tmp/tmpdt1lfo4p.java\t2023-03-24 14:19:05.928958844 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1 || arr.size() == 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:19:10.312942418 +0100\n+++ /tmp/tmp06cejx6b.java\t2023-03-24 14:19:10.312942418 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() > 1) {\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (arr.size() == 1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/mergesort/java_programs/MERGESORT.java\t2023-03-24 14:19:14.672926083 +0100\n+++ /tmp/tmp1q3qcmbf.java\t2023-03-24 14:19:14.672926083 +0100\n@@ -33,11 +33,11 @@\n         result.addAll(left.subList(i,left.size()).isEmpty() ? right.subList(j, right.size()) : left.subList(i, left.size()));\n         return result;\n     }\n \n     public static ArrayList<Integer> mergesort(ArrayList<Integer> arr) {\n-        if (arr.size() == 0) { // <= 1 in correct version\n+if (arr.size() == 1;\n             return arr;\n         } else {\n             int middle = arr.size() / 2;\n             ArrayList<Integer> left = new ArrayList<Integer>(100);\n             left.addAll(arr.subList(0,middle));\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (arr.size() <= 1) { // <= 1 in correct version"
    },
    "depth_first_search": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (node.getNode() == node.getNode()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:36.865517272 +0100\n+++ /tmp/tmpvbtbco9c.java\t2023-03-24 14:16:36.865517272 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNode()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:38.653510573 +0100\n+++ /tmp/tmp4l7a_m1l.java\t2023-03-24 14:16:38.657510560 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (node.getNode() == node.getNode()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:40.441503875 +0100\n+++ /tmp/tmp3cg_yg9k.java\t2023-03-24 14:16:40.441503875 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNode()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (node.getNode() == node.getNodeValue()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:42.273497013 +0100\n+++ /tmp/tmplibx7h12.java\t2023-03-24 14:16:42.273497013 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNodeValue()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (node.getNode() == node) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:44.097490183 +0100\n+++ /tmp/tmp6_v3fcv_.java\t2023-03-24 14:16:44.097490183 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (node.getNode() == Node.ELEMENT_NODE) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:45.889483469 +0100\n+++ /tmp/tmp6qemjxgx.java\t2023-03-24 14:16:45.889483469 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == Node.ELEMENT_NODE) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "List<Node> successornodes = nodes.stream().collect(Collectors.toSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:47.581477132 +0100\n+++ /tmp/tmpdsnrpwc5.java\t2023-03-24 14:16:47.609477027 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().collect(Collectors.toSet());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (node.getNode() == node.getNodeValue()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:49.389470358 +0100\n+++ /tmp/tmpntndxn0h.java\t2023-03-24 14:16:49.389470358 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNodeValue()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (node.getRole() == node.getRole()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:51.129463841 +0100\n+++ /tmp/tmpb392exeq.java\t2023-03-24 14:16:51.129463841 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.getRole()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (!nodes.contains(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:52.801457577 +0100\n+++ /tmp/tmpzl6ana29.java\t2023-03-24 14:16:52.801457577 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!nodes.contains(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "List<Node> successornodes = nodes.stream().collect(Collectors.toList());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:54.521451135 +0100\n+++ /tmp/tmpcsc2zatf.java\t2023-03-24 14:16:54.521451135 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().collect(Collectors.toList());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (node.getNodeType() == Node.ELEMENT_NODE) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:56.257444634 +0100\n+++ /tmp/tmp3dq_u9cs.java\t2023-03-24 14:16:56.257444634 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNodeType() == Node.ELEMENT_NODE) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (node.getNode() == node.getNodeFlag()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:57.973438206 +0100\n+++ /tmp/tmpb_twl9mb.java\t2023-03-24 14:16:57.973438206 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNodeFlag()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (node.getName().equals(node.name)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:16:59.625432017 +0100\n+++ /tmp/tmpgbq9663e.java\t2023-03-24 14:16:59.625432017 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getName().equals(node.name)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (!node.equals(node)) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:01.325425648 +0100\n+++ /tmp/tmpw7was4ed.java\t2023-03-24 14:17:01.325425648 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.equals(node)) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "List<Node> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:05.185411190 +0100\n+++ /tmp/tmpatawtr0c.java\t2023-03-24 14:17:05.185411190 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (node.getName().equals(node.getName())) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:06.877404851 +0100\n+++ /tmp/tmprfiih0e0.java\t2023-03-24 14:17:06.881404837 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getName().equals(node.getName())) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "List<Node> successornodes = nodes.stream().collect(Collectors.toSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:08.549398587 +0100\n+++ /tmp/tmpbk4g2jub.java\t2023-03-24 14:17:08.549398587 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().collect(Collectors.toSet());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (node.getNode() == node) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:10.221392326 +0100\n+++ /tmp/tmp7mhl93yd.java\t2023-03-24 14:17:10.225392310 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "List<Node> node = nodes.stream().collect(Collectors.toSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:11.905386016 +0100\n+++ /tmp/tmpy_9c9dcf.java\t2023-03-24 14:17:11.905386016 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> node = nodes.stream().collect(Collectors.toSet());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (node.getRole() == node.getRole()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:13.585379722 +0100\n+++ /tmp/tmpwl0f0_yc.java\t2023-03-24 14:17:13.585379722 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getRole() == node.getRole()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (node.getNode() == node.getNodeExpression) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:15.297373311 +0100\n+++ /tmp/tmpvm58x3ez.java\t2023-03-24 14:17:15.297373311 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNodeExpression) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "List<Node> successornodes = nodes.stream().collect(Collectors.joining(\",\"));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:17.045366761 +0100\n+++ /tmp/tmpom1rkrn2.java\t2023-03-24 14:17:17.069366672 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().collect(Collectors.joining(\",\"));\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (node.getNode() == node.getNodeFlag()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:18.841360033 +0100\n+++ /tmp/tmp8_gifz96.java\t2023-03-24 14:17:18.841360033 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNodeFlag()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "List<Node> node = nodes.stream().collect(Collectors.toList());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:20.549353635 +0100\n+++ /tmp/tmpgz26tsq7.java\t2023-03-24 14:17:20.549353635 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> node = nodes.stream().collect(Collectors.toList());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "List<Node> successornodes = nodes.stream().collect(Collectors.toList());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:22.313347029 +0100\n+++ /tmp/tmphjt9f48_.java\t2023-03-24 14:17:22.313347029 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().collect(Collectors.toList());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "Assert.notNull(node, \"Node must not be null!\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:24.013340660 +0100\n+++ /tmp/tmpse73gij8.java\t2023-03-24 14:17:24.017340644 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Assert.notNull(node, \"Node must not be null!\");\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "Map<String, Node> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:25.857333752 +0100\n+++ /tmp/tmpwja0ualc.java\t2023-03-24 14:17:25.857333752 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Map<String, Node> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "List<Node> nodes = nodes.stream().collect(Collectors.toSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:27.613327173 +0100\n+++ /tmp/tmp4hgyis_9.java\t2023-03-24 14:17:27.613327173 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> nodes = nodes.stream().collect(Collectors.toSet());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (node.getNode() == Node.ELEMENT_NODE) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:29.321320777 +0100\n+++ /tmp/tmpq88bjryn.java\t2023-03-24 14:17:29.325320761 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == Node.ELEMENT_NODE) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "List<Node> successorOne = nodes.stream().collect(Collectors.toSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:31.109314077 +0100\n+++ /tmp/tmphi51ccfe.java\t2023-03-24 14:17:31.109314077 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successorOne = nodes.stream().collect(Collectors.toSet());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "Node successornodes = node.getFirstChildOfType(ASTArguments.class);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:32.909307336 +0100\n+++ /tmp/tmppcbn9ff4.java\t2023-03-24 14:17:32.909307336 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Node successornodes = node.getFirstChildOfType(ASTArguments.class);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (node.getNode() == node.getNode) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:34.853300053 +0100\n+++ /tmp/tmpd3vhh922.java\t2023-03-24 14:17:34.853300053 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode() == node.getNode) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "Node successornodes = node.getFirstChildOfType(ASTPrimaryExpression.class);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:36.545293714 +0100\n+++ /tmp/tmpzjl0o25d.java\t2023-03-24 14:17:36.549293698 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Node successornodes = node.getFirstChildOfType(ASTPrimaryExpression.class);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "List<Node> successorunion = nodes.stream().collect(Collectors.toSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:38.277287226 +0100\n+++ /tmp/tmp8284s0r2.java\t2023-03-24 14:17:38.277287226 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successorunion = nodes.stream().collect(Collectors.toSet());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (node.getMetadata().isGeneratedCode()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:39.949280963 +0100\n+++ /tmp/tmpvxlvzpmr.java\t2023-03-24 14:17:39.953280946 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getMetadata().isGeneratedCode()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "List<Node> successornodes = nodes.stream().filter(node::getSuccessor);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:41.665274535 +0100\n+++ /tmp/tmpkk1d2dp6.java\t2023-03-24 14:17:41.669274519 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().filter(node::getSuccessor);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "List<Node> nodes = nodes.stream().collect(Collectors.toList());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:43.377268120 +0100\n+++ /tmp/tmpghq78np_.java\t2023-03-24 14:17:43.377268120 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> nodes = nodes.stream().collect(Collectors.toList());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "Node successornodes = node.getFirstChildOfType(Node.class);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:45.121261587 +0100\n+++ /tmp/tmp8za2r0bz.java\t2023-03-24 14:17:45.121261587 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Node successornodes = node.getFirstChildOfType(Node.class);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "List<Node> successorOne = nodes.stream().collect(Collectors.toList());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:46.837255159 +0100\n+++ /tmp/tmppbueqtpe.java\t2023-03-24 14:17:46.837255159 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successorOne = nodes.stream().collect(Collectors.toList());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "List<Node> successorunion = nodes.stream().collect(Collectors.toList());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:48.537248790 +0100\n+++ /tmp/tmpil2bb0a1.java\t2023-03-24 14:17:48.537248790 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successorunion = nodes.stream().collect(Collectors.toList());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "node = node.getFirstChildOfType(ASTArguments.class);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:50.293242211 +0100\n+++ /tmp/tmppkehchw3.java\t2023-03-24 14:17:50.293242211 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node = node.getFirstChildOfType(ASTArguments.class);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "node = node.getFirstChildOfType(ASTPrimaryExpression.class);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:52.061235589 +0100\n+++ /tmp/tmp2oqsnu0u.java\t2023-03-24 14:17:52.065235573 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node = node.getFirstChildOfType(ASTPrimaryExpression.class);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "int successorIndex = node.getFirstDescendantOfType(ASTArguments.class);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:53.817229010 +0100\n+++ /tmp/tmpxk_ifmzq.java\t2023-03-24 14:17:53.817229010 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+int successorIndex = node.getFirstDescendantOfType(ASTArguments.class);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "Node successorNode = node.getFirstChild();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:55.565222460 +0100\n+++ /tmp/tmpgwbj0udw.java\t2023-03-24 14:17:55.565222460 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Node successorNode = node.getFirstChild();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "List<Node> successornodes = nodes.stream().filter(node::isCopy);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:57.389215628 +0100\n+++ /tmp/tmputx6ub6r.java\t2023-03-24 14:17:57.389215628 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().filter(node::isCopy);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "Map<String, Node> successornodes = node.getSuccessor();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:17:59.177208928 +0100\n+++ /tmp/tmpgmqix7hz.java\t2023-03-24 14:17:59.181208915 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Map<String, Node> successornodes = node.getSuccessor();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "Optional<Node> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:00.937202335 +0100\n+++ /tmp/tmpfkstuam2.java\t2023-03-24 14:18:00.937202335 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Optional<Node> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "List<Node> successor = nodes.stream().collect(Collectors.toSet());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:02.765195487 +0100\n+++ /tmp/tmpfuovncen.java\t2023-03-24 14:18:02.765195487 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successor = nodes.stream().collect(Collectors.toSet());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (!nodes.contains(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:04.457189148 +0100\n+++ /tmp/tmpc_4e5v6o.java\t2023-03-24 14:18:04.457189148 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!nodes.contains(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "List<Node> successornodes = nodes.stream().filter(node::isNode);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:06.213182569 +0100\n+++ /tmp/tmppt6pk9o4.java\t2023-03-24 14:18:06.217182556 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.stream().filter(node::isNode);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "Set<Node> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:07.909176217 +0100\n+++ /tmp/tmp06cl4i2l.java\t2023-03-24 14:18:07.909176217 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Set<Node> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "Set<Node> successornodes = node.getSuccessor();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:09.593169907 +0100\n+++ /tmp/tmp7xkucaq7.java\t2023-03-24 14:18:09.593169907 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Set<Node> successornodes = node.getSuccessor();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "List<Node> successornodes = node.getSuccessorAttributes();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:11.265163644 +0100\n+++ /tmp/tmpfabbb0bb.java\t2023-03-24 14:18:11.265163644 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = node.getSuccessorAttributes();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (node.getNode()) { return false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:12.937157381 +0100\n+++ /tmp/tmpe9s50gye.java\t2023-03-24 14:18:12.937157381 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode()) { return false; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "Set<Node> successornodes = node.getSuccessorNames();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:14.665150907 +0100\n+++ /tmp/tmp5baoikq2.java\t2023-03-24 14:18:14.665150907 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Set<Node> successornodes = node.getSuccessorNames();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "Assert.notNull(node, \"Node must not be null\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:16.521143953 +0100\n+++ /tmp/tmpe9971fxa.java\t2023-03-24 14:18:16.521143953 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Assert.notNull(node, \"Node must not be null\");\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "HashSet<Node> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:18.421136835 +0100\n+++ /tmp/tmph72_n4y_.java\t2023-03-24 14:18:18.421136835 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+HashSet<Node> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "Map<String, JsonNode> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:20.177130257 +0100\n+++ /tmp/tmpdq4e7icc.java\t2023-03-24 14:18:20.177130257 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Map<String, JsonNode> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "Set<Node> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:21.897123813 +0100\n+++ /tmp/tmp48uwpjvq.java\t2023-03-24 14:18:21.897123813 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Set<Node> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "List<Node> successornodes = node.getOrderByAttributes();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:23.537117667 +0100\n+++ /tmp/tmpjvg38xgl.java\t2023-03-24 14:18:23.541117654 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = node.getOrderByAttributes();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "List<Node> successornodes = node.getSuccessfullyList();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:25.249111253 +0100\n+++ /tmp/tmpot4a1bps.java\t2023-03-24 14:18:25.249111253 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = node.getSuccessfullyList();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "List<Node> successornodes = nodes.get(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:26.893105095 +0100\n+++ /tmp/tmp16kv2rrn.java\t2023-03-24 14:18:26.897105079 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = nodes.get(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!node.equals(node)) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:28.589098740 +0100\n+++ /tmp/tmp6s5h34hc.java\t2023-03-24 14:18:28.589098740 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (!node.equals(node)) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "node = node.getParentNode();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:32.713083291 +0100\n+++ /tmp/tmpaye5gmn3.java\t2023-03-24 14:18:32.713083291 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node = node.getParentNode();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (node.getNode()) { return true; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:34.457076756 +0100\n+++ /tmp/tmpkbexzskx.java\t2023-03-24 14:18:34.457076756 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+if (node.getNode()) { return true; }\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "Map<String, Node> successor = node.getSuccessor();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:36.241070072 +0100\n+++ /tmp/tmpy11icq8z.java\t2023-03-24 14:18:36.277069937 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Map<String, Node> successor = node.getSuccessor();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "List<Node> successornodes = node.getSuccessor();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:37.973063585 +0100\n+++ /tmp/tmpvpzhiu77.java\t2023-03-24 14:18:37.973063585 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = node.getSuccessor();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "Map<String, Node> entry = node.getSuccessor();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:39.777056826 +0100\n+++ /tmp/tmpcmwlzejp.java\t2023-03-24 14:18:39.781056809 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Map<String, Node> entry = node.getSuccessor();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "Collection<Node> successornodes = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:41.573050095 +0100\n+++ /tmp/tmpyz3n_omb.java\t2023-03-24 14:18:41.573050095 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Collection<Node> successornodes = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "List<Node> search(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:43.325043533 +0100\n+++ /tmp/tmp1tgl4lc1.java\t2023-03-24 14:18:43.329043517 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> search(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "List<Node> nodes = node.getNodes();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:45.045037087 +0100\n+++ /tmp/tmp2lpdrqux.java\t2023-03-24 14:18:45.045037087 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> nodes = node.getNodes();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "Set<Node> successorSet = node.getSuccessors();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:46.773030613 +0100\n+++ /tmp/tmpyiezyo9a.java\t2023-03-24 14:18:46.773030613 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Set<Node> successorSet = node.getSuccessors();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "Node successornodes = node.getFirstChild();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:48.509024110 +0100\n+++ /tmp/tmpose6vqeu.java\t2023-03-24 14:18:48.509024110 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Node successornodes = node.getFirstChild();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "final Node successorNode = node.getFirstChild();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:50.257017561 +0100\n+++ /tmp/tmpaae9wqj6.java\t2023-03-24 14:18:50.261017545 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+final Node successorNode = node.getFirstChild();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "node = node.getOrDefault(node, -1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:52.021010953 +0100\n+++ /tmp/tmpwz9lr9v3.java\t2023-03-24 14:18:52.021010953 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node = node.getOrDefault(node, -1);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "System.out.println(node.toString());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:53.753004463 +0100\n+++ /tmp/tmp_lxa26gf.java\t2023-03-24 14:18:53.753004463 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+System.out.println(node.toString());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "List<Node> successornodes = node.getRight();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:57.988988592 +0100\n+++ /tmp/tmpny_dv0a9.java\t2023-03-24 14:18:57.992988576 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successornodes = node.getRight();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "List<Node> successor = node.getSuccessor();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:18:59.800981803 +0100\n+++ /tmp/tmp79ak0nl6.java\t2023-03-24 14:18:59.800981803 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+List<Node> successor = node.getSuccessor();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "node = node.getFirstChild();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:01.588975103 +0100\n+++ /tmp/tmpbth8_46p.java\t2023-03-24 14:19:01.588975103 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node = node.getFirstChild();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "System.out.println(node.toString());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:03.320968614 +0100\n+++ /tmp/tmposd9ih7l.java\t2023-03-24 14:19:03.320968614 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+System.out.println(node.toString());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "search(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:07.524952864 +0100\n+++ /tmp/tmpixg6m530.java\t2023-03-24 14:19:07.528952848 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+search(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "boolean successornodes = node.getSuccessor();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:11.340938567 +0100\n+++ /tmp/tmp5ch6orxw.java\t2023-03-24 14:19:11.340938567 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+boolean successornodes = node.getSuccessor();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "Set<Node> search(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:13.084932031 +0100\n+++ /tmp/tmpe12hxmen.java\t2023-03-24 14:19:13.084932031 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Set<Node> search(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "int successorIndex = node.getIncrementIncrement();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:14.796925617 +0100\n+++ /tmp/tmpbh0urv6d.java\t2023-03-24 14:19:14.796925617 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+int successorIndex = node.getIncrementIncrement();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "SearchRequest successor = nodes.get(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:16.540919084 +0100\n+++ /tmp/tmpmtcsgcr0.java\t2023-03-24 14:19:16.540919084 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+SearchRequest successor = nodes.get(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "Node successor = node.getFirstChild();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:18.968909987 +0100\n+++ /tmp/tmpsfl79f01.java\t2023-03-24 14:19:18.972909970 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Node successor = node.getFirstChild();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "NodeList successornodes = node.getChildNodes();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:21.564900260 +0100\n+++ /tmp/tmptmsdoazz.java\t2023-03-24 14:19:21.564900260 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+NodeList successornodes = node.getChildNodes();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "node = node.getNodeValue();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:24.032891013 +0100\n+++ /tmp/tmpo3tfm0ll.java\t2023-03-24 14:19:24.032891013 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node = node.getNodeValue();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "int successorIndex = node.getNodeCount();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:26.364882276 +0100\n+++ /tmp/tmp48e43u36.java\t2023-03-24 14:19:26.364882276 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+int successorIndex = node.getNodeCount();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "Logger.getLogger(node.getClass());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:28.032876027 +0100\n+++ /tmp/tmppexuvdfb.java\t2023-03-24 14:19:28.032876027 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Logger.getLogger(node.getClass());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "String successor = nodes.get(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:29.748869597 +0100\n+++ /tmp/tmphpzofpto.java\t2023-03-24 14:19:29.748869597 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+String successor = nodes.get(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "HashSet<Node> search(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:31.500863032 +0100\n+++ /tmp/tmpi93iygna.java\t2023-03-24 14:19:31.500863032 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+HashSet<Node> search(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "int successorIndex = node.getCount();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:33.248856483 +0100\n+++ /tmp/tmppdzki511.java\t2023-03-24 14:19:33.252856466 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+int successorIndex = node.getCount();\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "context.registerNode(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:34.972850023 +0100\n+++ /tmp/tmps3sttyvk.java\t2023-03-24 14:19:34.976850007 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+context.registerNode(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "candidates.addAll(node.nodes);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:36.732843429 +0100\n+++ /tmp/tmprd31gnno.java\t2023-03-24 14:19:36.732843429 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+candidates.addAll(node.nodes);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "node.add(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:38.520836729 +0100\n+++ /tmp/tmpe2kjq_4c.java\t2023-03-24 14:19:38.520836729 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node.add(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "node.startNode(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:40.240830285 +0100\n+++ /tmp/tmpt6ij2hmr.java\t2023-03-24 14:19:40.244830269 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+node.startNode(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "LOG.error(node.toString());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:41.988823733 +0100\n+++ /tmp/tmpi0fzyiye.java\t2023-03-24 14:19:42.008823658 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+LOG.error(node.toString());\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "Nodes.add(node);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/depth_first_search/java_programs/DEPTH_FIRST_SEARCH.java\t2023-03-24 14:19:43.776817034 +0100\n+++ /tmp/tmptspw89pl.java\t2023-03-24 14:19:43.776817034 +0100\n@@ -17,10 +17,11 @@\n                 if (nodesvisited.contains(node)) {\n                     return false;\n                 } else if (node == goalnode) {\n                     return true;\n                 } else {\n+Nodes.add(node);\n                     for (Node successornodes : node.getSuccessors()) {\n                         if (search(successornodes)) { return true; }\n                     }\n                 }\n                 return false;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "nodesvisited.add(node);"
    },
    "shortest_paths": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:26.000883640 +0100\n+++ /tmp/tmp1979esai.java\t2023-03-24 14:19:26.072883368 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:27.876876609 +0100\n+++ /tmp/tmp_uirpusy.java\t2023-03-24 14:19:27.876876609 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (update_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:29.676869866 +0100\n+++ /tmp/tmp4j90rbk0.java\t2023-03-24 14:19:29.680869850 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.get(edge.toString()))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:31.524862943 +0100\n+++ /tmp/tmpmr9q8gob.java\t2023-03-24 14:19:31.524862943 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.get(edge.toString()))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (!update_weight.contains(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:33.276856378 +0100\n+++ /tmp/tmpe88y8ow9.java\t2023-03-24 14:19:33.276856378 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.contains(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (update_weight_by_node.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:35.028849813 +0100\n+++ /tmp/tmp30zjf2fk.java\t2023-03-24 14:19:35.028849813 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight_by_node.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.size() - 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:36.756843337 +0100\n+++ /tmp/tmpoj8zi7g4.java\t2023-03-24 14:19:36.756843337 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.size() - 1); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (!Objects.equals(edge, update_weight)) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:38.544836640 +0100\n+++ /tmp/tmpw7h0okzz.java\t2023-03-24 14:19:38.572836535 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!Objects.equals(edge, update_weight)) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (update_weight == Integer.MAX_VALUE) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:40.292830088 +0100\n+++ /tmp/tmpnvyhsptq.java\t2023-03-24 14:19:40.292830088 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight == Integer.MAX_VALUE) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.get(edge.toString()))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:42.100823316 +0100\n+++ /tmp/tmpklzs4ui8.java\t2023-03-24 14:19:42.100823316 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.get(edge.toString()))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:43.796816961 +0100\n+++ /tmp/tmpj8ht82v4.java\t2023-03-24 14:19:43.800816945 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()).edge.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:45.568810321 +0100\n+++ /tmp/tmpmrqxjkem.java\t2023-03-24 14:19:45.568810321 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()).edge.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:47.696802346 +0100\n+++ /tmp/tmp_z5uhkze.java\t2023-03-24 14:19:47.696802346 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:49.720794763 +0100\n+++ /tmp/tmpbmqvcb19.java\t2023-03-24 14:19:49.720794763 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (update_weight <= 0) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:51.452788274 +0100\n+++ /tmp/tmp7n_l1vzp.java\t2023-03-24 14:19:51.456788257 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:53.196781738 +0100\n+++ /tmp/tmpb9ggz9a0.java\t2023-03-24 14:19:53.196781738 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (WEIGHT_by_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:54.952775160 +0100\n+++ /tmp/tmpj_rgba5n.java\t2023-03-24 14:19:54.956775144 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (WEIGHT_by_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (update_weight!= null) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:56.656768776 +0100\n+++ /tmp/tmp7b4t9v0x.java\t2023-03-24 14:19:56.656768776 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight!= null) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (edge.get(edge).size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:19:58.408762211 +0100\n+++ /tmp/tmp6sffwvvm.java\t2023-03-24 14:19:58.408762211 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(edge).size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (update_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString()).edge.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:00.148755689 +0100\n+++ /tmp/tmpplb76iu9.java\t2023-03-24 14:20:00.148755689 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString()).edge.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (update_weight >= 0.0) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:01.964748884 +0100\n+++ /tmp/tmpp0geno64.java\t2023-03-24 14:20:01.964748884 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight >= 0.0) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (update_weight!= null) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:03.736742247 +0100\n+++ /tmp/tmpzaf4rsy6.java\t2023-03-24 14:20:03.740742230 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight!= null) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (!update_weight.equals(edge.get(edge))) { weight_by_node.put(edge, weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:05.668735006 +0100\n+++ /tmp/tmpb7uo4_1t.java\t2023-03-24 14:20:05.668735006 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.equals(edge.get(edge))) { weight_by_node.put(edge, weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.get(edge.toString()))) { return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:07.488728188 +0100\n+++ /tmp/tmpx9qx3ojm.java\t2023-03-24 14:20:07.488728188 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.get(edge.toString()))) { return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (!update_node.equals(edge.get(edge))) { weight_by_node.put(edge, weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:09.348721219 +0100\n+++ /tmp/tmphls8p8ly.java\t2023-03-24 14:20:09.352721202 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_node.equals(edge.get(edge))) { weight_by_node.put(edge, weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (update_weight <= weight_by_node.size()) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:11.112714608 +0100\n+++ /tmp/tmpvhuem35a.java\t2023-03-24 14:20:11.112714608 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= weight_by_node.size()) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "return weight_by_node.get(edge.toString());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:12.892707939 +0100\n+++ /tmp/tmpb4fcmeop.java\t2023-03-24 14:20:12.892707939 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+return weight_by_node.get(edge.toString());\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (update_weight <= Integer.MAX_VALUE) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:14.664701298 +0100\n+++ /tmp/tmp106gvm88.java\t2023-03-24 14:20:14.664701298 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= Integer.MAX_VALUE) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.get(edge))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:16.528694313 +0100\n+++ /tmp/tmp3meyssx9.java\t2023-03-24 14:20:16.532694300 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.get(edge))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "int update_weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:18.268687793 +0100\n+++ /tmp/tmpuek72dm_.java\t2023-03-24 14:20:18.272687780 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+int update_weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString())); return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:19.964681440 +0100\n+++ /tmp/tmp6tyzz4c0.java\t2023-03-24 14:20:19.988681350 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!update_weight_by_node.equals(edge.get(edge))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:21.700674933 +0100\n+++ /tmp/tmpvu2s6zrx.java\t2023-03-24 14:20:21.700674933 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.equals(edge.get(edge))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.get(edge))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:23.400668563 +0100\n+++ /tmp/tmp3fh0juio.java\t2023-03-24 14:20:23.404668550 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.get(edge))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.get(1))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:25.080662268 +0100\n+++ /tmp/tmpipsdy3e3.java\t2023-03-24 14:20:25.080662268 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.get(1))); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.size() - 1);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:26.768655943 +0100\n+++ /tmp/tmpk91n6zbm.java\t2023-03-24 14:20:26.768655943 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.size() - 1);\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "int update_weight = Math.min(update_weight, weight_by_node.size()); return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:28.432649710 +0100\n+++ /tmp/tmpoth185ox.java\t2023-03-24 14:20:28.432649710 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+int update_weight = Math.min(update_weight, weight_by_node.size()); return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (update_weight == null) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:30.200643083 +0100\n+++ /tmp/tmp8yh3t_cx.java\t2023-03-24 14:20:30.200643083 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight == null) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.get(edge.toString()))) { return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:31.908636683 +0100\n+++ /tmp/tmpbtrxftfw.java\t2023-03-24 14:20:31.912636670 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.get(edge.toString()))) { return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (edge.get(edge).size() == 1) return weight_by_node; else return weight_by_node.get(edge.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:33.616630282 +0100\n+++ /tmp/tmppfgvfkyp.java\t2023-03-24 14:20:33.640630194 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.get(edge).size() == 1) return weight_by_node; else return weight_by_node.get(edge.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.get(edge.size() - 1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:35.424623613 +0100\n+++ /tmp/tmpax23o7bf.java\t2023-03-24 14:20:35.424623613 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.get(edge.size() - 1)); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.get(edge))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:37.176617452 +0100\n+++ /tmp/tmprv3fw85s.java\t2023-03-24 14:20:37.180617438 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.get(edge))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (update_weight_by_node.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:38.932611279 +0100\n+++ /tmp/tmppfbo53p3.java\t2023-03-24 14:20:38.936611265 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight_by_node.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (!weight_by_node.containsKey(edge.get(edge.toString()))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:40.596605427 +0100\n+++ /tmp/tmpn4e96usg.java\t2023-03-24 14:20:40.600605413 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!weight_by_node.containsKey(edge.get(edge.toString()))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (!update_weight_by_node.equals(edge.get(edge))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:42.320599362 +0100\n+++ /tmp/tmpwx8n17qk.java\t2023-03-24 14:20:42.324599348 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.equals(edge.get(edge))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.toString())) { return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:44.072593199 +0100\n+++ /tmp/tmp2epdfhqd.java\t2023-03-24 14:20:44.076593185 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.toString())) { return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!weight_by_node.containsKey(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:45.820587049 +0100\n+++ /tmp/tmpzgs1ym9r.java\t2023-03-24 14:20:45.824587035 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!weight_by_node.containsKey(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (!update_weight.contains(edge.get(edge.toString()))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:47.580580854 +0100\n+++ /tmp/tmpnbvjcduc.java\t2023-03-24 14:20:47.584580840 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.contains(edge.get(edge.toString()))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (!update_weight.contains(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:49.344574646 +0100\n+++ /tmp/tmpx6bpo0r0.java\t2023-03-24 14:20:49.348574632 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.contains(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.toString())) { weight_by_node.set(edge.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:51.108568434 +0100\n+++ /tmp/tmp_w4suyww.java\t2023-03-24 14:20:51.112568420 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.toString())) { weight_by_node.set(edge.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:52.800562475 +0100\n+++ /tmp/tmp9ik2tlap.java\t2023-03-24 14:20:52.800562475 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString()));\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.get(edge))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:54.552556305 +0100\n+++ /tmp/tmphn0nclze.java\t2023-03-24 14:20:54.556556291 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.get(edge))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (update_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:56.380549866 +0100\n+++ /tmp/tmpc02kz19h.java\t2023-03-24 14:20:56.380549866 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) return weight_by_node; else return weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (!update_weight.equals(edge.get(edge))) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:58.120543734 +0100\n+++ /tmp/tmpwwro2kn7.java\t2023-03-24 14:20:58.120543734 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.equals(edge.get(edge))) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (!weight_by_node.containsKey(edge.toString())) { return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:20:59.856537617 +0100\n+++ /tmp/tmp9w8zr4rp.java\t2023-03-24 14:20:59.856537617 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!weight_by_node.containsKey(edge.toString())) { return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.get(edge))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:01.576531554 +0100\n+++ /tmp/tmpm52p_w3e.java\t2023-03-24 14:21:01.576531554 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.get(edge))); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.size())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:03.276525560 +0100\n+++ /tmp/tmpltneun0v.java\t2023-03-24 14:21:03.276525560 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.size())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (!update_weight.equals(edge.get(edge))) return weight_by_node; else return weight_by_node.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:05.032519367 +0100\n+++ /tmp/tmppyto9gan.java\t2023-03-24 14:21:05.036519353 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.equals(edge.get(edge))) return weight_by_node; else return weight_by_node.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.toString())) { return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:06.792513161 +0100\n+++ /tmp/tmp_kjimymn.java\t2023-03-24 14:21:06.792513161 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.toString())) { return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "int update_weight = Math.min(update_node.get(edge.size() - 1).toString(), weight_by_node.get(edge.toString()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:08.540506994 +0100\n+++ /tmp/tmp14eu36dy.java\t2023-03-24 14:21:08.544506980 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+int update_weight = Math.min(update_node.get(edge.size() - 1).toString(), weight_by_node.get(edge.toString()));\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (!weight_by_node.containsKey(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:10.232501025 +0100\n+++ /tmp/tmpfxg3b1av.java\t2023-03-24 14:21:10.232501025 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!weight_by_node.containsKey(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.get(2))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:11.912495097 +0100\n+++ /tmp/tmp687dgd7q.java\t2023-03-24 14:21:11.912495097 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node.get(edge.get(2))); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:13.664488912 +0100\n+++ /tmp/tmpd_dhr8u7.java\t2023-03-24 14:21:13.664488912 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!update_weight.equals(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:15.384482840 +0100\n+++ /tmp/tmprcekqnu4.java\t2023-03-24 14:21:15.384482840 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.equals(edge.get(edge.toString()))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!update_weight.contains(edge.get(edge.toString()))) { weight_by_node.put(edge.toString(), weight_by_node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:17.116476724 +0100\n+++ /tmp/tmpu9bpff3u.java\t2023-03-24 14:21:17.116476724 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.contains(edge.get(edge.toString()))) { weight_by_node.put(edge.toString(), weight_by_node); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "int update_weight = Math.min(weight_by_node.get(edge.toString()), weight_by_node.get(edge.size() - 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:18.860470567 +0100\n+++ /tmp/tmp6mm9ggo8.java\t2023-03-24 14:21:18.860470567 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+int update_weight = Math.min(weight_by_node.get(edge.toString()), weight_by_node.get(edge.size() - 1));\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()).size(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:20.536464647 +0100\n+++ /tmp/tmpffv3dkpy.java\t2023-03-24 14:21:20.536464647 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()).size(); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.get(edge))) { weight_by_node.put(edge, weight_by_node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:22.288458457 +0100\n+++ /tmp/tmpn3l9w650.java\t2023-03-24 14:21:22.292458443 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.get(edge))) { weight_by_node.put(edge, weight_by_node); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (!update_weight.equals(edge.get(edge))) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:24.032452294 +0100\n+++ /tmp/tmps7lc5810.java\t2023-03-24 14:21:24.032452294 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.equals(edge.get(edge))) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "int update_weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:25.788446089 +0100\n+++ /tmp/tmpk224k274.java\t2023-03-24 14:21:25.788446089 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+int update_weight_by_node.put(edge.toString(), weight_by_node.get(edge.toString()));\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:27.560439824 +0100\n+++ /tmp/tmp93kxjs6h.java\t2023-03-24 14:21:27.560439824 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.toString())) { weight_by_node.put(edge.toString(), weight_by_node); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (update_weight <= 0) return weight_by_node; else return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:29.384433376 +0100\n+++ /tmp/tmphgkv9upz.java\t2023-03-24 14:21:29.388433362 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) return weight_by_node; else return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()).build(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:31.180427025 +0100\n+++ /tmp/tmplkli2d3u.java\t2023-03-24 14:21:31.184427011 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.get(edge.toString()).build(); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!update_weight_by_node.equals(edge.get(edge.toString()))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:32.968420701 +0100\n+++ /tmp/tmp8rfbgbt_.java\t2023-03-24 14:21:32.968420701 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.equals(edge.get(edge.toString()))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:34.824414137 +0100\n+++ /tmp/tmpn6qpgp_r.java\t2023-03-24 14:21:34.824414137 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (update_weight == -1) return weight_by_node; else return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:36.600407853 +0100\n+++ /tmp/tmp1lj5phcy.java\t2023-03-24 14:21:36.604407839 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight == -1) return weight_by_node; else return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return edge.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:38.300401837 +0100\n+++ /tmp/tmpozcw7y31.java\t2023-03-24 14:21:38.304401823 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return edge.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (!weight_by_node.containsKey(edge.get(edge))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:39.960395963 +0100\n+++ /tmp/tmpc4py25l8.java\t2023-03-24 14:21:39.960395963 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!weight_by_node.containsKey(edge.get(edge))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (!update_weight.equals(edge.get(edge.toString()))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:41.632390046 +0100\n+++ /tmp/tmpwvx8limn.java\t2023-03-24 14:21:41.632390046 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.equals(edge.get(edge.toString()))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (!update_weight.equals(edge.get(edge))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:43.248384322 +0100\n+++ /tmp/tmp0t_ct7fg.java\t2023-03-24 14:21:43.248384322 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.equals(edge.get(edge))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:44.900378472 +0100\n+++ /tmp/tmpu4jdj8gd.java\t2023-03-24 14:21:44.904378458 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) { weight_by_node.put(edge.toString(), weight_by_node); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "return weight_by_node.get(edge.get(edge.toString()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:46.544372650 +0100\n+++ /tmp/tmp0jb72prh.java\t2023-03-24 14:21:46.544372650 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+return weight_by_node.get(edge.get(edge.toString()));\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (update_weight <= 0) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:48.184366840 +0100\n+++ /tmp/tmpn_s1o4bu.java\t2023-03-24 14:21:48.184366840 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:49.836360989 +0100\n+++ /tmp/tmp6ktmnf9s.java\t2023-03-24 14:21:49.836360989 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "return weight_by_node;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:51.460355233 +0100\n+++ /tmp/tmpgro5f_kg.java\t2023-03-24 14:21:51.460355233 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+return weight_by_node;\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (edge.size() == 1) { weight_by_node.set(edge.get(edge.toString())); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:53.108349394 +0100\n+++ /tmp/tmpq1ts5gn3.java\t2023-03-24 14:21:53.108349394 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) { weight_by_node.set(edge.get(edge.toString())); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (!update_weight_by_node.contains(edge.toString())) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:54.756343552 +0100\n+++ /tmp/tmplueyc14a.java\t2023-03-24 14:21:54.756343552 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.contains(edge.toString())) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (!weight_by_node.containsKey(edge.toString())) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:56.344337923 +0100\n+++ /tmp/tmp9q8vbroi.java\t2023-03-24 14:21:56.344337923 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!weight_by_node.containsKey(edge.toString())) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (!update_weight_by_node.containsKey(edge.toString())) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:57.940332263 +0100\n+++ /tmp/tmpptfd2hxo.java\t2023-03-24 14:21:57.944332249 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight_by_node.containsKey(edge.toString())) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return weight_by_node.clone(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:21:59.576326462 +0100\n+++ /tmp/tmpxjeycxua.java\t2023-03-24 14:21:59.576326462 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return weight_by_node.clone(); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (update_weight!= null) return weight_by_node; else return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:01.172320801 +0100\n+++ /tmp/tmp3k68400y.java\t2023-03-24 14:22:01.172320801 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight!= null) return weight_by_node; else return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "int update_weight = Math.min(update_weight, weight_by_node.size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:02.736315255 +0100\n+++ /tmp/tmpdqd1jp8y.java\t2023-03-24 14:22:02.736315255 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+int update_weight = Math.min(update_weight, weight_by_node.size());\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "return weight_by_node.get(edge.toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:04.288309747 +0100\n+++ /tmp/tmpo8pq9xip.java\t2023-03-24 14:22:04.288309747 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+return weight_by_node.get(edge.toString()); }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (!update_node.containsKey(edge.get(edge))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:05.872304126 +0100\n+++ /tmp/tmp2kbjumot.java\t2023-03-24 14:22:05.876304112 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_node.containsKey(edge.get(edge))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return edge; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:07.432298589 +0100\n+++ /tmp/tmpdicoxx2i.java\t2023-03-24 14:22:07.432298589 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return edge; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (!update_weight.contains(edge.get(edge))) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:09.012292982 +0100\n+++ /tmp/tmpltcf8vk3.java\t2023-03-24 14:22:09.016292968 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (!update_weight.contains(edge.get(edge))) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (update_weight <= 0) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:10.564287472 +0100\n+++ /tmp/tmpdnyszwjn.java\t2023-03-24 14:22:10.568287458 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (edge.size() == 1) return weight_by_node; else return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:12.188281705 +0100\n+++ /tmp/tmpoo6dqu6j.java\t2023-03-24 14:22:12.188281705 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (edge.size() == 1) return weight_by_node; else return null; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (update_weight <= 0) return weight_by_node; else return edge; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:13.800275981 +0100\n+++ /tmp/tmpp312nk8h.java\t2023-03-24 14:22:13.800275981 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight <= 0) return weight_by_node; else return edge; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (update_weight!= null) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:15.356270455 +0100\n+++ /tmp/tmp7sps61d9.java\t2023-03-24 14:22:15.356270455 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (update_weight!= null) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (WEIGHT_by_weight <= 0) return weight_by_node; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_paths/java_programs/SHORTEST_PATHS.java\t2023-03-24 14:22:16.896264985 +0100\n+++ /tmp/tmp78_lsljp.java\t2023-03-24 14:22:16.896264985 +0100\n@@ -25,39 +25,7 @@\n             for (List<String> edge : weight_by_edge.keySet()) {\n                 int update_weight = Math.min(\n                         weight_by_node.get(edge.get(0))\n                                 + weight_by_edge.get(edge),\n                         weight_by_node.get(edge.get(1)));\n-                weight_by_edge.put(edge, update_weight);\n-            }\n-        }\n-        return weight_by_node;\n-    }\n-\n-\n-    /**\n-     * Rewrite shortest_paths method\n-     * @param node\n-     * @param weight_by_edge\n-     * @return\n-     */\n-\n-    public static Map<String, Integer> shortest_paths(Node source, List<WeightedEdge> weight_by_edge) {\n-        Map<String,Integer> weight_by_node = new HashMap<String,Integer>();\n-        for (WeightedEdge edge : weight_by_edge) {\n-                weight_by_node.put(edge.node1.toString(), INF);\n-                weight_by_node.put(edge.node2.toString(), INF);\n-        }\n-\n-        weight_by_node.put(source.getValue(), 0);\n-        for (int i = 0; i < weight_by_node.size(); i++) {\n-            for (WeightedEdge edge : weight_by_edge) {\n-                int update_weight = Math.min(\n-                        weight_by_node.get(edge.node1.toString())\n-                                + edge.weight,\n-                        weight_by_node.get(edge.node2.toString()));\n-                edge.weight = update_weight;\n-            }\n-        }\n-        return weight_by_node;\n-    }\n+if (WEIGHT_by_weight <= 0) return weight_by_node; }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "weight_by_node.put(edge.get(1), update_weight); } } return weight_by_node; }"
    },
    "flatten": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (arr!= null) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:19:49.416795903 +0100\n+++ /tmp/tmpd5s7jzs3.java\t2023-03-24 14:19:49.484795647 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (arr!= null) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:19:51.132789473 +0100\n+++ /tmp/tmpx77t1zjb.java\t2023-03-24 14:19:51.132789473 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (arr.size() == 1) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:19:52.888782892 +0100\n+++ /tmp/tmp8913c_0_.java\t2023-03-24 14:19:52.892782879 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 1) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (arr!= null) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:19:54.584776537 +0100\n+++ /tmp/tmp5jjcio0h.java\t2023-03-24 14:19:54.584776537 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (arr.size() == 0) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:19:56.264770244 +0100\n+++ /tmp/tmp_m0r6ij0.java\t2023-03-24 14:19:56.264770244 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 0) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (arr.size() == 1) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:19:57.924764025 +0100\n+++ /tmp/tmp5ffz9k60.java\t2023-03-24 14:19:57.924764025 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 1) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (arr!= null) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:19:59.548757939 +0100\n+++ /tmp/tmp9x_6rwl_.java\t2023-03-24 14:19:59.552757924 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (arr.size() == 1) { result.addAll(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:01.208751720 +0100\n+++ /tmp/tmpbmrdd2wi.java\t2023-03-24 14:20:01.212751704 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 1) { result.addAll(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (arr.size() == 1) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:02.944745214 +0100\n+++ /tmp/tmpn6m_rpt0.java\t2023-03-24 14:20:02.944745214 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 1) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (arr.size() == 0) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:04.624738919 +0100\n+++ /tmp/tmpx0l2inft.java\t2023-03-24 14:20:04.628738902 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 0) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (this.contains(x)) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:06.256732804 +0100\n+++ /tmp/tmp7k4qhn_9.java\t2023-03-24 14:20:06.256732804 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (this.contains(x)) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (arr.contains(x)) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:07.948726463 +0100\n+++ /tmp/tmpsxzdr1re.java\t2023-03-24 14:20:07.948726463 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.contains(x)) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "else if (x == y) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:09.532720529 +0100\n+++ /tmp/tmpzwzcr55_.java\t2023-03-24 14:20:09.532720529 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == y) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (arr.getClass().getName().equals(x.toString())) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:11.152714457 +0100\n+++ /tmp/tmptmob5f0p.java\t2023-03-24 14:20:11.152714457 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.getClass().getName().equals(x.toString())) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (arr.size() == 0) { result.addAll(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:12.868708027 +0100\n+++ /tmp/tmpw3_vqexr.java\t2023-03-24 14:20:12.868708027 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 0) { result.addAll(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (arr!= null) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:14.616701479 +0100\n+++ /tmp/tmp7uobo32y.java\t2023-03-24 14:20:14.616701479 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (arr.size() == 0) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:16.252695347 +0100\n+++ /tmp/tmp_qct4sn_.java\t2023-03-24 14:20:16.252695347 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 0) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (arr.getClass().getName().equals(x.toString())) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:17.916689114 +0100\n+++ /tmp/tmpgzihjkqo.java\t2023-03-24 14:20:17.916689114 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.getClass().getName().equals(x.toString())) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (x == y) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:19.572682908 +0100\n+++ /tmp/tmp10wqyzrv.java\t2023-03-24 14:20:19.572682908 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x == y) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (elements.contains(x)) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:21.320676357 +0100\n+++ /tmp/tmpufpfmm1c.java\t2023-03-24 14:20:21.320676357 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (elements.contains(x)) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (arr.contains(x)) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:22.964670199 +0100\n+++ /tmp/tmpxuksgzqv.java\t2023-03-24 14:20:22.964670199 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.contains(x)) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "} else if (arr instanceof JSONArray) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:24.640663917 +0100\n+++ /tmp/tmpvrehoixx.java\t2023-03-24 14:20:24.640663917 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+} else if (arr instanceof JSONArray) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "else if (x == null) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:26.332657576 +0100\n+++ /tmp/tmpzlruhhm6.java\t2023-03-24 14:20:26.332657576 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == null) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (arr.size() == 1) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:28.016651268 +0100\n+++ /tmp/tmplsugx79g.java\t2023-03-24 14:20:28.016651268 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 1) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (elements.contains(x)) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:29.640645183 +0100\n+++ /tmp/tmp385ynwyh.java\t2023-03-24 14:20:29.640645183 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (elements.contains(x)) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (arr!= null) { result.addAll(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:31.440638438 +0100\n+++ /tmp/tmprt7n05bq.java\t2023-03-24 14:20:31.440638438 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.addAll(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (arr == null) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:33.172631948 +0100\n+++ /tmp/tmp8kg5f_0p.java\t2023-03-24 14:20:33.172631948 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr == null) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (buffer.length() == 0) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:34.828625741 +0100\n+++ /tmp/tmp2wqioqzi.java\t2023-03-24 14:20:34.828625741 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (buffer.length() == 0) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (arr == null) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:36.516619772 +0100\n+++ /tmp/tmp4cf1n2aj.java\t2023-03-24 14:20:36.516619772 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr == null) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "else if (x == y) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:38.152614021 +0100\n+++ /tmp/tmppu7fwpnx.java\t2023-03-24 14:20:38.156614007 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == y) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (df == null) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:39.788608270 +0100\n+++ /tmp/tmpgxo70xpy.java\t2023-03-24 14:20:39.788608270 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (df == null) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (this.contains(x)) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:41.472602346 +0100\n+++ /tmp/tmptbfw_31g.java\t2023-03-24 14:20:41.472602346 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (this.contains(x)) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "} else if (x == null) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:43.172596365 +0100\n+++ /tmp/tmpdelvqi6k.java\t2023-03-24 14:20:43.172596365 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+} else if (x == null) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (arr.contains(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:44.800590638 +0100\n+++ /tmp/tmpqq7p4ak2.java\t2023-03-24 14:20:44.804590624 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.contains(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (buffer.size() == 0) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:46.448584839 +0100\n+++ /tmp/tmpnrbnw34a.java\t2023-03-24 14:20:46.452584825 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (buffer.size() == 0) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "} else if (x == null) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:48.084579080 +0100\n+++ /tmp/tmpjl_7dzua.java\t2023-03-24 14:20:48.084579080 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+} else if (x == null) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (!(arr instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:49.720573321 +0100\n+++ /tmp/tmp1qx97alj.java\t2023-03-24 14:20:49.724573307 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(arr instanceof ArrayList<?>)) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (arr.getClass().getSimpleName().equals(x)) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:51.344567602 +0100\n+++ /tmp/tmpw59hxebs.java\t2023-03-24 14:20:51.344567602 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.getClass().getSimpleName().equals(x)) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (fr == null) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:53.008561744 +0100\n+++ /tmp/tmprll3ixgh.java\t2023-03-24 14:20:53.008561744 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (fr == null) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (arr!= null) { result.addAll(flatten(x)); } else { return flatten(arr); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:54.688555826 +0100\n+++ /tmp/tmp4gp7ovff.java\t2023-03-24 14:20:54.688555826 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.addAll(flatten(x)); } else { return flatten(arr); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "else if (x == null) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:56.356549950 +0100\n+++ /tmp/tmpfv5xn8d7.java\t2023-03-24 14:20:56.356549950 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == null) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "} else if (arr instanceof JSONArray) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:58.052543974 +0100\n+++ /tmp/tmpjip6q_rc.java\t2023-03-24 14:20:58.052543974 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+} else if (arr instanceof JSONArray) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "else if (x == y) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:20:59.788537857 +0100\n+++ /tmp/tmpmo8kmiap.java\t2023-03-24 14:20:59.788537857 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == y) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (fr == null) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:01.520531751 +0100\n+++ /tmp/tmp3wcgww5_.java\t2023-03-24 14:21:01.524531737 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (fr == null) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (x == y) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:03.272525574 +0100\n+++ /tmp/tmpnlvqv19f.java\t2023-03-24 14:21:03.272525574 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x == y) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!(arr instanceof ArrayList<?>)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:04.956519638 +0100\n+++ /tmp/tmplzj8wboy.java\t2023-03-24 14:21:04.956519638 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(arr instanceof ArrayList<?>)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (arr.size() == 0) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:06.656513640 +0100\n+++ /tmp/tmpxdo58xbw.java\t2023-03-24 14:21:06.656513640 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 0) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "} else if (arr instanceof JSONArray) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:08.364507615 +0100\n+++ /tmp/tmp766rixri.java\t2023-03-24 14:21:08.364507615 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+} else if (arr instanceof JSONArray) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "else if (x == null) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:09.996501858 +0100\n+++ /tmp/tmpcqb8ur7u.java\t2023-03-24 14:21:09.996501858 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == null) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (!super.contains(x)) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:11.688495889 +0100\n+++ /tmp/tmp04f_vcjw.java\t2023-03-24 14:21:11.688495889 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!super.contains(x)) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (this.contains(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:13.340490058 +0100\n+++ /tmp/tmpusmaeb1w.java\t2023-03-24 14:21:13.344490041 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (this.contains(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (arr.getClass().getSimpleName().equals(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:15.040484055 +0100\n+++ /tmp/tmplmsb28od.java\t2023-03-24 14:21:15.044484041 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.getClass().getSimpleName().equals(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (!(arr instanceof ArrayList<?>)) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:16.704478180 +0100\n+++ /tmp/tmp45ewjnb0.java\t2023-03-24 14:21:16.704478180 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(arr instanceof ArrayList<?>)) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (true) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:18.316472488 +0100\n+++ /tmp/tmp0yioxcei.java\t2023-03-24 14:21:18.320472475 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (true) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (x == y) { result.add(flatten(x)); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:20.016466482 +0100\n+++ /tmp/tmpy8rpynl9.java\t2023-03-24 14:21:20.020466468 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (x == y) { result.add(flatten(x)); } else { return null; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (!super.contains(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:21.652460704 +0100\n+++ /tmp/tmpn45dvl33.java\t2023-03-24 14:21:21.656460690 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!super.contains(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (!(arr instanceof ArrayList<?>)) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:23.296454894 +0100\n+++ /tmp/tmp_89u1qb0.java\t2023-03-24 14:21:23.300454880 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!(arr instanceof ArrayList<?>)) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (recording) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:24.944449071 +0100\n+++ /tmp/tmps_3ankf1.java\t2023-03-24 14:21:24.944449071 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (recording) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (val == null) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:26.652443035 +0100\n+++ /tmp/tmpahg68yb3.java\t2023-03-24 14:21:26.652443035 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (val == null) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (arr instanceof ArrayList) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:28.304437194 +0100\n+++ /tmp/tmp300uof1f.java\t2023-03-24 14:21:28.304437194 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr instanceof ArrayList) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (!Modifier.isStatic(x.getModifiers())) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:30.020431127 +0100\n+++ /tmp/tmpbe4x8mgr.java\t2023-03-24 14:21:30.020431127 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!Modifier.isStatic(x.getModifiers())) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (converted) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:31.620425470 +0100\n+++ /tmp/tmpkc2z_pi0.java\t2023-03-24 14:21:31.620425470 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (converted) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (flatten) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:33.280419599 +0100\n+++ /tmp/tmpy2mdhc1j.java\t2023-03-24 14:21:33.280419599 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (COMMAJOR_TYPE.equals(x)) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:34.892413896 +0100\n+++ /tmp/tmpnttxc7oh.java\t2023-03-24 14:21:34.892413896 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (COMMAJOR_TYPE.equals(x)) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (arr.size() == 1) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:36.576407937 +0100\n+++ /tmp/tmp_zq8upp1.java\t2023-03-24 14:21:36.580407923 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 1) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (separator == null) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:38.204402177 +0100\n+++ /tmp/tmpmvkjy3aw.java\t2023-03-24 14:21:38.208402163 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (separator == null) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (!elements.contains(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:39.852396344 +0100\n+++ /tmp/tmpc4auyd48.java\t2023-03-24 14:21:39.856396330 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!elements.contains(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (COMMAJOR_TYPE.equals(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:41.472390610 +0100\n+++ /tmp/tmpc_9tm7mb.java\t2023-03-24 14:21:41.472390610 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (COMMAJOR_TYPE.equals(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (city!= null) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:43.056385004 +0100\n+++ /tmp/tmpw2aergm3.java\t2023-03-24 14:21:43.056385004 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (city!= null) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (arr.size() == 1) { result.addAll(flatten(x)); } else { return result;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:44.688379223 +0100\n+++ /tmp/tmpfeoso_3y.java\t2023-03-24 14:21:44.688379223 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 1) { result.addAll(flatten(x)); } else { return result;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (Block.class.equals(x)) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:46.324373429 +0100\n+++ /tmp/tmpyjnuopa1.java\t2023-03-24 14:21:46.324373429 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (Block.class.equals(x)) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "else if (x == y) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:47.928367747 +0100\n+++ /tmp/tmpz2z2qc4h.java\t2023-03-24 14:21:47.928367747 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == y) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!arr.contains(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:49.540362037 +0100\n+++ /tmp/tmpoda8odap.java\t2023-03-24 14:21:49.540362037 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!arr.contains(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if ( blockSize) { result.add(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:51.224356070 +0100\n+++ /tmp/tmpd43_nvzb.java\t2023-03-24 14:21:51.224356070 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if ( blockSize) { result.add(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (Block.class.isAssignableFrom(x.getClass())) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:52.804350470 +0100\n+++ /tmp/tmpez9n1tw5.java\t2023-03-24 14:21:52.804350470 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (Block.class.isAssignableFrom(x.getClass())) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (arr.size() == 0) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:54.416344756 +0100\n+++ /tmp/tmp9m2uoc2g.java\t2023-03-24 14:21:54.416344756 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 0) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (arr.size() == 0) { result.addAll(flatten(x)); } else { return result;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:56.076338873 +0100\n+++ /tmp/tmp_5x7_aac.java\t2023-03-24 14:21:56.076338873 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == 0) { result.addAll(flatten(x)); } else { return result;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (arr!= null) { result.addAll(flatten(x)); return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:57.668333228 +0100\n+++ /tmp/tmp19kvkosc.java\t2023-03-24 14:21:57.668333228 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.addAll(flatten(x)); return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "else if (x == null) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:21:59.284327496 +0100\n+++ /tmp/tmpm30hqchu.java\t2023-03-24 14:21:59.284327496 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == null) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "else if (x == null) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:00.860321907 +0100\n+++ /tmp/tmpdjzuscn6.java\t2023-03-24 14:22:00.860321907 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == null) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (arr!= null) { result.addAll(flatten(x)); return result; } else { return null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:02.408316416 +0100\n+++ /tmp/tmpujkgywso.java\t2023-03-24 14:22:02.412316402 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.addAll(flatten(x)); return result; } else { return null;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (arr.contains(x)) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:03.960310910 +0100\n+++ /tmp/tmps7nicunu.java\t2023-03-24 14:22:03.960310910 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.contains(x)) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (Block.class.equals(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:05.540305304 +0100\n+++ /tmp/tmpjpi2puhj.java\t2023-03-24 14:22:05.540305304 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (Block.class.equals(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (!elements.contains(entry.getValue())) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:07.068299882 +0100\n+++ /tmp/tmpwz7fw0kv.java\t2023-03-24 14:22:07.068299882 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (!elements.contains(entry.getValue())) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (elements.contains(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:08.668294205 +0100\n+++ /tmp/tmprbemy7h9.java\t2023-03-24 14:22:08.672294188 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (elements.contains(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "throw x.syntaxError(\"Misshaped tag\");",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:10.268288523 +0100\n+++ /tmp/tmpw8pmwfpr.java\t2023-03-24 14:22:10.268288523 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+throw x.syntaxError(\"Misshaped tag\");\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (opts.containsKey(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:11.812283041 +0100\n+++ /tmp/tmpm03fpa4h.java\t2023-03-24 14:22:11.812283041 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (opts.containsKey(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (arr.indexOf(x) == -1) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:13.448277234 +0100\n+++ /tmp/tmpu6cw5zjq.java\t2023-03-24 14:22:13.448277234 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.indexOf(x) == -1) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (arr.getClass().isArray()) { result.add(flatten(x)); } else { return result;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:15.060271507 +0100\n+++ /tmp/tmpz1mc00do.java\t2023-03-24 14:22:15.060271507 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.getClass().isArray()) { result.add(flatten(x)); } else { return result;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (true) { result.addAll(flatten(x)); } else { return result; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:16.648265867 +0100\n+++ /tmp/tmpqdxc2mf2.java\t2023-03-24 14:22:16.648265867 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (true) { result.addAll(flatten(x)); } else { return result; }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (arr.size() == x) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:18.232260239 +0100\n+++ /tmp/tmp4d_kiltc.java\t2023-03-24 14:22:18.232260239 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.size() == x) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "else if (x == y) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:19.992253986 +0100\n+++ /tmp/tmp0_x4l5qy.java\t2023-03-24 14:22:19.992253986 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+else if (x == y) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (arr.getClass().isArray()) { result.add(flatten(x)); } else { return null;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:21.832247446 +0100\n+++ /tmp/tmpwwjdkrj5.java\t2023-03-24 14:22:21.832247446 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr.getClass().isArray()) { result.add(flatten(x)); } else { return null;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (this.contains(x)) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:23.332242117 +0100\n+++ /tmp/tmpiybyxj4w.java\t2023-03-24 14:22:23.336242100 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (this.contains(x)) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (arr!= null) { result.remove(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:24.852236712 +0100\n+++ /tmp/tmpdxqg0yin.java\t2023-03-24 14:22:24.852236712 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (arr!= null) { result.remove(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if ( Thread.currentThread().isInterrupted()) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:26.396231222 +0100\n+++ /tmp/tmpmwq18uc0.java\t2023-03-24 14:22:26.396231222 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if ( Thread.currentThread().isInterrupted()) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (elements.contains(x)) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:27.964225647 +0100\n+++ /tmp/tmpv0nkhovq.java\t2023-03-24 14:22:27.964225647 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (elements.contains(x)) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (city!= null) { result.addAll(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:29.556219986 +0100\n+++ /tmp/tmp2_vgrc5i.java\t2023-03-24 14:22:29.560219972 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (city!= null) { result.addAll(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (flatten(x)) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:31.052214664 +0100\n+++ /tmp/tmpgm1omx3l.java\t2023-03-24 14:22:31.052214664 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (flatten(x)) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (city!= null) { result.add(flatten(x)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/flatten/java_programs/FLATTEN.java\t2023-03-24 14:22:32.644209001 +0100\n+++ /tmp/tmpec27imjy.java\t2023-03-24 14:22:32.644209001 +0100\n@@ -16,14 +16,9 @@\n             ArrayList result = new ArrayList(50);\n             for (Object x : narr) {\n                 if (x instanceof ArrayList) {\n                     result.addAll((ArrayList) flatten(x));\n                 } else {\n-                    result.add(flatten(x));\n-                }\n-            }\n-            return result;\n-        } else {\n-            return flatten(arr);\n+if (city!= null) { result.add(flatten(x)); }\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "result.add((x)); } } return result; } else { return arr;"
    },
    "get_factors": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:21.236249567 +0100\n+++ /tmp/tmpz26ez01l.java\t2023-03-24 14:22:21.292249366 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "return new ArrayList<Integer>();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:23.068243054 +0100\n+++ /tmp/tmpm7o1rwuy.java\t2023-03-24 14:22:23.068243054 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>();\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:26.888229472 +0100\n+++ /tmp/tmp6oi9vwk2.java\t2023-03-24 14:22:26.888229472 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:28.532223627 +0100\n+++ /tmp/tmpqm9myuju.java\t2023-03-24 14:22:28.532223627 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:30.164217823 +0100\n+++ /tmp/tmpc695088h.java\t2023-03-24 14:22:30.164217823 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (prependDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:31.892211677 +0100\n+++ /tmp/tmpribtywfr.java\t2023-03-24 14:22:31.892211677 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(prepend); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:33.552205771 +0100\n+++ /tmp/tmphi0by8nh.java\t2023-03-24 14:22:33.552205771 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(prepend); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (prependQuery) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:35.380199266 +0100\n+++ /tmp/tmpenqnf8u6.java\t2023-03-24 14:22:35.380199266 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependQuery) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:37.560191508 +0100\n+++ /tmp/tmp7coha9ia.java\t2023-03-24 14:22:37.560191508 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(prepend); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:39.272185415 +0100\n+++ /tmp/tmp9tesrek9.java\t2023-03-24 14:22:39.272185415 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(prepend); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (prependDocType) { return new ArrayList<Integer>(); } else { add(prependDocType); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:41.096178920 +0100\n+++ /tmp/tmplz_x5zm9.java\t2023-03-24 14:22:41.096178920 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) { return new ArrayList<Integer>(); } else { add(prependDocType); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return add(prepend); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:42.792172883 +0100\n+++ /tmp/tmpl3n65gxm.java\t2023-03-24 14:22:42.792172883 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return add(prepend); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(prepend.size()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:44.568166560 +0100\n+++ /tmp/tmpb7enmtoa.java\t2023-03-24 14:22:44.568166560 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(prepend.size()); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (prependNew) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:46.360160174 +0100\n+++ /tmp/tmpbcj_muc4.java\t2023-03-24 14:22:46.364160160 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependNew) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (prependDoc!= null) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:47.988154378 +0100\n+++ /tmp/tmp3yzfwjo_.java\t2023-03-24 14:22:47.988154378 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc!= null) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (prependDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:49.704148262 +0100\n+++ /tmp/tmpfepsh9_4.java\t2023-03-24 14:22:49.704148262 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:51.452142034 +0100\n+++ /tmp/tmpae7qq93k.java\t2023-03-24 14:22:51.452142034 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(prepend); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:53.212135762 +0100\n+++ /tmp/tmpjanbe_ed.java\t2023-03-24 14:22:53.212135762 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(prepend); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (prependDoc.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:54.848129932 +0100\n+++ /tmp/tmpq1ed_40_.java\t2023-03-24 14:22:54.848129932 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:56.576123769 +0100\n+++ /tmp/tmp_8cwoprb.java\t2023-03-24 14:22:56.576123769 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (prependDocType) { return new ArrayList<Integer>(); } else { new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:58.188118022 +0100\n+++ /tmp/tmpur7zkola.java\t2023-03-24 14:22:58.188118022 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) { return new ArrayList<Integer>(); } else { new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (prepend.size() == 0) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:22:59.872112018 +0100\n+++ /tmp/tmprz7ld8sl.java\t2023-03-24 14:22:59.872112018 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend.size() == 0) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:23:01.692105527 +0100\n+++ /tmp/tmpcu1k3duy.java\t2023-03-24 14:23:01.692105527 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(2); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(prependDoc); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:23:12.812065845 +0100\n+++ /tmp/tmp4emddnh5.java\t2023-03-24 14:23:12.820065817 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(prependDoc); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (!prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:23:23.520027600 +0100\n+++ /tmp/tmpzcb758cp.java\t2023-03-24 14:23:23.528027572 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (prependDocDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:23:33.795990865 +0100\n+++ /tmp/tmpj8oeh2q6.java\t2023-03-24 14:23:33.795990865 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (prepend && prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:23:43.551955962 +0100\n+++ /tmp/tmpsurstq1l.java\t2023-03-24 14:23:43.551955962 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend && prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (prependDocPath) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:23:53.799919271 +0100\n+++ /tmp/tmp1s4mmh9y.java\t2023-03-24 14:23:53.799919271 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocPath) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:24:03.131885831 +0100\n+++ /tmp/tmps8xaqwqu.java\t2023-03-24 14:24:03.131885831 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(2); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(prepend()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:24:12.815851106 +0100\n+++ /tmp/tmp0608d_hu.java\t2023-03-24 14:24:12.815851106 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(prepend()); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (!prependDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:24:21.719819156 +0100\n+++ /tmp/tmpddkhp_v3.java\t2023-03-24 14:24:21.719819156 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (!prependDoc.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:24:30.123788981 +0100\n+++ /tmp/tmpulefeczt.java\t2023-03-24 14:24:30.123788981 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDoc.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (prepend) return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:24:38.883757509 +0100\n+++ /tmp/tmppw7ip04t.java\t2023-03-24 14:24:38.883757509 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (keys.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:24:46.767729169 +0100\n+++ /tmp/tmp4de1eiok.java\t2023-03-24 14:24:46.767729169 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (keys.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (n == 0) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:24:54.951699731 +0100\n+++ /tmp/tmprle48qs2.java\t2023-03-24 14:24:54.951699731 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (n == 0) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return Arrays.asList(prepend); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:12.999634758 +0100\n+++ /tmp/tmppf_2v9kk.java\t2023-03-24 14:25:13.035634629 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return Arrays.asList(prepend); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(prependPath); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:20.039609390 +0100\n+++ /tmp/tmpnpwdd1eg.java\t2023-03-24 14:25:20.039609390 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(prependPath); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (!prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:26.667585499 +0100\n+++ /tmp/tmpkjqix437.java\t2023-03-24 14:25:26.667585499 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (prepend && prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:33.231561828 +0100\n+++ /tmp/tmpd6vligco.java\t2023-03-24 14:25:33.231561828 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend && prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (prependQuery) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:40.067537168 +0100\n+++ /tmp/tmpiyx7lsfd.java\t2023-03-24 14:25:40.071537151 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependQuery) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (!prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:46.259514821 +0100\n+++ /tmp/tmpzdejfstv.java\t2023-03-24 14:25:46.259514821 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (prependDocType) return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:52.535492158 +0100\n+++ /tmp/tmpgdrkgljb.java\t2023-03-24 14:25:52.535492158 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (f.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:25:59.039468669 +0100\n+++ /tmp/tmp7uhgdpwm.java\t2023-03-24 14:25:59.039468669 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (f.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (prepend == 0) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:04.863447625 +0100\n+++ /tmp/tmp0upzi93_.java\t2023-03-24 14:26:04.863447625 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend == 0) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(prependDocType); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:11.511423595 +0100\n+++ /tmp/tmpu6sf530u.java\t2023-03-24 14:26:11.511423595 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(prependDocType); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (!prependDocPath) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:17.523401856 +0100\n+++ /tmp/tmptc8yxea4.java\t2023-03-24 14:26:17.523401856 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDocPath) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (prependPath) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:23.159381466 +0100\n+++ /tmp/tmp2890qd8x.java\t2023-03-24 14:26:23.159381466 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependPath) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<String>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:29.075360063 +0100\n+++ /tmp/tmp5w4rnraj.java\t2023-03-24 14:26:29.075360063 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<String>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:34.595340081 +0100\n+++ /tmp/tmpjc5t89da.java\t2023-03-24 14:26:34.595340081 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend.isEmpty()) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:39.547322154 +0100\n+++ /tmp/tmpvmss41eg.java\t2023-03-24 14:26:39.547322154 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (prependNew) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:44.355304739 +0100\n+++ /tmp/tmph9rjh069.java\t2023-03-24 14:26:44.355304739 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependNew) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (prependEntity) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:48.771288742 +0100\n+++ /tmp/tmpcc3q9tr4.java\t2023-03-24 14:26:48.771288742 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependEntity) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (trim) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:53.223272611 +0100\n+++ /tmp/tmp6k2u0ceq.java\t2023-03-24 14:26:53.223272611 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (trim) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<String>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:26:57.447257302 +0100\n+++ /tmp/tmpo6pjd62b.java\t2023-03-24 14:26:57.451257288 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<String>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else if (prepend) { add(prepend); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:01.459242759 +0100\n+++ /tmp/tmpw967zv69.java\t2023-03-24 14:27:01.459242759 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else if (prepend) { add(prepend); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (prepend)) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:05.415228414 +0100\n+++ /tmp/tmpqrqkbw32.java\t2023-03-24 14:27:05.415228414 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend)) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else if (prepend) { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:08.927215681 +0100\n+++ /tmp/tmp4yvw1ovt.java\t2023-03-24 14:27:08.927215681 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else if (prepend) { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(size()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:12.607202331 +0100\n+++ /tmp/tmp1mkkpw2e.java\t2023-03-24 14:27:12.611202317 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer>(size()); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (prependDocType) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:16.367188689 +0100\n+++ /tmp/tmp2sxi2n4m.java\t2023-03-24 14:27:16.367188689 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(f); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:19.743176440 +0100\n+++ /tmp/tmpcwwq6j9z.java\t2023-03-24 14:27:19.747176426 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(f); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(em, sb); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:23.123164174 +0100\n+++ /tmp/tmpcfgo4d5j.java\t2023-03-24 14:27:23.123164174 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(em, sb); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (!prependDoc.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:26.139153226 +0100\n+++ /tmp/tmpik9rzjmk.java\t2023-03-24 14:27:26.139153226 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDoc.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer, Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:28.515144601 +0100\n+++ /tmp/tmpa_ziil_l.java\t2023-03-24 14:27:28.515144601 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<Integer, Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList(prepend); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:31.023135495 +0100\n+++ /tmp/tmpfbgsrcq2.java\t2023-03-24 14:27:31.023135495 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return new ArrayList(prepend); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<>(2); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:33.623126054 +0100\n+++ /tmp/tmp3s16i0a_.java\t2023-03-24 14:27:33.627126040 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocType) { return new ArrayList<Integer>(); } else { return new ArrayList<>(2); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:35.975117513 +0100\n+++ /tmp/tmp8l7u_x7j.java\t2023-03-24 14:27:35.979117500 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return prepend; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:37.967110277 +0100\n+++ /tmp/tmp3d1t2h2j.java\t2023-03-24 14:27:37.967110277 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return prepend; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return add(f); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:40.095102548 +0100\n+++ /tmp/tmpvbk3084n.java\t2023-03-24 14:27:40.095102548 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return add(f); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (!prepend) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:42.275094628 +0100\n+++ /tmp/tmpz1s2682r.java\t2023-03-24 14:27:42.275094628 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:44.359087057 +0100\n+++ /tmp/tmpgaj1uemp.java\t2023-03-24 14:27:44.359087057 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (!prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:46.403079631 +0100\n+++ /tmp/tmpjbdzvsby.java\t2023-03-24 14:27:46.407079617 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return add(prependDoc); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:48.567071767 +0100\n+++ /tmp/tmpaefuzfqa.java\t2023-03-24 14:27:48.567071767 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return add(prependDoc); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(em); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:50.787063702 +0100\n+++ /tmp/tmppm_0hssr.java\t2023-03-24 14:27:50.787063702 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(em); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (prependDoc) { return new ArrayList<Integer>(); } else { add(prependDoc); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:52.975055747 +0100\n+++ /tmp/tmpoiz8re1l.java\t2023-03-24 14:27:52.975055747 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc) { return new ArrayList<Integer>(); } else { add(prependDoc); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { return null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:55.143047865 +0100\n+++ /tmp/tmpxidxaz8m.java\t2023-03-24 14:27:55.143047865 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { return null; }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (prepend) return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:57.327039926 +0100\n+++ /tmp/tmp36fyncou.java\t2023-03-24 14:27:57.331039912 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(r); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:27:59.355032556 +0100\n+++ /tmp/tmp3v5_rim8.java\t2023-03-24 14:27:59.355032556 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(r); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (prependDocDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:01.511024717 +0100\n+++ /tmp/tmpfz84pk6e.java\t2023-03-24 14:28:01.511024717 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDocDoc) { return new ArrayList<Integer>(); } else { return new ArrayList<>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:03.567017238 +0100\n+++ /tmp/tmpqgj0cn30.java\t2023-03-24 14:28:03.567017238 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(i); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(ret); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:05.543010051 +0100\n+++ /tmp/tmpfe429cld.java\t2023-03-24 14:28:05.543010051 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(ret); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { add(t); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:07.495002954 +0100\n+++ /tmp/tmpcadtl04v.java\t2023-03-24 14:28:07.495002954 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { add(t); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { addFields(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:09.594995312 +0100\n+++ /tmp/tmpicv6fsq8.java\t2023-03-24 14:28:09.594995312 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { addFields(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (prependDoc!= null) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:11.650987833 +0100\n+++ /tmp/tmpquae50v6.java\t2023-03-24 14:28:11.654987821 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc!= null) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (prepend) return new ArrayList<Integer>(); else return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:13.646980572 +0100\n+++ /tmp/tmpw0_fvjvh.java\t2023-03-24 14:28:13.646980572 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) return new ArrayList<Integer>(); else return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (prepend) { return new ArrayList<Integer>(); } else { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:15.534973702 +0100\n+++ /tmp/tmpsaoqc1nc.java\t2023-03-24 14:28:15.538973688 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) { return new ArrayList<Integer>(); } else { }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (!prependDoc) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:17.554966354 +0100\n+++ /tmp/tmpiehxssni.java\t2023-03-24 14:28:17.554966354 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDoc) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (!prepend.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:19.594958928 +0100\n+++ /tmp/tmpsqexrrgd.java\t2023-03-24 14:28:19.594958928 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (prepend.size() == 0) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:21.562951766 +0100\n+++ /tmp/tmpsk4sbcku.java\t2023-03-24 14:28:21.562951766 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend.size() == 0) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (!prependDocPath) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:23.574944443 +0100\n+++ /tmp/tmpopvo0dw1.java\t2023-03-24 14:28:23.578944430 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDocPath) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (!prependDocType) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:25.622936990 +0100\n+++ /tmp/tmpjc220kiv.java\t2023-03-24 14:28:25.626936973 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependDocType) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (prependDoc.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:27.734929301 +0100\n+++ /tmp/tmpanpqzgiv.java\t2023-03-24 14:28:27.734929301 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (!prependPath.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:29.742921989 +0100\n+++ /tmp/tmp7rlxxui8.java\t2023-03-24 14:28:29.746921976 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prependPath.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (prependDoc) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:31.662915000 +0100\n+++ /tmp/tmpplybp20u.java\t2023-03-24 14:28:31.662915000 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependDoc) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (prepend.isEmpty()) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:33.794907234 +0100\n+++ /tmp/tmpdkmiv5pn.java\t2023-03-24 14:28:33.794907234 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend.isEmpty()) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (prependNew) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:35.754900096 +0100\n+++ /tmp/tmp3bz3gaz5.java\t2023-03-24 14:28:35.754900096 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependNew) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (!prepends) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:37.666893132 +0100\n+++ /tmp/tmpovo_513j.java\t2023-03-24 14:28:37.666893132 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepends) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (prependQuery) { return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:39.574886185 +0100\n+++ /tmp/tmpco722icp.java\t2023-03-24 14:28:39.574886185 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prependQuery) { return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (prepend) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:41.346879728 +0100\n+++ /tmp/tmpt0lvwxyl.java\t2023-03-24 14:28:41.346879728 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (prepend) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (!prepend) return new ArrayList<Integer>(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:43.106873319 +0100\n+++ /tmp/tmpjexb6ftz.java\t2023-03-24 14:28:43.106873319 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+if (!prepend) return new ArrayList<Integer>(); }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "return new ArrayList<Integer>(prepend);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/get_factors/java_programs/GET_FACTORS.java\t2023-03-24 14:28:44.858866936 +0100\n+++ /tmp/tmp9i15rvr1.java\t2023-03-24 14:28:44.858866936 +0100\n@@ -22,8 +22,8 @@\n                 prepend.add(i);\n                 prepend.addAll(get_factors(n / i));\n                 return prepend;\n             }\n         }\n-        return new ArrayList<Integer>();\n+return new ArrayList<Integer>(prepend);\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return new ArrayList<Integer>(Arrays.asList(n));"
    },
    "wrap": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { line = text.substring(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:37.556191522 +0100\n+++ /tmp/tmpiupnpyh5.java\t2023-03-24 14:22:37.568191480 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { line = text.substring(i); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (lines.size() > 1) { lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:41.272178294 +0100\n+++ /tmp/tmpmsob4wt5.java\t2023-03-24 14:22:41.272178294 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "getContext().createLineViolation(this, \"Do not use relative path for #include \\\"\" + text + \"\\\"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:44.948165204 +0100\n+++ /tmp/tmp0f1afkbh.java\t2023-03-24 14:22:44.952165190 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+getContext().createLineViolation(this, \"Do not use relative path for #include \\\"\" + text + \"\\\"\"); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser platform='{}'\", file); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:46.480159747 +0100\n+++ /tmp/tmpz0vwcrwr.java\t2023-03-24 14:22:46.480159747 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser platform='{}'\", file); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser '{}'\", file); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:48.120153906 +0100\n+++ /tmp/tmp9bq_n416.java\t2023-03-24 14:22:48.120153906 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser '{}'\", file); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { line = lines.get(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:49.744148122 +0100\n+++ /tmp/tmpuldjwlg4.java\t2023-03-24 14:22:49.748148105 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { line = lines.get(i); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "for (int i = 0; i < lines.size(); i++) { line = text.charAt(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:53.324135364 +0100\n+++ /tmp/tmpdldh_4ud.java\t2023-03-24 14:22:53.328135347 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (int i = 0; i < lines.size(); i++) { line = text.charAt(i); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (line.charAt(0) == '\\n') { lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:54.928129647 +0100\n+++ /tmp/tmp2tqaabub.java\t2023-03-24 14:22:54.932129630 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.charAt(0) == '\\n') { lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"Found line '{}'\", line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:56.516123984 +0100\n+++ /tmp/tmp4np717uy.java\t2023-03-24 14:22:56.520123972 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"Found line '{}'\", line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser platform='{}'\", line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:58.052118507 +0100\n+++ /tmp/tmp6vvmht07.java\t2023-03-24 14:22:58.052118507 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser platform='{}'\", line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (lines.size() > 0 || lines.size() > 1) { return lines.get(0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:22:59.652112802 +0100\n+++ /tmp/tmp10xntv5e.java\t2023-03-24 14:22:59.652112802 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 0 || lines.size() > 1) { return lines.get(0); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (text.charAt(0) == '\\n') { lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:23:01.304106912 +0100\n+++ /tmp/tmp1vypw9d9.java\t2023-03-24 14:23:01.308106895 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.charAt(0) == '\\n') { lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "getContext().createLineViolation(this, \"Do not use relative path for #include \\\"\" + line + \"\\\"\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:23:21.256035689 +0100\n+++ /tmp/tmpzjpzbyf8.java\t2023-03-24 14:23:21.264035661 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+getContext().createLineViolation(this, \"Do not use relative path for #include \\\"\" + line + \"\\\"\"); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "} else if (text.charAt(0) == '\\n') { lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:23:29.680005583 +0100\n+++ /tmp/tmpqw_u_sa9.java\t2023-03-24 14:23:29.680005583 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+} else if (text.charAt(0) == '\\n') { lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (text!= null) { lines.add(lines); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:23:38.351974568 +0100\n+++ /tmp/tmpwyizqeeu.java\t2023-03-24 14:23:38.351974568 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { lines.add(lines); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (lines.size() > 1) { lines.add(lines.get(0).substring(1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:23:47.191942932 +0100\n+++ /tmp/tmpgpjwftub.java\t2023-03-24 14:23:47.191942932 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { lines.add(lines.get(0).substring(1)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (lines.size() > 0 || lines.size() > 1) { throw new RuntimeException(\"internal error\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:24:07.671869554 +0100\n+++ /tmp/tmpe6x9a97o.java\t2023-03-24 14:24:07.671869554 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 0 || lines.size() > 1) { throw new RuntimeException(\"internal error\"); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (c == '\\n' || c == '\\r' || c == '\\t') { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:24:26.699801277 +0100\n+++ /tmp/tmpzltnp4tl.java\t2023-03-24 14:24:26.699801277 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (c == '\\n' || c == '\\r' || c == '\\t') { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "} else if (line.indexOf(\"://\")!= -1) { line = text.substring(start, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:24:35.395770045 +0100\n+++ /tmp/tmpjewqbxj2.java\t2023-03-24 14:24:35.395770045 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+} else if (line.indexOf(\"://\")!= -1) { line = text.substring(start, end); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"storing lines {}\", line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:24:43.611740514 +0100\n+++ /tmp/tmpbicmzozm.java\t2023-03-24 14:24:43.611740514 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"storing lines {}\", line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"Adding line '{}'\", line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:24:51.371712611 +0100\n+++ /tmp/tmpcx_eqg0c.java\t2023-03-24 14:24:51.371712611 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"Adding line '{}'\", line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser '{}'\", line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:24:59.423683638 +0100\n+++ /tmp/tmp3adp59uv.java\t2023-03-24 14:24:59.423683638 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser '{}'\", line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (text.charAt(start)!='') { lines.add(lines.get(start)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:25:06.943656567 +0100\n+++ /tmp/tmp6lg9my_r.java\t2023-03-24 14:25:06.951656541 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.charAt(start)!='') { lines.add(lines.get(start)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (lines.size() > 1) { line = new Line(lines.get(0).substring(1)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:25:13.995631171 +0100\n+++ /tmp/tmp0q76u43m.java\t2023-03-24 14:25:13.995631171 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { line = new Line(lines.get(0).substring(1)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (lines.size() > 1) { line = new Line(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:25:20.991605960 +0100\n+++ /tmp/tmpngfps04g.java\t2023-03-24 14:25:20.991605960 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { line = new Line(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (lines.size() > 0 || lines.size() > 1) { line = lines.get(0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:25:27.207583554 +0100\n+++ /tmp/tmp5bxg48w1.java\t2023-03-24 14:25:27.207583554 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 0 || lines.size() > 1) { line = lines.get(0); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (lines.size() > 0 || lines.size() > 1) { throw new IllegalArgumentException(\"Illegal lines\"); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:25:41.619531568 +0100\n+++ /tmp/tmph02feb_8.java\t2023-03-24 14:25:41.619531568 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 0 || lines.size() > 1) { throw new IllegalArgumentException(\"Illegal lines\"); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (lines.size() > 1) { line = new Line(lines.get(0)); line = null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:25:55.399481814 +0100\n+++ /tmp/tmp8dv8z6oh.java\t2023-03-24 14:25:55.399481814 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { line = new Line(lines.get(0)); line = null; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (lines.size() > 1) { return lines.get(0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:01.183460922 +0100\n+++ /tmp/tmple25kbww.java\t2023-03-24 14:26:01.183460922 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { return lines.get(0); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (text!= null) { lines.add(text); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:07.339438676 +0100\n+++ /tmp/tmpp079hxt5.java\t2023-03-24 14:26:07.339438676 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { lines.add(text); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "for (Iterator i = lines.iterator(); i.hasNext();) { if (i.hasNext()) break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:20.455391248 +0100\n+++ /tmp/tmp5n18ggo_.java\t2023-03-24 14:26:20.455391248 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+for (Iterator i = lines.iterator(); i.hasNext();) { if (i.hasNext()) break; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (lines.size() > 0 && lines.contains(line.substring(start, end))) { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:33.227345032 +0100\n+++ /tmp/tmpu3o34lez.java\t2023-03-24 14:26:33.227345032 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 0 && lines.contains(line.substring(start, end))) { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (lines.size() > 1) { line = lines.get(0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:37.795328495 +0100\n+++ /tmp/tmpqxufylwg.java\t2023-03-24 14:26:37.795328495 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { line = lines.get(0); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (lines.size() > 0 || lines.size() > 0) { return lines.get(0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:48.679289075 +0100\n+++ /tmp/tmp3nkph455.java\t2023-03-24 14:26:48.679289075 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 0 || lines.size() > 0) { return lines.get(0); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "this.lines = lines.toArray(new String[lines.size()]);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:52.971273524 +0100\n+++ /tmp/tmpqs1qv47y.java\t2023-03-24 14:26:52.971273524 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines = lines.toArray(new String[lines.size()]);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (line.charAt(0) == '\\n') { lines.add(lines.get(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:26:56.963259059 +0100\n+++ /tmp/tmp2f3gkxwz.java\t2023-03-24 14:26:56.963259059 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.charAt(0) == '\\n') { lines.add(lines.get(i)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "} else if (text.charAt(0) == '#') { lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:00.655245673 +0100\n+++ /tmp/tmpqcxgkh09.java\t2023-03-24 14:27:00.655245673 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+} else if (text.charAt(0) == '#') { lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (lines.size() > 1) { lines.add(lines.get(0).toString()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:04.195232839 +0100\n+++ /tmp/tmpg0y2bnvg.java\t2023-03-24 14:27:04.195232839 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { lines.add(lines.get(0).toString()); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (text.charAt(0) == '\\n') { lines.add(lines.get(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:12.711201956 +0100\n+++ /tmp/tmpqhzij3jq.java\t2023-03-24 14:27:12.711201956 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.charAt(0) == '\\n') { lines.add(lines.get(i)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (text!= null) { lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:16.371188675 +0100\n+++ /tmp/tmpiolux8md.java\t2023-03-24 14:27:16.371188675 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"storing line {}\", line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:23.579162518 +0100\n+++ /tmp/tmpfrhc5qei.java\t2023-03-24 14:27:23.579162518 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"storing line {}\", line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (LOG.isTraceEnabled()) { LOG.trace(\"Found line: {}\", line); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:26.359152428 +0100\n+++ /tmp/tmpm7so8hx9.java\t2023-03-24 14:27:26.359152428 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isTraceEnabled()) { LOG.trace(\"Found line: {}\", line); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (text.charAt(0) == '#') { lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:28.639144153 +0100\n+++ /tmp/tmp67f0ozn0.java\t2023-03-24 14:27:28.639144153 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.charAt(0) == '#') { lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (lines.size() > 1) { this.lines.add(lines.get(0)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:34.075124412 +0100\n+++ /tmp/tmp2sovjx99.java\t2023-03-24 14:27:34.075124412 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { this.lines.add(lines.get(0)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "} else if (line.indexOf(\"://\")!= -1) { line = text.substring(start, start + 1); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:36.259116484 +0100\n+++ /tmp/tmpy0q3j9zy.java\t2023-03-24 14:27:36.263116466 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+} else if (line.indexOf(\"://\")!= -1) { line = text.substring(start, start + 1); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (text!= null) { line = text.substring(start, end); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:38.167109551 +0100\n+++ /tmp/tmp_3d4al1g.java\t2023-03-24 14:27:38.167109551 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { line = text.substring(start, end); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (lines.size() > 1) { lines.add(lines.get(0).trim()); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:40.279101880 +0100\n+++ /tmp/tmp451zpvwr.java\t2023-03-24 14:27:40.279101880 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { lines.add(lines.get(0).trim()); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser platform='{}'\", i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:45.011084689 +0100\n+++ /tmp/tmp_7pvj31k.java\t2023-03-24 14:27:45.015084676 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (LOG.isDebugEnabled()) { LOG.debug(\"build log parser platform='{}'\", i); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (lines.size() > 0 || lines.size() > 1) { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:47.067077220 +0100\n+++ /tmp/tmpjbn_6psd.java\t2023-03-24 14:27:47.067077220 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 0 || lines.size() > 1) { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (lines.size() > 1) { lines.add(lines.get(i)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:49.207069441 +0100\n+++ /tmp/tmpb9k9yhzb.java\t2023-03-24 14:27:49.207069441 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() > 1) { lines.add(lines.get(i)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "return lines.toArray(new String[lines.size()]);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:51.191062233 +0100\n+++ /tmp/tmpplnuo8kl.java\t2023-03-24 14:27:51.191062233 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+return lines.toArray(new String[lines.size()]);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (text!= null) { lines.add(text.substring(start)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:53.179055005 +0100\n+++ /tmp/tmp9wirth3k.java\t2023-03-24 14:27:53.179055005 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { lines.add(text.substring(start)); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "line = text.substring(start, end);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:55.271047403 +0100\n+++ /tmp/tmpqmn9fg0t.java\t2023-03-24 14:27:55.271047403 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+line = text.substring(start, end);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (pattern.matcher(line).find()) { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:57.319039958 +0100\n+++ /tmp/tmps7nuvulw.java\t2023-03-24 14:27:57.319039958 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (pattern.matcher(line).find()) { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "this.lines = Collections.singletonList( new ArrayList<String>(lines.size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:27:59.323032670 +0100\n+++ /tmp/tmpluetyhh2.java\t2023-03-24 14:27:59.323032670 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines = Collections.singletonList( new ArrayList<String>(lines.size()));\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (text!= null) { this.lines.add(text); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:01.415025063 +0100\n+++ /tmp/tmpt12d0tdl.java\t2023-03-24 14:28:01.415025063 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { this.lines.add(text); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (lines.size() == 1) { return Collections.emptySet(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:03.419017775 +0100\n+++ /tmp/tmpwrk1rc35.java\t2023-03-24 14:28:03.419017775 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (lines.size() == 1) { return Collections.emptySet(); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (text!= null) { return lines; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:05.339010793 +0100\n+++ /tmp/tmp0xf3wumr.java\t2023-03-24 14:28:05.339010793 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text!= null) { return lines; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (\"://\".equals(code)) { lines.add(lines); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:09.794994588 +0100\n+++ /tmp/tmp0tcxs3os.java\t2023-03-24 14:28:09.794994588 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (\"://\".equals(code)) { lines.add(lines); }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "lines.add(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:11.730987545 +0100\n+++ /tmp/tmpy4scmlwz.java\t2023-03-24 14:28:11.730987545 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+lines.add(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "line = lines.toArray(new String[lines.size()]);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:13.678980458 +0100\n+++ /tmp/tmp4o6qrf7o.java\t2023-03-24 14:28:13.678980458 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+line = lines.toArray(new String[lines.size()]);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "this.lines.add(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:15.670973210 +0100\n+++ /tmp/tmpl1c1vmeu.java\t2023-03-24 14:28:15.670973210 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines.add(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "log.debug(\" lines: '{}'\", lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:17.550966367 +0100\n+++ /tmp/tmp3j510eo_.java\t2023-03-24 14:28:17.550966367 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+log.debug(\" lines: '{}'\", lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "log.debug(\"Found line '{}'\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:19.486959323 +0100\n+++ /tmp/tmpj8pvl4k9.java\t2023-03-24 14:28:19.486959323 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+log.debug(\"Found line '{}'\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (pattern.matcher(line).matches()) { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:21.346952552 +0100\n+++ /tmp/tmp4q8_uh22.java\t2023-03-24 14:28:21.346952552 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (pattern.matcher(line).matches()) { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (text.charAt(0) == '\\\\') { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:23.258945593 +0100\n+++ /tmp/tmpmsgv82lz.java\t2023-03-24 14:28:23.258945593 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.charAt(0) == '\\\\') { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "this.lines = new ArrayList<>(lines.size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:25.162938662 +0100\n+++ /tmp/tmphd7l_h43.java\t2023-03-24 14:28:25.166938648 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines = new ArrayList<>(lines.size());\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "this.lines = Collections.unmodifiableSet(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:27.142931454 +0100\n+++ /tmp/tmp_nufyb22.java\t2023-03-24 14:28:27.142931454 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines = Collections.unmodifiableSet(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (line.charAt(0) == '\\n') { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:29.054924493 +0100\n+++ /tmp/tmpvgje_gme.java\t2023-03-24 14:28:29.058924481 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (line.charAt(0) == '\\n') { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "LOG.debug(\"build log parser platform='{}'\", file);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:30.886917823 +0100\n+++ /tmp/tmpdjhk_pet.java\t2023-03-24 14:28:30.886917823 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+LOG.debug(\"build log parser platform='{}'\", file);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (text.charAt(0) == '\\n') { return; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:32.678911298 +0100\n+++ /tmp/tmpqjjv8g2y.java\t2023-03-24 14:28:32.678911298 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+if (text.charAt(0) == '\\n') { return; }\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "log.debug(\"storing lines {}\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:34.438904888 +0100\n+++ /tmp/tmpz_pvqn3a.java\t2023-03-24 14:28:34.438904888 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+log.debug(\"storing lines {}\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "log.debug(\" lines: '{}'\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:36.066898962 +0100\n+++ /tmp/tmpbp53qslb.java\t2023-03-24 14:28:36.066898962 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+log.debug(\" lines: '{}'\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "line = new Line(lines.get(0));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:37.770892754 +0100\n+++ /tmp/tmpponnx67b.java\t2023-03-24 14:28:37.770892754 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+line = new Line(lines.get(0));\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "log.debug(\" lines of '{}'\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:39.550886273 +0100\n+++ /tmp/tmp63ey7zmi.java\t2023-03-24 14:28:39.550886273 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+log.debug(\" lines of '{}'\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "this.lines = Collections.unmodifiableMap(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:41.310879860 +0100\n+++ /tmp/tmpazmb0y8a.java\t2023-03-24 14:28:41.310879860 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines = Collections.unmodifiableMap(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "log.debug(\"Adding line {}\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:43.070873450 +0100\n+++ /tmp/tmpqo0z133g.java\t2023-03-24 14:28:43.070873450 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+log.debug(\"Adding line {}\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "this.lines = Collections.singletonList(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:44.866866906 +0100\n+++ /tmp/tmp0zw9b3t0.java\t2023-03-24 14:28:44.866866906 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines = Collections.singletonList(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "LOG.debug(\"storing lines {}\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:46.686860274 +0100\n+++ /tmp/tmpk2uluyw3.java\t2023-03-24 14:28:46.686860274 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+LOG.debug(\"storing lines {}\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "LOG.debug(\"storing line {}\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:48.806852548 +0100\n+++ /tmp/tmpj4waj1z8.java\t2023-03-24 14:28:48.806852548 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+LOG.debug(\"storing line {}\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "this.lines = Arrays.asList(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:50.670845755 +0100\n+++ /tmp/tmpu92gw3zm.java\t2023-03-24 14:28:50.670845755 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines = Arrays.asList(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "lines.add(lines.get(0));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:52.534838963 +0100\n+++ /tmp/tmp0lhb_ezp.java\t2023-03-24 14:28:52.534838963 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+lines.add(lines.get(0));\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "addLine(lines, lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:56.626824048 +0100\n+++ /tmp/tmpwohplyh0.java\t2023-03-24 14:28:56.626824048 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+addLine(lines, lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "line = lines.iterator().next();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:28:58.438817443 +0100\n+++ /tmp/tmp4jkz2hqp.java\t2023-03-24 14:28:58.442817429 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+line = lines.iterator().next();\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "log.debug(\" lines {}\", line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:02.642802116 +0100\n+++ /tmp/tmpz_s_nc0v.java\t2023-03-24 14:29:02.642802116 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+log.debug(\" lines {}\", line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "this.lines.addAll(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:04.386795757 +0100\n+++ /tmp/tmpb2heyz1b.java\t2023-03-24 14:29:04.386795757 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines.addAll(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "this.lines.add(text);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:06.162789281 +0100\n+++ /tmp/tmpfj356yb6.java\t2023-03-24 14:29:06.162789281 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines.add(text);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "line = lines.get(0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:07.906782920 +0100\n+++ /tmp/tmp387xzp8o.java\t2023-03-24 14:29:07.930782833 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+line = lines.get(0);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "this.lines.clear();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:12.010767954 +0100\n+++ /tmp/tmp18djh4u5.java\t2023-03-24 14:29:12.010767954 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+this.lines.clear();\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "line = text.substring(start);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:13.698761796 +0100\n+++ /tmp/tmpyr2cet3y.java\t2023-03-24 14:29:13.698761796 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+line = text.substring(start);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "addLine(line, lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:15.454755390 +0100\n+++ /tmp/tmpgpvt8nn4.java\t2023-03-24 14:29:15.458755376 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+addLine(line, lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "addLine(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:17.150749203 +0100\n+++ /tmp/tmpg6ta_n3b.java\t2023-03-24 14:29:17.154749189 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+addLine(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "lines.add(c);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:18.930742709 +0100\n+++ /tmp/tmpfw9g7za3.java\t2023-03-24 14:29:18.930742709 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+lines.add(c);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "lines.add(text);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:20.738736112 +0100\n+++ /tmp/tmph_y6wlbx.java\t2023-03-24 14:29:20.742736096 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+lines.add(text);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": true
            },
            {
                "k": 95,
                "tentative_fix": "stack.push(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:24.742721501 +0100\n+++ /tmp/tmpaumvj3jy.java\t2023-03-24 14:29:24.742721501 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+stack.push(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "parts.add(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:26.570714830 +0100\n+++ /tmp/tmpyza_sfbu.java\t2023-03-24 14:29:26.574714815 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+parts.add(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "startLine(lines);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:28.334708391 +0100\n+++ /tmp/tmpoif352qc.java\t2023-03-24 14:29:28.334708391 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+startLine(lines);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "addLine(line);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:30.166701705 +0100\n+++ /tmp/tmp_t8e_lgw.java\t2023-03-24 14:29:30.170701691 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+addLine(line);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "return lines.get(0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:31.870695484 +0100\n+++ /tmp/tmpvlx40vzg.java\t2023-03-24 14:29:31.870695484 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+return lines.get(0);\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "lines.clear();",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/wrap/java_programs/WRAP.java\t2023-03-24 14:29:33.546689367 +0100\n+++ /tmp/tmpa300twj3.java\t2023-03-24 14:29:33.546689367 +0100\n@@ -26,9 +26,9 @@\n             }\n             line = text.substring(0,end);\n             text = text.substring(end);\n             lines.add(line);\n         }\n-\n+lines.clear();\n         return lines;\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "lines.add(text);"
    },
    "find_first_in_sorted": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (hi <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:28:48.998851848 +0100\n+++ /tmp/tmpf2poqjxp.java\t2023-03-24 14:28:48.998851848 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (hi <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:28:53.138836761 +0100\n+++ /tmp/tmpsyaifye2.java\t2023-03-24 14:28:53.138836761 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (hi!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:28:57.262821729 +0100\n+++ /tmp/tmpnwyrus4_.java\t2023-03-24 14:28:57.262821729 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi!= null) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (hi <= arr.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:28:59.098815036 +0100\n+++ /tmp/tmplwreknpf.java\t2023-03-24 14:28:59.098815036 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= arr.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (hi!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:03.238799944 +0100\n+++ /tmp/tmpf1ii_1d_.java\t2023-03-24 14:29:03.238799944 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi!= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (hi <= 0f) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:07.278785211 +0100\n+++ /tmp/tmp74ttwcc2.java\t2023-03-24 14:29:07.278785211 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0f) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (hi <= _hi.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:11.434770054 +0100\n+++ /tmp/tmpv8qte2_7.java\t2023-03-24 14:29:11.438770040 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= _hi.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (hi <= hi.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:13.334763123 +0100\n+++ /tmp/tmppmn1sqvr.java\t2023-03-24 14:29:13.338763109 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= hi.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (hi <= types.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:15.158756470 +0100\n+++ /tmp/tmp3pzbypji.java\t2023-03-24 14:29:15.162756456 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= types.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (hi <= 0 || (hi!= null)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:17.022749670 +0100\n+++ /tmp/tmptv9q6m1c.java\t2023-03-24 14:29:17.022749670 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= null)) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (hi <= lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:18.906742797 +0100\n+++ /tmp/tmph_tgy30_.java\t2023-03-24 14:29:18.906742797 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (hi <= 0x7F) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:23.006727837 +0100\n+++ /tmp/tmpz986z_ti.java\t2023-03-24 14:29:23.006727837 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0x7F) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (hi <=lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:27.154712699 +0100\n+++ /tmp/tmpkkshxqpw.java\t2023-03-24 14:29:27.154712699 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (hi <= 0x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:31.338697427 +0100\n+++ /tmp/tmp3n2yj59w.java\t2023-03-24 14:29:31.338697427 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (hi <= 0 || result.length > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:33.142690841 +0100\n+++ /tmp/tmp5s63ikxm.java\t2023-03-24 14:29:33.146690827 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || result.length > 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (hi <= 99) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:34.954684226 +0100\n+++ /tmp/tmpu1cojack.java\t2023-03-24 14:29:34.954684226 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 99) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (hi <= 0 || hi > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:39.330668250 +0100\n+++ /tmp/tmpguhm3ss8.java\t2023-03-24 14:29:39.330668250 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || hi > x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (hi <= 0 || (hi!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:43.754652093 +0100\n+++ /tmp/tmpoj3cf0kr.java\t2023-03-24 14:29:43.754652093 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= null) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (hi <= 0 || (hi > lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:45.534645592 +0100\n+++ /tmp/tmpsu8n5l10.java\t2023-03-24 14:29:45.534645592 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi > lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (hi <=FontResolver.resolve(hi)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:47.386638829 +0100\n+++ /tmp/tmphz8ws17r.java\t2023-03-24 14:29:47.386638829 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=FontResolver.resolve(hi)) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (hi <= 0 || x == lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:49.286631889 +0100\n+++ /tmp/tmp2yjc2e0l.java\t2023-03-24 14:29:49.290631873 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || x == lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (hi <= 0 || (hi!= x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:53.466616617 +0100\n+++ /tmp/tmp1qhudal9.java\t2023-03-24 14:29:53.466616617 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= x)) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (hi <= c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:57.538601740 +0100\n+++ /tmp/tmp3ai8pt74.java\t2023-03-24 14:29:57.538601740 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= c) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (hi <= <= arr.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:29:59.342595148 +0100\n+++ /tmp/tmp5ztsmjpn.java\t2023-03-24 14:29:59.342595148 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= <= arr.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (hi <= output.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:01.154588527 +0100\n+++ /tmp/tmpf9x8phhk.java\t2023-03-24 14:30:01.154588527 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= output.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (hi <=Rule.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:02.990581818 +0100\n+++ /tmp/tmplpyc7cq7.java\t2023-03-24 14:30:02.990581818 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=Rule.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (hi <= result.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:04.818575135 +0100\n+++ /tmp/tmpk67sxy39.java\t2023-03-24 14:30:04.818575135 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= result.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (hi <= classes.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:06.578568703 +0100\n+++ /tmp/tmpm7da0tn9.java\t2023-03-24 14:30:06.578568703 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= classes.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (hi <= _hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:08.458561831 +0100\n+++ /tmp/tmpcgeqajgw.java\t2023-03-24 14:30:08.458561831 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= _hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (hi <= 0 || (hi >= lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:10.358554886 +0100\n+++ /tmp/tmps3lvn8zl.java\t2023-03-24 14:30:10.358554886 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi >= lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (hi <= PAGE_ALL) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:12.122548438 +0100\n+++ /tmp/tmph4mu38ic.java\t2023-03-24 14:30:12.122548438 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= PAGE_ALL) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (hi <= 0 && -lo <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:13.894541958 +0100\n+++ /tmp/tmp5_snowyu.java\t2023-03-24 14:30:13.894541958 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 && -lo <= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (hi <= 0 || hi.length > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:18.114526529 +0100\n+++ /tmp/tmpjc1ycrwz.java\t2023-03-24 14:30:18.114526529 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || hi.length > 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (hi <= 0 || hi.length == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:20.038519492 +0100\n+++ /tmp/tmpv2hof67c.java\t2023-03-24 14:30:20.038519492 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || hi.length == 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (hi!= arr.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:21.854512852 +0100\n+++ /tmp/tmp2y2btf5r.java\t2023-03-24 14:30:21.858512836 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi!= arr.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (hi <= SURR1_LAST) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:26.030497577 +0100\n+++ /tmp/tmphbhjo4f0.java\t2023-03-24 14:30:26.030497577 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= SURR1_LAST) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (hi <=UserAgent.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:27.810491067 +0100\n+++ /tmp/tmpjqissby6.java\t2023-03-24 14:30:27.810491067 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=UserAgent.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (hi <= ns.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:29.614484467 +0100\n+++ /tmp/tmpubt_sopk.java\t2023-03-24 14:30:29.614484467 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= ns.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (hi >=lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:31.406477912 +0100\n+++ /tmp/tmp82lagf3h.java\t2023-03-24 14:30:31.410477898 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi >=lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (hi <= 0 || lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:35.418463234 +0100\n+++ /tmp/tmpjm2a97d6.java\t2023-03-24 14:30:35.418463234 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (hi <= 0 || -lo <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:37.242456560 +0100\n+++ /tmp/tmpe_na4g17.java\t2023-03-24 14:30:37.246456544 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || -lo <= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (hi <= baseNode.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:41.374441438 +0100\n+++ /tmp/tmptni39rcs.java\t2023-03-24 14:30:41.374441438 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= baseNode.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (hi <= 0 && (hi!= null)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:43.202434749 +0100\n+++ /tmp/tmpa5wq6rue.java\t2023-03-24 14:30:43.202434749 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 && (hi!= null)) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (hi <= 0 || -lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:45.046428000 +0100\n+++ /tmp/tmpre002peq.java\t2023-03-24 14:30:45.046428000 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || -lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (hi <=Layer.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:47.610418614 +0100\n+++ /tmp/tmpo5oh56hi.java\t2023-03-24 14:30:47.610418614 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=Layer.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (hi <= 0 || (hi!= lo)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:49.442411909 +0100\n+++ /tmp/tmp68ucvrda.java\t2023-03-24 14:30:49.442411909 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= lo)) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (hi <= 0 || (hi!= 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:54.842392139 +0100\n+++ /tmp/tmph9uwwudy.java\t2023-03-24 14:30:54.842392139 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= 1) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (hi <= System.currentTimeMillis()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:30:56.398386441 +0100\n+++ /tmp/tmpwp05awbs.java\t2023-03-24 14:30:56.398386441 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= System.currentTimeMillis()) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (hi <= pages.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:01.470367868 +0100\n+++ /tmp/tmpdtpf761l.java\t2023-03-24 14:31:01.470367868 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= pages.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (hi <= 0 && hi!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:03.534360311 +0100\n+++ /tmp/tmpjp9qblbo.java\t2023-03-24 14:31:03.538360295 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 && hi!= null) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (hi <= offset) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:05.914351594 +0100\n+++ /tmp/tmppl0d_f6e.java\t2023-03-24 14:31:05.914351594 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= offset) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (hi <= SURR1_FIRST) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:08.434342362 +0100\n+++ /tmp/tmp3vuqxgr2.java\t2023-03-24 14:31:08.434342362 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= SURR1_FIRST) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (hi <= 0 || (hi!= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:10.294335550 +0100\n+++ /tmp/tmpl3en89oc.java\t2023-03-24 14:31:10.294335550 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (hi!= -1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:12.686326786 +0100\n+++ /tmp/tmp3ia560rt.java\t2023-03-24 14:31:12.690326772 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi!= -1) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (hi <= 0 || (hi >=lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:18.750304569 +0100\n+++ /tmp/tmp0ft6spni.java\t2023-03-24 14:31:18.750304569 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi >=lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (hi <= <= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:20.462298296 +0100\n+++ /tmp/tmp18adj0lc.java\t2023-03-24 14:31:20.522298077 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= <= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (hi <= 0 || (hi!= c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:22.618290395 +0100\n+++ /tmp/tmpmp1_k_mx.java\t2023-03-24 14:31:22.618290395 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= c) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (hi <= (hi >= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:25.062281438 +0100\n+++ /tmp/tmp0k6ek19g.java\t2023-03-24 14:31:25.262280707 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= (hi >= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (hi <= 0 || result == x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:27.318273170 +0100\n+++ /tmp/tmp8kv8uv7_.java\t2023-03-24 14:31:27.318273170 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || result == x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (hi <= 0 || (hi <= x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:30.454261675 +0100\n+++ /tmp/tmp4mrl8p5h.java\t2023-03-24 14:31:30.454261675 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi <= x)) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (hi <= 0x7f) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:36.202240604 +0100\n+++ /tmp/tmp2jia4eka.java\t2023-03-24 14:31:36.202240604 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0x7f) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (hi >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:41.962219487 +0100\n+++ /tmp/tmpgud5utnu.java\t2023-03-24 14:31:41.962219487 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi >= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (hi <=lo) { // do this occur?",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:46.638202338 +0100\n+++ /tmp/tmpd6apis86.java\t2023-03-24 14:31:46.638202338 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=lo) { // do this occur?\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (hi <= 0 || hi > lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:51.970182784 +0100\n+++ /tmp/tmp0wsaws7r.java\t2023-03-24 14:31:51.970182784 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || hi > lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (hi <= 0 || -hi < 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:31:58.026160568 +0100\n+++ /tmp/tmp6zpt_as2.java\t2023-03-24 14:31:58.026160568 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || -hi < 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (hi <= low) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:03.666139877 +0100\n+++ /tmp/tmpzmie8102.java\t2023-03-24 14:32:03.666139877 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= low) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (hi <= 0 || (hi!= lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:05.914131627 +0100\n+++ /tmp/tmpicz1o0v9.java\t2023-03-24 14:32:05.914131627 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (hi <=).length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:07.762124847 +0100\n+++ /tmp/tmp6qkcj18y.java\t2023-03-24 14:32:07.762124847 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=).length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (hi <= 0 || (hi!= 100) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:09.938116862 +0100\n+++ /tmp/tmpf_bo2h9_.java\t2023-03-24 14:32:09.978116714 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi!= 100) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (hi <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:12.446107656 +0100\n+++ /tmp/tmpv58pu1rf.java\t2023-03-24 14:32:12.618107026 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (hi <= (hi!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:19.038083461 +0100\n+++ /tmp/tmpcltx9akf.java\t2023-03-24 14:32:19.038083461 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= (hi!= null) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (hi <= ch) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:20.702077354 +0100\n+++ /tmp/tmpm3vgvz_4.java\t2023-03-24 14:32:20.702077354 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= ch) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (hi <= result) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:23.214068131 +0100\n+++ /tmp/tmpgyd5bvjm.java\t2023-03-24 14:32:23.214068131 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= result) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (hi <=Res.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:25.470059848 +0100\n+++ /tmp/tmph7vlphc0.java\t2023-03-24 14:32:25.470059848 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=Res.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (hi <= 6) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:27.238053358 +0100\n+++ /tmp/tmpve2tq8bl.java\t2023-03-24 14:32:27.238053358 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 6) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (hi >= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:31.518037641 +0100\n+++ /tmp/tmpg8_1qvae.java\t2023-03-24 14:32:31.518037641 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi >= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (hi <= b) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:35.526022925 +0100\n+++ /tmp/tmplcdy8ln9.java\t2023-03-24 14:32:35.526022925 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= b) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (hi <= 0 || x == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:37.430015932 +0100\n+++ /tmp/tmpvcfg27u1.java\t2023-03-24 14:32:37.430015932 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || x == 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (hi <= 0 || (hi <= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:41.598000623 +0100\n+++ /tmp/tmpmo171qhp.java\t2023-03-24 14:32:41.598000623 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 || (hi <= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (hi <=hi) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:43.421993922 +0100\n+++ /tmp/tmpolc4x9wi.java\t2023-03-24 14:32:43.421993922 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=hi) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (hi <= language) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:47.477979023 +0100\n+++ /tmp/tmpnrkrhz2n.java\t2023-03-24 14:32:47.477979023 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= language) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (hi <= BoxCount.length) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:49.353972132 +0100\n+++ /tmp/tmpjjmsm5ib.java\t2023-03-24 14:32:49.353972132 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= BoxCount.length) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (hi <= 0 && lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:51.165965476 +0100\n+++ /tmp/tmpqkby7zws.java\t2023-03-24 14:32:51.165965476 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 && lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (hi <= outputInteger) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:53.025958642 +0100\n+++ /tmp/tmpf7n7nkv0.java\t2023-03-24 14:32:53.025958642 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= outputInteger) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (hi <= y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:54.921951676 +0100\n+++ /tmp/tmp1k75ykle.java\t2023-03-24 14:32:54.925951660 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= y) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (hi!= x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:32:56.721945061 +0100\n+++ /tmp/tmp5jgam4s9.java\t2023-03-24 14:32:56.721945061 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi!= x) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (hi <=complete) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:00.785930126 +0100\n+++ /tmp/tmpdt3z64uq.java\t2023-03-24 14:33:00.785930126 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=complete) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (hi!= 0f) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:02.685923144 +0100\n+++ /tmp/tmpdnxsqumv.java\t2023-03-24 14:33:02.685923144 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi!= 0f) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (hi <= 0 ) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:06.809907988 +0100\n+++ /tmp/tmpsswwq0us.java\t2023-03-24 14:33:06.809907988 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0 ) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (hi <= handler) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:11.005892565 +0100\n+++ /tmp/tmpcrdqjljb.java\t2023-03-24 14:33:11.005892565 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= handler) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (hi <= trackStatement) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:12.837885829 +0100\n+++ /tmp/tmpq3ap398_.java\t2023-03-24 14:33:12.837885829 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= trackStatement) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (hi <=channel) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:15.029877773 +0100\n+++ /tmp/tmpy0hmw_pi.java\t2023-03-24 14:33:15.033877757 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=channel) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (hi <= f) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:17.421868979 +0100\n+++ /tmp/tmpat20cy6q.java\t2023-03-24 14:33:17.421868979 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= f) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (hi <= 0xff) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:19.345861906 +0100\n+++ /tmp/tmp3ht8te0k.java\t2023-03-24 14:33:19.345861906 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 0xff) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (hi <=...) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:23.725845800 +0100\n+++ /tmp/tmpv35oq383.java\t2023-03-24 14:33:23.725845800 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <=...) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (hi <= EPS) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:25.557839063 +0100\n+++ /tmp/tmp597fkuzz.java\t2023-03-24 14:33:25.557839063 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= EPS) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (hi <= 8) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:27.561831694 +0100\n+++ /tmp/tmpb6bs_vv6.java\t2023-03-24 14:33:27.561831694 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 8) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (hi <= (hi >= 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:31.785816161 +0100\n+++ /tmp/tmpypfacgo6.java\t2023-03-24 14:33:31.785816161 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= (hi >= 0) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (hi <= 'f') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:33.521809775 +0100\n+++ /tmp/tmpv_4ww9wt.java\t2023-03-24 14:33:33.525809762 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi <= 'f') {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (hi >= lo) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/find_first_in_sorted/java_programs/FIND_FIRST_IN_SORTED.java\t2023-03-24 14:33:37.689794446 +0100\n+++ /tmp/tmpvxdpdvhv.java\t2023-03-24 14:33:37.693794429 +0100\n@@ -14,11 +14,11 @@\n \n     public static int find_first_in_sorted(int[] arr, int x) {\n         int lo = 0;\n         int hi = arr.length;\n \n-        while (lo <= hi) {\n+if (hi >= lo) {\n             int mid = (lo + hi) / 2; // check if this is floor division\n \n             if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                 return mid;\n             } else if (x <= arr[mid]) {\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "while (lo < hi) {"
    },
    "kheapsort": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "for (Integer x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:39.778666613 +0100\n+++ /tmp/tmpflqi7x7d.java\t2023-03-24 14:29:39.778666613 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (arr.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:43.854651729 +0100\n+++ /tmp/tmp28mivv6t.java\t2023-03-24 14:29:43.854651729 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "for (int x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:45.654645154 +0100\n+++ /tmp/tmp_nitusra.java\t2023-03-24 14:29:45.654645154 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:49.670630485 +0100\n+++ /tmp/tmpxu13zhcu.java\t2023-03-24 14:29:49.670630485 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 1) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (arr.size() > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:51.390624201 +0100\n+++ /tmp/tmpv80fdjx8.java\t2023-03-24 14:29:51.390624201 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > x) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (arr.size() > 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:53.142617802 +0100\n+++ /tmp/tmpz51_a69o.java\t2023-03-24 14:29:53.142617802 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 2) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (arr.size() > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:54.894611402 +0100\n+++ /tmp/tmpe1lg5dyf.java\t2023-03-24 14:29:54.898611386 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > i) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if ( arr.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:56.710604766 +0100\n+++ /tmp/tmpiv8x2xm3.java\t2023-03-24 14:29:56.710604766 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if ( arr.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (arr.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:29:58.546598057 +0100\n+++ /tmp/tmp3p2_fd7r.java\t2023-03-24 14:29:58.546598057 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (arr.size() > k) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:00.306591627 +0100\n+++ /tmp/tmpp0fj_9na.java\t2023-03-24 14:30:00.306591627 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > k) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (arr.size() > 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:02.130584960 +0100\n+++ /tmp/tmpk9tsl_yp.java\t2023-03-24 14:30:02.130584960 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 2) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (arr!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:03.954578294 +0100\n+++ /tmp/tmp9zw17od2.java\t2023-03-24 14:30:03.954578294 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr!= null) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "for (Integer x : arr){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:05.670572021 +0100\n+++ /tmp/tmp7x6qk_gj.java\t2023-03-24 14:30:05.670572021 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr){\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (arr.size() > size) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:09.694557313 +0100\n+++ /tmp/tmp9618ffr6.java\t2023-03-24 14:30:09.694557313 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > size) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (v > arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:11.474550806 +0100\n+++ /tmp/tmpf7dg0jz1.java\t2023-03-24 14:30:11.474550806 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (v > arr.size()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (arr.size() > m) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:13.202544489 +0100\n+++ /tmp/tmpcz5ojjmy.java\t2023-03-24 14:30:13.206544473 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > m) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if ( arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:14.954538083 +0100\n+++ /tmp/tmpv3bksbg7.java\t2023-03-24 14:30:14.954538083 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if ( arr.size() > 1) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (arr.size() > n) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:16.726531603 +0100\n+++ /tmp/tmpat8gf9vr.java\t2023-03-24 14:30:16.730531589 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > n) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (arr.size() > count) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:18.458525270 +0100\n+++ /tmp/tmp70yayaw5.java\t2023-03-24 14:30:18.458525270 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > count) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (arr.size() > index) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:20.198518908 +0100\n+++ /tmp/tmpmr6rpq97.java\t2023-03-24 14:30:20.198518908 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > index) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (arr.size() > 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:21.982512383 +0100\n+++ /tmp/tmp0qnv5wjb.java\t2023-03-24 14:30:21.982512383 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 3) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (arr.size() > 10) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:23.698506108 +0100\n+++ /tmp/tmp4e819yak.java\t2023-03-24 14:30:23.698506108 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 10) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (arr.size() > y) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:25.642498996 +0100\n+++ /tmp/tmppyk5mqkt.java\t2023-03-24 14:30:25.642498996 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > y) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (arr.size() > v) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:27.358492719 +0100\n+++ /tmp/tmptvzxogid.java\t2023-03-24 14:30:27.358492719 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > v) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (arr.size() > 0 ) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:29.166486107 +0100\n+++ /tmp/tmpjhady23v.java\t2023-03-24 14:30:29.166486107 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 0 ) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (arr.size() > 31) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:30.886479815 +0100\n+++ /tmp/tmpkcb0852f.java\t2023-03-24 14:30:30.890479799 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 31) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (arr.size() > depth) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:32.678473258 +0100\n+++ /tmp/tmp52jxiuwo.java\t2023-03-24 14:30:32.678473258 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > depth) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (arr.size() > 2){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:34.406466935 +0100\n+++ /tmp/tmpvlioybh3.java\t2023-03-24 14:30:34.410466922 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 2){\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (heap.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:36.238460234 +0100\n+++ /tmp/tmpl5fiowq4.java\t2023-03-24 14:30:36.238460234 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (heap.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (arr.size() > f) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:37.926454057 +0100\n+++ /tmp/tmp8sn3sexk.java\t2023-03-24 14:30:37.930454041 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > f) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if ( arr.size() > 2) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:39.690447602 +0100\n+++ /tmp/tmp6i_vrrar.java\t2023-03-24 14:30:39.694447586 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if ( arr.size() > 2) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "for (Integer x : arr.values()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:41.534440852 +0100\n+++ /tmp/tmprsjhljlu.java\t2023-03-24 14:30:41.534440852 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr.values()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (arr.size() > 2 ) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:43.250434572 +0100\n+++ /tmp/tmp9q91tvdw.java\t2023-03-24 14:30:43.254434558 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 2 ) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (arr.size() > u) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:45.098427809 +0100\n+++ /tmp/tmphp93hv8e.java\t2023-03-24 14:30:45.098427809 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > u) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (arr.size() > 1.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:47.370419493 +0100\n+++ /tmp/tmpe3d_82y5.java\t2023-03-24 14:30:47.370419493 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 1.0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (arr.size() > ch) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:49.398412070 +0100\n+++ /tmp/tmpf_rtmomp.java\t2023-03-24 14:30:49.402412054 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > ch) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (e.getValue()!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:51.414404688 +0100\n+++ /tmp/tmp6nvprkwq.java\t2023-03-24 14:30:51.414404688 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (e.getValue()!= null) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (arr.size() > 2)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:53.742396166 +0100\n+++ /tmp/tmposphupr8.java\t2023-03-24 14:30:53.742396166 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 2)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (arr.size() >'') {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:56.358386588 +0100\n+++ /tmp/tmphjbtt938.java\t2023-03-24 14:30:56.358386588 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() >'') {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (arr.size() > c) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:30:58.510378708 +0100\n+++ /tmp/tmphimohmsh.java\t2023-03-24 14:30:58.630378269 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > c) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (arr.size() > 1;) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:01.282368556 +0100\n+++ /tmp/tmpwkarcjaq.java\t2023-03-24 14:31:01.282368556 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 1;) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if ( arr.size() > x) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:03.354360969 +0100\n+++ /tmp/tmpjrw7kd2b.java\t2023-03-24 14:31:03.494360456 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if ( arr.size() > x) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (arr.size() > 1)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:05.802352003 +0100\n+++ /tmp/tmprjiyma99.java\t2023-03-24 14:31:05.802352003 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 1)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (arr.size() > p) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:07.794344706 +0100\n+++ /tmp/tmp_vmsz0jt.java\t2023-03-24 14:31:08.174343315 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > p) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (arr.size() > len) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:10.186335946 +0100\n+++ /tmp/tmphdbhp8ok.java\t2023-03-24 14:31:10.186335946 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > len) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if ( \"\\n\".equals(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:12.494327490 +0100\n+++ /tmp/tmpg9mxbnu9.java\t2023-03-24 14:31:12.606327081 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if ( \"\\n\".equals(x)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (output.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:15.054318112 +0100\n+++ /tmp/tmpjzj5_oo3.java\t2023-03-24 14:31:15.054318112 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (output.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (arr.size() == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:17.854307853 +0100\n+++ /tmp/tmpatoktm4m.java\t2023-03-24 14:31:17.858307837 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() == 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (scores.contains(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:20.550297974 +0100\n+++ /tmp/tmp4i0f6wbg.java\t2023-03-24 14:31:20.554297960 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (scores.contains(x)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (v!= arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:22.678290176 +0100\n+++ /tmp/tmplw0vdkla.java\t2023-03-24 14:31:22.678290176 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (v!= arr.size()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "for (String x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:25.450280017 +0100\n+++ /tmp/tmp3oond40l.java\t2023-03-24 14:31:25.450280017 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (String x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (arr.size() > 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:27.402272864 +0100\n+++ /tmp/tmpzw3g3833.java\t2023-03-24 14:31:27.402272864 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 1) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (aa.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:30.042263186 +0100\n+++ /tmp/tmpocq1e0te.java\t2023-03-24 14:31:30.042263186 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (aa.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (urls.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:32.434254418 +0100\n+++ /tmp/tmpszv6ubw9.java\t2023-03-24 14:31:32.438254404 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (urls.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (arr.size() % k) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:34.446247042 +0100\n+++ /tmp/tmp43148z2z.java\t2023-03-24 14:31:34.446247042 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() % k) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (arr.size() == 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:36.050241163 +0100\n+++ /tmp/tmpljh6uzzs.java\t2023-03-24 14:31:36.050241163 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() == 1) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:38.190233316 +0100\n+++ /tmp/tmps4id1vob.java\t2023-03-24 14:31:38.190233316 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.isEmpty()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (blocks.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:40.614224430 +0100\n+++ /tmp/tmphrjk4v4m.java\t2023-03-24 14:31:40.614224430 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (blocks.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (arr.size() > connected) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:42.338218107 +0100\n+++ /tmp/tmp8r8o0rsn.java\t2023-03-24 14:31:42.342218093 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > connected) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (messages.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:44.298210921 +0100\n+++ /tmp/tmpm1rlkisj.java\t2023-03-24 14:31:44.302210904 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (messages.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "while (arr.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:46.230203835 +0100\n+++ /tmp/tmphcwojz28.java\t2023-03-24 14:31:46.230203835 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+while (arr.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (dir == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:48.398195885 +0100\n+++ /tmp/tmpj5b4ut_e.java\t2023-03-24 14:31:48.398195885 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (dir == null) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (arr.size() > 6) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:51.146185806 +0100\n+++ /tmp/tmptdjhs545.java\t2023-03-24 14:31:51.298185248 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 6) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (x > arr.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:54.498173510 +0100\n+++ /tmp/tmp0ed8k6gf.java\t2023-03-24 14:31:54.502173496 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (x > arr.size()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (arr.size() > 3) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:56.270167011 +0100\n+++ /tmp/tmp_sewsxcy.java\t2023-03-24 14:31:56.270167011 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 3) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (ir.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:31:58.126160202 +0100\n+++ /tmp/tmp9xiw6i0e.java\t2023-03-24 14:31:58.126160202 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (ir.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "for (BigInteger x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:00.598151132 +0100\n+++ /tmp/tmpo7rv38ob.java\t2023-03-24 14:32:00.598151132 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (BigInteger x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (arr.size() > 0)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:02.458144309 +0100\n+++ /tmp/tmpvh6lz8j0.java\t2023-03-24 14:32:02.458144309 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 0)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (ie.size() > 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:04.046138482 +0100\n+++ /tmp/tmptvj1qpq2.java\t2023-03-24 14:32:04.046138482 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (ie.size() > 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (arr.contains(x)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:05.874131774 +0100\n+++ /tmp/tmp74vb8y0m.java\t2023-03-24 14:32:05.874131774 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.contains(x)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "for (Integer x: arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:07.906124318 +0100\n+++ /tmp/tmprt7lx6lx.java\t2023-03-24 14:32:07.906124318 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x: arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "for (Integer x : arr)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:13.726102958 +0100\n+++ /tmp/tmpbh2hsm9_.java\t2023-03-24 14:32:13.726102958 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Integer x : arr)) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (!arr.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:15.390096851 +0100\n+++ /tmp/tmpjw4md1da.java\t2023-03-24 14:32:15.390096851 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (!arr.isEmpty()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "for (Long x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:18.494085458 +0100\n+++ /tmp/tmpczokk6if.java\t2023-03-24 14:32:18.494085458 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Long x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (arr.size() > 1; {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:20.550077910 +0100\n+++ /tmp/tmplrw9ebvm.java\t2023-03-24 14:32:20.550077910 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 1; {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (arr.size() > 0); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:23.230068074 +0100\n+++ /tmp/tmpif_gr3uv.java\t2023-03-24 14:32:23.434067325 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr.size() > 0); }\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "for (int x: arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:25.410060069 +0100\n+++ /tmp/tmpytxorsqs.java\t2023-03-24 14:32:25.410060069 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x: arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (multipleEdges) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:29.390045457 +0100\n+++ /tmp/tmpg0jquait.java\t2023-03-24 14:32:29.390045457 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (multipleEdges) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "for (V x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:31.298038450 +0100\n+++ /tmp/tmp41kfcra6.java\t2023-03-24 14:32:31.298038450 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (V x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "for (Int x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:33.126031737 +0100\n+++ /tmp/tmp1crp1yf0.java\t2023-03-24 14:32:33.130031724 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (Int x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "for (long x : arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:34.866025347 +0100\n+++ /tmp/tmpdv1qlt1l.java\t2023-03-24 14:32:34.866025347 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (long x : arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "for (int x : arr){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:36.670018722 +0100\n+++ /tmp/tmp17yhimtb.java\t2023-03-24 14:32:36.674018708 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+for (int x : arr){\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (indices.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:40.750003739 +0100\n+++ /tmp/tmpbf2sqidq.java\t2023-03-24 14:32:40.750003739 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (indices.isEmpty()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (boxes!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:42.561997082 +0100\n+++ /tmp/tmpmpt1keug.java\t2023-03-24 14:32:42.561997082 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (boxes!= null) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (it!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:44.321990618 +0100\n+++ /tmp/tmprfd4aalz.java\t2023-03-24 14:32:44.321990618 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (it!= null) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (v > arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:46.133983961 +0100\n+++ /tmp/tmpaycrlwdm.java\t2023-03-24 14:32:46.133983961 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (v > arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (ir == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:47.849977658 +0100\n+++ /tmp/tmpd1lsm6l4.java\t2023-03-24 14:32:47.849977658 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (ir == null) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if ( roots.isEmpty()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:49.581971294 +0100\n+++ /tmp/tmpn5j8wvd_.java\t2023-03-24 14:32:49.581971294 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if ( roots.isEmpty()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (it.hasNext()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:51.337964844 +0100\n+++ /tmp/tmpah8uyr2x.java\t2023-03-24 14:32:51.337964844 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (it.hasNext()) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (fallback) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:53.069958479 +0100\n+++ /tmp/tmp4e74of_c.java\t2023-03-24 14:32:53.069958479 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (fallback) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (forced) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:54.841951970 +0100\n+++ /tmp/tmpha__a605.java\t2023-03-24 14:32:54.841951970 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (forced) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (signed) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:56.573945605 +0100\n+++ /tmp/tmp788im4jx.java\t2023-03-24 14:32:56.577945589 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (signed) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (axis == 0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:32:58.329939151 +0100\n+++ /tmp/tmpqma7q2c0.java\t2023-03-24 14:32:58.329939151 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (axis == 0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (arr) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:33:00.105932626 +0100\n+++ /tmp/tmp4m239mue.java\t2023-03-24 14:33:00.105932626 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (arr) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (accumulate) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:33:01.861926172 +0100\n+++ /tmp/tmp80u7snsx.java\t2023-03-24 14:33:01.861926172 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (accumulate) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (5.0) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:33:03.585919836 +0100\n+++ /tmp/tmp5vod1a56.java\t2023-03-24 14:33:03.585919836 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (5.0) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (enqueue) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:33:05.457912957 +0100\n+++ /tmp/tmpcohbz6it.java\t2023-03-24 14:33:05.461912941 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (enqueue) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (fixed) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:33:07.205906531 +0100\n+++ /tmp/tmp6i7kzxaf.java\t2023-03-24 14:33:07.205906531 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (fixed) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (pf) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:33:09.033899814 +0100\n+++ /tmp/tmpo2vj67nw.java\t2023-03-24 14:33:09.033899814 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (pf) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (ir) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kheapsort/java_programs/KHEAPSORT.java\t2023-03-24 14:33:10.901892947 +0100\n+++ /tmp/tmp0lvuzgkc.java\t2023-03-24 14:33:10.901892947 +0100\n@@ -22,11 +22,11 @@\n         for (Integer v : arr.subList(0,k)) {\n             heap.add(v);\n         }\n \n         ArrayList<Integer> output = new ArrayList<Integer>();\n-        for (Integer x : arr) {\n+if (ir) {\n             heap.add(x);\n             Integer popped = heap.poll();\n             output.add(popped);\n         }\n \n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "for (Integer x : arr.subList(k, arr.size())) {"
    },
    "kth": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:17.729867847 +0100\n+++ /tmp/tmp0oqycfbn.java\t2023-03-24 14:33:17.773867683 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:21.929852405 +0100\n+++ /tmp/tmpj5lnopwh.java\t2023-03-24 14:33:21.929852405 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if ( num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:23.745845726 +0100\n+++ /tmp/tmp6oxcoi59.java\t2023-03-24 14:33:23.745845726 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (num_lessoreq <= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:27.857830605 +0100\n+++ /tmp/tmplgxfjot7.java\t2023-03-24 14:33:27.857830605 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq <= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (this._lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:32.061815146 +0100\n+++ /tmp/tmpprtc39h9.java\t2023-03-24 14:33:32.065815130 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (this._lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (Math.abs(num_lessoreq) > 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:33.781808820 +0100\n+++ /tmp/tmpdjdgyp9w.java\t2023-03-24 14:33:33.785808804 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) > 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (num_lessoreq <= 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:37.873793768 +0100\n+++ /tmp/tmp51lv9v8p.java\t2023-03-24 14:33:37.873793768 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq <= 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return -1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:41.961778730 +0100\n+++ /tmp/tmpojuosgpg.java\t2023-03-24 14:33:41.961778730 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return -1; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (num_lessoreq < num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:46.725761206 +0100\n+++ /tmp/tmpb_i_yu5l.java\t2023-03-24 14:33:46.725761206 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq < num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (readOnly) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:50.885745898 +0100\n+++ /tmp/tmpetsns62x.java\t2023-03-24 14:33:50.889745884 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (readOnly) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (this.lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:52.633739467 +0100\n+++ /tmp/tmps6kza2aj.java\t2023-03-24 14:33:52.633739467 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (this.lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return u; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:54.389733005 +0100\n+++ /tmp/tmp3w3ag7de.java\t2023-03-24 14:33:54.393732991 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return u; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (num_lessoreq == 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:33:56.233726221 +0100\n+++ /tmp/tmpf1st2m_2.java\t2023-03-24 14:33:56.237726204 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq == 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (previous_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:00.429710778 +0100\n+++ /tmp/tmpgx44wnsu.java\t2023-03-24 14:34:00.429710778 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (previous_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:02.117704566 +0100\n+++ /tmp/tmpxp8l3e_4.java\t2023-03-24 14:34:02.117704566 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if ( (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:07.053686399 +0100\n+++ /tmp/tmpa_4cr6i5.java\t2023-03-24 14:34:07.057686385 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:09.213678449 +0100\n+++ /tmp/tmppw434hta.java\t2023-03-24 14:34:09.213678449 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if ([num_lessoreq] > 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:10.905672221 +0100\n+++ /tmp/tmpezldfrzm.java\t2023-03-24 14:34:11.029671764 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ([num_lessoreq] > 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (buffer.size() < num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:14.109660424 +0100\n+++ /tmp/tmphqrwhss0.java\t2023-03-24 14:34:14.113660411 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (buffer.size() < num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (k < num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:16.265652489 +0100\n+++ /tmp/tmptj0xj8it.java\t2023-03-24 14:34:16.265652489 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (k < num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0.0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:21.589632885 +0100\n+++ /tmp/tmpayeic93z.java\t2023-03-24 14:34:21.589632885 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return 0.0; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (num_lessoreq > 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:23.653625285 +0100\n+++ /tmp/tmpafavpsv1.java\t2023-03-24 14:34:23.653625285 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq > 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (Max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:29.285604546 +0100\n+++ /tmp/tmplaowhorn.java\t2023-03-24 14:34:29.285604546 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if ()\", num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:31.609595989 +0100\n+++ /tmp/tmpiubdksbk.java\t2023-03-24 14:34:31.609595989 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ()\", num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (num_lessoreq <= 0.0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:33.321589684 +0100\n+++ /tmp/tmpiphao5gk.java\t2023-03-24 14:34:33.321589684 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq <= 0.0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:39.565566685 +0100\n+++ /tmp/tmp821lp86i.java\t2023-03-24 14:34:39.565566685 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (max_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (Math.abs(num_lessoreq) > 0.0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:41.697558833 +0100\n+++ /tmp/tmpyjyj_z4h.java\t2023-03-24 14:34:41.697558833 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) > 0.0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return k; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:47.625536995 +0100\n+++ /tmp/tmpt5bhb38l.java\t2023-03-24 14:34:47.629536979 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return k; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:52.765518057 +0100\n+++ /tmp/tmpnzz5oe95.java\t2023-03-24 14:34:52.765518057 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (current == num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:54.317512338 +0100\n+++ /tmp/tmpkylu6y2c.java\t2023-03-24 14:34:54.317512338 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (current == num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (Math.abs(n) >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:57.045502288 +0100\n+++ /tmp/tmpc7pnom72.java\t2023-03-24 14:34:57.045502288 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(n) >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return Endpoint.newBuilder(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:34:58.721496113 +0100\n+++ /tmp/tmpvbqn8izq.java\t2023-03-24 14:34:58.725496096 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return Endpoint.newBuilder(); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (Preferred_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:00.709488785 +0100\n+++ /tmp/tmp3pvkhpnd.java\t2023-03-24 14:35:00.709488785 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Preferred_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (pretty_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:02.845480913 +0100\n+++ /tmp/tmp_n9za0k1.java\t2023-03-24 14:35:02.845480913 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (pretty_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (buffer.size() == num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:05.077472688 +0100\n+++ /tmp/tmpgixbiotf.java\t2023-03-24 14:35:05.077472688 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (buffer.size() == num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (:_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:07.369464241 +0100\n+++ /tmp/tmpgtusu7wf.java\t2023-03-24 14:35:07.369464241 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (:_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (Multi_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:09.617455956 +0100\n+++ /tmp/tmpcegmgmdf.java\t2023-03-24 14:35:09.617455956 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Multi_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if ([num_lessoreq] == 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:12.205446419 +0100\n+++ /tmp/tmppmo_f192.java\t2023-03-24 14:35:12.353445872 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ([num_lessoreq] == 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (lang.equals(num_lessoreq)) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:13.945440005 +0100\n+++ /tmp/tmptqqn10h1.java\t2023-03-24 14:35:13.945440005 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (lang.equals(num_lessoreq)) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (num_lessoreq >= num_lessless) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:16.273431422 +0100\n+++ /tmp/tmp427ow3ie.java\t2023-03-24 14:35:16.273431422 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessless) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if ('>_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:18.313423902 +0100\n+++ /tmp/tmp8_8ogazz.java\t2023-03-24 14:35:18.313423902 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ('>_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { returnordered; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:20.477415926 +0100\n+++ /tmp/tmphdq1eq0w.java\t2023-03-24 14:35:20.477415926 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { returnordered; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (buf.readableBytes() >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:22.513408421 +0100\n+++ /tmp/tmptdp1bp9w.java\t2023-03-24 14:35:22.801407357 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (buf.readableBytes() >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (num_lessoreq >= num_v) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:25.789396343 +0100\n+++ /tmp/tmpuds6mky5.java\t2023-03-24 14:35:25.789396343 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_v) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (Math.abs(num_lessoreq) >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:27.901388554 +0100\n+++ /tmp/tmpiaudl8_4.java\t2023-03-24 14:35:27.901388554 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if ( (__lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:29.977380900 +0100\n+++ /tmp/tmp25xjwce2.java\t2023-03-24 14:35:29.977380900 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( (__lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (Math.max(num_lessoreq, k)) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:32.181372773 +0100\n+++ /tmp/tmp_ar9_iz7.java\t2023-03-24 14:35:32.181372773 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.max(num_lessoreq, k)) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (Math.abs(s) >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:35.065362139 +0100\n+++ /tmp/tmpx114za94.java\t2023-03-24 14:35:35.065362139 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(s) >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (Math.abs(num_lessoreq) > Math.abs(e.get(k)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:37.321353819 +0100\n+++ /tmp/tmpudv_ekbn.java\t2023-03-24 14:35:37.321353819 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) > Math.abs(e.get(k)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (File.class.isInstance(num_lessoreq)) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:39.393346179 +0100\n+++ /tmp/tmp4cvk4_8k.java\t2023-03-24 14:35:39.393346179 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (File.class.isInstance(num_lessoreq)) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (first_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:41.533338286 +0100\n+++ /tmp/tmpvciojaof.java\t2023-03-24 14:35:41.533338286 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (first_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (getPredicates() == num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:44.265328211 +0100\n+++ /tmp/tmpnc9guqcf.java\t2023-03-24 14:35:44.265328211 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (getPredicates() == num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(Levels, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:46.069321558 +0100\n+++ /tmp/tmpvhi4przt.java\t2023-03-24 14:35:46.069321558 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(Levels, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (Math.abs(matrix.get(k, k))) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:47.853314978 +0100\n+++ /tmp/tmp0sml23_d.java\t2023-03-24 14:35:47.853314978 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(matrix.get(k, k))) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot.doubleValue(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:49.717308102 +0100\n+++ /tmp/tmpemplzeph.java\t2023-03-24 14:35:49.717308102 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot.doubleValue(); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot.size(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:51.509301490 +0100\n+++ /tmp/tmprm63eqes.java\t2023-03-24 14:35:51.509301490 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return pivot.size(); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (n >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:53.385294571 +0100\n+++ /tmp/tmplm99ba07.java\t2023-03-24 14:35:53.385294571 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (n >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return v; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:55.289287549 +0100\n+++ /tmp/tmpfi5szwu5.java\t2023-03-24 14:35:55.289287549 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return v; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if ( Math.max(num_lessoreq, k)) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:57.037281100 +0100\n+++ /tmp/tmpl63b9jy4.java\t2023-03-24 14:35:57.037281100 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( Math.max(num_lessoreq, k)) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (num_lessoreq < 0.0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:35:58.753274768 +0100\n+++ /tmp/tmpaketm3gx.java\t2023-03-24 14:35:58.753274768 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq < 0.0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if ( \":\" + k >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:02.841259687 +0100\n+++ /tmp/tmpaaxmcxia.java\t2023-03-24 14:36:02.845259673 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( \":\" + k >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (Math.abs(num_lessoreq) > Math.abs(num_lessoreq)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:04.789252499 +0100\n+++ /tmp/tmpho47jaa9.java\t2023-03-24 14:36:04.789252499 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) > Math.abs(num_lessoreq)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (num_lessoreq == 0.0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:06.565245946 +0100\n+++ /tmp/tmpnaa2h85k.java\t2023-03-24 14:36:06.569245932 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq == 0.0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (num_lessoreq >= 0.0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:10.577231142 +0100\n+++ /tmp/tmpal33cjdh.java\t2023-03-24 14:36:10.581231129 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= 0.0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq && pivot >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:14.457216826 +0100\n+++ /tmp/tmpe5un6oki.java\t2023-03-24 14:36:14.457216826 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq && pivot >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if ( num_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:16.265210153 +0100\n+++ /tmp/tmplf5_4i7q.java\t2023-03-24 14:36:16.265210153 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ( num_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (scaleFactor == num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:17.969203866 +0100\n+++ /tmp/tmp_ah0_9_m.java\t2023-03-24 14:36:17.969203866 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (scaleFactor == num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (buffer.size() > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:19.733197356 +0100\n+++ /tmp/tmp6gl0s9_n.java\t2023-03-24 14:36:19.737197340 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (buffer.size() > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (num_lessoreq > 0.0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:21.481190904 +0100\n+++ /tmp/tmpde3w7z2b.java\t2023-03-24 14:36:21.485190890 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq > 0.0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (diff > 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:25.701175328 +0100\n+++ /tmp/tmp8he0lqml.java\t2023-03-24 14:36:25.705175315 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (diff > 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (current!= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:27.409169026 +0100\n+++ /tmp/tmpcrxmd1kb.java\t2023-03-24 14:36:27.409169026 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (current!= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (size < num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:29.225162321 +0100\n+++ /tmp/tmphpnu2dod.java\t2023-03-24 14:36:29.225162321 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (size < num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (num_lessoreq >= num_less) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:31.009155736 +0100\n+++ /tmp/tmpl3k55lvn.java\t2023-03-24 14:36:31.009155736 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_less) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (canRead(num_lessoreq)) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:35.137140498 +0100\n+++ /tmp/tmpz3kd_pk1.java\t2023-03-24 14:36:35.137140498 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (canRead(num_lessoreq)) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return this; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:36.865134120 +0100\n+++ /tmp/tmpmqh353we.java\t2023-03-24 14:36:36.869134104 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return this; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (horeq >= num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:38.597127726 +0100\n+++ /tmp/tmpa1upmbmt.java\t2023-03-24 14:36:38.597127726 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (horeq >= num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (k > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:40.341121288 +0100\n+++ /tmp/tmp9_5ssdrw.java\t2023-03-24 14:36:40.341121288 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (k > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (f > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:44.417106239 +0100\n+++ /tmp/tmpt9gqhco4.java\t2023-03-24 14:36:44.417106239 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (f > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (this._lessoreq >= num_lessoreq) { return kth(above, k); } else { return -1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:46.185099710 +0100\n+++ /tmp/tmp51xxn2et.java\t2023-03-24 14:36:46.189099696 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (this._lessoreq >= num_lessoreq) { return kth(above, k); } else { return -1; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (column == num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:48.025092916 +0100\n+++ /tmp/tmpn74dow2u.java\t2023-03-24 14:36:48.029092903 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (column == num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (Math.abs(matrix.get(k, k)) > Matrices.EPS) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:49.853086166 +0100\n+++ /tmp/tmpmjag9emg.java\t2023-03-24 14:36:49.853086166 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(matrix.get(k, k)) > Matrices.EPS) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return g.out(); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:51.613079670 +0100\n+++ /tmp/tmp30ciekd3.java\t2023-03-24 14:36:51.613079670 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= num_lessoreq) { return kth(above, k); } else { return g.out(); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (Math.abs(num_lessoreq) > Math.abs(e.get(k)) { return kth(e, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:53.457072860 +0100\n+++ /tmp/tmpfyeob4qv.java\t2023-03-24 14:36:53.457072860 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) > Math.abs(e.get(k)) { return kth(e, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (capacity > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:55.169066537 +0100\n+++ /tmp/tmp_raccdl3.java\t2023-03-24 14:36:55.169066537 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (capacity > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (Collections.emptyList().size() > 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:36:57.057059565 +0100\n+++ /tmp/tmpizr3dvrq.java\t2023-03-24 14:36:57.061059552 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Collections.emptyList().size() > 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (this._lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:01.157044424 +0100\n+++ /tmp/tmpic_ucd68.java\t2023-03-24 14:37:01.157044424 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (this._lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (n > num_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:03.001037613 +0100\n+++ /tmp/tmpo0qp_ea2.java\t2023-03-24 14:37:03.001037613 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (n > num_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (Math.abs(e.get(k)) > Math.abs(e.get(k)) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:04.789031011 +0100\n+++ /tmp/tmp77e9fvj2.java\t2023-03-24 14:37:04.789031011 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(e.get(k)) > Math.abs(e.get(k)) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (num_lessoreq == 1) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:06.397025071 +0100\n+++ /tmp/tmprza227s2.java\t2023-03-24 14:37:06.397025071 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq == 1) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (num_lessoreq >= 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:11.285007017 +0100\n+++ /tmp/tmp_r72vcrf.java\t2023-03-24 14:37:11.285007017 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq >= 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (pretty_lessoreq) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:15.424991726 +0100\n+++ /tmp/tmp0ihxuccp.java\t2023-03-24 14:37:15.424991726 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (pretty_lessoreq) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (num_lessoreq <= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:17.256984959 +0100\n+++ /tmp/tmpr_230q4b.java\t2023-03-24 14:37:17.256984959 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq <= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (previous_lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:19.112978102 +0100\n+++ /tmp/tmpy5zh53z9.java\t2023-03-24 14:37:19.116978086 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (previous_lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (remaining == 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:20.944971332 +0100\n+++ /tmp/tmpc65grl7v.java\t2023-03-24 14:37:20.944971332 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (remaining == 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if ([num_lessoreq] > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:22.728964742 +0100\n+++ /tmp/tmpjs1z5duw.java\t2023-03-24 14:37:22.728964742 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if ([num_lessoreq] > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (Math.abs(num_lessoreq) > 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:24.464958328 +0100\n+++ /tmp/tmpeo7q80f4.java\t2023-03-24 14:37:24.464958328 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Math.abs(num_lessoreq) > 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (this.lessoreq >= num_lessoreq) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:26.184951975 +0100\n+++ /tmp/tmpxa0u_dw5.java\t2023-03-24 14:37:26.188951959 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (this.lessoreq >= num_lessoreq) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (Preferred) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:27.952945442 +0100\n+++ /tmp/tmpniv76hhd.java\t2023-03-24 14:37:27.952945442 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (Preferred) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (capacity > 0) { return kth(above, k); } else { return pivot; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:29.740938835 +0100\n+++ /tmp/tmp6gbbizm4.java\t2023-03-24 14:37:29.744938822 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (capacity > 0) { return kth(above, k); } else { return pivot; }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (num_lessoreq <= 0) { return kth(above, k); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/kth/java_programs/KTH.java\t2023-03-24 14:37:31.572932067 +0100\n+++ /tmp/tmpl8l8z4a6.java\t2023-03-24 14:37:31.572932067 +0100\n@@ -27,11 +27,11 @@\n         int num_less = below.size();\n         int num_lessoreq = arr.size() - above.size();\n         if (k < num_less) {\n             return kth(below, k);\n         } else if (k >= num_lessoreq) {\n-            return kth(above, k);\n+if (num_lessoreq <= 0) { return kth(above, k); }\n         } else {\n             return pivot;\n         }\n     }\n }\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "return kth(above, k-num_lessoreq);"
    },
    "shortest_path_lengths": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:45.505765694 +0100\n+++ /tmp/tmpcow5z1ea.java\t2023-03-24 14:33:45.553765517 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:47.249759276 +0100\n+++ /tmp/tmpq8g9ykkk.java\t2023-03-24 14:33:47.253759263 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "new ArrayList<>(length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:49.005752816 +0100\n+++ /tmp/tmpbctt6xg3.java\t2023-03-24 14:33:49.005752816 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "sumLengths(length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:50.793746238 +0100\n+++ /tmp/tmpkt5b9qp5.java\t2023-03-24 14:33:50.793746238 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+sumLengths(length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "!length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:52.613739541 +0100\n+++ /tmp/tmpiu8npkya.java\t2023-03-24 14:33:52.613739541 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+!length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "0) { length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:54.389733005 +0100\n+++ /tmp/tmp2jd4f1ti.java\t2023-03-24 14:33:54.389733005 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+0) { length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j,k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:56.193726367 +0100\n+++ /tmp/tmpclbxnv_7.java\t2023-03-24 14:33:56.197726354 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j,k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": ".max(length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:58.005719701 +0100\n+++ /tmp/tmpc6xoh82p.java\t2023-03-24 14:33:58.005719701 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+.max(length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "new HashSet<>(length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:33:59.793713118 +0100\n+++ /tmp/tmpb5j_1ria.java\t2023-03-24 14:33:59.793713118 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new HashSet<>(length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:01.601706465 +0100\n+++ /tmp/tmprp970qgo.java\t2023-03-24 14:34:01.601706465 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:03.409699810 +0100\n+++ /tmp/tmp5ri6rjr5.java\t2023-03-24 14:34:03.409699810 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (length_by_path.get(Arrays.asList(j,k)); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:05.633691625 +0100\n+++ /tmp/tmpwv4tmxj0.java\t2023-03-24 14:34:05.741691229 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.get(Arrays.asList(j,k)); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "+ (length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:07.385685177 +0100\n+++ /tmp/tmpsdoygrg7.java\t2023-03-24 14:34:07.385685177 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n++ (length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:09.229678389 +0100\n+++ /tmp/tmpfl5t8c5_.java\t2023-03-24 14:34:09.229678389 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (!length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:11.069671617 +0100\n+++ /tmp/tmpj3ms3sah.java\t2023-03-24 14:34:11.069671617 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (!length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "(count_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:13.981660895 +0100\n+++ /tmp/tmpsc8ws3m_.java\t2023-03-24 14:34:14.081660528 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(count_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j,k))); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:16.273652459 +0100\n+++ /tmp/tmpxm_770l0.java\t2023-03-24 14:34:16.273652459 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j,k))); }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "0) : length_by_path.get(Arrays.asList(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:18.473644360 +0100\n+++ /tmp/tmps36x5pn5.java\t2023-03-24 14:34:18.473644360 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+0) : length_by_path.get(Arrays.asList(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:20.641636376 +0100\n+++ /tmp/tmpffju5njn.java\t2023-03-24 14:34:20.717636096 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "\"length_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:23.105627303 +0100\n+++ /tmp/tmp7q0p05xv.java\t2023-03-24 14:34:23.109627290 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+\"length_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "\"count_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:25.605618098 +0100\n+++ /tmp/tmp2qh5p10z.java\t2023-03-24 14:34:25.605618098 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+\"count_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:27.653610558 +0100\n+++ /tmp/tmp6z3r83f7.java\t2023-03-24 14:34:27.653610558 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "new ArrayList<>(length_by_path.values().size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:29.285604546 +0100\n+++ /tmp/tmpcingprsm.java\t2023-03-24 14:34:29.285604546 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.values().size()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "(length_by_path.contains(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:31.153597667 +0100\n+++ /tmp/tmpqlbn_zsb.java\t2023-03-24 14:34:31.233597374 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.contains(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "numNodes.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:33.309589728 +0100\n+++ /tmp/tmpbo72bzu8.java\t2023-03-24 14:34:33.313589712 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+numNodes.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "to_by_path.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:36.117579387 +0100\n+++ /tmp/tmpssj_2ex1.java\t2023-03-24 14:34:36.281578780 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+to_by_path.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "new ArrayList<String>(length_by_path.size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:37.961572593 +0100\n+++ /tmp/tmppelsi7t9.java\t2023-03-24 14:34:37.961572593 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<String>(length_by_path.size()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "new ArrayList<>(length_by_path.size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:39.557566715 +0100\n+++ /tmp/tmpcauqeay3.java\t2023-03-24 14:34:39.557566715 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.size()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "new ArrayList<>(length_by_path.values().size())));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:41.565559318 +0100\n+++ /tmp/tmpxcw8cjyn.java\t2023-03-24 14:34:41.665558951 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.values().size())));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "Arrays.asList(get(i, k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:43.949550536 +0100\n+++ /tmp/tmp6n9a63it.java\t2023-03-24 14:34:43.949550536 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(get(i, k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "new ArrayList<>(), Arrays.asList(update_length));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:46.053542785 +0100\n+++ /tmp/tmpzovngfz5.java\t2023-03-24 14:34:46.077542698 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), Arrays.asList(update_length));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "new ArrayList<>(), Arrays.asList(update_length, k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:47.777536435 +0100\n+++ /tmp/tmp8sfc0cwu.java\t2023-03-24 14:34:47.781536419 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), Arrays.asList(update_length, k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "(length_by_path.get(Arrays.asList(j)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:49.673529449 +0100\n+++ /tmp/tmp046ck9mh.java\t2023-03-24 14:34:49.673529449 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.get(Arrays.asList(j)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "(length_by_path.size() - (length_by_length)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:51.945521078 +0100\n+++ /tmp/tmpheiyddmm.java\t2023-03-24 14:34:51.945521078 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.size() - (length_by_length)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "Arrays.asList(update_length, k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:54.237512635 +0100\n+++ /tmp/tmpam282obf.java\t2023-03-24 14:34:54.237512635 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(update_length, k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "buf.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:56.293505059 +0100\n+++ /tmp/tmp4vrkhv01.java\t2023-03-24 14:34:56.405504645 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+buf.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "new HashSet<String>(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:34:58.497496937 +0100\n+++ /tmp/tmpzndexudj.java\t2023-03-24 14:34:58.497496937 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new HashSet<String>(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "length_by_path.get(Arrays.asList(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:00.677488905 +0100\n+++ /tmp/tmppihirkmm.java\t2023-03-24 14:35:00.677488905 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+length_by_path.get(Arrays.asList(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "new ArrayList<String>(Arrays.asList(update_length, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:02.769481193 +0100\n+++ /tmp/tmpdsq9libd.java\t2023-03-24 14:35:02.805481063 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<String>(Arrays.asList(update_length, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "new ArrayList<>(length_by_path.values()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:05.017472911 +0100\n+++ /tmp/tmpgjez5nw9.java\t2023-03-24 14:35:05.017472911 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.values()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "new ArrayList<>(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:07.241464713 +0100\n+++ /tmp/tmpgg7cu8at.java\t2023-03-24 14:35:07.337464360 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "new ArrayList<String>(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:09.633455896 +0100\n+++ /tmp/tmpnowp2gn4.java\t2023-03-24 14:35:09.633455896 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<String>(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "numNodes.get(Arrays.asList(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:11.765448039 +0100\n+++ /tmp/tmpwkl6odnf.java\t2023-03-24 14:35:11.877447626 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+numNodes.get(Arrays.asList(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "e.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:13.805440519 +0100\n+++ /tmp/tmp1_77b0k4.java\t2023-03-24 14:35:13.805440519 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+e.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "Arrays.asList(get(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:15.845432999 +0100\n+++ /tmp/tmp2pecqww5.java\t2023-03-24 14:35:15.945432632 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(get(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "new ArrayList<>(), Arrays.asList(update_length, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:18.309423916 +0100\n+++ /tmp/tmpwdmm1crv.java\t2023-03-24 14:35:18.313423902 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), Arrays.asList(update_length, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "Arrays.asList(get(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:20.493415867 +0100\n+++ /tmp/tmp0ge00seh.java\t2023-03-24 14:35:20.493415867 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(get(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "Arrays.asList(get(i, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:22.529408361 +0100\n+++ /tmp/tmppeiefrf4.java\t2023-03-24 14:35:22.801407357 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(get(i, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "new ArrayList<>(Arrays.asList(update_length, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:25.325398053 +0100\n+++ /tmp/tmp9d1yhdvc.java\t2023-03-24 14:35:25.441397626 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(Arrays.asList(update_length, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "new ArrayList<>(length_by_path.values().length)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:27.473390132 +0100\n+++ /tmp/tmpxurp6p_b.java\t2023-03-24 14:35:27.701389291 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.values().length)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "new ArrayList<>(), new ArrayList<>(length_by_path.size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:29.941381034 +0100\n+++ /tmp/tmpvvjykh2z.java\t2023-03-24 14:35:29.945381017 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), new ArrayList<>(length_by_path.size()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "Arrays.asList(update_length, 0.0));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:32.197372716 +0100\n+++ /tmp/tmpby8r51gf.java\t2023-03-24 14:35:32.197372716 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(update_length, 0.0));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "\"get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:34.865362876 +0100\n+++ /tmp/tmpbh6xp_18.java\t2023-03-24 14:35:34.865362876 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+\"get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "output.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:36.949355192 +0100\n+++ /tmp/tmpedjd01iw.java\t2023-03-24 14:35:37.033354882 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+output.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "new ArrayList<>(), Arrays.asList(get(i, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:39.241346739 +0100\n+++ /tmp/tmp53iohiif.java\t2023-03-24 14:35:39.241346739 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), Arrays.asList(get(i, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "result.get(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:41.501338406 +0100\n+++ /tmp/tmp7fvuow3j.java\t2023-03-24 14:35:41.501338406 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+result.get(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "Arrays.asList(update_length,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:44.085328874 +0100\n+++ /tmp/tmp02qy82du.java\t2023-03-24 14:35:44.233328328 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(update_length,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (length_by_path.size() - 1; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:46.029321704 +0100\n+++ /tmp/tmpm8cbzbzu.java\t2023-03-24 14:35:46.029321704 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+if (length_by_path.size() - 1; }\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "new HashSet<>(Arrays.asList(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:47.805315155 +0100\n+++ /tmp/tmpnk_g6226.java\t2023-03-24 14:35:47.805315155 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new HashSet<>(Arrays.asList(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "new ArrayList<>(length_by_path.values()).size());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:49.649308352 +0100\n+++ /tmp/tmp2g490sdu.java\t2023-03-24 14:35:49.649308352 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(length_by_path.values()).size());\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "(length_by_path.size() - k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:51.501301520 +0100\n+++ /tmp/tmp08ad4yc3.java\t2023-03-24 14:35:51.501301520 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.size() - k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "Arrays.asList(get(i, k))));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:55.729285924 +0100\n+++ /tmp/tmp4nz0pyag.java\t2023-03-24 14:35:55.729285924 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(get(i, k))));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "Arrays.asList(get(i, k), false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:57.613278975 +0100\n+++ /tmp/tmp_naglbgk.java\t2023-03-24 14:35:57.613278975 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(get(i, k), false);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "(get(i, k) ));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:35:59.321272673 +0100\n+++ /tmp/tmpgqu1x50g.java\t2023-03-24 14:35:59.321272673 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(get(i, k) ));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "(length_by_path.size() - 1));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:01.109266078 +0100\n+++ /tmp/tmp8mlb901a.java\t2023-03-24 14:36:01.109266078 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(length_by_path.size() - 1));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "new ArrayList<>(Arrays.asList(update_length)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:02.845259673 +0100\n+++ /tmp/tmpsd2738gm.java\t2023-03-24 14:36:02.849259657 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(Arrays.asList(update_length)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "String.valueOf(get(i, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:04.653253002 +0100\n+++ /tmp/tmppppjoc4z.java\t2023-03-24 14:36:04.653253002 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+String.valueOf(get(i, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "Arrays.asList(get(i,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:06.453246361 +0100\n+++ /tmp/tmpi2y17h2f.java\t2023-03-24 14:36:06.453246361 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(get(i,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "new ArrayList<String>(numNodes.size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:08.205239897 +0100\n+++ /tmp/tmpkqgy5x74.java\t2023-03-24 14:36:08.205239897 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<String>(numNodes.size()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "new ArrayList<>(), new ArrayList<>(numNodes));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:10.017233210 +0100\n+++ /tmp/tmpowcl_aj9.java\t2023-03-24 14:36:10.017233210 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), new ArrayList<>(numNodes));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "new File(get(i, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:11.841226480 +0100\n+++ /tmp/tmp4f6t3ahv.java\t2023-03-24 14:36:11.841226480 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new File(get(i, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "Collections.singleton(null, new ArrayList<>()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:13.693219646 +0100\n+++ /tmp/tmpthgaff4x.java\t2023-03-24 14:36:13.693219646 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Collections.singleton(null, new ArrayList<>()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "new int[numNodes.size()];",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:15.429213240 +0100\n+++ /tmp/tmpclahq_r0.java\t2023-03-24 14:36:15.429213240 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new int[numNodes.size()];\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "Arrays.asList(update_length, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:17.201206699 +0100\n+++ /tmp/tmpbl2e9brf.java\t2023-03-24 14:36:17.205206686 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(update_length, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "Arrays.asList(update_length));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:19.133199571 +0100\n+++ /tmp/tmpg580bcv5.java\t2023-03-24 14:36:19.133199571 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(update_length));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "new ArrayList<>(get(i, k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:20.893193075 +0100\n+++ /tmp/tmpuwb8ps11.java\t2023-03-24 14:36:20.893193075 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(get(i, k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "new ArrayList<>(numNodes.size()));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:22.605186755 +0100\n+++ /tmp/tmp8squtgnn.java\t2023-03-24 14:36:22.621186698 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(numNodes.size()));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "new File(get(i, k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:24.433180010 +0100\n+++ /tmp/tmpzs2ad9_u.java\t2023-03-24 14:36:24.433180010 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new File(get(i, k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "(in_length - k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:26.277173204 +0100\n+++ /tmp/tmp8vrvfm0k.java\t2023-03-24 14:36:26.277173204 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(in_length - k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "new ArrayList<>(), update_length);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:28.045166678 +0100\n+++ /tmp/tmp2bwco9tj.java\t2023-03-24 14:36:28.045166678 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), update_length);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "new ArrayList<>(numNodes));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:29.769160313 +0100\n+++ /tmp/tmpd5omlt4n.java\t2023-03-24 14:36:29.769160313 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(numNodes));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "new ArrayList<>(), false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:31.469154038 +0100\n+++ /tmp/tmp41mau1lm.java\t2023-03-24 14:36:31.469154038 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>(), false);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "Arrays.asList(numNodes));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:33.185147705 +0100\n+++ /tmp/tmppw53bpiq.java\t2023-03-24 14:36:33.185147705 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(numNodes));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "Arrays.asList(index,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:34.989141044 +0100\n+++ /tmp/tmpo3jffevg.java\t2023-03-24 14:36:34.989141044 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+Arrays.asList(index,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "\"get(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:36.845134194 +0100\n+++ /tmp/tmpxx56m5xs.java\t2023-03-24 14:36:36.845134194 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+\"get(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "(get(j,k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:38.705127326 +0100\n+++ /tmp/tmph3ps_v96.java\t2023-03-24 14:36:38.705127326 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(get(j,k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "\"get(k,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:40.545120533 +0100\n+++ /tmp/tmp5s9ds3p6.java\t2023-03-24 14:36:40.545120533 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+\"get(k,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "+ (numNodes - k)));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:42.289114095 +0100\n+++ /tmp/tmphavto3lp.java\t2023-03-24 14:36:42.289114095 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n++ (numNodes - k)));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "(get(j,k));",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:46.617098115 +0100\n+++ /tmp/tmpbnor1m4x.java\t2023-03-24 14:36:46.617098115 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+(get(j,k));\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "new ArrayList<>());",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:48.329091794 +0100\n+++ /tmp/tmp_1hd106_.java\t2023-03-24 14:36:48.333091781 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+new ArrayList<>());\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "true, false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:50.065085384 +0100\n+++ /tmp/tmpbzv5_gam.java\t2023-03-24 14:36:50.065085384 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+true, false);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "0)!= 0.0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:51.745079180 +0100\n+++ /tmp/tmplpun46dw.java\t2023-03-24 14:36:51.745079180 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+0)!= 0.0;\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "0d);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:53.485072757 +0100\n+++ /tmp/tmpqvz063qy.java\t2023-03-24 14:36:53.485072757 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+0d);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "false);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:55.229066315 +0100\n+++ /tmp/tmp9qwyf6ks.java\t2023-03-24 14:36:55.229066315 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+false);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "0.0);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:56.973059875 +0100\n+++ /tmp/tmpumhj0_z3.java\t2023-03-24 14:36:56.973059875 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+0.0);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "true);",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:36:58.765053259 +0100\n+++ /tmp/tmp8hv6w6t8.java\t2023-03-24 14:36:58.769053242 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+true);\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "-1;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:37:00.509046817 +0100\n+++ /tmp/tmprcorsnpk.java\t2023-03-24 14:37:00.509046817 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+-1;\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "0;",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:37:02.265040331 +0100\n+++ /tmp/tmppygb023s.java\t2023-03-24 14:37:02.265040331 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+0;\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": ";",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:37:03.961034069 +0100\n+++ /tmp/tmpxhbxlfjl.java\t2023-03-24 14:37:03.961034069 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+;\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/shortest_path_lengths/java_programs/SHORTEST_PATH_LENGTHS.java\t2023-03-24 14:37:05.729027540 +0100\n+++ /tmp/tmpa39w2m64.java\t2023-03-24 14:37:05.729027540 +0100\n@@ -32,11 +32,11 @@\n         for (int k = 0; k < numNodes; k++) {\n             for (int i = 0; i < numNodes; i++) {\n                 for (int j = 0; j < numNodes; j++) {\n                     int update_length = Math.min(length_by_path.get(Arrays.asList(i,j)),\n                                                  sumLengths(length_by_path.get(Arrays.asList(i,k)),\n-                                                            length_by_path.get(Arrays.asList(j,k))));\n+\n                     length_by_path.put(Arrays.asList(i,j), update_length);\n                 }\n             }\n         }\n         return length_by_path;\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "length_by_path.get(Arrays.asList(k,j))));"
    },
    "next_permutation": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (i!= j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:11.169007447 +0100\n+++ /tmp/tmptbfszi0y.java\t2023-03-24 14:37:11.181007400 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (i!= j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (j.get(i) < perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:15.408991783 +0100\n+++ /tmp/tmp36_cmzl4.java\t2023-03-24 14:37:15.408991783 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) < perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (next_perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:17.280984869 +0100\n+++ /tmp/tmpiyaazkpb.java\t2023-03-24 14:37:17.280984869 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (!next_perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:19.108978115 +0100\n+++ /tmp/tmpp56wmk4a.java\t2023-03-24 14:37:19.108978115 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (j >= perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:20.968971246 +0100\n+++ /tmp/tmpexsktg4c.java\t2023-03-24 14:37:20.968971246 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (next_perm.get(j) < perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:25.164955744 +0100\n+++ /tmp/tmpa7iabl5s.java\t2023-03-24 14:37:25.164955744 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) < perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (j >= perm.get(i) && perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:26.888949373 +0100\n+++ /tmp/tmp8wvnzb2x.java\t2023-03-24 14:37:26.888949373 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(i) && perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if (!next_perm.get(j) < perm.get(i))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:28.700942678 +0100\n+++ /tmp/tmpyshs3sgn.java\t2023-03-24 14:37:28.700942678 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) < perm.get(i))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (next_perm.get(j) > perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:30.420936324 +0100\n+++ /tmp/tmpcsqe8fat.java\t2023-03-24 14:37:30.420936324 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) > perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (j >= perm.get(j) && perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:32.300929379 +0100\n+++ /tmp/tmpgwdenu3t.java\t2023-03-24 14:37:32.300929379 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(j) && perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (j < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:34.084922787 +0100\n+++ /tmp/tmpj3i8mlh4.java\t2023-03-24 14:37:34.088922770 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (j < perm.get(i) && perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:39.220903808 +0100\n+++ /tmp/tmplct1o74o.java\t2023-03-24 14:37:39.220903808 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i) && perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (j.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:40.880897672 +0100\n+++ /tmp/tmp0b0odxrr.java\t2023-03-24 14:37:40.880897672 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (j > perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:42.672891050 +0100\n+++ /tmp/tmpozjdugq6.java\t2023-03-24 14:37:42.672891050 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (j < perm.get(j) && perm.get(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:44.600883927 +0100\n+++ /tmp/tmp7y0_d3s9.java\t2023-03-24 14:37:44.600883927 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j) && perm.get(i); }\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (j > perm.get(j) < have.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:46.400877275 +0100\n+++ /tmp/tmpdfakymek.java\t2023-03-24 14:37:46.400877275 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > perm.get(j) < have.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (j.get(i) < perm.get(j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:48.232870504 +0100\n+++ /tmp/tmprs4h_1z9.java\t2023-03-24 14:37:48.232870504 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) < perm.get(j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (j >= perm.get(j) && perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:49.992864000 +0100\n+++ /tmp/tmpq214zjck.java\t2023-03-24 14:37:49.992864000 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(j) && perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (j < perm.get(j) <= perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:51.936856813 +0100\n+++ /tmp/tmpqkap_w9e.java\t2023-03-24 14:37:51.936856813 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j) <= perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (j < perm.get(j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:53.784849983 +0100\n+++ /tmp/tmpo_sbanro.java\t2023-03-24 14:37:53.784849983 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (Next_perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:55.564843406 +0100\n+++ /tmp/tmp95fegxjl.java\t2023-03-24 14:37:55.568843389 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (Next_perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (j >= perm.get(j) && perm.get(i); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:57.444836456 +0100\n+++ /tmp/tmpxgfb78m_.java\t2023-03-24 14:37:57.444836456 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(j) && perm.get(i); }\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (j.get(i) < perm.get(j)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:37:59.136830202 +0100\n+++ /tmp/tmpro3dcxdf.java\t2023-03-24 14:37:59.136830202 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) < perm.get(j)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (!next_perm.get(j) < perm.get(i)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:00.936823549 +0100\n+++ /tmp/tmpbktbr5e6.java\t2023-03-24 14:38:00.936823549 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) < perm.get(i)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (j.get(i) <= perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:02.696817041 +0100\n+++ /tmp/tmpivniw55e.java\t2023-03-24 14:38:02.696817041 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) <= perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (j < perm.get(i) || perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:04.560810152 +0100\n+++ /tmp/tmpvvtfep_i.java\t2023-03-24 14:38:04.560810152 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i) || perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (!next_perm.get(j) < perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:06.496802994 +0100\n+++ /tmp/tmpcylbcm94.java\t2023-03-24 14:38:06.496802994 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) < perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (j > perm.get(i) < perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:08.300796325 +0100\n+++ /tmp/tmpzxtaodd3.java\t2023-03-24 14:38:08.300796325 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > perm.get(i) < perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (j > perm.get(i) < have.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:10.132789552 +0100\n+++ /tmp/tmpbfx8xmca.java\t2023-03-24 14:38:10.132789552 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > perm.get(i) < have.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (j < perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:12.068782395 +0100\n+++ /tmp/tmpx6yv9zgn.java\t2023-03-24 14:38:12.072782382 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (j < perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:16.336766617 +0100\n+++ /tmp/tmp0ke0_k_g.java\t2023-03-24 14:38:16.336766617 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (next_perm.get(j)!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:18.096760108 +0100\n+++ /tmp/tmpm9ym_7vk.java\t2023-03-24 14:38:18.096760108 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j)!= null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (j >= perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:19.992753097 +0100\n+++ /tmp/tmpjrnlwfnu.java\t2023-03-24 14:38:19.996753084 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (next_perm.get(j) < perm.get(i))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:24.296737185 +0100\n+++ /tmp/tmpwhs8ezf7.java\t2023-03-24 14:38:24.296737185 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) < perm.get(i))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (j.get(i) < perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:26.028730779 +0100\n+++ /tmp/tmpgk6_gym7.java\t2023-03-24 14:38:26.028730779 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) < perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (j < perm.get(i) <= perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:27.788724271 +0100\n+++ /tmp/tmpb6uretcp.java\t2023-03-24 14:38:27.792724258 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i) <= perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (previous_perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:29.648717394 +0100\n+++ /tmp/tmpsml_5nm2.java\t2023-03-24 14:38:29.648717394 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (previous_perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (j < perm.get(j) || perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:31.452710723 +0100\n+++ /tmp/tmpcug86g77.java\t2023-03-24 14:38:31.452710723 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j) || perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (next_perm.get(j) < perm.get(i+1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:33.308703860 +0100\n+++ /tmp/tmpkfr5vzg7.java\t2023-03-24 14:38:33.308703860 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) < perm.get(i+1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (Next_perm.get(j) < perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:35.148697053 +0100\n+++ /tmp/tmppof_mzt_.java\t2023-03-24 14:38:35.148697053 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (Next_perm.get(j) < perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (j.get(j) < perm.get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:36.872690679 +0100\n+++ /tmp/tmpgz7o1sw1.java\t2023-03-24 14:38:36.892690605 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) < perm.get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (!next_perm.get(j) < perm.get(i+1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:38.652684094 +0100\n+++ /tmp/tmp1aqzcq_x.java\t2023-03-24 14:38:38.656684081 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) < perm.get(i+1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (j.get(i) < have.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:40.416677571 +0100\n+++ /tmp/tmpywaf4v4p.java\t2023-03-24 14:38:40.416677571 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) < have.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (next_perm.get(j) < perm.get(i)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:42.280670678 +0100\n+++ /tmp/tmph31m1_2p.java\t2023-03-24 14:38:42.280670678 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) < perm.get(i)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (first_perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:44.036664181 +0100\n+++ /tmp/tmpz1yw0yhe.java\t2023-03-24 14:38:44.036664181 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (first_perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (j.get(i) > perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:45.888657332 +0100\n+++ /tmp/tmpirsi_t9y.java\t2023-03-24 14:38:45.892657319 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) > perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (j.get(i) < perm.get(j')) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:47.828650158 +0100\n+++ /tmp/tmp0sumivzj.java\t2023-03-24 14:38:47.828650158 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) < perm.get(j')) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (!next_perm.get(j) < have.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:49.656643395 +0100\n+++ /tmp/tmpxv63wwwp.java\t2023-03-24 14:38:49.656643395 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) < have.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (!first_perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:51.536636440 +0100\n+++ /tmp/tmp7ur2ghnu.java\t2023-03-24 14:38:51.536636440 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!first_perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (j!= perm.get(j) < have.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:53.376629634 +0100\n+++ /tmp/tmpvy5xb0ez.java\t2023-03-24 14:38:53.380629621 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j!= perm.get(j) < have.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (next_perm.get(j) == perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:55.232622770 +0100\n+++ /tmp/tmpt6wlx8gu.java\t2023-03-24 14:38:55.236622753 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) == perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (j > i || j < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:38:57.004616214 +0100\n+++ /tmp/tmpxvjxxvu6.java\t2023-03-24 14:38:57.004616214 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > i || j < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if (Next_perm.get(j) < perm.get(i+1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:01.900598102 +0100\n+++ /tmp/tmpi68pr8o3.java\t2023-03-24 14:39:01.900598102 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (Next_perm.get(j) < perm.get(i+1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (!next_perm.get(j) instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:03.652591620 +0100\n+++ /tmp/tmp45yck93y.java\t2023-03-24 14:39:03.656591607 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) instanceof Integer)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (i!= j - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:05.820583599 +0100\n+++ /tmp/tmpodl6swt3.java\t2023-03-24 14:39:05.820583599 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (i!= j - 1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (j > perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:11.152563871 +0100\n+++ /tmp/tmpnpw6119h.java\t2023-03-24 14:39:11.152563871 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (file.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:15.500547786 +0100\n+++ /tmp/tmp622ky5op.java\t2023-03-24 14:39:15.500547786 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (file.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (perm.get(j) < perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:17.384540813 +0100\n+++ /tmp/tmporwi20lg.java\t2023-03-24 14:39:17.384540813 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (perm.get(j) < perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (file.get(j) <= perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:22.796520788 +0100\n+++ /tmp/tmpzfpk7qtb.java\t2023-03-24 14:39:22.840520625 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (file.get(j) <= perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (next_perm.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:24.672513846 +0100\n+++ /tmp/tmpgm_4rjea.java\t2023-03-24 14:39:24.672513846 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (next_perm.get(j)!= i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:27.284504180 +0100\n+++ /tmp/tmp_o34slap.java\t2023-03-24 14:39:27.292504150 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j)!= i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (j < perm.get(j).get(i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:29.152497267 +0100\n+++ /tmp/tmp6ipg3kiw.java\t2023-03-24 14:39:29.152497267 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j).get(i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (!next_perm.get(j) > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:31.368489066 +0100\n+++ /tmp/tmp4t4vieb3.java\t2023-03-24 14:39:31.404488931 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (!next_perm.get(j) == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:33.528481072 +0100\n+++ /tmp/tmpwevttbez.java\t2023-03-24 14:39:33.528481072 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j) == i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (j.get(i) <= perm.get(j)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:35.696473047 +0100\n+++ /tmp/tmpumn51uoc.java\t2023-03-24 14:39:35.700473034 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) <= perm.get(j)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (j.get(i)!= j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:38.064464282 +0100\n+++ /tmp/tmpaq_hmgjy.java\t2023-03-24 14:39:38.064464282 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i)!= j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (next_perm.get(j)!= j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:40.496455281 +0100\n+++ /tmp/tmps1z469s2.java\t2023-03-24 14:39:40.496455281 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j)!= j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (j < perm.get(i).get(j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:42.756446916 +0100\n+++ /tmp/tmpjav6e5yu.java\t2023-03-24 14:39:42.760446903 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i).get(j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (j < perm.get(j)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:44.920438909 +0100\n+++ /tmp/tmpgouzp01j.java\t2023-03-24 14:39:45.236437737 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": true,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (j > i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:50.492418283 +0100\n+++ /tmp/tmpu4_ums06.java\t2023-03-24 14:39:50.496418266 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (j < perm.size() - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:39:55.292400513 +0100\n+++ /tmp/tmpcw00l452.java\t2023-03-24 14:39:55.292400513 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.size() - 1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (j.get(j) < perm.get(i)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:00.796380138 +0100\n+++ /tmp/tmpzgp_v7lf.java\t2023-03-24 14:40:00.796380138 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(j) < perm.get(i)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (j.get(i) > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:03.204371222 +0100\n+++ /tmp/tmpaxfgdghg.java\t2023-03-24 14:40:03.204371222 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j.get(i) > j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if (rowIndices[i] < perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:06.436359256 +0100\n+++ /tmp/tmpoo3ayrqc.java\t2023-03-24 14:40:06.436359256 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (rowIndices[i] < perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (!next_perm.get(j).isCoded()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:08.748350696 +0100\n+++ /tmp/tmpmflx4su3.java\t2023-03-24 14:40:08.748350696 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!next_perm.get(j).isCoded()) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (j!= i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:10.928342625 +0100\n+++ /tmp/tmp7oelsx5k.java\t2023-03-24 14:40:10.928342625 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j!= i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (j > perm.get(j)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:17.096319790 +0100\n+++ /tmp/tmpa4ain3cp.java\t2023-03-24 14:40:17.096319790 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > perm.get(j)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (!(j instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:21.420303778 +0100\n+++ /tmp/tmp3eje0j3f.java\t2023-03-24 14:40:21.424303761 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!(j instanceof Integer)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (j < perm.get(i) - 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:23.344296654 +0100\n+++ /tmp/tmpa6wyb32j.java\t2023-03-24 14:40:23.344296654 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i) - 1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (j < perm.get(j) == null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:28.188278714 +0100\n+++ /tmp/tmpa2bw0uu7.java\t2023-03-24 14:40:28.188278714 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j) == null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (next_perm.get(j) == i) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:30.344270731 +0100\n+++ /tmp/tmpfu60or2e.java\t2023-03-24 14:40:30.344270731 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (next_perm.get(j) == i) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (!(j.get(i) instanceof Integer)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:32.564262508 +0100\n+++ /tmp/tmp4evqd8vx.java\t2023-03-24 14:40:32.564262508 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (!(j.get(i) instanceof Integer)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (j <= perm.get(i)) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:34.676254688 +0100\n+++ /tmp/tmpvs830u98.java\t2023-03-24 14:40:34.676254688 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j <= perm.get(i)) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (j >= perm.get(j)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:40.048234791 +0100\n+++ /tmp/tmpn6ci89ah.java\t2023-03-24 14:40:40.048234791 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(j)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (j < perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:44.240219264 +0100\n+++ /tmp/tmpg8o2bubj.java\t2023-03-24 14:40:44.240219264 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (j < perm.get(j+1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:46.100212377 +0100\n+++ /tmp/tmpko8wdmch.java\t2023-03-24 14:40:46.100212377 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j+1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (j < perm.get(j)] {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:47.768206197 +0100\n+++ /tmp/tmpqtkla8xn.java\t2023-03-24 14:40:47.772206184 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(j)] {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (j < perm.get(i)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:49.496199798 +0100\n+++ /tmp/tmpdrz9_264.java\t2023-03-24 14:40:49.496199798 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (j >= perm.get(j))) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:53.612184552 +0100\n+++ /tmp/tmpauaywc8z.java\t2023-03-24 14:40:53.612184552 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(j))) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (j < perm.get(i+1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:55.380178003 +0100\n+++ /tmp/tmpm31_19i6.java\t2023-03-24 14:40:55.380178003 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j < perm.get(i+1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (j!=null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:57.124171541 +0100\n+++ /tmp/tmppzf0vcng.java\t2023-03-24 14:40:57.128171528 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j!=null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (j >= perm.get(i)){",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:40:59.024164502 +0100\n+++ /tmp/tmpjqq6lx2j.java\t2023-03-24 14:40:59.024164502 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.get(i)){\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (get(j)!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:03.400148291 +0100\n+++ /tmp/tmpud5e4h6y.java\t2023-03-24 14:41:03.400148291 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (get(j)!= null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (i > j) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:05.276141342 +0100\n+++ /tmp/tmpaw83m8ao.java\t2023-03-24 14:41:05.276141342 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (i > j) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (j >= perm.size()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:09.364126197 +0100\n+++ /tmp/tmp8w9gbi97.java\t2023-03-24 14:41:09.364126197 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j >= perm.size()) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (log.isDebugEnabled()) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:13.520110800 +0100\n+++ /tmp/tmppufj8pnx.java\t2023-03-24 14:41:13.520110800 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (log.isDebugEnabled()) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (i!= j + 1) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:15.356103997 +0100\n+++ /tmp/tmpmu1qd5au.java\t2023-03-24 14:41:15.356103997 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (i!= j + 1) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (j instanceof Integer) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:19.596088290 +0100\n+++ /tmp/tmp48mpujqx.java\t2023-03-24 14:41:19.600088273 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j instanceof Integer) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (j!= null) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:21.532081116 +0100\n+++ /tmp/tmp3pps3231.java\t2023-03-24 14:41:21.532081116 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j!= null) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (j > i--) {",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/next_permutation/java_programs/NEXT_PERMUTATION.java\t2023-03-24 14:41:23.404074178 +0100\n+++ /tmp/tmpg57vxz1d.java\t2023-03-24 14:41:23.408074165 +0100\n@@ -14,11 +14,11 @@\n public class NEXT_PERMUTATION {\n     public static ArrayList<Integer> next_permutation(ArrayList<Integer> perm) {\n         for (int i=perm.size()-2; i!=-1; i--) {\n             if (perm.get(i) < perm.get(i+1)) {\n                 for (int j=perm.size()-1; j!=i; j--) {\n-                    if (perm.get(j) < perm.get(i)) {\n+if (j > i--) {\n                         ArrayList<Integer> next_perm = perm;\n                         int temp_j = perm.get(j);\n                         int temp_i = perm.get(i);\n                         next_perm.set(i,temp_j);\n                         next_perm.set(j,temp_i);\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "if (perm.get(j) > perm.get(i)) {"
    },
    "rpn_eval": {
        "patches": [
            {
                "k": 1,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:37:40.724898251 +0100\n+++ /tmp/tmptqst5q8z.java\t2023-03-24 14:37:40.748898160 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 2,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:37:44.856882979 +0100\n+++ /tmp/tmpiap18tpy.java\t2023-03-24 14:37:44.856882979 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 3,
                "tentative_fix": "if (bin_op.equals(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:37:48.864868167 +0100\n+++ /tmp/tmptasz39ff.java\t2023-03-24 14:37:48.864868167 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.equals(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 4,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:37:52.984852939 +0100\n+++ /tmp/tmp0ksbwdh9.java\t2023-03-24 14:37:52.984852939 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = b; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 5,
                "tentative_fix": "if (bin_op.get(a)!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:37:57.104837713 +0100\n+++ /tmp/tmpp_9jbejw.java\t2023-03-24 14:37:57.104837713 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a)!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 6,
                "tentative_fix": "if (bin_op.get(a) == null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:37:58.864831206 +0100\n+++ /tmp/tmpqxqwxho4.java\t2023-03-24 14:37:58.868831193 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a) == null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 7,
                "tentative_fix": "if (bin_op.hasValue()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:00.692824449 +0100\n+++ /tmp/tmpqsv292yi.java\t2023-03-24 14:38:00.692824449 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasValue()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 8,
                "tentative_fix": "if ( bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:02.500817766 +0100\n+++ /tmp/tmpphcccimy.java\t2023-03-24 14:38:02.500817766 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 9,
                "tentative_fix": "if (bin_op.get(a) <= b) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:06.672802343 +0100\n+++ /tmp/tmpyy7yg2q3.java\t2023-03-24 14:38:06.672802343 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a) <= b) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 10,
                "tentative_fix": "if (bin_op.equals(b)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:08.476795676 +0100\n+++ /tmp/tmpi0fwb468.java\t2023-03-24 14:38:08.476795676 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.equals(b)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 11,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = null; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:12.596780443 +0100\n+++ /tmp/tmpoylorp_5.java\t2023-03-24 14:38:12.596780443 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = null; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 12,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = 0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:16.768765018 +0100\n+++ /tmp/tmpi583i1se.java\t2023-03-24 14:38:16.768765018 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = 0; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 13,
                "tentative_fix": "if (bin_op!=null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:18.472758718 +0100\n+++ /tmp/tmpdy7a1qx7.java\t2023-03-24 14:38:18.476758705 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!=null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 14,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = \"-\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:22.508743796 +0100\n+++ /tmp/tmp5fbrvxv4.java\t2023-03-24 14:38:22.508743796 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = \"-\"; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 15,
                "tentative_fix": "if (bin_op.get(a) == b) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:24.336737035 +0100\n+++ /tmp/tmp_ihfs3h8.java\t2023-03-24 14:38:24.336737035 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a) == b) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 16,
                "tentative_fix": "if (bin_op.equals(a)) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:26.064730646 +0100\n+++ /tmp/tmpt8ossvgi.java\t2023-03-24 14:38:26.064730646 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.equals(a)) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 17,
                "tentative_fix": "if (bin_op.get(a)).equals(b)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:30.128715619 +0100\n+++ /tmp/tmpaqpqllx6.java\t2023-03-24 14:38:30.128715619 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a)).equals(b)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 18,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = 0.0; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:31.828709331 +0100\n+++ /tmp/tmp0w3mcpj_.java\t2023-03-24 14:38:31.828709331 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = 0.0; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 19,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = n; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:35.900694274 +0100\n+++ /tmp/tmpvdllwz0q.java\t2023-03-24 14:38:35.904694258 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = n; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 20,
                "tentative_fix": "if (bin_op.contains(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:37.708687588 +0100\n+++ /tmp/tmphmtrbyd7.java\t2023-03-24 14:38:37.708687588 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.contains(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 21,
                "tentative_fix": "if (bin_op.has(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:39.532680841 +0100\n+++ /tmp/tmp0p8anwil.java\t2023-03-24 14:38:39.532680841 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.has(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 22,
                "tentative_fix": "if (bin_op.hasNonNull(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:41.320674227 +0100\n+++ /tmp/tmpm6zl5xga.java\t2023-03-24 14:38:41.324674214 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasNonNull(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 23,
                "tentative_fix": "if (bin_op.hasColon()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:43.080667717 +0100\n+++ /tmp/tmpee5zt0bp.java\t2023-03-24 14:38:43.080667717 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasColon()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 24,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a, b); } else { c = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:44.824661267 +0100\n+++ /tmp/tmp1009clj2.java\t2023-03-24 14:38:44.824661267 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a, b); } else { c = b; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 25,
                "tentative_fix": "if (bin_op.get(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:48.704646918 +0100\n+++ /tmp/tmpc38vat1e.java\t2023-03-24 14:38:48.708646901 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 26,
                "tentative_fix": "if (bin_op.get(a) == 0.0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:50.468640391 +0100\n+++ /tmp/tmp258w46tm.java\t2023-03-24 14:38:50.468640391 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a) == 0.0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 27,
                "tentative_fix": "if (bin_op.hasCoordinates()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:52.172634087 +0100\n+++ /tmp/tmp20lsu8nl.java\t2023-03-24 14:38:52.172634087 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasCoordinates()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 28,
                "tentative_fix": "if (bin_op.compareTo(a) <= 0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:53.936627565 +0100\n+++ /tmp/tmpzp5lwe6n.java\t2023-03-24 14:38:53.936627565 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.compareTo(a) <= 0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 29,
                "tentative_fix": "if (bin_op!= null && bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:55.752620845 +0100\n+++ /tmp/tmpg5wnl8yv.java\t2023-03-24 14:38:55.752620845 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null && bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 30,
                "tentative_fix": "if (bin_op.get(a) < b) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:38:59.908605472 +0100\n+++ /tmp/tmp_1ng5a7s.java\t2023-03-24 14:38:59.908605472 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a) < b) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 31,
                "tentative_fix": "if (bin_op.get(a).equals(b)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:01.496599597 +0100\n+++ /tmp/tmppj6kzjqx.java\t2023-03-24 14:39:01.496599597 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a).equals(b)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 32,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = value; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:03.644591649 +0100\n+++ /tmp/tmpz_ippj7n.java\t2023-03-24 14:39:03.644591649 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = value; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 33,
                "tentative_fix": "if (r_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:05.836583539 +0100\n+++ /tmp/tmpk84qtj1k.java\t2023-03-24 14:39:05.836583539 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (r_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 34,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { break; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:08.380574127 +0100\n+++ /tmp/tmpgj0sap3k.java\t2023-03-24 14:39:08.384574114 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { break; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 35,
                "tentative_fix": "if (bin_op.get(a) <= b) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:15.268548642 +0100\n+++ /tmp/tmpamtchcvh.java\t2023-03-24 14:39:15.272548629 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a) <= b) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 36,
                "tentative_fix": "if (bin_op.hasDescendant(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:17.320541052 +0100\n+++ /tmp/tmpfj421dnp.java\t2023-03-24 14:39:17.320541052 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasDescendant(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 37,
                "tentative_fix": "if (bin_op.get(a)!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:19.832531754 +0100\n+++ /tmp/tmpkp9tax5j.java\t2023-03-24 14:39:19.832531754 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a)!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 38,
                "tentative_fix": "if (bin_op.get(a) == null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:21.800524472 +0100\n+++ /tmp/tmpmsx6n844.java\t2023-03-24 14:39:21.800524472 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a) == null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 39,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = \"\"; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:24.676513829 +0100\n+++ /tmp/tmppcp8y2zb.java\t2023-03-24 14:39:24.676513829 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = \"\"; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 40,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = time; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:26.960505379 +0100\n+++ /tmp/tmp_xjbw2z0.java\t2023-03-24 14:39:26.964505362 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = time; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 41,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = false; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:29.372496453 +0100\n+++ /tmp/tmpocvkhojy.java\t2023-03-24 14:39:29.376496437 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = false; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 42,
                "tentative_fix": "if (bin_op.apply(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:31.832487349 +0100\n+++ /tmp/tmpzsovv0kn.java\t2023-03-24 14:39:31.832487349 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.apply(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 43,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { current = b; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:33.624480717 +0100\n+++ /tmp/tmpatopq1oz.java\t2023-03-24 14:39:33.624480717 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { current = b; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 44,
                "tentative_fix": "if (bin_op.matcher(a).matches()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:36.024471835 +0100\n+++ /tmp/tmp6ljkotlx.java\t2023-03-24 14:39:36.024471835 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.matcher(a).matches()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 45,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = string; }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:38.328463306 +0100\n+++ /tmp/tmpbug8nycx.java\t2023-03-24 14:39:38.328463306 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { c = string; }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 46,
                "tentative_fix": "if (bin_op.compareTo(a) >= 0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:40.308455979 +0100\n+++ /tmp/tmp354_b2wv.java\t2023-03-24 14:39:40.308455979 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.compareTo(a) >= 0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 47,
                "tentative_fix": "if (bin_op!= null && a.equals(b)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:43.000446013 +0100\n+++ /tmp/tmpelyaqi65.java\t2023-03-24 14:39:43.004445999 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null && a.equals(b)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 48,
                "tentative_fix": "if (bin_op.isPresent()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:48.192426797 +0100\n+++ /tmp/tmp9n0in1h2.java\t2023-03-24 14:39:48.192426797 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isPresent()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 49,
                "tentative_fix": "if (bin_op.test(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:50.280419066 +0100\n+++ /tmp/tmpu4nvrcgo.java\t2023-03-24 14:39:50.284419053 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.test(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 50,
                "tentative_fix": "if (bin_op.hasTraceId()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:52.584410539 +0100\n+++ /tmp/tmpxcf56y16.java\t2023-03-24 14:39:52.588410522 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasTraceId()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 51,
                "tentative_fix": "if (bin_op.equalsIgnoreCase(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:54.656402867 +0100\n+++ /tmp/tmp_i1b5onj.java\t2023-03-24 14:39:54.656402867 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.equalsIgnoreCase(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 52,
                "tentative_fix": "if (bin_op.get(a), b) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:56.820394858 +0100\n+++ /tmp/tmpl_st3dwd.java\t2023-03-24 14:39:56.820394858 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.get(a), b) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 53,
                "tentative_fix": "if ( bin_op!= null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:39:59.036386653 +0100\n+++ /tmp/tmpgbzn8vpe.java\t2023-03-24 14:39:59.036386653 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if ( bin_op!= null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 54,
                "tentative_fix": "if (bin_op.hasDot) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:03.992368307 +0100\n+++ /tmp/tmprhzurzk4.java\t2023-03-24 14:40:03.992368307 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasDot) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 55,
                "tentative_fix": "if (bin_op.hasText()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:06.428359286 +0100\n+++ /tmp/tmpndnnn4ws.java\t2023-03-24 14:40:06.428359286 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasText()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 56,
                "tentative_fix": "if (bin_op.hasValue()) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:08.716350815 +0100\n+++ /tmp/tmplfnr80wf.java\t2023-03-24 14:40:08.716350815 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasValue()) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 57,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:10.928342625 +0100\n+++ /tmp/tmpgmbl3dp7.java\t2023-03-24 14:40:10.928342625 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 58,
                "tentative_fix": "if (bin_op.hasAttribute(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:16.488322041 +0100\n+++ /tmp/tmplpbpvu7z.java\t2023-03-24 14:40:16.488322041 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasAttribute(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 59,
                "tentative_fix": "if (r_op.equals(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:18.596314235 +0100\n+++ /tmp/tmpg1l373tl.java\t2023-03-24 14:40:18.596314235 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (r_op.equals(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 60,
                "tentative_fix": "if (bin_op.hasKey(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:20.688306487 +0100\n+++ /tmp/tmp5vva8b_0.java\t2023-03-24 14:40:20.744306281 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasKey(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 61,
                "tentative_fix": "if (bin_op.hasTraceId(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:23.312296770 +0100\n+++ /tmp/tmpo5hj7v7n.java\t2023-03-24 14:40:23.312296770 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasTraceId(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 62,
                "tentative_fix": "if (bin_op!= 0.0) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:25.460288816 +0100\n+++ /tmp/tmpdtuzioah.java\t2023-03-24 14:40:25.460288816 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= 0.0) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 63,
                "tentative_fix": "if (bin_op.pattern().equals(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:28.260278449 +0100\n+++ /tmp/tmp_fizfowd.java\t2023-03-24 14:40:28.260278449 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.pattern().equals(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 64,
                "tentative_fix": "if (bin_op.matches(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:30.344270731 +0100\n+++ /tmp/tmp449wv0ps.java\t2023-03-24 14:40:30.344270731 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.matches(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 65,
                "tentative_fix": "if (bin_op.isSuccessful()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:33.136260390 +0100\n+++ /tmp/tmpu0litbo4.java\t2023-03-24 14:40:33.136260390 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isSuccessful()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 66,
                "tentative_fix": "if (bin_op.size() == 1) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:34.888253901 +0100\n+++ /tmp/tmppf92dcxo.java\t2023-03-24 14:40:34.888253901 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.size() == 1) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 67,
                "tentative_fix": "if (bin_op.hasOriginalValue()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:36.984246140 +0100\n+++ /tmp/tmpqumnu4w1.java\t2023-03-24 14:40:36.984246140 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasOriginalValue()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 68,
                "tentative_fix": "if (bin_op == null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:39.224237842 +0100\n+++ /tmp/tmp6ask0cjd.java\t2023-03-24 14:40:39.224237842 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op == null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 69,
                "tentative_fix": "if (bin_op!= null) { c = bin_op.apply(a,b); } else { }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:43.416222318 +0100\n+++ /tmp/tmpt0p4bkpx.java\t2023-03-24 14:40:43.416222318 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c = bin_op.apply(a,b); } else { }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 70,
                "tentative_fix": "if (bin_op.equals(b)) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:47.536207056 +0100\n+++ /tmp/tmpgylsul7f.java\t2023-03-24 14:40:47.540207044 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.equals(b)) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 71,
                "tentative_fix": "if (bin_op.hasName(a)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:51.500192373 +0100\n+++ /tmp/tmp74b6j4ul.java\t2023-03-24 14:40:51.504192361 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasName(a)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 72,
                "tentative_fix": "if (bin_op.isMinusNode()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:53.468185086 +0100\n+++ /tmp/tmptt8v5mec.java\t2023-03-24 14:40:53.468185086 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isMinusNode()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 73,
                "tentative_fix": "if (bin_op!=null) { c = bin_op.apply(a, b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:55.284178359 +0100\n+++ /tmp/tmpzhbx9fl6.java\t2023-03-24 14:40:55.284178359 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!=null) { c = bin_op.apply(a, b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 74,
                "tentative_fix": "if(bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:40:59.432162993 +0100\n+++ /tmp/tmpesafhk4n.java\t2023-03-24 14:40:59.456162902 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if(bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 75,
                "tentative_fix": "if (bin_op.has If()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:03.608147521 +0100\n+++ /tmp/tmph5qr8knr.java\t2023-03-24 14:41:03.612147508 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.has If()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 76,
                "tentative_fix": "if (disc_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:05.268141372 +0100\n+++ /tmp/tmp0xxid8zn.java\t2023-03-24 14:41:05.268141372 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (disc_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 77,
                "tentative_fix": "if (bin_op.isPlusNode()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:07.080134658 +0100\n+++ /tmp/tmpyd3p5m7b.java\t2023-03-24 14:41:07.080134658 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isPlusNode()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 78,
                "tentative_fix": "if (negated) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:08.872128022 +0100\n+++ /tmp/tmpo50gf_n0.java\t2023-03-24 14:41:08.872128022 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (negated) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 79,
                "tentative_fix": "if (bin_op.isBinary()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:10.656121412 +0100\n+++ /tmp/tmpsvfhqwq6.java\t2023-03-24 14:41:10.656121412 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isBinary()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 80,
                "tentative_fix": "if (bin_op.hasMoreTokens()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:12.500114580 +0100\n+++ /tmp/tmp5skasdrg.java\t2023-03-24 14:41:12.504114563 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasMoreTokens()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 81,
                "tentative_fix": "if (bin_op.isTraceEnabled()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:14.316107850 +0100\n+++ /tmp/tmpozisj19m.java\t2023-03-24 14:41:14.316107850 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isTraceEnabled()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 82,
                "tentative_fix": "if (bin_op.equals(v)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:16.044101450 +0100\n+++ /tmp/tmp69p3ogqe.java\t2023-03-24 14:41:16.044101450 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.equals(v)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 83,
                "tentative_fix": "if (bin_op.equals(id)) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:17.832094823 +0100\n+++ /tmp/tmpicdt91_q.java\t2023-03-24 14:41:17.832094823 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.equals(id)) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 84,
                "tentative_fix": "if (blob && bin_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:19.644088110 +0100\n+++ /tmp/tmpggf4nbvu.java\t2023-03-24 14:41:19.644088110 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (blob && bin_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 85,
                "tentative_fix": "if (bin_op.hasSeconds()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:21.476081321 +0100\n+++ /tmp/tmp0d_6lq0w.java\t2023-03-24 14:41:21.476081321 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasSeconds()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 86,
                "tentative_fix": "if (bin_op.hasPrefix()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:23.284074622 +0100\n+++ /tmp/tmp9k8p0vne.java\t2023-03-24 14:41:23.284074622 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasPrefix()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 87,
                "tentative_fix": "if (bin_op.isColon()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:25.064068027 +0100\n+++ /tmp/tmpebv_fp3s.java\t2023-03-24 14:41:25.064068027 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isColon()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 88,
                "tentative_fix": "if (bin_op.isDigit()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:26.932061105 +0100\n+++ /tmp/tmpprh3vob8.java\t2023-03-24 14:41:26.932061105 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isDigit()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 89,
                "tentative_fix": "if (bin_op.isTrue) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:28.564055060 +0100\n+++ /tmp/tmp5bv4sful.java\t2023-03-24 14:41:28.564055060 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isTrue) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 90,
                "tentative_fix": "if (bin_op.isFalse()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:30.088049413 +0100\n+++ /tmp/tmp798omsfh.java\t2023-03-24 14:41:30.088049413 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isFalse()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 91,
                "tentative_fix": "if (bin_op!= null) { c -= bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:31.620043733 +0100\n+++ /tmp/tmpccy0jco5.java\t2023-03-24 14:41:31.624043719 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op!= null) { c -= bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": true,
                "test_exec": true,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 92,
                "tentative_fix": "if (bin_op.hasSeparator()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:35.148030662 +0100\n+++ /tmp/tmpg5vfazgs.java\t2023-03-24 14:41:35.148030662 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasSeparator()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 93,
                "tentative_fix": "if (bin_op.hasPattern()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:36.672025015 +0100\n+++ /tmp/tmpq_9sdtao.java\t2023-03-24 14:41:36.672025015 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasPattern()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 94,
                "tentative_fix": "if (bin_op.isDistinct()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:38.136019587 +0100\n+++ /tmp/tmpb8jh1oam.java\t2023-03-24 14:41:38.140019575 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isDistinct()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 95,
                "tentative_fix": "if (bin_op.isJust()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:39.568014283 +0100\n+++ /tmp/tmp8zoe7qbx.java\t2023-03-24 14:41:39.572014266 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isJust()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 96,
                "tentative_fix": "if (co_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:41.000008974 +0100\n+++ /tmp/tmpw9x1fakl.java\t2023-03-24 14:41:41.000008974 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (co_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 97,
                "tentative_fix": "if (bin_op.hasMatcher()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:42.472003521 +0100\n+++ /tmp/tmpu68q9qvw.java\t2023-03-24 14:41:42.472003521 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasMatcher()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 98,
                "tentative_fix": "if (bin_op.isTrue()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:43.935998093 +0100\n+++ /tmp/tmpqexq0l0h.java\t2023-03-24 14:41:43.939998080 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.isTrue()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 99,
                "tentative_fix": "if (bin_op.hasLine()) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:45.395992682 +0100\n+++ /tmp/tmpp0cjvwzu.java\t2023-03-24 14:41:45.395992682 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (bin_op.hasLine()) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            },
            {
                "k": 100,
                "tentative_fix": "if (fe_op!= null) { c = bin_op.apply(a,b); }",
                "patch": "--- /mnt/data/andre/mscthesis/storage_for_eval/quixbugs/rpn_eval/java_programs/RPN_EVAL.java\t2023-03-24 14:41:46.883987170 +0100\n+++ /tmp/tmp2lbsm8ik.java\t2023-03-24 14:41:46.887987153 +0100\n@@ -29,11 +29,11 @@\n                 token = (String) token;\n                 Double a = (Double) stack.pop();\n                 Double b = (Double) stack.pop();\n                 Double c = 0.0;\n                 BinaryOperator<Double> bin_op = op.get(token);\n-                c = bin_op.apply(a,b);\n+if (fe_op!= null) { c = bin_op.apply(a,b); }\n                 stack.push(c);\n             }\n         }\n \n         return (Double) stack.pop();\n",
                "compile_exec": true,
                "compile_pass": false,
                "test_exec": false,
                "test_pass": false,
                "identical": false
            }
        ],
        "ground_truth": "c = bin_op.apply(b,a);"
    }
}