{"Cli-40": [{"context": {"prefix": "        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n", "suffix": "        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n", "buggy": "        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n", "fix": "        {\n            return (T) createObject(str);\n        }\n        else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n        {\n            return (T) createNumber(str);\n        }\n        else if (PatternOptionBuilder.DATE_VALUE == clazz)\n        {\n            return (T) createDate(str);\n        }\n        else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n        {\n            return (T) createClass(str);\n        }\n        else if (PatternOptionBuilder.FILE_VALUE == clazz)\n        {\n            return (T) createFile(str);\n        }\n        else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n        {\n            return (T) openFile(str);\n        }\n        else if (PatternOptionBuilder.FILES_VALUE == clazz)\n        {\n            return (T) createFiles(str);\n        }\n        else if (PatternOptionBuilder.URL_VALUE == clazz)\n        {\n            return (T) createURL(str);\n        }\n        else\n        {\n            throw new ParseException(\"Unable to handle the class: \" + clazz);\n        }\n    }\n\n    /**\n      * Create an Object from the classname and empty constructor.\n      *\n      * @param classname the argument value\n      * @return the initialised object\n      * @throws ParseException if the class could not be found or the object could not be created\n      */\n    public static Object createObject(final String classname) throws ParseException\n    {\n        Class<?> cl;\n\n        try\n        {\n            cl = Class.forName(classname);\n        }\n        catch (final ClassNotFoundException cnfe)\n        {\n            throw new ParseException(\"Unable to find the class: \" + classname);\n        }\n        \n        try\n        {\n            return cl.newInstance();\n        }\n        catch (final Exception e)\n        {\n            throw new ParseException(e.getClass().getName() + \"; Unable to create an instance of: \" + classname);\n        }\n    }\n\n", "start": 69, "end": 135, "file": "main/java/org/apache/commons/cli/TypeHandler.java"}, "tokens": {"original": [{"openFile": {"identifier": "(TypeHandler) openFile()", "line": "return (T) openFile(str);"}}, {"createFile": {"identifier": "(TypeHandler) createFile()", "line": "return (T) createFile(str);"}}, {"createClass": {"identifier": "(TypeHandler) createClass()", "line": "return (T) createClass(str);"}}, {"createFiles": {"identifier": "(TypeHandler) createFiles()", "line": "return (T) createFiles(str);"}}, {"createNumber": {"identifier": "(TypeHandler) createNumber()", "line": "return (T) createNumber(str);"}}, {"createURL": {"identifier": "(TypeHandler) createURL()", "line": "return (T) createURL(str);"}}, {"createDate": {"identifier": "(TypeHandler) createDate()", "line": "return (T) createDate(str);"}}, {"createObject": {"identifier": "(TypeHandler) createObject()", "line": "return (T) createObject(str);"}}, {"createValue": {"identifier": "(TypeHandler) createValue()", "line": "return createValue(str, (Class<?>) obj);"}}, {"URL_VALUE": {"identifier": "(Class) URL_VALUE", "line": "else if (PatternOptionBuilder.URL_VALUE == clazz)"}}, {"DATE_VALUE": {"identifier": "(Class) DATE_VALUE", "line": "else if (PatternOptionBuilder.DATE_VALUE == clazz)"}}, {"FILE_VALUE": {"identifier": "(Class) FILE_VALUE", "line": "else if (PatternOptionBuilder.FILE_VALUE == clazz)"}}, {"CLASS_VALUE": {"identifier": "(Class) CLASS_VALUE", "line": "else if (PatternOptionBuilder.CLASS_VALUE == clazz)"}}, {"FILES_VALUE": {"identifier": "(Class) FILES_VALUE", "line": "else if (PatternOptionBuilder.FILES_VALUE == clazz)"}}, {"OBJECT_VALUE": {"identifier": "(Class) OBJECT_VALUE", "line": "else if (PatternOptionBuilder.OBJECT_VALUE == clazz)"}}, {"NUMBER_VALUE": {"identifier": "(Class) NUMBER_VALUE", "line": "else if (PatternOptionBuilder.NUMBER_VALUE == clazz)"}}, {"STRING_VALUE": {"identifier": "(Class) STRING_VALUE", "line": "if (PatternOptionBuilder.STRING_VALUE == clazz)"}}, {"TypeHandler": {"identifier": "(TypeHandler) TypeHandler", "line": "public class TypeHandler"}}]}}], "Cli-8": [{"context": {"prefix": "     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n", "suffix": "\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n", "buggy": "     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, nextLineTabStop);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n", "fix": "     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the \n     * text in <code>text</code> with the column width <code>width</code>.\n     * The wrap point is the last postion before startPos+width having a \n     * whitespace character (space, \\n, \\r).\n     *\n     * @param text The text being searched for the wrap position\n     * @param width width of the wrapped text\n     * @param startPos position from which to start the lookup whitespace \n     * character\n     * @return postion on which the text must be wrapped or -1 if the wrap \n     * position is at the end of the text\n     */\n    protected int findWrapPos(String text, int width, int startPos)\n", "start": 785, "end": 837, "file": "java/org/apache/commons/cli/HelpFormatter.java"}, "tokens": {"original": [{"toString": {"identifier": "(StringBuffer) toString()", "line": "renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());"}}, {"printWrapped": {"identifier": "(HelpFormatter) printWrapped()", "line": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop,"}}, {"printUsage": {"identifier": "(HelpFormatter) printUsage()", "line": "printUsage(pw, width, cmdLineSyntax);"}}, {"createPadding": {"identifier": "(HelpFormatter) createPadding()", "line": "final String padding = createPadding(nextLineTabStop);"}}, {"printOptions": {"identifier": "(HelpFormatter) printOptions()", "line": "printOptions(pw, width, options, leftPad, descPad);"}}, {"renderOptions": {"identifier": "(HelpFormatter) renderOptions()", "line": "renderOptions(sb, width, options, leftPad, descPad);"}}, {"printHelp": {"identifier": "(HelpFormatter) printHelp()", "line": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,"}}, {"setWidth": {"identifier": "(HelpFormatter) setWidth()", "line": "public void setWidth(int width)"}}, {"defaultWidth": {"identifier": "(int) defaultWidth", "line": "printHelp(defaultWidth, cmdLineSyntax, null, options, null, autoUsage);"}}, {"defaultLeftPad": {"identifier": "(int) defaultLeftPad", "line": "printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad,"}}, {"setNewLine": {"identifier": "(HelpFormatter) setNewLine()", "line": "public void setNewLine(String newline)"}}, {"getOptions": {"identifier": "(Options) getOptions()", "line": "List optList = new ArrayList(options.getOptions());"}}, {"defaultNewLine": {"identifier": "(String) defaultNewLine", "line": "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);"}}, {"appendOption": {"identifier": "(HelpFormatter) appendOption()", "line": "appendOption(buff, (Option) i.next(), true);"}}, {"getLongOpt": {"identifier": "(Option) getLongOpt()", "line": ".append(option.getLongOpt());"}}, {"isRequired": {"identifier": "(Option) isRequired()", "line": "appendOption(buff, option, option.isRequired());"}}, {"helpOptions": {"identifier": "(Options) helpOptions()", "line": "List optList = options.helpOptions();"}}, {"getWidth": {"identifier": "(HelpFormatter) getWidth()", "line": "public int getWidth()"}}, {"setLeftPadding": {"identifier": "(HelpFormatter) setLeftPadding()", "line": "public void setLeftPadding(int padding)"}}, {"setOptPrefix": {"identifier": "(HelpFormatter) setOptPrefix()", "line": "public void setOptPrefix(String prefix)"}}, {"getDescription": {"identifier": "(Option) getDescription()", "line": "optBuf.append(option.getDescription());"}}, {"getOptionGroup": {"identifier": "(Options) getOptionGroup()", "line": "OptionGroup group = options.getOptionGroup(option);"}}, {"OptionGroup": {"identifier": "(OptionGroup) OptionGroup", "line": "OptionGroup group = options.getOptionGroup(option);"}}, {"DEFAULT_WIDTH": {"identifier": "(int) DEFAULT_WIDTH", "line": "public int defaultWidth = DEFAULT_WIDTH;"}}, {"defaultDescPad": {"identifier": "(int) defaultDescPad", "line": "defaultDescPad, footer, autoUsage);"}}, {"getOpt": {"identifier": "(Option) getOpt()", "line": "buff.append(\"-\").append(option.getOpt());"}}, {"setSyntaxPrefix": {"identifier": "(HelpFormatter) setSyntaxPrefix()", "line": "public void setSyntaxPrefix(String prefix)"}}, {"getNewLine": {"identifier": "(HelpFormatter) getNewLine()", "line": "public String getNewLine()"}}, {"setArgName": {"identifier": "(HelpFormatter) setArgName()", "line": "* - use get/setArgName methods instead."}}, {"setDescPadding": {"identifier": "(HelpFormatter) setDescPadding()", "line": "public void setDescPadding(int padding)"}}, {"getLeftPadding": {"identifier": "(HelpFormatter) getLeftPadding()", "line": "public int getLeftPadding()"}}, {"getArgName": {"identifier": "(Option) getArgName()", "line": "optBuf.append(\" <\").append(option.getArgName()).append(\">\");"}}, {"getDescPadding": {"identifier": "(HelpFormatter) getDescPadding()", "line": "public int getDescPadding()"}}, {"defaultArgName": {"identifier": "(String) defaultArgName", "line": "return this.defaultArgName;"}}, {"hasArg": {"identifier": "(Option) hasArg()", "line": "if (option.hasArg() && (option.getArgName() != null))"}}, {"getKey": {"identifier": "(Option) getKey()", "line": "return opt1.getKey().compareToIgnoreCase(opt2.getKey());"}}, {"getOptPrefix": {"identifier": "(HelpFormatter) getOptPrefix()", "line": "public String getOptPrefix()"}}, {"getSyntaxPrefix": {"identifier": "(HelpFormatter) getSyntaxPrefix()", "line": "public String getSyntaxPrefix()"}}, {"hasLongOpt": {"identifier": "(Option) hasLongOpt()", "line": "if (option.hasLongOpt())"}}, {"HelpFormatter": {"identifier": "(HelpFormatter) HelpFormatter", "line": "public class HelpFormatter {"}}, {"hasArgName": {"identifier": "(Option) hasArgName()", "line": "if (option.hasArgName())"}}]}}], "Cli-11": [{"context": {"prefix": "        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n", "suffix": "        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n", "buggy": "        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && (option.getArgName() != null))\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n", "fix": "        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * Appends the usage clause for an Option to a StringBuffer.  \n     *\n     * @param buff the StringBuffer to append to\n     * @param option the Option to append\n     * @param required whether the Option is required or not\n     */\n    private static void appendOption(final StringBuffer buff, \n                                     final Option option, \n                                     final boolean required)\n    {\n        if (!required)\n        {\n            buff.append(\"[\");\n        }\n\n        if (option.getOpt() != null)\n        {\n            buff.append(\"-\").append(option.getOpt());\n        }\n        else\n        {\n            buff.append(\"--\").append(option.getLongOpt());\n        }\n\n        // if the Option has a value\n        if (option.hasArg() && option.hasArgName())\n        {\n            buff.append(\" <\").append(option.getArgName()).append(\">\");\n        }\n\n        // if the Option is not a required option\n        if (!required)\n        {\n            buff.append(\"]\");\n        }\n    }\n\n    /**\n     * <p>Print the cmdLineSyntax to the specified writer, using the\n     * specified width.</p>\n     *\n     * @param pw The printWriter to write the help to\n     * @param width The number of characters per line for the usage statement.\n     * @param cmdLineSyntax The usage statement.\n     */\n    public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n    {\n        int argPos = cmdLineSyntax.indexOf(' ') + 1;\n\n        printWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, \n                     defaultSyntaxPrefix + cmdLineSyntax);\n    }\n\n    /**\n     * <p>Print the help for the specified Options to the specified writer, \n     * using the specified width, left padding and description padding.</p>\n     *\n", "start": 600, "end": 662, "file": "java/org/apache/commons/cli/HelpFormatter.java"}, "tokens": {"original": [{"getDescription": {"identifier": "(Option) getDescription()", "line": "if (option.getDescription() != null)"}}, {"hasArgName": {"identifier": "(Option) hasArgName()", "line": "if (option.hasArgName())"}}, {"getOpt": {"identifier": "(Option) getOpt()", "line": "if (option.getOpt() != null)"}}, {"hasLongOpt": {"identifier": "(Option) hasLongOpt()", "line": "if (option.hasLongOpt())"}}, {"isRequired": {"identifier": "(Option) isRequired()", "line": "appendOption(buff, option, option.isRequired());"}}, {"appendOption": {"identifier": "(HelpFormatter) appendOption()", "line": "appendOption(buff, option, option.isRequired());"}}, {"helpOptions": {"identifier": "(Options) helpOptions()", "line": "List optList = options.helpOptions();"}}, {"getOptions": {"identifier": "(Options) getOptions()", "line": "List optList = new ArrayList(options.getOptions());"}}, {"getOptionGroup": {"identifier": "(Options) getOptionGroup()", "line": "OptionGroup group = options.getOptionGroup(option);"}}, {"OptionGroup": {"identifier": "(OptionGroup) OptionGroup", "line": "OptionGroup group = options.getOptionGroup(option);"}}, {"defaultArgName": {"identifier": "(String) defaultArgName", "line": "this.defaultArgName = name;"}}, {"getLongOpt": {"identifier": "(Option) getLongOpt()", "line": ".append(option.getLongOpt());"}}, {"setArgName": {"identifier": "(HelpFormatter) setArgName()", "line": "public void setArgName(String name)"}}, {"printOptions": {"identifier": "(HelpFormatter) printOptions()", "line": "printOptions(pw, width, options, leftPad, descPad);"}}, {"renderOptions": {"identifier": "(HelpFormatter) renderOptions()", "line": "renderOptions(sb, width, options, leftPad, descPad);"}}, {"createPadding": {"identifier": "(HelpFormatter) createPadding()", "line": "optBuf.append(createPadding(max - optBuf.length()));"}}, {"getKey": {"identifier": "(Option) getKey()", "line": "return opt1.getKey().compareToIgnoreCase(opt2.getKey());"}}, {"getNewLine": {"identifier": "(HelpFormatter) getNewLine()", "line": "public String getNewLine()"}}, {"setNewLine": {"identifier": "(HelpFormatter) setNewLine()", "line": "public void setNewLine(String newline)"}}, {"getOptPrefix": {"identifier": "(HelpFormatter) getOptPrefix()", "line": "public String getOptPrefix()"}}, {"printHelp": {"identifier": "(HelpFormatter) printHelp()", "line": "printHelp(cmdLineSyntax, header, options, footer, false);"}}, {"getSyntaxPrefix": {"identifier": "(HelpFormatter) getSyntaxPrefix()", "line": "public String getSyntaxPrefix()"}}, {"defaultWidth": {"identifier": "(int) defaultWidth", "line": "printHelp(defaultWidth, cmdLineSyntax, null, options, null, false);"}}, {"defaultLeftPad": {"identifier": "(int) defaultLeftPad", "line": "printHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad,"}}, {"findWrapPos": {"identifier": "(HelpFormatter) findWrapPos()", "line": "int pos = findWrapPos(text, width, 0);"}}, {"toString": {"identifier": "(Object) toString()", "line": "optBuf = new StringBuffer(prefixList.get(x++).toString());"}}, {"printUsage": {"identifier": "(HelpFormatter) printUsage()", "line": "printUsage(pw, width, cmdLineSyntax, options);"}}, {"setSyntaxPrefix": {"identifier": "(HelpFormatter) setSyntaxPrefix()", "line": "public void setSyntaxPrefix(String prefix)"}}, {"defaultNewLine": {"identifier": "(HelpFormatter) defaultNewLine", "line": "public String defaultNewLine = System.getProperty(\"line.separator\");"}}, {"printWrapped": {"identifier": "(HelpFormatter) printWrapped()", "line": "printWrapped(pw, width, buff.toString().indexOf(' ') + 1,"}}, {"setLeftPadding": {"identifier": "(HelpFormatter) setLeftPadding()", "line": "public void setLeftPadding(int padding)"}}, {"setDescPadding": {"identifier": "(HelpFormatter) setDescPadding()", "line": "public void setDescPadding(int padding)"}}, {"setOptPrefix": {"identifier": "(HelpFormatter) setOptPrefix()", "line": "public void setOptPrefix(String prefix)"}}, {"DEFAULT_WIDTH": {"identifier": "(HelpFormatter) DEFAULT_WIDTH", "line": "public static final int DEFAULT_WIDTH = 74;"}}, {"setWidth": {"identifier": "(HelpFormatter) setWidth()", "line": "public void setWidth(int width)"}}, {"getLeftPadding": {"identifier": "(HelpFormatter) getLeftPadding()", "line": "public int getLeftPadding()"}}, {"getDescPadding": {"identifier": "(HelpFormatter) getDescPadding()", "line": "public int getDescPadding()"}}, {"HelpFormatter": {"identifier": "(HelpFormatter) HelpFormatter", "line": "public class HelpFormatter {"}}, {"getWidth": {"identifier": "(HelpFormatter) getWidth()", "line": "public int getWidth()"}}, {"defaultDescPad": {"identifier": "(int) defaultDescPad", "line": "this.defaultDescPad = padding;"}}]}}], "Cli-17": [{"context": {"prefix": "     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n", "suffix": "            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "buggy": "     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "fix": "     *  are remaining characters in the token then add the remaining \n     *  characters as a token to the list of processed tokens.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b> \n     *  <code>stopAtNonOption</code> <b>IS</b> set then add the special token\n     *  \"<b>--</b>\" followed by the remaining characters and also \n     *  the remaining tokens directly to the processed tokens list.</li>\n     *  <li>if an {@link Option} does <b>NOT</b> exist <b>AND</b>\n     *  <code>stopAtNonOption</code> <b>IS NOT</b> set then add that\n     *  character prepended with \"<b>-</b>\".</li>\n     * </ul>\n     * </p>\n     *\n     * @param token The current token to be <b>burst</b>\n     * @param stopAtNonOption Specifies whether to stop processing\n     * at the first non-Option encountered.\n     */\n    protected void burstToken(String token, boolean stopAtNonOption)\n    {\n        for (int i = 1; i < token.length(); i++)\n        {\n            String ch = String.valueOf(token.charAt(i));\n\n            if (options.hasOption(ch))\n            {\n                tokens.add(\"-\" + ch);\n                currentOption = options.getOption(ch);\n\n                if (currentOption.hasArg() && (token.length() != (i + 1)))\n                {\n                    tokens.add(token.substring(i + 1));\n\n                    break;\n                }\n            }\n            else if (stopAtNonOption)\n            {\n                process(token.substring(i));\n                break;\n            }\n            else\n            {\n                tokens.add(token);\n                break;\n            }\n        }\n    }\n}\n", "start": 265, "end": 339, "file": "java/org/apache/commons/cli/PosixParser.java"}, "tokens": {}}], "Cli-25": [{"context": {"prefix": "        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n", "suffix": "        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n", "buggy": "        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = width - 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n", "fix": "        return sb;\n    }\n\n    /**\n     * Render the specified text and return the rendered Options\n     * in a StringBuffer.\n     *\n     * @param sb The StringBuffer to place the rendered text into.\n     * @param width The number of characters to display per line\n     * @param nextLineTabStop The position on the next line for the first tab.\n     * @param text The text to be rendered.\n     *\n     * @return the StringBuffer with the rendered Options contents.\n     */\n    protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                             int nextLineTabStop, String text)\n    {\n        int pos = findWrapPos(text, width, 0);\n\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n        if (nextLineTabStop >= width)\n        {\n            // stops infinite loop happening\n            nextLineTabStop = 1;\n        }\n\n        // all following lines must be padded with nextLineTabStop space \n        // characters\n        final String padding = createPadding(nextLineTabStop);\n\n        while (true)\n        {\n            text = padding + text.substring(pos).trim();\n            pos = findWrapPos(text, width, 0);\n\n            if (pos == -1)\n            {\n                sb.append(text);\n\n                return sb;\n            }\n            \n            if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) \n            {\n                pos = width;\n            }\n\n            sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        }\n    }\n\n    /**\n     * Finds the next text wrap position after <code>startPos</code> for the\n     * text in <code>text</code> with the column width <code>width</code>.\n", "start": 794, "end": 854, "file": "java/org/apache/commons/cli/HelpFormatter.java"}, "tokens": {"original": [{"defaultWidth": {"identifier": "(int) defaultWidth", "line": "this.defaultWidth = width;"}}, {"printWrapped": {"identifier": "(HelpFormatter) printWrapped()", "line": "printWrapped(pw, width, 0, text);"}}, {"findWrapPos": {"identifier": "(HelpFormatter) findWrapPos()", "line": "int pos = findWrapPos(text, width, 0);"}}, {"defaultNewLine": {"identifier": "(String) defaultNewLine", "line": "this.defaultNewLine = newline;"}}, {"createPadding": {"identifier": "(HelpFormatter) createPadding()", "line": "final String padding = createPadding(nextLineTabStop);"}}, {"toString": {"identifier": "(StringBuffer) toString()", "line": "renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());"}}, {"renderOptions": {"identifier": "(HelpFormatter) renderOptions()", "line": "renderOptions(sb, width, options, leftPad, descPad);"}}, {"setWidth": {"identifier": "(HelpFormatter) setWidth()", "line": "public void setWidth(int width)"}}, {"printUsage": {"identifier": "(HelpFormatter) printUsage()", "line": "printUsage(pw, width, cmdLineSyntax);"}}, {"printOptions": {"identifier": "(HelpFormatter) printOptions()", "line": "printOptions(pw, width, options, leftPad, descPad);"}}, {"DEFAULT_WIDTH": {"identifier": "(int) DEFAULT_WIDTH", "line": "public int defaultWidth = DEFAULT_WIDTH;"}}, {"defaultLeftPad": {"identifier": "(int) defaultLeftPad", "line": "this.defaultLeftPad = padding;"}}, {"defaultDescPad": {"identifier": "(int) defaultDescPad", "line": "this.defaultDescPad = padding;"}}, {"helpOptions": {"identifier": "(Options) helpOptions()", "line": "List optList = options.helpOptions();"}}, {"setNewLine": {"identifier": "(HelpFormatter) setNewLine()", "line": "public void setNewLine(String newline)"}}, {"appendOption": {"identifier": "(HelpFormatter) appendOption()", "line": "appendOption(buff, (Option) i.next(), true);"}}, {"printHelp": {"identifier": "(HelpFormatter) printHelp()", "line": "printHelp(cmdLineSyntax, header, options, footer, false);"}}, {"defaultArgName": {"identifier": "(String) defaultArgName", "line": "this.defaultArgName = name;"}}, {"getWidth": {"identifier": "(HelpFormatter) getWidth()", "line": "public int getWidth()"}}, {"getOpt": {"identifier": "(Option) getOpt()", "line": "if (option.getOpt() != null)"}}, {"getOptions": {"identifier": "(OptionGroup) getOptions()", "line": "List optList = new ArrayList(group.getOptions());"}}, {"setLeftPadding": {"identifier": "(HelpFormatter) setLeftPadding()", "line": "* - use get/setLeftPadding methods instead."}}, {"getLongOpt": {"identifier": "(Option) getLongOpt()", "line": "buff.append(\"--\").append(option.getLongOpt());"}}, {"isRequired": {"identifier": "(Option) isRequired()", "line": "appendOption(buff, option, option.isRequired());"}}, {"setDescPadding": {"identifier": "(HelpFormatter) setDescPadding()", "line": "* - use get/setDescPadding methods instead."}}, {"getDescription": {"identifier": "(Option) getDescription()", "line": "if (option.getDescription() != null)"}}, {"getOptionGroup": {"identifier": "(Options) getOptionGroup()", "line": "OptionGroup group = options.getOptionGroup(option);"}}, {"OptionGroup": {"identifier": "(OptionGroup) OptionGroup", "line": "OptionGroup group = options.getOptionGroup(option);"}}, {"hasLongOpt": {"identifier": "(Option) hasLongOpt()", "line": "if (option.hasLongOpt())"}}, {"setArgName": {"identifier": "(HelpFormatter) setArgName()", "line": "* - use get/setArgName methods instead."}}, {"setOptPrefix": {"identifier": "(HelpFormatter) setOptPrefix()", "line": "* - use get/setOptPrefix methods instead."}}, {"getNewLine": {"identifier": "(HelpFormatter) getNewLine()", "line": "public String getNewLine()"}}, {"getLeftPadding": {"identifier": "(HelpFormatter) getLeftPadding()", "line": "public int getLeftPadding()"}}, {"setSyntaxPrefix": {"identifier": "(HelpFormatter) setSyntaxPrefix()", "line": "* - use get/setSyntaxPrefix methods instead."}}, {"getOptPrefix": {"identifier": "(HelpFormatter) getOptPrefix()", "line": "public String getOptPrefix()"}}, {"getKey": {"identifier": "(Option) getKey()", "line": "return opt1.getKey().compareToIgnoreCase(opt2.getKey());"}}, {"getSyntaxPrefix": {"identifier": "(HelpFormatter) getSyntaxPrefix()", "line": "public String getSyntaxPrefix()"}}, {"getArgName": {"identifier": "(Option) getArgName()", "line": "buff.append(\" <\").append(option.getArgName()).append(\">\");"}}, {"hasArgName": {"identifier": "(Option) hasArgName()", "line": "if (option.hasArg() && option.hasArgName())"}}, {"hasArg": {"identifier": "(Option) hasArg()", "line": "if (option.hasArg() && option.hasArgName())"}}, {"getDescPadding": {"identifier": "(HelpFormatter) getDescPadding()", "line": "public int getDescPadding()"}}, {"HelpFormatter": {"identifier": "(HelpFormatter) HelpFormatter", "line": "public class HelpFormatter"}}]}}], "Cli-28": [{"context": {"prefix": "\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n", "suffix": "                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n", "buggy": "\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    break;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n", "fix": "\n        for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n        {\n            String option = e.nextElement().toString();\n\n            if (!cmd.hasOption(option))\n            {\n                Option opt = getOptions().getOption(option);\n\n                // get the value from the properties instance\n                String value = properties.getProperty(option);\n\n                if (opt.hasArg())\n                {\n                    if (opt.getValues() == null || opt.getValues().length == 0)\n                    {\n                        try\n                        {\n                            opt.addValueForProcessing(value);\n                        }\n                        catch (RuntimeException exp)\n                        {\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                }\n                else if (!(\"yes\".equalsIgnoreCase(value)\n                        || \"true\".equalsIgnoreCase(value)\n                        || \"1\".equalsIgnoreCase(value)))\n                {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n\n                cmd.addOption(opt);\n            }\n        }\n    }\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options\n     * are not present.\n     *\n     * @throws MissingOptionException if any of the required Options\n     * are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException\n    {\n        // if there are required options that have not been processsed\n        if (!getRequiredOptions().isEmpty())\n        {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * <p>Process the argument values for the specified Option\n     * <code>opt</code> using the values retrieved from the\n     * specified iterator <code>iter</code>.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line\n     * Options.\n     *\n", "start": 257, "end": 321, "file": "java/org/apache/commons/cli/Parser.java"}, "tokens": {"original": [{"CommandLine": {"identifier": "(CommandLine) CommandLine", "line": "protected CommandLine cmd;"}}, {"clearValues": {"identifier": "(Option) clearValues()", "line": "opt.clearValues();"}}, {"processOption": {"identifier": "(Parser) processOption()", "line": "processOption(t, iterator);"}}, {"requiredOptions": {"identifier": "(List) requiredOptions", "line": "return requiredOptions;"}}, {"setSelected": {"identifier": "(OptionGroup) setSelected()", "line": "group.setSelected(opt);"}}, {"processArgs": {"identifier": "(Parser) processArgs()", "line": "processArgs(opt, iter);"}}, {"addArg": {"identifier": "(CommandLine) addArg()", "line": "cmd.addArg(t);"}}, {"addOption": {"identifier": "(CommandLine) addOption()", "line": "cmd.addOption(opt);"}}, {"setOptions": {"identifier": "(Parser) setOptions()", "line": "setOptions(options);"}}, {"getOptions": {"identifier": "(Parser) getOptions()", "line": "boolean hasOption = getOptions().hasOption(arg);"}}, {"hasOption": {"identifier": "(Options) hasOption()", "line": "boolean hasOption = getOptions().hasOption(arg);"}}, {"isRequired": {"identifier": "(Option) isRequired()", "line": "if (opt.isRequired())"}}, {"getKey": {"identifier": "(Option) getKey()", "line": "getRequiredOptions().remove(opt.getKey());"}}, {"toString": {"identifier": "(Object) toString()", "line": "String option = e.nextElement().toString();"}}, {"OptionGroup": {"identifier": "(OptionGroup) OptionGroup", "line": "OptionGroup group = (OptionGroup) it.next();"}}, {"helpOptions": {"identifier": "(Options) helpOptions()", "line": "for (Iterator it = options.helpOptions().iterator(); it.hasNext();)"}}, {"getOptionGroups": {"identifier": "(Options) getOptionGroups()", "line": "for (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)"}}, {"getOptionGroup": {"identifier": "(Options) getOptionGroup()", "line": "OptionGroup group = getOptions().getOptionGroup(opt);"}}, {"getOption": {"identifier": "(Options) getOption()", "line": "Option opt = (Option) getOptions().getOption(arg).clone();"}}, {"hasArg": {"identifier": "(Option) hasArg()", "line": "if (opt.hasArg())"}}, {"hasOptionalArg": {"identifier": "(Option) hasOptionalArg()", "line": "if (opt.getValues() == null && !opt.hasOptionalArg())"}}, {"getValues": {"identifier": "(Option) getValues()", "line": "if (opt.getValues() == null && !opt.hasOptionalArg())"}}]}}], "Codec-2": [{"context": {"prefix": "                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n", "suffix": "                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n", "buggy": "                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n", "fix": "                    buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                        buf[pos++] = PAD;\n                    }\n                    break;\n\n                case 2:\n                    buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                    // URL-SAFE skips the padding to further reduce size.\n                    if (encodeTable == STANDARD_ENCODE_TABLE) {\n                        buf[pos++] = PAD;\n                    }\n                    break;\n            }\n            if (lineLength > 0 && pos > 0) {\n                System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                pos += lineSeparator.length;\n            }\n        } else {\n            for (int i = 0; i < inAvail; i++) {\n                if (buf == null || buf.length - pos < encodeSize) {\n                    resizeBuf();\n                }\n                modulus = (++modulus) % 3;\n                int b = in[inPos++];\n                if (b < 0) { b += 256; }\n                x = (x << 8) + b;\n                if (0 == modulus) {\n                    buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n                    buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n                    buf[pos++] = encodeTable[x & MASK_6BITS];\n                    currentLinePos += 4;\n", "start": 427, "end": 463, "file": "java/org/apache/commons/codec/binary/Base64.java"}, "tokens": {"original": [{"inAvail": {"identifier": "(int) inAvail", "line": "if (inAvail < 0) {"}}, {"currentLinePos": {"identifier": "(int) currentLinePos", "line": "if (lineLength > 0 && lineLength <= currentLinePos) {"}}, {"readPos": {"identifier": "(int) readPos", "line": "if (readPos >= pos) {"}}, {"CHUNK_SEPARATOR": {"identifier": "(byte) CHUNK_SEPARATOR", "line": "this(lineLength, CHUNK_SEPARATOR);"}}, {"lineSeparator": {"identifier": "(byte) lineSeparator", "line": "this(lineLength, lineSeparator, false);"}}, {"isBase64": {"identifier": "(Base64) isBase64()", "line": "if (isBase64(data[i])) {"}}, {"DECODE_TABLE": {"identifier": "(byte) DECODE_TABLE", "line": "if (b >= 0 && b < DECODE_TABLE.length) {"}}, {"encodeSize": {"identifier": "(int) encodeSize", "line": "if (buf == null || buf.length - pos < encodeSize) {"}}, {"decodeSize": {"identifier": "(int) decodeSize", "line": "if (buf == null || buf.length - pos < decodeSize) {"}}, {"encodeTable": {"identifier": "(byte) encodeTable", "line": "if (encodeTable == STANDARD_ENCODE_TABLE) {"}}, {"isUrlSafe": {"identifier": "(Base64) isUrlSafe()", "line": "public boolean isUrlSafe() {"}}, {"hasData": {"identifier": "(Base64) hasData()", "line": "boolean hasData() {"}}, {"inPos": {"identifier": "() inPos", "line": "void encode(byte[] in, int inPos, int inAvail) {"}}, {"toIntegerBytes": {"identifier": "(Base64) toIntegerBytes()", "line": "static byte[] toIntegerBytes(BigInteger bigInt) {"}}, {"decodeInteger": {"identifier": "(Base64) decodeInteger()", "line": "public static BigInteger decodeInteger(byte[] pArray) {"}}, {"resizeBuf": {"identifier": "(Base64) resizeBuf()", "line": "private void resizeBuf() {"}}, {"CHUNK_SIZE": {"identifier": "(Base64) CHUNK_SIZE", "line": "static final int CHUNK_SIZE = 76;"}}, {"readResults": {"identifier": "(Base64) readResults()", "line": "b64.readResults(buf, 0, buf.length);"}}, {"encodeInteger": {"identifier": "(Base64) encodeInteger()", "line": "public static byte[] encodeInteger(BigInteger bigInt) {"}}, {"MASK_6BITS": {"identifier": "(int) MASK_6BITS", "line": "buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];"}}, {"isWhiteSpace": {"identifier": "(Base64) isWhiteSpace()", "line": "if (!isBase64(arrayOctet[i]) && !isWhiteSpace(arrayOctet[i])) {"}}, {"encodeBase64": {"identifier": "(Base64) encodeBase64()", "line": "public static byte[] encodeBase64(byte[] binaryData) {"}}, {"MASK_8BITS": {"identifier": "(Base64) MASK_8BITS", "line": "private static final int MASK_8BITS = 0xff;"}}, {"decodeBase64": {"identifier": "(Base64) decodeBase64()", "line": "public static byte[] decodeBase64(byte[] base64Data) {"}}]}}], "Codec-3": [{"context": {"prefix": "            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n", "suffix": "                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n", "buggy": "            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 4, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n", "fix": "            //-- -ges-, -gep-, -gel-, -gie- at beginning --//\n            result.append('K', 'J');\n            index += 2;\n        } else if ((contains(value, index + 1, 2, \"ER\") || \n                    charAt(value, index + 1) == 'Y') &&\n                   !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n                   !contains(value, index - 1, 1, \"E\", \"I\") && \n                   !contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n            //-- -ger-, -gy- --//\n            result.append('K', 'J');\n            index += 2;\n        } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || \n                   contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n            //-- Italian \"biaggi\" --//\n            if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                //-- obvious germanic --//\n                result.append('K');\n            } else if (contains(value, index + 1, 3, \"IER\")) {\n                result.append('J');\n            } else {\n                result.append('J', 'K');\n            }\n            index += 2;\n        } else if (charAt(value, index + 1) == 'G') {\n            index += 2;\n            result.append('K');\n        } else {\n            index++;\n            result.append('K');\n        }\n        return index;\n    }\n    \n    /**\n     * Handles 'GH' cases\n", "start": 437, "end": 471, "file": "java/org/apache/commons/codec/language/DoubleMetaphone.java"}, "tokens": {"original": [{"slavoGermanic": {"identifier": "(boolean) slavoGermanic", "line": "} else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {"}}, {"conditionCH0": {"identifier": "(DoubleMetaphone) conditionCH0()", "line": "} else if (conditionCH0(value, index)) {"}}, {"conditionCH1": {"identifier": "(DoubleMetaphone) conditionCH1()", "line": "} else if (conditionCH1(value, index)) {"}}, {"charAt": {"identifier": "(DoubleMetaphone) charAt()", "line": "} else if (charAt(value, index + 1) == 'N') {"}}, {"isVowel": {"identifier": "(DoubleMetaphone) isVowel()", "line": "} else if (isVowel(charAt(value, index - 2))) {"}}, {"conditionL0": {"identifier": "(DoubleMetaphone) conditionL0()", "line": "if (conditionL0(value, index)) {"}}, {"L_T_K_S_N_M_B_Z": {"identifier": "(String) L_T_K_S_N_M_B_Z", "line": "} else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, \"S\", \"K\", \"L\")) {"}}, {"conditionM0": {"identifier": "(DoubleMetaphone) conditionM0()", "line": "index = conditionM0(value, index) ? index + 2 : index + 1;"}}, {"conditionC0": {"identifier": "(DoubleMetaphone) conditionC0()", "line": "if (conditionC0(value, index)) {  // very confusing, moved out"}}, {"handleC": {"identifier": "(DoubleMetaphone) handleC()", "line": "index = handleC(value, result, index);"}}, {"handleD": {"identifier": "(DoubleMetaphone) handleD()", "line": "index = handleD(value, result, index);"}}, {"handleH": {"identifier": "(DoubleMetaphone) handleH()", "line": "index = handleH(value, result, index);"}}, {"handleL": {"identifier": "(DoubleMetaphone) handleL()", "line": "index = handleL(value, result, index);"}}, {"handleP": {"identifier": "(DoubleMetaphone) handleP()", "line": "index = handleP(value, result, index);"}}, {"handleT": {"identifier": "(DoubleMetaphone) handleT()", "line": "index = handleT(value, result, index);"}}, {"handleW": {"identifier": "(DoubleMetaphone) handleW()", "line": "index = handleW(value, result, index);"}}, {"handleX": {"identifier": "(DoubleMetaphone) handleX()", "line": "index = handleX(value, result, index);"}}, {"handleCH": {"identifier": "(DoubleMetaphone) handleCH()", "line": "index = handleCH(value, result, index);"}}, {"handleGH": {"identifier": "(DoubleMetaphone) handleGH()", "line": "index = handleGH(value, result, index);"}}, {"handleSC": {"identifier": "(DoubleMetaphone) handleSC()", "line": "index = handleSC(value, result, index);"}}, {"handleCC": {"identifier": "(DoubleMetaphone) handleCC()", "line": "return handleCC(value, result, index);"}}, {"handleAEIOUY": {"identifier": "(DoubleMetaphone) handleAEIOUY()", "line": "index = handleAEIOUY(value, result, index);"}}, {"handleG": {"identifier": "(DoubleMetaphone) handleG()", "line": "index = handleG(value, result, index, slavoGermanic);"}}, {"handleJ": {"identifier": "(DoubleMetaphone) handleJ()", "line": "index = handleJ(value, result, index, slavoGermanic);"}}, {"handleR": {"identifier": "(DoubleMetaphone) handleR()", "line": "index = handleR(value, result, index, slavoGermanic);"}}, {"handleS": {"identifier": "(DoubleMetaphone) handleS()", "line": "index = handleS(value, result, index, slavoGermanic);"}}, {"handleZ": {"identifier": "(DoubleMetaphone) handleZ()", "line": "index = handleZ(value, result, index, slavoGermanic);"}}, {"isComplete": {"identifier": "(DoubleMetaphoneResult) isComplete()", "line": "while (!result.isComplete() && index <= value.length() - 1) {"}}, {"isSilentStart": {"identifier": "(DoubleMetaphone) isSilentStart()", "line": "int index = isSilentStart(value) ? 1 : 0;"}}, {"SILENT_START": {"identifier": "(String) SILENT_START", "line": "if (value.startsWith(SILENT_START[i])) {"}}, {"isSlavoGermanic": {"identifier": "(DoubleMetaphone) isSlavoGermanic()", "line": "private boolean isSlavoGermanic(String value) {"}}, {"doubleMetaphone": {"identifier": "(DoubleMetaphone) doubleMetaphone()", "line": "public String doubleMetaphone(String value, boolean alternate) {"}}, {"cleanInput": {"identifier": "(DoubleMetaphone) cleanInput()", "line": "value = cleanInput(value);"}}, {"appendAlternate": {"identifier": "(DoubleMetaphoneResult) appendAlternate()", "line": "public void appendAlternate(String value) {"}}, {"appendPrimary": {"identifier": "(DoubleMetaphoneResult) appendPrimary()", "line": "public void appendPrimary(String value) {"}}, {"getAlternate": {"identifier": "(DoubleMetaphoneResult) getAlternate()", "line": "public String getAlternate() {"}}, {"DoubleMetaphone": {"identifier": "(DoubleMetaphone) DoubleMetaphone", "line": "public class DoubleMetaphone implements StringEncoder {"}}, {"setMaxCodeLen": {"identifier": "(DoubleMetaphone) setMaxCodeLen()", "line": "public void setMaxCodeLen(int maxCodeLen) {"}}, {"maxCodeLen": {"identifier": "(DoubleMetaphone) maxCodeLen", "line": "public void setMaxCodeLen(int maxCodeLen) {"}}, {"getMaxCodeLen": {"identifier": "(DoubleMetaphone) getMaxCodeLen()", "line": "public int getMaxCodeLen() {"}}, {"getPrimary": {"identifier": "(DoubleMetaphoneResult) getPrimary()", "line": "public String getPrimary() {"}}]}}], "Codec-4": [{"context": {"prefix": "    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n", "suffix": "    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n", "buggy": "    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(false);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n", "fix": "    private int modulus;\n\n    /**\n     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this Base64 object becomes useless,\n     * and must be thrown away.\n     */\n    private boolean eof;\n\n    /**\n     * Place holder for the 3 bytes we're dealing with for our base64 logic. Bitwise operations store and extract the\n     * base64 encoding or decoding from this variable.\n     */\n    private int x;\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is 0 (no chunking), and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     */\n    public Base64() {\n        this(0);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n     * <p>\n     * When encoding the line length is 76, the line separator is CRLF, and the encoding table is STANDARD_ENCODE_TABLE.\n     * </p>\n     * \n     * <p>\n     * When decoding all variants are supported.\n     * </p>\n     * \n     * @param urlSafe\n     *            if <code>true</code>, URL-safe encoding is used. In most cases this should be set to\n     *            <code>false</code>.\n     * @since 1.4\n     */\n    public Base64(boolean urlSafe) {\n        this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);\n    }\n\n    /**\n     * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.\n     * <p>\n     * When encoding the line length is given in the constructor, the line separator is CRLF, and the encoding table is\n", "start": 199, "end": 249, "file": "java/org/apache/commons/codec/binary/Base64.java"}, "tokens": {"original": [{"lineLength": {"identifier": "(int) lineLength", "line": "this(lineLength, lineSeparator, false);"}}, {"lineSeparator": {"identifier": "(byte) lineSeparator", "line": "this(lineLength, lineSeparator, false);"}}, {"encodeBase64": {"identifier": "(Base64) encodeBase64()", "line": "return encodeBase64(binaryData, false);"}}, {"CHUNK_SEPARATOR": {"identifier": "(byte) CHUNK_SEPARATOR", "line": "this(lineLength, CHUNK_SEPARATOR);"}}, {"encodeSize": {"identifier": "(int) encodeSize", "line": "this.encodeSize = 4;"}}, {"resizeBuffer": {"identifier": "(Base64) resizeBuffer()", "line": "resizeBuffer();"}}, {"readResults": {"identifier": "(Base64) readResults()", "line": "readResults(buf, 0, buf.length);"}}, {"CHUNK_SIZE": {"identifier": "(int) CHUNK_SIZE", "line": "this(CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);"}}, {"toIntegerBytes": {"identifier": "(Base64) toIntegerBytes()", "line": "return encodeBase64(toIntegerBytes(bigInt), false);"}}, {"readPos": {"identifier": "(Base64) readPos", "line": "private int readPos;"}}, {"decodeSize": {"identifier": "(Base64) decodeSize", "line": "private final int decodeSize;"}}, {"isBase64": {"identifier": "(Base64) isBase64()", "line": "if (isBase64(arrayOctet[i])) {"}}, {"isUrlSafe": {"identifier": "(Base64) isUrlSafe()", "line": "if (isUrlSafe() && pos < buf.length) {"}}, {"decodeBase64": {"identifier": "(Base64) decodeBase64()", "line": "return new BigInteger(1, decodeBase64(pArray));"}}, {"encodeTable": {"identifier": "(Base64) encodeTable", "line": "private final byte[] encodeTable;"}}, {"newStringUtf8": {"identifier": "(StringUtils) newStringUtf8()", "line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));"}}, {"StringUtils": {"identifier": "(StringUtils) StringUtils", "line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));"}}, {"hasData": {"identifier": "(Base64) hasData()", "line": "boolean hasData() {"}}, {"currentLinePos": {"identifier": "(int) currentLinePos", "line": "currentLinePos = 0;"}}, {"getBytesUtf8": {"identifier": "(StringUtils) getBytesUtf8()", "line": "return decode(StringUtils.getBytesUtf8(pArray));"}}, {"MASK_6BITS": {"identifier": "(Base64) MASK_6BITS", "line": "private static final int MASK_6BITS = 0x3f;"}}, {"MASK_8BITS": {"identifier": "(Base64) MASK_8BITS", "line": "private static final int MASK_8BITS = 0xff;"}}, {"getEncodeLength": {"identifier": "(Base64) getEncodeLength()", "line": "long len = getEncodeLength(pArray, lineLength, lineSeparator);"}}, {"DECODE_TABLE": {"identifier": "(Base64) DECODE_TABLE", "line": "private static final byte[] DECODE_TABLE = {"}}, {"isWhiteSpace": {"identifier": "(Base64) isWhiteSpace()", "line": "private static boolean isWhiteSpace(byte byteToCheck) {"}}, {"encodeToString": {"identifier": "(Base64) encodeToString()", "line": "public String encodeToString(byte[] pArray) {"}}, {"decodeInteger": {"identifier": "(Base64) decodeInteger()", "line": "public static BigInteger decodeInteger(byte[] pArray) {"}}, {"encodeInteger": {"identifier": "(Base64) encodeInteger()", "line": "public static byte[] encodeInteger(BigInteger bigInt) {"}}]}}], "Codec-7": [{"context": {"prefix": "                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n", "suffix": "    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n", "buggy": "                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n", "fix": "                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm but does not chunk the output.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     */\n    public static byte[] encodeBase64(byte[] binaryData) {\n        return encodeBase64(binaryData, false);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm into 76 character blocks separated by CRLF.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters.\n     * @since 1.4\n     */    \n    public static String encodeBase64String(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n    \n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     * \n     * @param binaryData\n     *            binary data to encode\n     * @return byte[] containing Base64 characters in their UTF-8 representation.\n     * @since 1.4\n     */\n    public static byte[] encodeBase64URLSafe(byte[] binaryData) {\n        return encodeBase64(binaryData, false, true);\n    }\n\n    /**\n     * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n     * url-safe variation emits - and _ instead of + and / characters.\n     *\n     * @param binaryData\n     *            binary data to encode\n     * @return String containing Base64 characters\n     * @since 1.4\n     */    \n    public static String encodeBase64URLSafeString(byte[] binaryData) {\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));\n", "start": 643, "end": 695, "file": "java/org/apache/commons/codec/binary/Base64.java"}, "tokens": {"original": [{"lineSeparator": {"identifier": "(byte) lineSeparator", "line": "String sep = StringUtils.newStringUtf8(lineSeparator);"}}, {"decodeBase64": {"identifier": "(Base64) decodeBase64()", "line": "return new BigInteger(1, decodeBase64(pArray));"}}, {"getBytesUtf8": {"identifier": "(StringUtils) getBytesUtf8()", "line": "return decode(StringUtils.getBytesUtf8(pArray));"}}, {"toIntegerBytes": {"identifier": "(Base64) toIntegerBytes()", "line": "return encodeBase64(toIntegerBytes(bigInt), false);"}}, {"encodeToString": {"identifier": "(Base64) encodeToString()", "line": "public String encodeToString(byte[] pArray) {"}}, {"MIME_CHUNK_SIZE": {"identifier": "(int) MIME_CHUNK_SIZE", "line": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);"}}, {"CHUNK_SEPARATOR": {"identifier": "(byte) CHUNK_SEPARATOR", "line": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);"}}, {"getEncodeLength": {"identifier": "(Base64) getEncodeLength()", "line": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);"}}, {"isBase64": {"identifier": "(Base64) isBase64()", "line": "public static boolean isBase64(byte octet) {"}}, {"encodeSize": {"identifier": "(int) encodeSize", "line": "this.encodeSize = 4 + lineSeparator.length;"}}, {"lineLength": {"identifier": "(int) lineLength", "line": "this(lineLength, lineSeparator, false);"}}, {"encodeTable": {"identifier": "(byte) encodeTable", "line": "return this.encodeTable == URL_SAFE_ENCODE_TABLE;"}}, {"decodeSize": {"identifier": "(Base64) decodeSize", "line": "private final int decodeSize;"}}, {"isWhiteSpace": {"identifier": "(Base64) isWhiteSpace()", "line": "private static boolean isWhiteSpace(byte byteToCheck) {"}}, {"decodeInteger": {"identifier": "(Base64) decodeInteger()", "line": "public static BigInteger decodeInteger(byte[] pArray) {"}}, {"encodeInteger": {"identifier": "(Base64) encodeInteger()", "line": "public static byte[] encodeInteger(BigInteger bigInt) {"}}, {"readPos": {"identifier": "(int) readPos", "line": "return buffer != null ? pos - readPos : 0;"}}, {"readResults": {"identifier": "(Base64) readResults()", "line": "readResults(result, 0, result.length);"}}, {"currentLinePos": {"identifier": "(Base64) currentLinePos", "line": "private int currentLinePos;"}}, {"DECODE_TABLE": {"identifier": "(byte) DECODE_TABLE", "line": "return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);"}}, {"MASK_6BITS": {"identifier": "(Base64) MASK_6BITS", "line": "private static final int MASK_6BITS = 0x3f;"}}, {"MASK_8BITS": {"identifier": "(Base64) MASK_8BITS", "line": "private static final int MASK_8BITS = 0xff;"}}, {"isUrlSafe": {"identifier": "(Base64) isUrlSafe()", "line": "public boolean isUrlSafe() {"}}, {"resizeBuffer": {"identifier": "(Base64) resizeBuffer()", "line": "private void resizeBuffer() {"}}, {"PEM_CHUNK_SIZE": {"identifier": "(Base64) PEM_CHUNK_SIZE", "line": "public static final int PEM_CHUNK_SIZE = 64;"}}, {"hasData": {"identifier": "(Base64) hasData()", "line": "boolean hasData() {"}}]}}], "Codec-9": [{"context": {"prefix": "        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n", "suffix": "        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n", "buggy": "        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n", "fix": "        return encodeBase64(binaryData, isChunked, urlSafe, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Encodes binary data using the base64 algorithm, optionally chunking the output into 76 character blocks.\n     * \n     * @param binaryData\n     *            Array containing binary data to encode.\n     * @param isChunked\n     *            if <code>true</code> this encoder will chunk the base64 output into 76 character blocks\n     * @param urlSafe\n     *            if <code>true</code> this encoder will emit - and _ instead of the usual + and / characters.\n     * @param maxResultSize\n     *            The maximum result size to accept.\n     * @return Base64-encoded data.\n     * @throws IllegalArgumentException\n     *             Thrown when the input array needs an output array bigger than maxResultSize\n     * @since 1.4\n     */\n    public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n        if (binaryData == null || binaryData.length == 0) {\n            return binaryData;\n        }\n\n        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);\n        if (len > maxResultSize) {\n            throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len +\n                \") than the specified maxium size of \" +\n                maxResultSize);\n        }\n                \n        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n        return b64.encode(binaryData);\n    }\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n", "start": 802, "end": 850, "file": "java/org/apache/commons/codec/binary/Base64.java"}, "tokens": {"original": [{"urlSafe": {"identifier": "(boolean) urlSafe", "line": "this(MIME_CHUNK_SIZE, CHUNK_SEPARATOR, urlSafe);"}}, {"lineLength": {"identifier": "(int) lineLength", "line": "this(lineLength, CHUNK_SEPARATOR);"}}, {"encodeBase64": {"identifier": "(Base64) encodeBase64()", "line": "return encodeBase64(binaryData, false, true);"}}, {"isChunked": {"identifier": "(boolean) isChunked", "line": "return encodeBase64(binaryData, isChunked, false);"}}, {"newStringUtf8": {"identifier": "(StringUtils) newStringUtf8()", "line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));"}}, {"StringUtils": {"identifier": "(StringUtils) StringUtils", "line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false, true));"}}, {"lineSeparator": {"identifier": "(byte) lineSeparator", "line": "lineSeparator = CHUNK_SEPARATOR;  // this just gets ignored"}}, {"PEM_CHUNK_SIZE": {"identifier": "(Base64) PEM_CHUNK_SIZE", "line": "public static final int PEM_CHUNK_SIZE = 64;"}}, {"toIntegerBytes": {"identifier": "(Base64) toIntegerBytes()", "line": "return encodeBase64(toIntegerBytes(bigInt), false);"}}, {"maxResultSize": {"identifier": "() maxResultSize", "line": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {"}}, {"encodeToString": {"identifier": "(Base64) encodeToString()", "line": "public String encodeToString(byte[] pArray) {"}}, {"encodeTable": {"identifier": "(byte) encodeTable", "line": "return this.encodeTable == URL_SAFE_ENCODE_TABLE;"}}, {"MASK_6BITS": {"identifier": "(int) MASK_6BITS", "line": "buffer[pos++] = encodeTable[x & MASK_6BITS];"}}, {"getBytesUtf8": {"identifier": "(StringUtils) getBytesUtf8()", "line": "return decode(StringUtils.getBytesUtf8(pArray));"}}, {"decodeInteger": {"identifier": "(Base64) decodeInteger()", "line": "public static BigInteger decodeInteger(byte[] pArray) {"}}, {"encodeInteger": {"identifier": "(Base64) encodeInteger()", "line": "public static byte[] encodeInteger(BigInteger bigInt) {"}}, {"currentLinePos": {"identifier": "(int) currentLinePos", "line": "if (lineLength > 0 && lineLength <= currentLinePos) {"}}, {"DECODE_TABLE": {"identifier": "(byte) DECODE_TABLE", "line": "return octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);"}}, {"decodeBase64": {"identifier": "(Base64) decodeBase64()", "line": "public static byte[] decodeBase64(byte[] base64Data) {"}}, {"MASK_8BITS": {"identifier": "(int) MASK_8BITS", "line": "buffer[pos++] = (byte) (x & MASK_8BITS);"}}, {"encodeSize": {"identifier": "(int) encodeSize", "line": "this.decodeSize = this.encodeSize - 1;"}}, {"decodeSize": {"identifier": "(int) decodeSize", "line": "this.decodeSize = this.encodeSize - 1;"}}, {"readResults": {"identifier": "(Base64) readResults()", "line": "int readResults(byte[] b, int bPos, int bAvail) {"}}, {"hasData": {"identifier": "(Base64) hasData()", "line": "boolean hasData() {"}}, {"readPos": {"identifier": "(int) readPos", "line": "byte[] buf = new byte[pos - readPos];"}}, {"isWhiteSpace": {"identifier": "(Base64) isWhiteSpace()", "line": "private static boolean isWhiteSpace(byte byteToCheck) {"}}, {"isBase64": {"identifier": "(Base64) isBase64()", "line": "return isBase64(StringUtils.getBytesUtf8(base64));"}}, {"isUrlSafe": {"identifier": "(Base64) isUrlSafe()", "line": "public boolean isUrlSafe() {"}}, {"resizeBuffer": {"identifier": "(Base64) resizeBuffer()", "line": "private void resizeBuffer() {"}}]}}], "Codec-10": [{"context": {"prefix": "\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n", "suffix": "\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n", "buggy": "\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"^mb\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n", "fix": "\n        // 2. Remove anything not A-Z\n        txt = txt.replaceAll(\"[^a-z]\", \"\");\n\n        // 2.5. Remove final e\n        txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n\n        // 3. Handle various start options\n        txt = txt.replaceAll(\"^cough\", \"cou2f\");\n        txt = txt.replaceAll(\"^rough\", \"rou2f\");\n        txt = txt.replaceAll(\"^tough\", \"tou2f\");\n        txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n        txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n        txt = txt.replaceAll(\"^gn\", \"2n\");\n\n        // End \n        txt = txt.replaceAll(\"mb$\", \"m2\");\n\n        // 4. Handle replacements\n        txt = txt.replaceAll(\"cq\", \"2q\");\n        txt = txt.replaceAll(\"ci\", \"si\");\n        txt = txt.replaceAll(\"ce\", \"se\");\n        txt = txt.replaceAll(\"cy\", \"sy\");\n        txt = txt.replaceAll(\"tch\", \"2ch\");\n        txt = txt.replaceAll(\"c\", \"k\");\n        txt = txt.replaceAll(\"q\", \"k\");\n        txt = txt.replaceAll(\"x\", \"k\");\n        txt = txt.replaceAll(\"v\", \"f\");\n        txt = txt.replaceAll(\"dg\", \"2g\");\n        txt = txt.replaceAll(\"tio\", \"sio\");\n        txt = txt.replaceAll(\"tia\", \"sia\");\n        txt = txt.replaceAll(\"d\", \"t\");\n        txt = txt.replaceAll(\"ph\", \"fh\");\n", "start": 59, "end": 91, "file": "java/org/apache/commons/codec/language/Caverphone.java"}, "tokens": {"original": []}}], "Codec-17": [{"context": {"prefix": "            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n", "suffix": "    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n", "buggy": "            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n", "fix": "            return new String(bytes, charsetName);\n        } catch (final UnsupportedEncodingException e) {\n            throw StringUtils.newIllegalStateException(charsetName, e);\n        }\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the ISO-8859-1 charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters, may be <code>null</code>\n     * @return A new <code>String</code> decoded from the specified array of bytes using the ISO-8859-1 charset, or\n     *         <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringIso8859_1(final byte[] bytes) {\n        return newString(bytes, Charsets.ISO_8859_1);\n    }\n\n    /**\n     * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n     *\n     * @param bytes\n     *            The bytes to be decoded into characters\n     * @return A new <code>String</code> decoded from the specified array of bytes using the US-ASCII charset,\n     *         or <code>null</code> if the input byte array was <code>null</code>.\n     * @throws NullPointerException\n     *             Thrown if {@link Charsets#US_ASCII} is not initialized, which should never happen since it is\n     *             required by the Java platform specification.\n     * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n     */\n    public static String newStringUsAscii(final byte[] bytes) {\n        return newString(bytes, Charsets.US_ASCII);\n    }\n\n    /**\n", "start": 319, "end": 357, "file": "main/java/org/apache/commons/codec/binary/StringUtils.java"}, "tokens": {"original": [{"newString": {"identifier": "(StringUtils) newString()", "line": "return newString(bytes, Charsets.UTF_8);"}}, {"UTF_8": {"identifier": "(Charset) UTF_8", "line": "return newString(bytes, Charsets.UTF_8);"}}, {"UTF_16": {"identifier": "(Charset) UTF_16", "line": "return newString(bytes, Charsets.UTF_16);"}}, {"US_ASCII": {"identifier": "(Charset) US_ASCII", "line": "return newString(bytes, Charsets.US_ASCII);"}}, {"UTF_16BE": {"identifier": "(Charset) UTF_16BE", "line": "return newString(bytes, Charsets.UTF_16BE);"}}, {"UTF_16LE": {"identifier": "(Charset) UTF_16LE", "line": "return newString(bytes, Charsets.UTF_16LE);"}}, {"getBytes": {"identifier": "(StringUtils) getBytes()", "line": "return getBytes(string, Charsets.ISO_8859_1);"}}, {"getByteBuffer": {"identifier": "(StringUtils) getByteBuffer()", "line": "return getByteBuffer(string, Charsets.UTF_8);"}}, {"newStringUtf8": {"identifier": "(StringUtils) newStringUtf8()", "line": "public static String newStringUtf8(final byte[] bytes) {"}}, {"newStringUtf16": {"identifier": "(StringUtils) newStringUtf16()", "line": "public static String newStringUtf16(final byte[] bytes) {"}}, {"StringUtils": {"identifier": "(StringUtils) StringUtils", "line": "throw StringUtils.newIllegalStateException(charsetName, e);"}}, {"regionMatches": {"identifier": "(CharSequenceUtils) regionMatches()", "line": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));"}}, {"getBytesUtf8": {"identifier": "(StringUtils) getBytesUtf8()", "line": "public static byte[] getBytesUtf8(final String string) {"}}, {"getBytesUtf16": {"identifier": "(StringUtils) getBytesUtf16()", "line": "public static byte[] getBytesUtf16(final String string) {"}}, {"getBytesUsAscii": {"identifier": "(StringUtils) getBytesUsAscii()", "line": "public static byte[] getBytesUsAscii(final String string) {"}}, {"getBytesUtf16Be": {"identifier": "(StringUtils) getBytesUtf16Be()", "line": "public static byte[] getBytesUtf16Be(final String string) {"}}, {"getBytesUtf16Le": {"identifier": "(StringUtils) getBytesUtf16Le()", "line": "public static byte[] getBytesUtf16Le(final String string) {"}}]}}], "Codec-18": [{"context": {"prefix": "     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n", "suffix": "    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n", "buggy": "     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n", "fix": "     * StringUtils.equals(\"abc\", \"ABC\") = false\n     * </pre>\n     *\n     * <p>\n     * Copied from Apache Commons Lang r1583482 on April 10, 2014 (day of 3.3.2 release).\n     * </p>\n     *\n     * @see Object#equals(Object)\n     * @param cs1\n     *            the first CharSequence, may be <code>null</code>\n     * @param cs2\n     *            the second CharSequence, may be <code>null</code>\n     * @return <code>true</code> if the CharSequences are equal (case-sensitive), or both <code>null</code>\n     * @since 1.10\n     */\n    public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1 instanceof String && cs2 instanceof String) {\n            return cs1.equals(cs2);\n        }\n        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n     * @return the encoded bytes\n     */\n    private static byte[] getBytes(final String string, final Charset charset) {\n        if (string == null) {\n            return null;\n        }\n        return string.getBytes(charset);\n    }\n\n    /**\n     * Calls {@link String#getBytes(Charset)}\n     *\n     * @param string\n     *            The string to encode (if null, return null).\n     * @param charset\n     *            The {@link Charset} to encode the <code>String</code>\n", "start": 55, "end": 105, "file": "main/java/org/apache/commons/codec/binary/StringUtils.java"}, "tokens": {"original": [{"newString": {"identifier": "(StringUtils) newString()", "line": "private static String newString(final byte[] bytes, final Charset charset) {"}}, {"UTF_8": {"identifier": "(Charset) UTF_8", "line": "return newString(bytes, Charsets.UTF_8);"}}, {"UTF_16": {"identifier": "(Charset) UTF_16", "line": "return newString(bytes, Charsets.UTF_16);"}}, {"US_ASCII": {"identifier": "(Charset) US_ASCII", "line": "return newString(bytes, Charsets.US_ASCII);"}}, {"UTF_16BE": {"identifier": "(Charset) UTF_16BE", "line": "return newString(bytes, Charsets.UTF_16BE);"}}, {"UTF_16LE": {"identifier": "(Charset) UTF_16LE", "line": "return newString(bytes, Charsets.UTF_16LE);"}}, {"StringUtils": {"identifier": "(StringUtils) StringUtils", "line": "throw StringUtils.newIllegalStateException(charsetName, e);"}}, {"ISO_8859_1": {"identifier": "(Charset) ISO_8859_1", "line": "return newString(bytes, Charsets.ISO_8859_1);"}}, {"getBytes": {"identifier": "(StringUtils) getBytes()", "line": "private static byte[] getBytes(final String string, final Charset charset) {"}}, {"getByteBuffer": {"identifier": "(StringUtils) getByteBuffer()", "line": "private static ByteBuffer getByteBuffer(final String string, final Charset charset) {"}}, {"getBytesUtf8": {"identifier": "(StringUtils) getBytesUtf8()", "line": "public static byte[] getBytesUtf8(final String string) {"}}, {"getBytesUtf16": {"identifier": "(StringUtils) getBytesUtf16()", "line": "public static byte[] getBytesUtf16(final String string) {"}}, {"getBytesUsAscii": {"identifier": "(StringUtils) getBytesUsAscii()", "line": "public static byte[] getBytesUsAscii(final String string) {"}}, {"getBytesUtf16Be": {"identifier": "(StringUtils) getBytesUtf16Be()", "line": "public static byte[] getBytesUtf16Be(final String string) {"}}, {"getBytesUtf16Le": {"identifier": "(StringUtils) getBytesUtf16Le()", "line": "public static byte[] getBytesUtf16Le(final String string) {"}}, {"newStringUtf8": {"identifier": "(StringUtils) newStringUtf8()", "line": "public static String newStringUtf8(final byte[] bytes) {"}}, {"newStringUtf16": {"identifier": "(StringUtils) newStringUtf16()", "line": "public static String newStringUtf16(final byte[] bytes) {"}}]}}], "JacksonCore-5": [{"context": {"prefix": "\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n", "suffix": "            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n", "buggy": "\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i++);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n", "fix": "\n    @Override public String toString() { return _asString; }\n    @Override public int hashCode() { return _asString.hashCode(); }\n\n    @Override public boolean equals(Object o) {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (!(o instanceof JsonPointer)) return false;\n        return _asString.equals(((JsonPointer) o)._asString);\n    }\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private final static int _parseIndex(String str) {\n        final int len = str.length();\n        // [Issue#133]: beware of super long indexes; assume we never\n        // have arrays over 2 billion entries so ints are fine.\n        if (len == 0 || len > 10) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);\n            if (c > '9' || c < '0') {\n                return -1;\n            }\n        }\n        if (len == 10) {\n            long l = NumberInput.parseLong(str);\n            if (l > Integer.MAX_VALUE) {\n                return -1;\n            }\n        }\n        return NumberInput.parseInt(str);\n    }\n    \n    protected static JsonPointer _parseTail(String input) {\n        final int end = input.length();\n\n        // first char is the contextual slash, skip\n        for (int i = 1; i < end; ) {\n            char c = input.charAt(i);\n            if (c == '/') { // common case, got a segment\n                return new JsonPointer(input, input.substring(1, i),\n                        _parseTail(input.substring(i)));\n            }\n            ++i;\n            // quoting is different; offline this case\n", "start": 167, "end": 217, "file": "main/java/com/fasterxml/jackson/core/JsonPointer.java"}, "tokens": {"original": [{"_appendEscape": {"identifier": "(JsonPointer) _appendEscape()", "line": "_appendEscape(sb, input.charAt(i++));"}}, {"_asString": {"identifier": "(String) _asString", "line": "_asString = fullString;"}}, {"parseLong": {"identifier": "(NumberInput) parseLong()", "line": "long l = NumberInput.parseLong(str);"}}, {"NumberInput": {"identifier": "(NumberInput) NumberInput", "line": "long l = NumberInput.parseLong(str);"}}, {"_parseTail": {"identifier": "(JsonPointer) _parseTail()", "line": "return _parseTail(input);"}}, {"parseInt": {"identifier": "(NumberInput) parseInt()", "line": "return NumberInput.parseInt(str);"}}, {"hashCode": {"identifier": "(String) hashCode()", "line": "@Override public int hashCode() { return _asString.hashCode(); }"}}, {"matchProperty": {"identifier": "(JsonPointer) matchProperty()", "line": "public JsonPointer matchProperty(String name) {"}}, {"JsonPointer": {"identifier": "(JsonPointer) JsonPointer", "line": "public JsonPointer matchProperty(String name) {"}}, {"matchElement": {"identifier": "(JsonPointer) matchElement()", "line": "public JsonPointer matchElement (int index) {"}}, {"_parseIndex": {"identifier": "(JsonPointer) _parseIndex()", "line": "private final static int _parseIndex(String str) {"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return new JsonPointer(input, sb.toString(),"}}, {"valueOf": {"identifier": "(JsonPointer) valueOf()", "line": "public static JsonPointer valueOf(String input) { return compile(input); }"}}, {"_nextSegment": {"identifier": "(JsonPointer) _nextSegment", "line": "protected final JsonPointer _nextSegment;"}}, {"mayMatchElement": {"identifier": "(JsonPointer) mayMatchElement()", "line": "public boolean mayMatchElement() { return _matchingElementIndex >= 0; }"}}]}}], "JacksonCore-8": [{"context": {"prefix": "         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n", "suffix": "        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n", "buggy": "         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n", "fix": "         */\n        return (_inputStart >= 0) ? _inputStart : 0;\n    }\n\n    /**\n     * Method that can be used to check whether textual contents can\n     * be efficiently accessed using {@link #getTextBuffer}.\n     */\n    public boolean hasTextAsCharacters()\n    {\n        // if we have array in some form, sure\n        if (_inputStart >= 0 || _resultArray != null)  return true;\n        // not if we have String as value\n        if (_resultString != null) return false;\n        return true;\n    }\n    \n    public char[] getTextBuffer()\n    {\n        // Are we just using shared input buffer?\n        if (_inputStart >= 0) return _inputBuffer;\n        if (_resultArray != null)  return _resultArray;\n        if (_resultString != null) {\n            return (_resultArray = _resultString.toCharArray());\n        }\n        // Nope; but does it fit in just one segment?\n        if (!_hasSegments && _currentSegment != null)  return _currentSegment;\n        // Nope, need to have/create a non-segmented array and return it\n        return contentsAsArray();\n    }\n\n    /*\n    /**********************************************************\n    /* Other accessors:\n    /**********************************************************\n     */\n\n    public String contentsAsString()\n    {\n        if (_resultString == null) {\n            // Has array been requested? Can make a shortcut, if so:\n            if (_resultArray != null) {\n                _resultString = new String(_resultArray);\n            } else {\n                // Do we use shared array?\n                if (_inputStart >= 0) {\n                    if (_inputLen < 1) {\n                        return (_resultString = \"\");\n                    }\n                    _resultString = new String(_inputBuffer, _inputStart, _inputLen);\n                } else { // nope... need to copy\n                    // But first, let's see if we have just one buffer\n                    int segLen = _segmentSize;\n", "start": 280, "end": 332, "file": "main/java/com/fasterxml/jackson/core/util/TextBuffer.java"}, "tokens": {"original": [{"_segments": {"identifier": "(ArrayList) _segments", "line": "_segments.add(_currentSegment);"}}, {"_segmentSize": {"identifier": "(int) _segmentSize", "line": "if ((_segmentSize == 0) && (_currentSegment != null)) {"}}, {"_currentSize": {"identifier": "(int) _currentSize", "line": "public int getCurrentSegmentSize() { return _currentSize; }"}}, {"_inputStart": {"identifier": "(int) _inputStart", "line": "if (_inputStart >= 0) return _inputBuffer;"}}, {"_inputBuffer": {"identifier": "(char) _inputBuffer", "line": "if (_inputStart >= 0) return _inputBuffer;"}}, {"_resultArray": {"identifier": "(char) _resultArray", "line": "if (_resultArray != null)  return _resultArray;"}}, {"_resultString": {"identifier": "(String) _resultString", "line": "if (_resultString != null) return false;"}}, {"_inputLen": {"identifier": "(int) _inputLen", "line": "int sharedLen = _inputLen;"}}, {"contentsAsArray": {"identifier": "(TextBuffer) contentsAsArray()", "line": "return contentsAsArray();"}}, {"parseBigDecimal": {"identifier": "(NumberInput) parseBigDecimal()", "line": "return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);"}}, {"NumberInput": {"identifier": "(NumberInput) NumberInput", "line": "return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize);"}}, {"toString": {"identifier": "(TextBuffer) toString()", "line": "@Override public String toString() { return contentsAsString(); }"}}, {"clearSegments": {"identifier": "(TextBuffer) clearSegments()", "line": "private void clearSegments()"}}, {"TextBuffer": {"identifier": "(TextBuffer) TextBuffer", "line": "*  <li>TextBuffer uses segments character arrays, to avoid having"}}, {"parseDouble": {"identifier": "(NumberInput) parseDouble()", "line": "return NumberInput.parseDouble(contentsAsString());"}}, {"NO_CHARS": {"identifier": "(char) NO_CHARS", "line": "return NO_CHARS;"}}, {"_allocator": {"identifier": "(BufferRecycler) _allocator", "line": "if (_allocator == null) {"}}, {"resultArray": {"identifier": "(TextBuffer) resultArray()", "line": "_resultArray = result = resultArray();"}}, {"BufferRecycler": {"identifier": "(BufferRecycler) BufferRecycler", "line": "private final BufferRecycler _allocator;"}}, {"getTextOffset": {"identifier": "(TextBuffer) getTextOffset()", "line": "public int getTextOffset() {"}}, {"getTextBuffer": {"identifier": "(TextBuffer) getTextBuffer()", "line": "public char[] getTextBuffer()"}}, {"resetWithCopy": {"identifier": "(TextBuffer) resetWithCopy()", "line": "public void resetWithCopy(char[] buf, int start, int len)"}}, {"ensureNotShared": {"identifier": "(TextBuffer) ensureNotShared()", "line": "public void ensureNotShared() {"}}, {"MIN_SEGMENT_LEN": {"identifier": "(int) MIN_SEGMENT_LEN", "line": "if (newLen < MIN_SEGMENT_LEN) {"}}, {"MAX_SEGMENT_LEN": {"identifier": "(int) MAX_SEGMENT_LEN", "line": "if (newLen > MAX_SEGMENT_LEN) {"}}, {"resetWithShared": {"identifier": "(TextBuffer) resetWithShared()", "line": "public void resetWithShared(char[] buf, int start, int len)"}}, {"allocCharBuffer": {"identifier": "(BufferRecycler) allocCharBuffer()", "line": "return _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);"}}, {"resetWithString": {"identifier": "(TextBuffer) resetWithString()", "line": "public void resetWithString(String value)"}}, {"resetWithEmpty": {"identifier": "(TextBuffer) resetWithEmpty()", "line": "resetWithEmpty();"}}, {"releaseBuffers": {"identifier": "(TextBuffer) releaseBuffers()", "line": "public void releaseBuffers()"}}]}}], "JacksonCore-11": [{"context": {"prefix": "\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n", "suffix": "        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n\n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n", "buggy": "\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n\n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n", "fix": "\n    private void _verifyNeedForRehash() {\n        // Yes if above 80%, or above 50% AND have ~1% spill-overs\n        if (_count > (_hashSize >> 1)) { // over 50%\n            int spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\n            if ((spillCount > (1 + _count >> 7))\n                    || (_count > (_hashSize * 0.80))) {\n                _needRehash = true;\n            }\n        }\n    }\n\n    private void _verifySharing()\n    {\n        if (_hashShared) {\n            _hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n            _names = Arrays.copyOf(_names, _names.length);\n            _hashShared = false;\n            // 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n            //    we rehash as needed, as need-rehash flag is not copied from parent\n            _verifyNeedForRehash();\n        }\n        if (_needRehash) {\n            rehash();\n        }\n    }\n\n    /**\n     * Method called to find the location within hash table to add a new symbol in.\n     */\n    private int _findOffsetForAdd(int hash)\n    {\n        // first, check the primary:\n        int offset = _calcOffset(hash);\n        final int[] hashArea = _hashArea;\n        if (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n            return offset;\n        }\n        // then secondary\n        int offset2 = _secondaryStart + ((offset >> 3) << 2);\n        if (hashArea[offset2+3] == 0) {\n", "start": 861, "end": 901, "file": "main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java"}, "tokens": {}}], "JacksonCore-25": [{"context": {"prefix": "                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n", "suffix": "                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n", "buggy": "                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i <= maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n", "fix": "                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        return JsonToken.VALUE_STRING;\n    }\n\n    private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n    {\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n        char[] outBuf = _textBuffer.getCurrentSegment();\n        int outPtr = _textBuffer.getCurrentSegmentSize();\n        final int maxCode = codes.length;\n\n        while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!_loadMore()) { // acceptable for now (will error out later)\n                    break;\n                }\n            }\n            char c = _inputBuffer[_inputPtr];\n            int i = (int) c;\n            if (i < maxCode) {\n                if (codes[i] != 0) {\n                    break;\n                }\n            } else if (!Character.isJavaIdentifierPart(c)) {\n                break;\n            }\n            ++_inputPtr;\n            hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n            // Ok, let's add char to output:\n            outBuf[outPtr++] = c;\n\n            // Need more room?\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n        }\n        _textBuffer.setCurrentLength(outPtr);\n        {\n            TextBuffer tb = _textBuffer;\n            char[] buf = tb.getTextBuffer();\n            int start = tb.getTextOffset();\n            int len = tb.size();\n\n            return _symbols.findSymbol(buf, start, len, hash);\n", "start": 1937, "end": 1987, "file": "main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java"}, "tokens": {"original": [{"_nameCopied": {"identifier": "(boolean) _nameCopied", "line": "if (!_nameCopied) {"}}, {"inObject": {"identifier": "(boolean) inObject", "line": "if (inObject) {"}}, {"_loadMore": {"identifier": "(ReaderBasedJsonParser) _loadMore()", "line": "if (!_loadMore()) {"}}, {"isNumeric": {"identifier": "(JsonToken) isNumeric()", "line": "if (t.isNumeric()) {"}}, {"_inputPtr": {"identifier": "(int) _inputPtr", "line": "if (_inputPtr < _inputEnd) {"}}, {"_inputEnd": {"identifier": "(int) _inputEnd", "line": "if (_inputPtr < _inputEnd) {"}}, {"outPtr": {"identifier": "(int) outPtr", "line": "if (outPtr >= outBuf.length) {"}}, {"outBuf": {"identifier": "(char) outBuf", "line": "if (outPtr >= outBuf.length) {"}}, {"_reader": {"identifier": "(Reader) _reader", "line": "if (_reader != null) {"}}, {"_binaryValue": {"identifier": "(byte) _binaryValue", "line": "if (_binaryValue == null) {"}}, {"JsonToken": {"identifier": "(JsonToken) JsonToken", "line": "if (t == JsonToken.FIELD_NAME) {"}}, {"FIELD_NAME": {"identifier": "(JsonToken) FIELD_NAME", "line": "if (t == JsonToken.FIELD_NAME) {"}}, {"VALUE_TRUE": {"identifier": "(JsonToken) VALUE_TRUE", "line": "if (t == JsonToken.VALUE_TRUE) {"}}, {"START_ARRAY": {"identifier": "(JsonToken) START_ARRAY", "line": "if (t == JsonToken.START_ARRAY) {"}}, {"VALUE_FALSE": {"identifier": "(JsonToken) VALUE_FALSE", "line": "if (t == JsonToken.VALUE_FALSE) {"}}, {"VALUE_STRING": {"identifier": "(JsonToken) VALUE_STRING", "line": "if (t == JsonToken.VALUE_STRING) {"}}, {"_nameCopyBuffer": {"identifier": "(char) _nameCopyBuffer", "line": "if (_nameCopyBuffer == null) {"}}, {"_inputBuffer": {"identifier": "(char) _inputBuffer", "line": "if (_inputBuffer[end] == '\"') {"}}, {"inRoot": {"identifier": "(JsonStreamContext) inRoot()", "line": "if (_parsingContext.inRoot()) {"}}, {"_parsingContext": {"identifier": "(JsonReadContext) _parsingContext", "line": "if (_parsingContext.inRoot()) {"}}, {"inArray": {"identifier": "(JsonStreamContext) inArray()", "line": "if (!_parsingContext.inArray()) {"}}, {"usesPadding": {"identifier": "(Base64Variant) usesPadding()", "line": "if (b64variant.usesPadding()) {"}}, {"expectComma": {"identifier": "(JsonReadContext) expectComma()", "line": "if (_parsingContext.expectComma()) {"}}, {"START_OBJECT": {"identifier": "(JsonToken) START_OBJECT", "line": "} else if (t == JsonToken.START_OBJECT) {"}}, {"_skipColon": {"identifier": "(ReaderBasedJsonParser) _skipColon()", "line": "i = _skipColon();"}}, {"Base64Variant": {"identifier": "(Base64Variant) Base64Variant", "line": "if (bits != Base64Variant.BASE64_VALUE_PADDING) {"}}, {"_skipWSOrEnd": {"identifier": "(ReaderBasedJsonParser) _skipWSOrEnd()", "line": "int i = _skipWSOrEnd();"}}, {"_skipComma": {"identifier": "(ReaderBasedJsonParser) _skipComma()", "line": "i = _skipComma(i);"}}, {"isEnabled": {"identifier": "(JsonParser) isEnabled()", "line": "if (!isEnabled(Feature.ALLOW_COMMENTS)) {"}}, {"ALLOW_COMMENTS": {"identifier": "(Feature) ALLOW_COMMENTS", "line": "if (!isEnabled(Feature.ALLOW_COMMENTS)) {"}}, {"charToHex": {"identifier": "(CharTypes) charToHex()", "line": "int digit = CharTypes.charToHex(ch);"}}, {"CharTypes": {"identifier": "(CharTypes) CharTypes", "line": "int digit = CharTypes.charToHex(ch);"}}, {"nextToken": {"identifier": "(ReaderBasedJsonParser) nextToken()", "line": "JsonToken t = nextToken();"}}, {"usesPaddingChar": {"identifier": "(Base64Variant) usesPaddingChar()", "line": "if (!b64variant.usesPaddingChar(ch)) {"}}, {"_hashSeed": {"identifier": "(int) _hashSeed", "line": "int hash = _hashSeed;"}}, {"_decodeEscaped": {"identifier": "(ReaderBasedJsonParser) _decodeEscaped()", "line": "c = _decodeEscaped();"}}, {"_parsePosNumber": {"identifier": "(ReaderBasedJsonParser) _parsePosNumber()", "line": "t = _parsePosNumber(i);"}}, {"_handleOddValue": {"identifier": "(ReaderBasedJsonParser) _handleOddValue()", "line": "t = _handleOddValue(i);"}}, {"_icLatin1": {"identifier": "(int) _icLatin1", "line": "final int[] codes = _icLatin1;"}}, {"getTextOffset": {"identifier": "(TextBuffer) getTextOffset()", "line": "int start = tb.getTextOffset();"}}, {"_nextToken": {"identifier": "(JsonToken) _nextToken", "line": "JsonToken t = _nextToken;"}}, {"getCurrentName": {"identifier": "(JsonReadContext) getCurrentName()", "line": "String n = _parsingContext.getCurrentName();"}}, {"_matchTrue": {"identifier": "(ReaderBasedJsonParser) _matchTrue()", "line": "private final void _matchTrue() throws IOException {"}}, {"_matchNull": {"identifier": "(ReaderBasedJsonParser) _matchNull()", "line": "private final void _matchNull() throws IOException {"}}, {"_matchFalse": {"identifier": "(ReaderBasedJsonParser) _matchFalse()", "line": "private final void _matchFalse() throws IOException {"}}, {"_getText2": {"identifier": "(ReaderBasedJsonParser) _getText2()", "line": "protected final String _getText2(JsonToken t) {"}}, {"_objectCodec": {"identifier": "(ObjectCodec) _objectCodec", "line": "_objectCodec = codec;"}}, {"_nameStartCol": {"identifier": "(ReaderBasedJsonParser) _nameStartCol", "line": "protected int _nameStartCol;"}}, {"asCharArray": {"identifier": "(JsonToken) asCharArray()", "line": "char[] ch = t.asCharArray();"}}, {"_textBuffer": {"identifier": "(TextBuffer) _textBuffer", "line": "TextBuffer tb = _textBuffer;"}}, {"TextBuffer": {"identifier": "(TextBuffer) TextBuffer", "line": "TextBuffer tb = _textBuffer;"}}, {"_skipComment": {"identifier": "(ReaderBasedJsonParser) _skipComment()", "line": "_skipComment();"}}, {"_parseNegNumber": {"identifier": "(ReaderBasedJsonParser) _parseNegNumber()", "line": "t = _parseNegNumber();"}}, {"_updateLocation": {"identifier": "(ReaderBasedJsonParser) _updateLocation()", "line": "private final void _updateLocation()"}}, {"getCodec": {"identifier": "(ReaderBasedJsonParser) getCodec()", "line": "@Override public ObjectCodec getCodec() { return _objectCodec; }"}}, {"ObjectCodec": {"identifier": "(ObjectCodec) ObjectCodec", "line": "@Override public ObjectCodec getCodec() { return _objectCodec; }"}}, {"startPtr": {"identifier": "(int) startPtr", "line": "int len = ptr-startPtr;"}}, {"_skipCComment": {"identifier": "(ReaderBasedJsonParser) _skipCComment()", "line": "_skipCComment();"}}, {"_parseName": {"identifier": "(ReaderBasedJsonParser) _parseName()", "line": "String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);"}}, {"_handleOddName": {"identifier": "(ReaderBasedJsonParser) _handleOddName()", "line": "String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);"}}, {"_closeScope": {"identifier": "(ReaderBasedJsonParser) _closeScope()", "line": "private void _closeScope(int i) throws JsonParseException {"}}, {"setCodec": {"identifier": "(ReaderBasedJsonParser) setCodec()", "line": "@Override public void setCodec(ObjectCodec c) { _objectCodec = c; }"}}, {"finishToken": {"identifier": "(ReaderBasedJsonParser) finishToken()", "line": "public void finishToken() throws IOException {"}}, {"getTextBuffer": {"identifier": "(TextBuffer) getTextBuffer()", "line": "char[] buf = tb.getTextBuffer();"}}, {"getNextChar": {"identifier": "(ReaderBasedJsonParser) getNextChar()", "line": ": getNextChar(\"expected a digit for number exponent\");"}}, {"_skipColon2": {"identifier": "(ReaderBasedJsonParser) _skipColon2()", "line": "return _skipColon2(true);"}}, {"_nextAfterName": {"identifier": "(ReaderBasedJsonParser) _nextAfterName()", "line": "private final JsonToken _nextAfterName()"}}, {"asQuotedChars": {"identifier": "(SerializableString) asQuotedChars()", "line": "char[] nameChars = sstr.asQuotedChars();"}}, {"_ioContext": {"identifier": "(IOContext) _ioContext", "line": "if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {"}}, {"HASH_MULT": {"identifier": "(int) HASH_MULT", "line": "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;"}}, {"nextFieldName": {"identifier": "(ReaderBasedJsonParser) nextFieldName()", "line": "public String nextFieldName() throws IOException"}}, {"hashSeed": {"identifier": "(CharsToNameCanonicalizer) hashSeed()", "line": "_hashSeed = st.hashSeed();"}}, {"_decodeBase64": {"identifier": "(ReaderBasedJsonParser) _decodeBase64()", "line": "_binaryValue = _decodeBase64(b64variant);"}}, {"_closeInput": {"identifier": "(ReaderBasedJsonParser) _closeInput()", "line": "protected void _closeInput() throws IOException {"}}, {"releaseBuffered": {"identifier": "(ReaderBasedJsonParser) releaseBuffered()", "line": "public int releaseBuffered(Writer w) throws IOException {"}}, {"_nameStartRow": {"identifier": "(int) _nameStartRow", "line": "-1L, total, _nameStartRow, _nameStartCol);"}}, {"_symbols": {"identifier": "(ReaderBasedJsonParser) _symbols", "line": "final protected CharsToNameCanonicalizer _symbols;"}}, {"VALUE_NULL": {"identifier": "(JsonToken) VALUE_NULL", "line": "return (_currToken = JsonToken.VALUE_NULL);"}}, {"_handleOddName2": {"identifier": "(ReaderBasedJsonParser) _handleOddName2()", "line": "return _handleOddName2(start, hash, codes);"}}, {"_skipLine": {"identifier": "(ReaderBasedJsonParser) _skipLine()", "line": "_skipLine();"}}, {"getTextLength": {"identifier": "(ReaderBasedJsonParser) getTextLength()", "line": "public final int getTextLength() throws IOException"}}, {"_skipCR": {"identifier": "(ReaderBasedJsonParser) _skipCR()", "line": "protected final void _skipCR() throws IOException {"}}, {"getInputSource": {"identifier": "(ReaderBasedJsonParser) getInputSource()", "line": "@Override public Object getInputSource() { return _reader; }"}}, {"_releaseBuffers": {"identifier": "(ReaderBasedJsonParser) _releaseBuffers()", "line": "protected void _releaseBuffers() throws IOException {"}}, {"toByteArray": {"identifier": "(ByteArrayBuilder) toByteArray()", "line": "_binaryValue = builder.toByteArray();"}}, {"nextLongValue": {"identifier": "(ReaderBasedJsonParser) nextLongValue()", "line": "public final long nextLongValue(long defaultValue) throws IOException"}}, {"_handleApos": {"identifier": "(ReaderBasedJsonParser) _handleApos()", "line": "return _handleApos();"}}, {"nextTextValue": {"identifier": "(ReaderBasedJsonParser) nextTextValue()", "line": "public final String nextTextValue() throws IOException"}}, {"getBinaryValue": {"identifier": "(ReaderBasedJsonParser) getBinaryValue()", "line": "byte[] b = getBinaryValue(b64variant);"}}, {"_matchToken": {"identifier": "(ReaderBasedJsonParser) _matchToken()", "line": "_matchToken(match, 3);"}}, {"IOContext": {"identifier": "(IOContext) IOContext", "line": "import com.fasterxml.jackson.core.io.IOContext;"}}, {"getText": {"identifier": "(ReaderBasedJsonParser) getText()", "line": "public final String getText() throws IOException"}}, {"_matchToken2": {"identifier": "(ReaderBasedJsonParser) _matchToken2()", "line": "private final void _matchToken2(String matchStr, int i) throws IOException"}}, {"nextIntValue": {"identifier": "(ReaderBasedJsonParser) nextIntValue()", "line": "public final int nextIntValue(int defaultValue) throws IOException"}}, {"resetFloat": {"identifier": "(ParserBase) resetFloat()", "line": "return resetFloat(neg, intLen, fractLen, expLen);"}}, {"JsonParser": {"identifier": "(JsonParser) JsonParser", "line": "* This is a concrete implementation of {@link JsonParser}, which is"}}, {"_parseAposName": {"identifier": "(ReaderBasedJsonParser) _parseAposName()", "line": "return _parseAposName();"}}, {"_checkMatchEnd": {"identifier": "(ReaderBasedJsonParser) _checkMatchEnd()", "line": "private final void _checkMatchEnd(String matchStr, int i, int c) throws IOException {"}}, {"_skipColonFast": {"identifier": "(ReaderBasedJsonParser) _skipColonFast()", "line": "private final int _skipColonFast(int ptr) throws IOException"}}, {"_skipString": {"identifier": "(ReaderBasedJsonParser) _skipString()", "line": "_skipString(); // only strings can be partial"}}, {"_verifyNLZ2": {"identifier": "(ReaderBasedJsonParser) _verifyNLZ2()", "line": "private char _verifyNLZ2() throws IOException"}}, {"appendTwoBytes": {"identifier": "(ByteArrayBuilder) appendTwoBytes()", "line": "builder.appendTwoBytes(decodedData);"}}, {"_skipWSOrEnd2": {"identifier": "(ReaderBasedJsonParser) _skipWSOrEnd2()", "line": "private int _skipWSOrEnd2() throws IOException"}}, {"resetAsNaN": {"identifier": "(ParserBase) resetAsNaN()", "line": "return resetAsNaN(\"NaN\", Double.NaN);"}}, {"typeDesc": {"identifier": "(JsonStreamContext) typeDesc()", "line": "_reportInvalidEOF(\" within/between \"+_parsingContext.typeDesc()+\" entries\","}}, {"getValue": {"identifier": "(SerializableString) getValue()", "line": "return _isNextTokenNameMaybe(i, sstr.getValue());"}}, {"resetInt": {"identifier": "(ParserBase) resetInt()", "line": "return resetInt(true, intLen);"}}, {"ParserBase": {"identifier": "(ParserBase) ParserBase", "line": "import com.fasterxml.jackson.core.base.ParserBase;"}}, {"_finishString": {"identifier": "(ReaderBasedJsonParser) _finishString()", "line": "_finishString(); // only strings can be incomplete"}}, {"findSymbol": {"identifier": "(CharsToNameCanonicalizer) findSymbol()", "line": "return _symbols.findSymbol(buf, start, len, hash);"}}, {"_finishString2": {"identifier": "(ReaderBasedJsonParser) _finishString2()", "line": "protected void _finishString2() throws IOException"}}, {"_readBinary": {"identifier": "(ReaderBasedJsonParser) _readBinary()", "line": "return _readBinary(b64variant, out, buf);"}}, {"getIntValue": {"identifier": "(ParserBase) getIntValue()", "line": "return getIntValue();"}}, {"_parseFloat": {"identifier": "(ReaderBasedJsonParser) _parseFloat()", "line": "private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)"}}, {"_parseName2": {"identifier": "(ReaderBasedJsonParser) _parseName2()", "line": "private String _parseName2(int startPtr, int hash, int endChar) throws IOException"}}, {"_parseNumber2": {"identifier": "(ReaderBasedJsonParser) _parseNumber2()", "line": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException"}}, {"getLongValue": {"identifier": "(ParserBase) getLongValue()", "line": "return getLongValue();"}}, {"END_ARRAY": {"identifier": "(JsonToken) END_ARRAY", "line": "_currToken = JsonToken.END_ARRAY;"}}, {"resetWithShared": {"identifier": "(TextBuffer) resetWithShared()", "line": "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));"}}, {"END_OBJECT": {"identifier": "(JsonToken) END_OBJECT", "line": "_currToken = JsonToken.END_OBJECT;"}}, {"_eofAsNextChar": {"identifier": "(ParserBase) _eofAsNextChar()", "line": "return _eofAsNextChar();"}}, {"readBinaryValue": {"identifier": "(ReaderBasedJsonParser) readBinaryValue()", "line": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException"}}, {"OutputStream": {"identifier": "(OutputStream) OutputStream", "line": "public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException"}}, {"_tokenInputRow": {"identifier": "(int) _tokenInputRow", "line": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"}}, {"_tokenInputCol": {"identifier": "(int) _tokenInputCol", "line": "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);"}}, {"getMask": {"identifier": "(Feature.ALLOW_TRAILING_COMMA) getMask()", "line": "protected final static int FEAT_MASK_TRAILING_COMMA = Feature.ALLOW_TRAILING_COMMA.getMask();"}}, {"setCurrentName": {"identifier": "(JsonReadContext) setCurrentName()", "line": "_parsingContext.setCurrentName(name);"}}, {"_numTypesValid": {"identifier": "(int) _numTypesValid", "line": "_numTypesValid = NR_UNKNOWN;"}}, {"_currInputRow": {"identifier": "(int) _currInputRow", "line": "_nameStartRow = _currInputRow;"}}, {"asString": {"identifier": "(JsonToken) asString()", "line": "return t.asString();"}}, {"resetWithCopy": {"identifier": "(TextBuffer) resetWithCopy()", "line": "_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));"}}, {"getPaddingChar": {"identifier": "(Base64Variant) getPaddingChar()", "line": "throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");"}}]}}], "JacksonCore-26": [{"context": {"prefix": "    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n", "suffix": "        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n", "buggy": "    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n", "fix": "    public final boolean needMoreInput() {\n        return (_inputPtr >=_inputEnd) && !_endOfInput;\n    }\n\n    @Override\n    public void feedInput(byte[] buf, int start, int end) throws IOException\n    {\n        // Must not have remaining input\n        if (_inputPtr < _inputEnd) {\n            _reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n        }\n        if (end < start) {\n            _reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n        }\n        // and shouldn't have been marked as end-of-input\n        if (_endOfInput) {\n            _reportError(\"Already closed, can not feed more input\");\n        }\n        // Time to update pointers first\n        _currInputProcessed += _origBufferLen;\n\n        // Also need to adjust row start, to work as if it extended into the past wrt new buffer\n        _currInputRowStart = start - (_inputEnd - _currInputRowStart);\n\n        // And then update buffer settings\n        _currBufferStart = start;\n        _inputBuffer = buf;\n        _inputPtr = start;\n        _inputEnd = end;\n        _origBufferLen = end - start;\n    }\n\n    @Override\n    public void endOfInput() {\n        _endOfInput = true;\n    }\n\n    /*\n    /**********************************************************************\n    /* Abstract methods/overrides from JsonParser\n    /**********************************************************************\n     */\n\n    /* Implementing these methods efficiently for non-blocking cases would\n     * be complicated; so for now let's just use the default non-optimized\n     * implementation\n     */\n\n//    public boolean nextFieldName(SerializableString str) throws IOException\n//    public String nextTextValue() throws IOException\n//    public int nextIntValue(int defaultValue) throws IOException\n//    public long nextLongValue(long defaultValue) throws IOException\n", "start": 82, "end": 132, "file": "main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java"}, "tokens": {}}], "JacksonDatabind-1": [{"context": {"prefix": "            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n", "suffix": "        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n", "buggy": "            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n", "fix": "            ser.serialize(value, jgen, prov);\n        } else {\n            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n        }\n    }\n\n    /**\n     * Alternative to {@link #serializeAsField} that is used when a POJO\n     * is serialized as JSON Array; the difference is that no field names\n     * are written.\n     * \n     * @since 2.1\n     */\n    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n        throws Exception\n    {\n        Object value = get(bean);\n        if (value == null) { // nulls need specialized handling\n            if (_nullSerializer != null) {\n                _nullSerializer.serialize(null, jgen, prov);\n            } else { // can NOT suppress entries in tabular output\n                jgen.writeNull();\n            }\n            return;\n        }\n        // otherwise find serializer to use\n        JsonSerializer<Object> ser = _serializer;\n        if (ser == null) {\n            Class<?> cls = value.getClass();\n            PropertySerializerMap map = _dynamicSerializers;\n            ser = map.serializerFor(cls);\n            if (ser == null) {\n                ser = _findAndAddDynamic(map, cls, prov);\n            }\n        }\n        // and then see if we must suppress certain values (default, empty)\n        if (_suppressableValue != null) {\n            if (MARKER_FOR_EMPTY == _suppressableValue) {\n                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n                    serializeAsPlaceholder(bean, jgen, prov);\n                    return;\n                }\n            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n                serializeAsPlaceholder(bean, jgen, prov);\n                return;\n            }\n        }\n        // For non-nulls: simple check for direct cycles\n", "start": 568, "end": 614, "file": "main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java"}, "tokens": {}}], "JacksonDatabind-16": [{"context": {"prefix": "            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n", "suffix": "    }\n}\n\n\n", "buggy": "            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous != null) && previous.equals(ann);\n    }\n}\n\n\n", "fix": "            return primary;\n        }\n        HashMap<Class<? extends Annotation>,Annotation> annotations\n            = new HashMap<Class<? extends Annotation>,Annotation>();\n        // add secondary ones first\n        for (Annotation ann : secondary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        // to be overridden by primary ones\n        for (Annotation ann : primary._annotations.values()) {\n            annotations.put(ann.annotationType(), ann);\n        }\n        return new AnnotationMap(annotations);\n    }\n    \n    @Override\n    public int size() {\n        return (_annotations == null) ? 0 : _annotations.size();\n    }\n\n    /**\n     * Method called to add specified annotation in the Map, but\n     * only if it didn't yet exist.\n     */\n    public boolean addIfNotPresent(Annotation ann)\n    {\n        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n            _add(ann);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Method called to add specified annotation in the Map.\n     * \n     * @return True if the addition changed the contents, that is, this map did not\n     *   already have specified annotation\n     */\n    public boolean add(Annotation ann) {\n        return _add(ann);\n    }\n\n    @Override\n    public String toString() {\n        if (_annotations == null) {\n            return \"[null]\";\n        }\n        return _annotations.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods\n    /**********************************************************\n     */\n\n    protected final boolean _add(Annotation ann) {\n        if (_annotations == null) {\n            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n        }\n        Annotation previous = _annotations.put(ann.annotationType(), ann);\n        return (previous == null) || !previous.equals(ann);\n    }\n}\n\n\n", "start": 49, "end": 173, "file": "main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java"}, "tokens": {"original": [{"_annotations": {"identifier": "(HashMap) _annotations", "line": "return (_annotations == null) ? 0 : _annotations.size();"}}, {"AnnotationMap": {"identifier": "(AnnotationMap) AnnotationMap", "line": "return new AnnotationMap(annotations);"}}, {"toString": {"identifier": "(AbstractMap) toString()", "line": "return _annotations.toString();"}}, {"addIfNotPresent": {"identifier": "(AnnotationMap) addIfNotPresent()", "line": "public boolean addIfNotPresent(Annotation ann)"}}]}}], "JacksonDatabind-17": [{"context": {"prefix": "            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n", "suffix": "\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n", "buggy": "            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n", "fix": "            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes) : null;            \n        }\n\n        /**\n         * Method called to check if the default type handler should be\n         * used for given type.\n         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n         * use typing; that is both due to them being concrete and final,\n         * and since actual serializers and deserializers will also ignore any\n         * attempts to enforce typing.\n         */\n        public boolean useForType(JavaType t)\n        {\n            switch (_appliesFor) {\n            case NON_CONCRETE_AND_ARRAYS:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // fall through\n            case OBJECT_AND_NON_CONCRETE:\n//                return t.isJavaLangObject() || \n                return (t.getRawClass() == Object.class)\n                        || (!t.isConcrete()\n                                // [databind#88] Should not apply to JSON tree models:\n                                && !TreeNode.class.isAssignableFrom(t.getRawClass()));\n\n            case NON_FINAL:\n                while (t.isArrayType()) {\n                    t = t.getContentType();\n                }\n                // [Issue#88] Should not apply to JSON tree models:\n                return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n            default:\n            //case JAVA_LANG_OBJECT:\n//                return t.isJavaLangObject();\n                return (t.getRawClass() == Object.class);\n            }\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Internal constants, singletons\n    /**********************************************************\n     */\n    \n    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n\n", "start": 155, "end": 203, "file": "main/java/com/fasterxml/jackson/databind/ObjectMapper.java"}, "tokens": {"original": [{"isFinal": {"identifier": "(JavaType) isFinal()", "line": "return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());"}}, {"constructType": {"identifier": "(TypeFactory) constructType()", "line": "JavaType t = _typeFactory.constructType(valueToUpdate.getClass());"}}, {"_typeFactory": {"identifier": "(TypeFactory) _typeFactory", "line": "JavaType t = _typeFactory.constructType(valueToUpdate.getClass());"}}, {"JavaType": {"identifier": "(JavaType) JavaType", "line": "JavaType t = _typeFactory.constructType(valueToUpdate.getClass());"}}, {"getMessage": {"identifier": "(Throwable) getMessage()", "line": "throw new IllegalArgumentException(e.getMessage(), e);"}}, {"convertValue": {"identifier": "(ObjectMapper) convertValue()", "line": "*   objectMapper.convertValue(n, valueClass);"}}, {"getName": {"identifier": "(Class) getName()", "line": "throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()"}}, {"registerModules": {"identifier": "(ObjectMapper) registerModules()", "line": "return registerModules(findModules());"}}, {"findModules": {"identifier": "(ObjectMapper) findModules()", "line": "return registerModules(findModules());"}}, {"ObjectWriter": {"identifier": "(ObjectWriter) ObjectWriter", "line": "return new ObjectWriter(this, getSerializationConfig());"}}, {"_jsonFactory": {"identifier": "(JsonFactory) _jsonFactory", "line": "+\" for format \"+_jsonFactory.getFormatName());"}}, {"getNullValue": {"identifier": "(JsonDeserializer) getNullValue()", "line": "result = _findRootDeserializer(ctxt, valueType).getNullValue();"}}, {"serializeValue": {"identifier": "(DefaultSerializerProvider) serializeValue()", "line": "_serializerProvider(cfg).serializeValue(jgen, value);"}}, {"getModuleName": {"identifier": "(Module) getModuleName()", "line": "String name = module.getModuleName();"}}, {"isEnabled": {"identifier": "(DeserializationConfig) isEnabled()", "line": "return _deserializationConfig.isEnabled(f);"}}, {"getNodeFactory": {"identifier": "(ObjectMapper) getNodeFactory()", "line": "n = getNodeFactory().nullNode();"}}, {"nullNode": {"identifier": "(JsonNodeFactory) nullNode()", "line": "n = getNodeFactory().nullNode();"}}, {"ObjectReader": {"identifier": "(ObjectReader) ObjectReader", "line": "return new ObjectReader(this, getDeserializationConfig()).with(f);"}}, {"getSimpleName": {"identifier": "(PropertyName) getSimpleName()", "line": "expName = pname.getSimpleName();"}}, {"ObjectMapper": {"identifier": "(ObjectMapper) ObjectMapper", "line": "_checkInvalidCopy(ObjectMapper.class);"}}, {"getRootName": {"identifier": "(MapperConfigBase) getRootName()", "line": "String expName = config.getRootName();"}}, {"getJsonFactory": {"identifier": "(ObjectMapper) getJsonFactory()", "line": "*  getJsonFactory().isEnabled(f);"}}, {"JsonNode": {"identifier": "(JsonNode) JsonNode", "line": "return new TreeTraversingParser((JsonNode) n, this);"}}, {"readValue": {"identifier": "(ObjectMapper) readValue()", "line": "public <T> T readValue(String content, Class<T> valueType)"}}, {"arrayNode": {"identifier": "(JsonNodeFactory) arrayNode()", "line": "return _deserializationConfig.getNodeFactory().arrayNode();"}}, {"JsonGenerator": {"identifier": "(JsonGenerator) JsonGenerator", "line": "protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)"}}, {"objectNode": {"identifier": "(JsonNodeFactory) objectNode()", "line": "return _deserializationConfig.getNodeFactory().objectNode();"}}, {"isConcrete": {"identifier": "(JavaType) isConcrete()", "line": "|| (!t.isConcrete()"}}, {"withView": {"identifier": "(DeserializationConfig) withView()", "line": "return new ObjectReader(this, getDeserializationConfig().withView(view));"}}, {"DateFormat": {"identifier": "(DateFormat) DateFormat", "line": "* serialize objects using specified {@link DateFormat}; or, if"}}, {"treeToValue": {"identifier": "(ObjectMapper) treeToValue()", "line": "public <T> T treeToValue(TreeNode n, Class<T> valueType)"}}, {"canSerialize": {"identifier": "(ObjectMapper) canSerialize()", "line": "public boolean canSerialize(Class<?> type) {"}}, {"readerWithView": {"identifier": "(ObjectMapper) readerWithView()", "line": "public ObjectReader readerWithView(Class<?> view) {"}}, {"treeAsTokens": {"identifier": "(ObjectMapper) treeAsTokens()", "line": "return readValue(treeAsTokens(n), valueType);"}}, {"createInstance": {"identifier": "(DefaultSerializerProvider) createInstance()", "line": "return _serializerProvider.createInstance(config, _serializerFactory);"}}, {"_readValue": {"identifier": "(ObjectMapper) _readValue()", "line": "return (T) _readValue(getDeserializationConfig(), jp, valueType);"}}, {"valueToTree": {"identifier": "(ObjectMapper) valueToTree()", "line": "public <T extends JsonNode> T valueToTree(Object fromValue)"}}, {"DefaultTyping": {"identifier": "(DefaultTyping) DefaultTyping", "line": "protected final DefaultTyping _appliesFor;"}}, {"_appliesFor": {"identifier": "(DefaultTypeResolverBuilder) _appliesFor", "line": "protected final DefaultTyping _appliesFor;"}}, {"RootNameLookup": {"identifier": "(RootNameLookup) RootNameLookup", "line": "protected final RootNameLookup _rootNames;"}}, {"_rootNames": {"identifier": "(ObjectMapper) _rootNames", "line": "protected final RootNameLookup _rootNames;"}}, {"useForType": {"identifier": "(DefaultTypeResolverBuilder) useForType()", "line": "return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes) : null;"}}, {"createArrayNode": {"identifier": "(ObjectMapper) createArrayNode()", "line": "public ArrayNode createArrayNode() {"}}, {"MapperConfig": {"identifier": "(MapperConfig) MapperConfig", "line": "* Method for enabling specified {@link MapperConfig} features."}}, {"MapperFeature": {"identifier": "(MapperFeature) MapperFeature", "line": "public boolean isEnabled(MapperFeature f) {"}}, {"setDateFormat": {"identifier": "(ObjectMapper) setDateFormat()", "line": "public ObjectMapper setDateFormat(DateFormat dateFormat)"}}, {"INDENT_OUTPUT": {"identifier": "(SerializationFeature) INDENT_OUTPUT", "line": "if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {"}}, {"setFilters": {"identifier": "(ObjectMapper) setFilters()", "line": "*  mapper.setFilters(mapper.getSerializationConfig().withFilters(filterProvider));"}}, {"StdDateFormat": {"identifier": "(StdDateFormat) StdDateFormat", "line": "import com.fasterxml.jackson.databind.util.StdDateFormat;"}}, {"_factory": {"identifier": "(DeserializerFactory) _factory", "line": "DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);"}}, {"CLOSE_CLOSEABLE": {"identifier": "(SerializationFeature) CLOSE_CLOSEABLE", "line": "if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {"}}, {"canDeserialize": {"identifier": "(ObjectMapper) canDeserialize()", "line": "public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)"}}, {"TypeFactory": {"identifier": "(TypeFactory) TypeFactory", "line": "* Note: will also set {@link TypeFactory} that deserialization and"}}, {"hasGenericTypes": {"identifier": "(JavaType) hasGenericTypes()", "line": "&& !toValueType.hasGenericTypes()"}}, {"readTree": {"identifier": "(ObjectMapper) readTree()", "line": "public <T extends TreeNode> T readTree(JsonParser jp)"}}, {"addMixIn": {"identifier": "(ObjectMapper) addMixIn()", "line": "public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)"}}, {"getFactory": {"identifier": "(ObjectMapper) getFactory()", "line": "public JsonFactory getJsonFactory() { return getFactory(); }"}}, {"addHandler": {"identifier": "(ObjectMapper) addHandler()", "line": "mapper.addHandler(handler);"}}, {"JSON_NODE_TYPE": {"identifier": "(JavaType) JSON_NODE_TYPE", "line": "JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);"}}, {"TokenBuffer": {"identifier": "(TokenBuffer) TokenBuffer", "line": "TokenBuffer buf = new TokenBuffer(this, false);"}}, {"writeValue": {"identifier": "(ObjectMapper) writeValue()", "line": "writeValue(buf, fromValue);"}}, {"withFilters": {"identifier": "(SerializationConfig) withFilters()", "line": "getSerializationConfig().withFilters(filterProvider));"}}, {"readValues": {"identifier": "(ObjectMapper) readValues()", "line": "return readValues(jp, _typeFactory.constructType(valueType));"}}, {"BaseSettings": {"identifier": "(BaseSettings) BaseSettings", "line": "import com.fasterxml.jackson.databind.cfg.BaseSettings;"}}, {"withHandler": {"identifier": "(DeserializationConfig) withHandler()", "line": "_deserializationConfig = _deserializationConfig.withHandler(h);"}}, {"findRootName": {"identifier": "(RootNameLookup) findRootName()", "line": "PropertyName pname = _rootNames.findRootName(rootType, config);"}}, {"PropertyName": {"identifier": "(PropertyName) PropertyName", "line": "PropertyName pname = _rootNames.findRootName(rootType, config);"}}, {"SubtypeResolver": {"identifier": "(SubtypeResolver) SubtypeResolver", "line": "protected SubtypeResolver _subtypeResolver;"}}, {"writerWithView": {"identifier": "(ObjectMapper) writerWithView()", "line": "public ObjectWriter writerWithView(Class<?> serializationView) {"}}, {"getContentType": {"identifier": "(JavaType) getContentType()", "line": "t = t.getContentType();"}}, {"registerModule": {"identifier": "(ObjectMapper) registerModule()", "line": "registerModule(module);"}}, {"asParser": {"identifier": "(TokenBuffer) asParser()", "line": "final JsonParser jp = buf.asParser();"}}, {"setupModule": {"identifier": "(Module) setupModule()", "line": "module.setupModule(new Module.SetupContext()"}}, {"_convert": {"identifier": "(ObjectMapper) _convert()", "line": "return (T) _convert(fromValue, toValueType);"}}, {"setVisibility": {"identifier": "(ObjectMapper) setVisibility()", "line": "*  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);"}}, {"defaultInstance": {"identifier": "(TypeFactory) defaultInstance()", "line": "_typeFactory = TypeFactory.defaultInstance();"}}, {"ObjectCodec": {"identifier": "(ObjectCodec) ObjectCodec", "line": "public <C extends ObjectCodec> C getOwner() {"}}, {"writeTree": {"identifier": "(ObjectMapper) writeTree()", "line": "public void writeTree(JsonGenerator jgen, TreeNode rootNode)"}}, {"NamedType": {"identifier": "(NamedType) NamedType", "line": "public void registerSubtypes(NamedType... subtypes) {"}}, {"writerWithType": {"identifier": "(ObjectMapper) writerWithType()", "line": "public ObjectWriter writerWithType(Class<?> rootType) {"}}, {"JsonNodeFactory": {"identifier": "(JsonNodeFactory) JsonNodeFactory", "line": "public JsonNodeFactory getNodeFactory() {"}}, {"_initForReading": {"identifier": "(ObjectMapper) _initForReading()", "line": "JsonToken t = _initForReading(jp);"}}, {"withVisibility": {"identifier": "(DeserializationConfig) withVisibility()", "line": "_deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);"}}, {"getTimeZone": {"identifier": "(TimeZone) getTimeZone()", "line": "TimeZone.getTimeZone(\"GMT\"),"}}, {"setCodec": {"identifier": "(JsonFactory) setCodec()", "line": "_jsonFactory.setCodec(this);"}}, {"useRootWrapping": {"identifier": "(DeserializationConfig) useRootWrapping()", "line": "if (cfg.useRootWrapping()) {"}}, {"withModifier": {"identifier": "(TypeFactory) withModifier()", "line": "f = f.withModifier(modifier);"}}, {"ResolvedType": {"identifier": "(ResolvedType) ResolvedType", "line": "import com.fasterxml.jackson.core.type.ResolvedType;"}}, {"constructUnsafe": {"identifier": "(SimpleType) constructUnsafe()", "line": "private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);"}}, {"SimpleType": {"identifier": "(SimpleType) SimpleType", "line": "private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);"}}, {"setNodeFactory": {"identifier": "(ObjectMapper) setNodeFactory()", "line": "public ObjectMapper setNodeFactory(JsonNodeFactory f) {"}}, {"FilterProvider": {"identifier": "(FilterProvider) FilterProvider", "line": "public void setFilters(FilterProvider filterProvider) {"}}, {"isArrayType": {"identifier": "(JavaType) isArrayType()", "line": "while (t.isArrayType()) {"}}, {"setTypeFactory": {"identifier": "(ObjectMapper) setTypeFactory()", "line": "mapper.setTypeFactory(f);"}}, {"typeProperty": {"identifier": "(TypeResolverBuilder) typeProperty()", "line": "typer = typer.typeProperty(propertyName);"}}, {"setLocale": {"identifier": "(ObjectMapper) setLocale()", "line": "public ObjectMapper setLocale(Locale l) {"}}, {"nextToken": {"identifier": "(JsonParser) nextToken()", "line": "t = jp.nextToken();"}}, {"NullNode": {"identifier": "(NullNode) NullNode", "line": "return (n == null) ? NullNode.instance : n;"}}, {"TypeModifier": {"identifier": "(TypeModifier) TypeModifier", "line": "public void addTypeModifier(TypeModifier modifier) {"}}, {"getTypeFactory": {"identifier": "(ObjectMapper) getTypeFactory()", "line": "public TypeFactory getTypeFactory() {"}}, {"setTimeZone": {"identifier": "(ObjectMapper) setTimeZone()", "line": "public ObjectMapper setTimeZone(TimeZone tz) {"}}, {"DEFAULT_BASE": {"identifier": "(ObjectMapper) DEFAULT_BASE", "line": "protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,"}}, {"mixInCount": {"identifier": "(ObjectMapper) mixInCount()", "line": "public final int mixInCount() {"}}, {"WRAP_ROOT_VALUE": {"identifier": "(SerializationFeature) WRAP_ROOT_VALUE", "line": "SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);"}}, {"setConfig": {"identifier": "(ObjectMapper) setConfig()", "line": "public ObjectMapper setConfig(SerializationConfig config) {"}}, {"getCodec": {"identifier": "(JsonFactory) getCodec()", "line": "if (jf.getCodec() == null) { // as per [JACKSON-741]"}}, {"NON_FINAL": {"identifier": "(DefaultTyping) NON_FINAL", "line": "case NON_FINAL:"}}]}}], "JacksonDatabind-27": [{"context": {"prefix": "        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n", "suffix": "                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n", "buggy": "        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n", "fix": "        throws IOException\n    {\n        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n        final PropertyBasedCreator creator = _propertyBasedCreator;\n        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n\n        TokenBuffer tokens = new TokenBuffer(p);\n        tokens.writeStartObject();\n\n        JsonToken t = p.getCurrentToken();\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            p.nextToken(); // to point to value\n            // creator property?\n            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n            if (creatorProp != null) {\n                // first: let's check to see if this might be part of value with external type id:\n                // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                //   since it is not the bean\n                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                    ;\n                } else {\n                    // Last creator property to set?\n                    if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                        Object bean;\n                        try {\n                            bean = creator.build(ctxt, buffer);\n                        } catch (Exception e) {\n                            wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                            continue; // never gets here\n                        }\n                        // if so, need to copy all remaining tokens into buffer\n                        while (t == JsonToken.FIELD_NAME) {\n                            p.nextToken(); // to skip name\n                            tokens.copyCurrentStructure(p);\n                            t = p.nextToken();\n                        }\n                        if (bean.getClass() != _beanType.getRawClass()) {\n", "start": 774, "end": 812, "file": "main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java"}, "tokens": {"original": [{"readIdProperty": {"identifier": "(PropertyValueBuffer) readIdProperty()", "line": "if (buffer.readIdProperty(propName)) {"}}, {"handledType": {"identifier": "(BeanDeserializerBase) handledType()", "line": "handleIgnoredProperty(p, ctxt, handledType(), propName);"}}, {"_anySetter": {"identifier": "(SettableAnyProperty) _anySetter", "line": "_anySetter.deserializeAndSet(p, ctxt, bean, propName);"}}, {"_ignorableProps": {"identifier": "(Set) _ignorableProps", "line": "if (_ignorableProps != null && _ignorableProps.contains(propName)) {"}}, {"_objectIdReader": {"identifier": "(ObjectIdReader) _objectIdReader", "line": "&& _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {"}}, {"bufferProperty": {"identifier": "(PropertyValueBuffer) bufferProperty()", "line": "buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));"}}, {"injectValues": {"identifier": "(BeanDeserializerBase) injectValues()", "line": "injectValues(ctxt, bean);"}}, {"creatorProp": {"identifier": "(SettableBeanProperty) creatorProp", "line": "if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {"}}, {"assignParameter": {"identifier": "(PropertyValueBuffer) assignParameter()", "line": "if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {"}}, {"wrapAndThrow": {"identifier": "(BeanDeserializerBase) wrapAndThrow()", "line": "wrapAndThrow(e, bean, propName, ctxt);"}}, {"_beanProperties": {"identifier": "(BeanPropertyMap) _beanProperties", "line": "SettableBeanProperty prop = _beanProperties.find(propName);"}}, {"getRawClass": {"identifier": "(JavaType) getRawClass()", "line": "wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);"}}, {"_beanType": {"identifier": "(JavaType) _beanType", "line": "wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);"}}, {"startBuilding": {"identifier": "(PropertyBasedCreator) startBuilding()", "line": "PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);"}}, {"getName": {"identifier": "(SettableBeanProperty) getName()", "line": "wrapAndThrow(e, _beanType.getRawClass(), prop.getName(), ctxt);"}}, {"visibleInView": {"identifier": "(SettableBeanProperty) visibleInView()", "line": "if (!prop.visibleInView(activeView)) {"}}, {"NameTransformer": {"identifier": "(NameTransformer) NameTransformer", "line": "protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) {"}}, {"BeanPropertyMap": {"identifier": "(BeanPropertyMap) BeanPropertyMap", "line": "BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,"}}, {"writeFieldName": {"identifier": "(TokenBuffer) writeFieldName()", "line": "tokens.writeFieldName(propName);"}}, {"_injectables": {"identifier": "(ValueInjector) _injectables", "line": "if (_injectables != null) {"}}, {"ObjectIdReader": {"identifier": "(ObjectIdReader) ObjectIdReader", "line": "public BeanDeserializer(BeanDeserializerBase src, ObjectIdReader oir) {"}}, {"TokenBuffer": {"identifier": "(TokenBuffer) TokenBuffer", "line": "import com.fasterxml.jackson.databind.util.TokenBuffer;"}}, {"_missingToken": {"identifier": "(BeanDeserializer) _missingToken()", "line": "protected Object _missingToken(JsonParser p, DeserializationContext ctxt) throws IOException {"}}, {"hasViews": {"identifier": "(boolean) hasViews", "line": "ignorableProps, ignoreAllUnknown, hasViews);"}}, {"BeanDescription": {"identifier": "(BeanDescription) BeanDescription", "line": "public BeanDeserializer(BeanDeserializerBuilder builder, BeanDescription beanDesc,"}}, {"getActiveView": {"identifier": "(DeserializationContext) getActiveView()", "line": "final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;"}}, {"writeEndObject": {"identifier": "(TokenBuffer) writeEndObject()", "line": "tokens.writeEndObject();"}}]}}], "JacksonDatabind-34": [{"context": {"prefix": "    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n", "suffix": "            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}", "buggy": "    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}", "fix": "    public void serialize(Number value, JsonGenerator g, SerializerProvider provider) throws IOException\n    {\n        // should mostly come in as one of these two:\n        if (value instanceof BigDecimal) {\n            g.writeNumber((BigDecimal) value);\n        } else if (value instanceof BigInteger) {\n            g.writeNumber((BigInteger) value);\n            \n        /* These shouldn't match (as there are more specific ones),\n         * but just to be sure:\n         */\n        } else if (value instanceof Integer) {\n            g.writeNumber(value.intValue());\n        } else if (value instanceof Long) {\n            g.writeNumber(value.longValue());\n        } else if (value instanceof Double) {\n            g.writeNumber(value.doubleValue());\n        } else if (value instanceof Float) {\n            g.writeNumber(value.floatValue());\n        } else if ((value instanceof Byte) || (value instanceof Short)) {\n            g.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n        } else {\n            // We'll have to use fallback \"untyped\" number write method\n            g.writeNumber(value.toString());\n        }\n    }\n\n    @Override\n    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n    }\n\n    @Override\n    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n    {\n        if (_isInt) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else {\n            Class<?> h = handledType();\n            if (h == BigDecimal.class) {\n                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n            } else {\n                // otherwise bit unclear what to call... but let's try:\n                /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n            }\n        }\n    }\n}", "start": 40, "end": 120, "file": "main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java"}, "tokens": {"original": [{"visitIntFormat": {"identifier": "(StdSerializer) visitIntFormat()", "line": "visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);"}}, {"JavaType": {"identifier": "(JavaType) JavaType", "line": "public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException"}}, {"getSchema": {"identifier": "(NumberSerializer) getSchema()", "line": "public JsonNode getSchema(SerializerProvider provider, Type typeHint) {"}}, {"toString": {"identifier": "(Object) toString()", "line": "g.writeNumber(value.toString());"}}, {"handledType": {"identifier": "(StdSerializer) handledType()", "line": "Class<?> h = handledType();"}}]}}], "JacksonDatabind-37": [{"context": {"prefix": "        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n", "suffix": "                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n", "buggy": "        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n", "fix": "        }\n        // ... and while we are at it, not array types either\n        if (cls.isArray()) {\n            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n        }\n        return new SimpleType(cls);\n    }\n\n    @Override\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        if (_class == subclass) {\n            return this;\n        }\n        // Should we check that there is a sub-class relationship?\n        // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n        //    placeholder values, so no.\n        /*\n        if (!_class.isAssignableFrom(subclass)) {\n            throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                    +_class.getName());\n        }\n        */\n        // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n        return new SimpleType(subclass, _bindings, this, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    @Override\n    public JavaType withContentType(JavaType contentType) {\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContentType()\");\n    }\n    \n    @Override\n    public SimpleType withTypeHandler(Object h) {\n        if (_typeHandler == h) {\n            return this;\n        }\n        return new SimpleType(_class, _bindings, _superClass, _superInterfaces, _valueHandler, h, _asStatic);\n    }\n\n    @Override\n    public JavaType withContentTypeHandler(Object h) {\n        // no content type, so:\n        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n    }\n\n    @Override\n    public SimpleType withValueHandler(Object h) {\n", "start": 110, "end": 158, "file": "main/java/com/fasterxml/jackson/databind/type/SimpleType.java"}, "tokens": {"original": [{"JavaType": {"identifier": "(JavaType) JavaType", "line": "JavaType superClass, JavaType[] superInterfaces) {"}}, {"TypeBindings": {"identifier": "(TypeBindings) TypeBindings", "line": "protected SimpleType(Class<?> cls, TypeBindings bindings,"}}, {"_classSignature": {"identifier": "(TypeBase) _classSignature()", "line": "return _classSignature(_class, sb, true);"}}, {"constructUnsafe": {"identifier": "(SimpleType) constructUnsafe()", "line": "public static SimpleType constructUnsafe(Class<?> raw) {"}}, {"TypeBase": {"identifier": "(TypeBase) TypeBase", "line": "protected SimpleType(TypeBase base) {"}}, {"_narrow": {"identifier": "(SimpleType) _narrow()", "line": "protected JavaType _narrow(Class<?> subclass)"}}, {"withTypeHandler": {"identifier": "(SimpleType) withTypeHandler()", "line": "public SimpleType withTypeHandler(Object h) {"}}, {"emptyBindings": {"identifier": "(TypeBindings) emptyBindings()", "line": "this(cls, TypeBindings.emptyBindings(), null, null);"}}, {"isContainerType": {"identifier": "(SimpleType) isContainerType()", "line": "public boolean isContainerType() { return false; }"}}, {"containedType": {"identifier": "(TypeBase) containedType()", "line": "sb = containedType(i).getGenericSignature(sb);"}}, {"withContentType": {"identifier": "(SimpleType) withContentType()", "line": "public JavaType withContentType(JavaType contentType) {"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return sb.toString();"}}, {"toCanonical": {"identifier": "(ResolvedType) toCanonical()", "line": "sb.append(t.toCanonical());"}}]}}], "JacksonDatabind-46": [{"context": {"prefix": "    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n", "suffix": "        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n", "buggy": "    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(';');\n        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n", "fix": "    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public int containedTypeCount() {\n        return 1;\n    }\n\n    @Override\n    public JavaType containedType(int index) {\n        return (index == 0) ? _referencedType : null;\n    }\n\n    @Override\n    public String containedTypeName(int index) {\n        return (index == 0) ? \"T\" : null;\n    }\n\n    @Override\n    public Class<?> getParameterSource() {\n        // Hmmh. For now, assume it's the raw type\n        return _class;\n    }\n    \n    @Override\n    public StringBuilder getErasedSignature(StringBuilder sb) {\n        return _classSignature(_class, sb, true);\n    }\n    \n    @Override\n    public StringBuilder getGenericSignature(StringBuilder sb)\n    {\n        _classSignature(_class, sb, false);\n        sb.append('<');\n        sb = _referencedType.getGenericSignature(sb);\n        sb.append(\">;\");\n        return sb;\n    }\n    \n    /*\n    /**********************************************************\n    /* Standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public String toString()\n    {\n        return new StringBuilder(40)\n            .append(\"[reference type, class \")\n            .append(buildCanonicalName())\n            .append('<')\n            .append(_referencedType)\n            .append('>')\n            .append(']')\n            .toString();\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o.getClass() != getClass()) return false;\n\n        ReferenceType other = (ReferenceType) o;\n\n        if (other._class != _class) return false;\n        \n        // Otherwise actually mostly worry about referenced type\n        return _referencedType.equals(other._referencedType);\n    }\n", "start": 119, "end": 191, "file": "main/java/com/fasterxml/jackson/databind/type/ReferenceType.java"}, "tokens": {"original": [{"_referencedType": {"identifier": "(JavaType) _referencedType", "line": ".append(_referencedType)"}}, {"toCanonical": {"identifier": "(ResolvedType) toCanonical()", "line": "sb.append(_referencedType.toCanonical());"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return sb.toString();"}}, {"hashCode": {"identifier": "(JavaType) hashCode()", "line": "super(cls, refType.hashCode(),"}}, {"JavaType": {"identifier": "(JavaType) JavaType", "line": "public JavaType getReferencedType() {"}}, {"containedType": {"identifier": "(ReferenceType) containedType()", "line": "public JavaType containedType(int index) {"}}, {"withTypeHandler": {"identifier": "(ReferenceType) withTypeHandler()", "line": "public ReferenceType withTypeHandler(Object h)"}}, {"ReferenceType": {"identifier": "(ReferenceType) ReferenceType", "line": "public ReferenceType withTypeHandler(Object h)"}}, {"isReferenceType": {"identifier": "(ReferenceType) isReferenceType()", "line": "public boolean isReferenceType() {"}}, {"_classSignature": {"identifier": "(TypeBase) _classSignature()", "line": "_classSignature(_class, sb, false);"}}, {"getTypeHandler": {"identifier": "(JavaType) getTypeHandler()", "line": "if (h == _referencedType.<Object>getTypeHandler()) {"}}, {"getValueHandler": {"identifier": "(JavaType) getValueHandler()", "line": "if (h == _referencedType.<Object>getValueHandler()) {"}}, {"SimpleType": {"identifier": "(SimpleType) SimpleType", "line": "public class ReferenceType extends SimpleType"}}, {"_narrow": {"identifier": "(ReferenceType) _narrow()", "line": "protected JavaType _narrow(Class<?> subclass)"}}]}}], "JacksonDatabind-57": [{"context": {"prefix": "     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n", "suffix": "                true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /**\n", "buggy": "     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n                true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /**\n", "fix": "     * @param json String that contains JSON content to parse\n     */\n    @SuppressWarnings(\"resource\")\n    public <T> MappingIterator<T> readValues(String json)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            _reportUndetectableSource(json);\n        }\n        JsonParser p = _considerFilter(_parserFactory.createParser(json), true);\n        _initForMultiRead(p);\n        p.nextToken();\n        DeserializationContext ctxt = createDeserializationContext(p);\n        return _newIterator(p, ctxt, _findRootDeserializer(ctxt), true);\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),\n                true));\n    }\n\n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public final <T> MappingIterator<T> readValues(byte[] src)\n            throws IOException, JsonProcessingException {\n        return readValues(src, 0, src.length);\n    }\n    \n    /**\n     * Overloaded version of {@link #readValue(InputStream)}.\n     */\n    public <T> MappingIterator<T> readValues(File src)\n        throws IOException, JsonProcessingException\n    {\n        if (_dataFormatReaders != null) {\n            return _detectBindAndReadValues(\n                    _dataFormatReaders.findFormat(_inputStream(src)), false);\n        }\n        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), true));\n    }\n\n    /**\n", "start": 1415, "end": 1465, "file": "main/java/com/fasterxml/jackson/databind/ObjectReader.java"}, "tokens": {"original": [{"_bindAndClose": {"identifier": "(ObjectReader) _bindAndClose()", "line": "return (T) _bindAndClose(_considerFilter(_parserFactory.createParser(src), false));"}}, {"treeAsTokens": {"identifier": "(ObjectReader) treeAsTokens()", "line": "return (T) _bindAndClose(_considerFilter(treeAsTokens(src), false));"}}, {"findFormat": {"identifier": "(DataFormatReaders) findFormat()", "line": "return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);"}}, {"isEnabled": {"identifier": "(JsonFactory) isEnabled()", "line": "return _parserFactory.isEnabled(f);"}}, {"arrayNode": {"identifier": "(JsonNodeFactory) arrayNode()", "line": "return _config.getNodeFactory().arrayNode();"}}, {"getNodeFactory": {"identifier": "(DeserializationConfig) getNodeFactory()", "line": "return _config.getNodeFactory().arrayNode();"}}, {"_config": {"identifier": "(DeserializationConfig) _config", "line": "return _config.getNodeFactory().arrayNode();"}}, {"_inputStream": {"identifier": "(ObjectReader) _inputStream()", "line": "return (T) _detectBindAndClose(_dataFormatReaders.findFormat(_inputStream(src)), true);"}}, {"constructType": {"identifier": "(TypeFactory) constructType()", "line": "return forType(_config.getTypeFactory().constructType(valueType));"}}, {"forType": {"identifier": "(ObjectReader) forType()", "line": "return forType(_config.getTypeFactory().constructType(valueType));"}}, {"getTypeFactory": {"identifier": "(MapperConfig) getTypeFactory()", "line": "return forType(_config.getTypeFactory().constructType(valueType));"}}, {"_with": {"identifier": "(ObjectReader) _with()", "line": "return _with(_config.withFeatures(features));"}}, {"withFeatures": {"identifier": "(DeserializationConfig) withFeatures()", "line": "return _with(_config.withFeatures(features));"}}, {"objectNode": {"identifier": "(JsonNodeFactory) objectNode()", "line": "return _config.getNodeFactory().objectNode();"}}, {"readValues": {"identifier": "(ObjectReader) readValues()", "line": "return readValues(src, 0, src.length);"}}, {"getReader": {"identifier": "(Match) getReader()", "line": "return match.getReader()._bindAndReadValues(p);"}}, {"withoutFeatures": {"identifier": "(DeserializationConfig) withoutFeatures()", "line": "return _with(_config.withoutFeatures(features));"}}, {"_schema": {"identifier": "(FormatSchema) _schema", "line": "_schema, _injectableValues, _dataFormatReaders);"}}, {"ObjectReader": {"identifier": "(ObjectReader) ObjectReader", "line": "return new ObjectReader(this, new JsonPointerBasedFilter(pointer));"}}, {"_filter": {"identifier": "(TokenFilter) _filter", "line": "return ((_filter == null) || FilteringParserDelegate.class.isInstance(p))"}}, {"JavaType": {"identifier": "(JavaType) JavaType", "line": "return readValues(p, (JavaType) valueType);"}}, {"withAttributes": {"identifier": "(MapperConfigBase) withAttributes()", "line": "return _with(_config.withAttributes(attrs));"}}, {"getNullValue": {"identifier": "(JsonDeserializer) getNullValue()", "line": "result = _findRootDeserializer(ctxt).getNullValue(ctxt);"}}, {"withView": {"identifier": "(DeserializationConfig) withView()", "line": "return _with(_config.withView(activeView));"}}, {"createInstance": {"identifier": "(DefaultDeserializationContext) createInstance()", "line": "return _context.createInstance(_config, p, _injectableValues);"}}, {"_context": {"identifier": "(DefaultDeserializationContext) _context", "line": "return _context.createInstance(_config, p, _injectableValues);"}}, {"_valueToUpdate": {"identifier": "(Object) _valueToUpdate", "line": "return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,"}}, {"_valueType": {"identifier": "(JavaType) _valueType", "line": "return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,"}}, {"withRootName": {"identifier": "(MapperConfigBase) withRootName()", "line": "return _with(_config.withRootName(rootName));"}}, {"readValue": {"identifier": "(ObjectReader) readValue()", "line": "return readValue(treeAsTokens(n), valueType);"}}, {"_newIterator": {"identifier": "(ObjectReader) _newIterator()", "line": "return _newIterator(p, ctxt, _findRootDeserializer(ctxt), false);"}}, {"PropertyName": {"identifier": "(PropertyName) PropertyName", "line": "return _with(_config.withRootName(PropertyName.NO_NAME));"}}, {"NO_NAME": {"identifier": "(PropertyName) NO_NAME", "line": "return _with(_config.withRootName(PropertyName.NO_NAME));"}}, {"JsonNode": {"identifier": "(JsonNode) JsonNode", "line": "protected JsonNode _bindAndCloseAsTree(JsonParser p) throws IOException {"}}, {"withAttribute": {"identifier": "(MapperConfigBase) withAttribute()", "line": "return _with( _config.withAttribute(key, value));"}}, {"_bind": {"identifier": "(ObjectReader) _bind()", "line": "return (T) _bind(p, _valueToUpdate);"}}, {"getAttributes": {"identifier": "(MapperConfigBase) getAttributes()", "line": "return _config.getAttributes();"}}, {"withHandler": {"identifier": "(DeserializationConfig) withHandler()", "line": "return _with(_config.withHandler(h));"}}, {"_bindAsTree": {"identifier": "(ObjectReader) _bindAsTree()", "line": "return _bindAsTree(p);"}}, {"writeTree": {"identifier": "(ObjectReader) writeTree()", "line": "public void writeTree(JsonGenerator jgen, TreeNode rootNode) {"}}, {"getMessage": {"identifier": "(Throwable) getMessage()", "line": "throw new IllegalArgumentException(e.getMessage(), e);"}}, {"readTree": {"identifier": "(ObjectReader) readTree()", "line": "public JsonNode readTree(Reader r)"}}, {"JsonNodeFactory": {"identifier": "(JsonNodeFactory) JsonNodeFactory", "line": "public ObjectReader with(JsonNodeFactory f) {"}}, {"JSON_NODE_TYPE": {"identifier": "(JavaType) JSON_NODE_TYPE", "line": "result = (JsonNode) _unwrapAndDeserialize(p, ctxt, JSON_NODE_TYPE, deser);"}}, {"ResolvedType": {"identifier": "(ResolvedType) ResolvedType", "line": "public <T> Iterator<T> readValues(JsonParser p, ResolvedType valueType) throws IOException {"}}, {"TypeFactory": {"identifier": "(TypeFactory) TypeFactory", "line": "public TypeFactory getTypeFactory() {"}}, {"getFactory": {"identifier": "(ObjectReader) getFactory()", "line": "public JsonFactory getFactory() {"}}, {"_initForReading": {"identifier": "(ObjectReader) _initForReading()", "line": "protected JsonToken _initForReading(JsonParser p) throws IOException"}}, {"withType": {"identifier": "(ObjectReader) withType()", "line": "public ObjectReader withType(java.lang.reflect.Type valueType) {"}}, {"writeValue": {"identifier": "(ObjectReader) writeValue()", "line": "public void writeValue(JsonGenerator gen, Object value) throws IOException, JsonProcessingException {"}}, {"_jsonFactory": {"identifier": "(JsonFactory) _jsonFactory", "line": "_parserFactory = mapper._jsonFactory;"}}, {"MapperFeature": {"identifier": "(MapperFeature) MapperFeature", "line": "public boolean isEnabled(MapperFeature f) {"}}, {"ObjectMapper": {"identifier": "(ObjectMapper) ObjectMapper", "line": "protected ObjectReader(ObjectMapper mapper, DeserializationConfig config,"}}, {"createArrayNode": {"identifier": "(ObjectReader) createArrayNode()", "line": "public JsonNode createArrayNode() {"}}, {"getSimpleName": {"identifier": "(PropertyName) getSimpleName()", "line": "String expSimpleName = expRootName.getSimpleName();"}}, {"withoutRootName": {"identifier": "(ObjectReader) withoutRootName()", "line": "public ObjectReader withoutRootName() {"}}, {"findRootName": {"identifier": "(MapperConfigBase) findRootName()", "line": "PropertyName expRootName = _config.findRootName(rootType);"}}, {"constructUnsafe": {"identifier": "(SimpleType) constructUnsafe()", "line": "private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);"}}, {"SimpleType": {"identifier": "(SimpleType) SimpleType", "line": "private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);"}}, {"treeToValue": {"identifier": "(ObjectReader) treeToValue()", "line": "public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException"}}, {"_unwrapRoot": {"identifier": "(ObjectReader) _unwrapRoot", "line": "protected final boolean _unwrapRoot;"}}, {"isArrayType": {"identifier": "(JavaType) isArrayType()", "line": "if (valueToUpdate != null && valueType.isArrayType()) {"}}, {"getConfig": {"identifier": "(ObjectReader) getConfig()", "line": "public DeserializationConfig getConfig() {"}}, {"toString": {"identifier": "(DataFormatReaders) toString()", "line": "+detector.toString());"}}, {"NullNode": {"identifier": "(NullNode) NullNode", "line": "import com.fasterxml.jackson.databind.node.NullNode;"}}, {"ObjectCodec": {"identifier": "(ObjectCodec) ObjectCodec", "line": "extends ObjectCodec"}}, {"useRootWrapping": {"identifier": "(DeserializationConfig) useRootWrapping()", "line": "_unwrapRoot = config.useRootWrapping();"}}, {"hasMatch": {"identifier": "(Match) hasMatch()", "line": "if (!match.hasMatch()) {"}}]}}], "JacksonDatabind-70": [{"context": {"prefix": "    /* Public API\n    /**********************************************************\n     */\n\n    public int size() { return _size; }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n", "suffix": "                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    /**\n     * Convenience method that tries to find property with given name, and\n     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n     * on it, and return true; or, if not found, return false.\n     * Note, too, that if deserialization is attempted, possible exceptions\n     * are wrapped if and as necessary, so caller need not handle those.\n     * \n     * @since 2.5\n     */\n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n", "buggy": "    /* Public API\n    /**********************************************************\n     */\n\n    public int size() { return _size; }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(prop.getName());\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    /**\n     * Convenience method that tries to find property with given name, and\n     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n     * on it, and return true; or, if not found, return false.\n     * Note, too, that if deserialization is attempted, possible exceptions\n     * are wrapped if and as necessary, so caller need not handle those.\n     * \n     * @since 2.5\n     */\n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n", "fix": "    /* Public API\n    /**********************************************************\n     */\n\n    public int size() { return _size; }\n\n    /**\n     * Specialized method for removing specified existing entry.\n     * NOTE: entry MUST exist, otherwise an exception is thrown.\n     */\n    public void remove(SettableBeanProperty propToRm)\n    {\n        ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n        String key = getPropertyName(propToRm);\n        boolean found = false;\n\n        for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n            SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n            if (prop == null) {\n                continue;\n            }\n            if (!found) {\n                // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                //   as only former is lower-case in case-insensitive case\n                found = key.equals(_hashArea[i1]);\n                if (found) {\n                    // need to leave a hole here\n                    _propsInOrder[_findFromOrdered(prop)] = null;\n                    continue;\n                }\n            }\n            props.add(prop);\n        }\n        if (!found) {\n            throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\");\n        }\n        init(props);\n    }\n\n    /**\n     * Convenience method that tries to find property with given name, and\n     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n     * on it, and return true; or, if not found, return false.\n     * Note, too, that if deserialization is attempted, possible exceptions\n     * are wrapped if and as necessary, so caller need not handle those.\n     * \n     * @since 2.5\n     */\n    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n", "start": 415, "end": 463, "file": "main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java"}, "tokens": {"original": [{"_hashArea": {"identifier": "(Object) _hashArea", "line": "if (key.equals(_hashArea[i])) {"}}, {"getType": {"identifier": "(SettableBeanProperty) getType()", "line": "sb.append(prop.getType());"}}, {"getPropertyName": {"identifier": "(BeanPropertyMap) getPropertyName()", "line": "String key = getPropertyName(prop);"}}, {"propToRm": {"identifier": "(SettableBeanProperty) propToRm", "line": "String key = getPropertyName(propToRm);"}}, {"withSimpleName": {"identifier": "(SettableBeanProperty) withSimpleName()", "line": "prop = prop.withSimpleName(newName);"}}, {"_rename": {"identifier": "(BeanPropertyMap) _rename()", "line": "newProps.add(_rename(prop, transformer));"}}, {"_size": {"identifier": "(int) _size", "line": "_size = props.size();"}}, {"_hashMask": {"identifier": "(int) _hashMask", "line": "int slot = key.hashCode() & _hashMask;"}}, {"_propsInOrder": {"identifier": "(SettableBeanProperty) _propsInOrder", "line": "init(Arrays.asList(_propsInOrder));"}}, {"BeanPropertyMap": {"identifier": "(BeanPropertyMap) BeanPropertyMap", "line": "return new BeanPropertyMap(this, state);"}}, {"_spillCount": {"identifier": "(int) _spillCount", "line": "_spillCount = spillCount;"}}, {"_hashCode": {"identifier": "(BeanPropertyMap) _hashCode()", "line": "int slot = _hashCode(key);"}}, {"_find2": {"identifier": "(BeanPropertyMap) _find2()", "line": "return _find2(key, slot, match);"}}, {"assignIndexes": {"identifier": "(BeanPropertyMap) assignIndexes()", "line": "public BeanPropertyMap assignIndexes()"}}, {"NameTransformer": {"identifier": "(NameTransformer) NameTransformer", "line": "if (transformer == null || (transformer == NameTransformer.NOP)) {"}}, {"renameAll": {"identifier": "(BeanPropertyMap) renameAll()", "line": "public BeanPropertyMap renameAll(NameTransformer transformer)"}}, {"assignIndex": {"identifier": "(SettableBeanProperty) assignIndex()", "line": "prop.assignIndex(index++);"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return sb.toString();"}}, {"findSize": {"identifier": "(BeanPropertyMap) findSize()", "line": "final int hashSize = findSize(_size);"}}, {"withProperty": {"identifier": "(BeanPropertyMap) withProperty()", "line": "public BeanPropertyMap withProperty(SettableBeanProperty newProp)"}}, {"wrapWithPath": {"identifier": "(JsonMappingException) wrapWithPath()", "line": "throw JsonMappingException.wrapWithPath(t, bean, fieldName);"}}, {"wrapAndThrow": {"identifier": "(BeanPropertyMap) wrapAndThrow()", "line": "wrapAndThrow(e, bean, key, ctxt);"}}, {"WRAP_EXCEPTIONS": {"identifier": "(DeserializationFeature) WRAP_EXCEPTIONS", "line": "boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);"}}, {"isEnabled": {"identifier": "(DeserializationContext) isEnabled()", "line": "boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);"}}]}}], "JacksonDatabind-71": [{"context": {"prefix": "    public final static int TYPE_CURRENCY = 16;\n\n    final protected int _kind;\n    final protected Class<?> _keyClass;\n\n    /**\n     * Some types that are deserialized using a helper deserializer.\n     */\n    protected final FromStringDeserializer<?> _deser;\n    \n    protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n", "suffix": "            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n", "buggy": "    public final static int TYPE_CURRENCY = 16;\n\n    final protected int _kind;\n    final protected Class<?> _keyClass;\n\n    /**\n     * Some types that are deserialized using a helper deserializer.\n     */\n    protected final FromStringDeserializer<?> _deser;\n    \n    protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n        if (raw == String.class || raw == Object.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n", "fix": "    public final static int TYPE_CURRENCY = 16;\n\n    final protected int _kind;\n    final protected Class<?> _keyClass;\n\n    /**\n     * Some types that are deserialized using a helper deserializer.\n     */\n    protected final FromStringDeserializer<?> _deser;\n    \n    protected StdKeyDeserializer(int kind, Class<?> cls) {\n        this(kind, cls, null);\n    }\n\n    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n        _kind = kind;\n        _keyClass = cls;\n        _deser = deser;\n    }\n\n    public static StdKeyDeserializer forType(Class<?> raw)\n    {\n        int kind;\n\n        // first common types:\n        if (raw == String.class || raw == Object.class || raw == CharSequence.class) {\n            return StringKD.forType(raw);\n        } else if (raw == UUID.class) {\n            kind = TYPE_UUID;\n        } else if (raw == Integer.class) {\n            kind = TYPE_INT;\n        } else if (raw == Long.class) {\n            kind = TYPE_LONG;\n        } else if (raw == Date.class) {\n            kind = TYPE_DATE;\n        } else if (raw == Calendar.class) {\n            kind = TYPE_CALENDAR;\n        // then less common ones...\n        } else if (raw == Boolean.class) {\n            kind = TYPE_BOOLEAN;\n        } else if (raw == Byte.class) {\n            kind = TYPE_BYTE;\n        } else if (raw == Character.class) {\n            kind = TYPE_CHAR;\n        } else if (raw == Short.class) {\n            kind = TYPE_SHORT;\n        } else if (raw == Float.class) {\n            kind = TYPE_FLOAT;\n        } else if (raw == Double.class) {\n            kind = TYPE_DOUBLE;\n        } else if (raw == URI.class) {\n", "start": 49, "end": 99, "file": "main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java"}, "tokens": {"original": [{"StringKD": {"identifier": "(StringKD) StringKD", "line": "private final static StringKD sObject = new StringKD(Object.class);"}}, {"_factory": {"identifier": "(AnnotatedMethod) _factory", "line": "if (_factory != null) {"}}, {"getKeyClass": {"identifier": "(StdKeyDeserializer) getKeyClass()", "line": "public Class<?> getKeyClass() { return _keyClass; }"}}, {"_keyClass": {"identifier": "(Class) _keyClass", "line": "public Class<?> getKeyClass() { return _keyClass; }"}}, {"forType": {"identifier": "(StringKD) forType()", "line": "public static StringKD forType(Class<?> nominalType)"}}, {"parseDate": {"identifier": "(DeserializationContext) parseDate()", "line": "java.util.Date date = ctxt.parseDate(key);"}}, {"DelegatingKD": {"identifier": "(DelegatingKD) DelegatingKD", "line": "protected DelegatingKD(Class<?> cls, JsonDeserializer<?> deser) {"}}, {"findClass": {"identifier": "(DeserializationContext) findClass()", "line": "return ctxt.findClass(key);"}}, {"getParser": {"identifier": "(DeserializationContext) getParser()", "line": "Object result = _delegate.deserialize(ctxt.getParser(), ctxt);"}}, {"_parseInt": {"identifier": "(StdKeyDeserializer) _parseInt()", "line": "protected int _parseInt(String key) throws IllegalArgumentException {"}}, {"EnumKD": {"identifier": "(EnumKD) EnumKD", "line": "final static class EnumKD extends StdKeyDeserializer"}}, {"_parseLong": {"identifier": "(StdKeyDeserializer) _parseLong()", "line": "protected long _parseLong(String key) throws IllegalArgumentException {"}}, {"ClassUtil": {"identifier": "(ClassUtil) ClassUtil", "line": "import com.fasterxml.jackson.databind.util.ClassUtil;"}}, {"getEnumClass": {"identifier": "(EnumResolver) getEnumClass()", "line": "res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass());"}}, {"_byNameResolver": {"identifier": "(EnumResolver) _byNameResolver", "line": "res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass());"}}, {"EnumResolver": {"identifier": "(EnumResolver) EnumResolver", "line": "res = EnumResolver.constructUnsafeUsingToString(_byNameResolver.getEnumClass());"}}, {"TYPE_LOCALE": {"identifier": "(int) TYPE_LOCALE", "line": "return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);"}}, {"_parseDouble": {"identifier": "(StdKeyDeserializer) _parseDouble()", "line": "protected double _parseDouble(String key) throws IllegalArgumentException {"}}, {"deserializeKey": {"identifier": "(StdKeyDeserializer) deserializeKey()", "line": "public final Object deserializeKey(String key, DeserializationContext ctxt)"}}, {"_deser": {"identifier": "(StdKeyDeserializer) _deser", "line": "protected final FromStringDeserializer<?> _deser;"}}, {"TYPE_CURRENCY": {"identifier": "(int) TYPE_CURRENCY", "line": "return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);"}}, {"KeyDeserializer": {"identifier": "(KeyDeserializer) KeyDeserializer", "line": "public class StdKeyDeserializer extends KeyDeserializer"}}, {"getConfig": {"identifier": "(DeserializationContext) getConfig()", "line": "if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {"}}, {"isEnabled": {"identifier": "(DeserializationConfig) isEnabled()", "line": "if ((e == null) && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {"}}, {"_parse": {"identifier": "(StringFactoryKeyDeserializer) _parse()", "line": "public Object _parse(String key, DeserializationContext ctxt) throws Exception"}}, {"TYPE_INT": {"identifier": "(StdKeyDeserializer) TYPE_INT", "line": "public final static int TYPE_INT = 5;"}}, {"TYPE_BYTE": {"identifier": "(StdKeyDeserializer) TYPE_BYTE", "line": "public final static int TYPE_BYTE = 2;"}}, {"TYPE_CHAR": {"identifier": "(StdKeyDeserializer) TYPE_CHAR", "line": "public final static int TYPE_CHAR = 4;"}}, {"TYPE_LONG": {"identifier": "(StdKeyDeserializer) TYPE_LONG", "line": "public final static int TYPE_LONG = 6;"}}, {"TYPE_URI": {"identifier": "(StdKeyDeserializer) TYPE_URI", "line": "public final static int TYPE_URI = 13;"}}, {"TYPE_URL": {"identifier": "(StdKeyDeserializer) TYPE_URL", "line": "public final static int TYPE_URL = 14;"}}, {"_deserialize": {"identifier": "(FromStringDeserializer) _deserialize()", "line": "return _deser._deserialize(key, ctxt);"}}, {"TYPE_SHORT": {"identifier": "(StdKeyDeserializer) TYPE_SHORT", "line": "public final static int TYPE_SHORT = 3;"}}, {"TYPE_FLOAT": {"identifier": "(StdKeyDeserializer) TYPE_FLOAT", "line": "public final static int TYPE_FLOAT = 7;"}}, {"TYPE_DATE": {"identifier": "(StdKeyDeserializer) TYPE_DATE", "line": "public final static int TYPE_DATE = 10;"}}, {"TYPE_UUID": {"identifier": "(StdKeyDeserializer) TYPE_UUID", "line": "public final static int TYPE_UUID = 12;"}}, {"TYPE_DOUBLE": {"identifier": "(StdKeyDeserializer) TYPE_DOUBLE", "line": "public final static int TYPE_DOUBLE = 8;"}}, {"TYPE_CLASS": {"identifier": "(StdKeyDeserializer) TYPE_CLASS", "line": "public final static int TYPE_CLASS = 15;"}}, {"TYPE_BOOLEAN": {"identifier": "(StdKeyDeserializer) TYPE_BOOLEAN", "line": "public final static int TYPE_BOOLEAN = 1;"}}, {"_kind": {"identifier": "(StdKeyDeserializer) _kind", "line": "final protected int _kind;"}}, {"AnnotatedMethod": {"identifier": "(AnnotatedMethod) AnnotatedMethod", "line": "import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;"}}, {"TYPE_CALENDAR": {"identifier": "(StdKeyDeserializer) TYPE_CALENDAR", "line": "public final static int TYPE_CALENDAR = 11;"}}, {"findEnum": {"identifier": "(EnumResolver) findEnum()", "line": "Enum<?> e = res.findEnum(key);"}}, {"getEnumIds": {"identifier": "(EnumResolver) getEnumIds()", "line": "+res.getEnumIds());"}}]}}], "JacksonDatabind-82": [{"context": {"prefix": "    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n", "suffix": "            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n", "buggy": "    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.getIgnored();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n", "fix": "    {\n        final boolean isConcrete = !beanDesc.getType().isAbstract();\n        final SettableBeanProperty[] creatorProps = isConcrete\n                ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n                : null;\n        final boolean hasCreatorProps = (creatorProps != null);\n        \n        // 01-May-2016, tatu: Which base type to use here gets tricky, since\n        //   it may often make most sense to use general type for overrides,\n        //   but what we have here may be more specific impl type. But for now\n        //   just use it as is.\n        JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n                .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                        beanDesc.getClassInfo());\n        Set<String> ignored;\n\n        if (ignorals != null) {\n            boolean ignoreAny = ignorals.getIgnoreUnknown();\n            builder.setIgnoreUnknownProperties(ignoreAny);\n            // Or explicit/implicit definitions?\n            ignored = ignorals.findIgnoredForDeserialization();\n            for (String propName : ignored) {\n                builder.addIgnorable(propName);\n            }\n        } else {\n            ignored = Collections.emptySet();\n        }\n\n        // Also, do we have a fallback \"any\" setter?\n        AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();\n        AnnotatedMember anySetterField = null;\n        if (anySetterMethod != null) {\n            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod));\n        }\n        else {\n        \tanySetterField = beanDesc.findAnySetterField();\n        \tif(anySetterField != null) {\n        \t\tbuilder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));\n        \t}\n        }\n        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n", "start": 474, "end": 514, "file": "main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java"}, "tokens": {"original": [{"ignoreAny": {"identifier": "() ignoreAny", "line": "boolean ignoreAny = ignorals.getIgnoreUnknown();"}}, {"beanDesc": {"identifier": "(BeanDescription) beanDesc", "line": "Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();"}}, {"getName": {"identifier": "(BeanPropertyDefinition) getName()", "line": "String name = property.getName();"}}, {"getType": {"identifier": "(SettableBeanProperty) getType()", "line": "idType = idProp.getType();"}}, {"getValue": {"identifier": "(Entry) getValue()", "line": "AnnotatedMember m = entry.getValue();"}}, {"AnnotatedMember": {"identifier": "(AnnotatedMember) AnnotatedMember", "line": "AnnotatedMember m = entry.getValue();"}}, {"getConfig": {"identifier": "(DeserializationContext) getConfig()", "line": "JsonIgnoreProperties.Value ignorals = ctxt.getConfig()"}}, {"addIgnorable": {"identifier": "(BeanDeserializerBuilder) addIgnorable()", "line": "builder.addIgnorable(name);"}}, {"getClassInfo": {"identifier": "(BeanDescription) getClassInfo()", "line": "beanDesc.getClassInfo());"}}, {"getRawClass": {"identifier": "(JavaType) getRawClass()", "line": "String full = type.getRawClass().getName();"}}, {"ObjectIdInfo": {"identifier": "(ObjectIdInfo) ObjectIdInfo", "line": "ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();"}}, {"getObjectIdInfo": {"identifier": "(BeanDescription) getObjectIdInfo()", "line": "ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo();"}}, {"getScope": {"identifier": "(ObjectIdInfo) getScope()", "line": "gen = new PropertyBasedObjectIdGenerator(objectIdInfo.getScope());"}}, {"isIgnorableType": {"identifier": "(AnnotationIntrospector) isIgnorableType()", "line": "status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());"}}, {"ConfigOverride": {"identifier": "(ConfigOverride) ConfigOverride", "line": "ConfigOverride override = config.findConfigOverride(type);"}}, {"getGetter": {"identifier": "(BeanPropertyDefinition) getGetter()", "line": "AnnotatedMethod getter = propDef.getGetter();"}}, {"AnnotatedMethod": {"identifier": "(AnnotatedMethod) AnnotatedMethod", "line": "AnnotatedMethod getter = propDef.getGetter();"}}, {"PropertyName": {"identifier": "(PropertyName) PropertyName", "line": "PropertyName propName = objectIdInfo.getPropertyName();"}}, {"getPropertyName": {"identifier": "(ObjectIdInfo) getPropertyName()", "line": "PropertyName propName = objectIdInfo.getPropertyName();"}}, {"findProperties": {"identifier": "(BeanDescription) findProperties()", "line": "beanDesc, builder, beanDesc.findProperties(), ignored);"}}, {"getValueHandler": {"identifier": "(JavaType) getValueHandler()", "line": "deser = type.getValueHandler();"}}, {"getField": {"identifier": "(BeanPropertyDefinition) getField()", "line": "rawPropertyType = property.getField().getRawType();"}}, {"getRawType": {"identifier": "(AnnotatedField) getRawType()", "line": "rawPropertyType = property.getField().getRawType();"}}, {"getBeanClass": {"identifier": "(BeanDescription) getBeanClass()", "line": ".getDefaultPropertyIgnorals(beanDesc.getBeanClass(),"}}, {"buildAbstract": {"identifier": "(BeanDeserializerBuilder) buildAbstract()", "line": "deserializer = builder.buildAbstract();"}}, {"CreatorProperty": {"identifier": "(CreatorProperty) CreatorProperty", "line": "cprop = (CreatorProperty) cp;"}}, {"isAbstract": {"identifier": "(JavaType) isAbstract()", "line": "final boolean isConcrete = !beanDesc.getType().isAbstract();"}}, {"isConcrete": {"identifier": "() isConcrete", "line": "final boolean isConcrete = !beanDesc.getType().isAbstract();"}}, {"findProperty": {"identifier": "(BeanDeserializerBuilder) findProperty()", "line": "idProp = builder.findProperty(propName);"}}, {"getContentType": {"identifier": "(JavaType) getContentType()", "line": "type = ((AnnotatedField) mutator).getType().getContentType();"}}, {"AnnotatedField": {"identifier": "(AnnotatedField) AnnotatedField", "line": "type = ((AnnotatedField) mutator).getType().getContentType();"}}, {"getSetter": {"identifier": "(BeanPropertyDefinition) getSetter()", "line": "rawPropertyType = property.getSetter().getRawParameterType(0);"}}, {"BeanDescription": {"identifier": "(BeanDescription) BeanDescription", "line": "BeanDescription desc = config.introspectClassAnnotations(type);"}}, {"JavaType": {"identifier": "(JavaType) JavaType", "line": "JavaType propertyType = propDef.getField().getType();"}}, {"canBeABeanType": {"identifier": "(ClassUtil) canBeABeanType()", "line": "String typeStr = ClassUtil.canBeABeanType(type);"}}, {"ClassUtil": {"identifier": "(ClassUtil) ClassUtil", "line": "String typeStr = ClassUtil.canBeABeanType(type);"}}, {"findAnySetter": {"identifier": "(BeanDescription) findAnySetter()", "line": "AnnotatedMethod anySetterMethod = beanDesc.findAnySetter();"}}, {"hasSetter": {"identifier": "(BeanPropertyDefinition) hasSetter()", "line": "if (property.hasSetter()) {"}}, {"isLocalType": {"identifier": "(ClassUtil) isLocalType()", "line": "typeStr = ClassUtil.isLocalType(type, true);"}}, {"getTypeHandler": {"identifier": "(JavaType) getTypeHandler()", "line": "TypeDeserializer typeDeser = type.getTypeHandler();"}}, {"setObjectIdInfo": {"identifier": "(SettableBeanProperty) setObjectIdInfo()", "line": "prop.setObjectIdInfo(objectIdInfo);"}}, {"getIndex": {"identifier": "(AnnotatedParameter) getIndex()", "line": "beanDesc.getBeanClass().getName(), name, ((AnnotatedParameter) m).getIndex());"}}, {"updateBuilder": {"identifier": "(BeanDeserializerModifier) updateBuilder()", "line": "builder = mod.updateBuilder(config, beanDesc, builder);"}}, {"creatorProps": {"identifier": "(SettableBeanProperty) creatorProps", "line": "final boolean hasCreatorProps = (creatorProps != null);"}}, {"hasCreatorProps": {"identifier": "() hasCreatorProps", "line": "final boolean hasCreatorProps = (creatorProps != null);"}}, {"findInjectables": {"identifier": "(BeanDescription) findInjectables()", "line": "Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();"}}, {"setViews": {"identifier": "(SettableBeanProperty) setViews()", "line": "prop.setViews(views);"}}, {"hasField": {"identifier": "(BeanPropertyDefinition) hasField()", "line": "} else if (property.hasField()) {"}}, {"findViews": {"identifier": "(BeanPropertyDefinition) findViews()", "line": "Class<?>[] views = propDef.findViews();"}}, {"findMethod": {"identifier": "(BeanDescription) findMethod()", "line": "AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);"}}, {"addInjectable": {"identifier": "(BeanDeserializerBuilder) addInjectable()", "line": "builder.addInjectable(PropertyName.construct(m.getName()),"}}, {"_factoryConfig": {"identifier": "(DeserializerFactoryConfig) _factoryConfig", "line": "if (_factoryConfig.hasDeserializerModifiers()) {"}}, {"constructType": {"identifier": "(DeserializationContext) constructType()", "line": "JavaType builderType = ctxt.constructType(builderClass);"}}, {"addBeanProps": {"identifier": "(BeanDeserializerFactory) addBeanProps()", "line": "protected void addBeanProps(DeserializationContext ctxt,"}}, {"isThrowable": {"identifier": "(JavaType) isThrowable()", "line": "if (type.isThrowable()) {"}}, {"addInjectables": {"identifier": "(BeanDeserializerFactory) addInjectables()", "line": "protected void addInjectables(DeserializationContext ctxt,"}}, {"getTypeFactory": {"identifier": "(DeserializationContext) getTypeFactory()", "line": "idType = ctxt.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];"}}, {"addProperty": {"identifier": "(BeanDeserializerBuilder) addProperty()", "line": "builder.addProperty(prop);"}}, {"ObjectIdReader": {"identifier": "(ObjectIdReader) ObjectIdReader", "line": "*   it a bit to collect information on ObjectIdReader, for example."}}, {"filterBeanProps": {"identifier": "(BeanDeserializerFactory) filterBeanProps()", "line": "List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,"}}, {"hasGetter": {"identifier": "(BeanPropertyDefinition) hasGetter()", "line": "} else if (useGettersAsSetters && propDef.hasGetter()) {"}}, {"canInstantiate": {"identifier": "(ValueInstantiator) canInstantiate()", "line": "if (type.isAbstract() && !valueInstantiator.canInstantiate()) {"}}, {"setPOJOBuilder": {"identifier": "(BeanDeserializerBuilder) setPOJOBuilder()", "line": "builder.setPOJOBuilder(buildMethod, builderConfig);"}}, {"NO_VIEWS": {"identifier": "(BeanDeserializerFactory) NO_VIEWS", "line": "private final static Class<?>[] NO_VIEWS = new Class<?>[0];"}}, {"setAnySetter": {"identifier": "(BeanDeserializerBuilder) setAnySetter()", "line": "builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField));"}}, {"STD_OPTIONAL": {"identifier": "(PropertyMetadata) STD_OPTIONAL", "line": "PropertyMetadata.STD_OPTIONAL);"}}, {"MapperFeature": {"identifier": "(MapperFeature) MapperFeature", "line": "final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)"}}, {"isEnabled": {"identifier": "(DeserializationContext) isEnabled()", "line": "final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)"}}, {"isProxyType": {"identifier": "(ClassUtil) isProxyType()", "line": "if (ClassUtil.isProxyType(type)) {"}}, {"withConfig": {"identifier": "(BeanDeserializerFactory) withConfig()", "line": "public DeserializerFactory withConfig(DeserializerFactoryConfig config)"}}, {"isPrimitive": {"identifier": "(JavaType) isPrimitive()", "line": "if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {"}}, {"isEnumType": {"identifier": "(JavaType) isEnumType()", "line": "if (type.isAbstract() && !type.isPrimitive() && !type.isEnumType()) {"}}, {"getMember": {"identifier": "(AnnotatedMethod) getMember()", "line": "ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));"}}]}}], "JacksonDatabind-96": [{"context": {"prefix": "                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n", "suffix": "            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n", "buggy": "                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.findImplicitParamName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n", "fix": "                    _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                    return;\n                }\n            }\n            _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n            return;\n        }\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n\n        // If there's injection or explicit name, should be properties-based\n        boolean useProps = (paramName != null) || (injectId != null);\n        if (!useProps && (paramDef != null)) {\n            // One more thing: if implicit name matches property with a getter\n            // or field, we'll consider it property-based as well\n\n            // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n            //    not implicit name, but name with possible strategy-based-rename\n//            paramName = candidate.findImplicitParamName(0);\n            paramName = candidate.paramName(0);\n            useProps = (paramName != null) && paramDef.couldSerialize();\n        }\n        if (useProps) {\n            SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                    constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n            };\n            creators.addPropertyCreator(candidate.creator(), true, properties);\n            return;\n        }\n        _handleSingleArgumentCreator(creators, candidate.creator(), true, true);\n\n        // one more thing: sever link to creator property, to avoid possible later\n        // problems with \"unresolved\" constructor property\n        if (paramDef != null) {\n            ((POJOPropertyBuilder) paramDef).removeConstructors();\n        }\n    }\n\n    private boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n    {\n", "start": 713, "end": 755, "file": "main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java"}, "tokens": {"original": [{"PropertyName": {"identifier": "(PropertyName) PropertyName", "line": "PropertyName paramName = candidate.explicitParamName(0);"}}, {"paramCount": {"identifier": "(CreatorCandidate) paramCount()", "line": "final int paramCount = candidate.paramCount();"}}, {"_findParamName": {"identifier": "(BasicDeserializerFactory) _findParamName()", "line": "final PropertyName name = _findParamName(param, intr);"}}, {"propertyDef": {"identifier": "(CreatorCandidate) propertyDef()", "line": "BeanPropertyDefinition paramDef = candidate.propertyDef(0);"}}, {"paramDef": {"identifier": "() paramDef", "line": "BeanPropertyDefinition paramDef = candidate.propertyDef(0);"}}, {"injectId": {"identifier": "() injectId", "line": "JacksonInject.Value injectId = candidate.injection(0);"}}, {"getName": {"identifier": "(Class) getName()", "line": "String clsName = rawType.getName();"}}, {"NameTransformer": {"identifier": "(NameTransformer) NameTransformer", "line": "NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);"}}, {"getParameter": {"identifier": "(AnnotatedWithParams) getParameter()", "line": "final AnnotatedParameter param = ctor.getParameter(i);"}}, {"useProps": {"identifier": "(boolean) useProps", "line": "useProps = (paramName != null) && paramDef.couldSerialize();"}}, {"couldSerialize": {"identifier": "(BeanPropertyDefinition) couldSerialize()", "line": "useProps = (paramName != null) && paramDef.couldSerialize();"}}, {"getFullName": {"identifier": "(SettableBeanProperty) getFullName()", "line": "PropertyName pn = prop.getFullName();"}}, {"isEmpty": {"identifier": "(String) isEmpty()", "line": "if (implName != null && !implName.isEmpty()) {"}}, {"beanDesc": {"identifier": "(BeanDescription) beanDesc", "line": "beanDesc = config.introspectForCreation(type);"}}, {"JavaType": {"identifier": "(JavaType) JavaType", "line": "JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);"}}, {"CLASS_ITERABLE": {"identifier": "(Class) CLASS_ITERABLE", "line": "JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);"}}, {"findTypeMapping": {"identifier": "(AbstractTypeResolver) findTypeMapping()", "line": "JavaType concrete = resolver.findTypeMapping(config, type);"}}, {"getIndex": {"identifier": "(AnnotatedParameter) getIndex()", "line": "param.getIndex()));"}}, {"BeanDescription": {"identifier": "(BeanDescription) BeanDescription", "line": "BeanDescription beanDesc = config.introspect(enumType);"}}, {"getOwner": {"identifier": "(AnnotatedParameter) getOwner()", "line": "AnnotatedWithParams owner = param.getOwner();"}}, {"findWrapperName": {"identifier": "(AnnotationIntrospector) findWrapperName()", "line": "intr.findWrapperName(param), param, metadata);"}}, {"getType": {"identifier": "(AnnotatedParameter) getType()", "line": "JavaType type = resolveMemberAndTypeAnnotations(ctxt, param, param.getType());"}}, {"getDefaultTyper": {"identifier": "(MapperConfig) getDefaultTyper()", "line": "b = config.getDefaultTyper(baseType);"}}, {"AnnotatedMember": {"identifier": "(AnnotatedMember) AnnotatedMember", "line": "type, (AnnotatedMember) member);"}}, {"getRawClass": {"identifier": "(JavaType) getRawClass()", "line": "Class<?> rawType = type.getRawClass();"}}, {"withTypeHandler": {"identifier": "(JavaType) withTypeHandler()", "line": "type = type.withTypeHandler(valueTypeDeser);"}}, {"getBeanClass": {"identifier": "(BeanDescription) getBeanClass()", "line": "Class<?> raw = beanDesc.getBeanClass();"}}, {"TypeFactory": {"identifier": "(TypeFactory) TypeFactory", "line": "TypeFactory tf = ctxt.getTypeFactory();"}}, {"getTypeFactory": {"identifier": "(DeserializationContext) getTypeFactory()", "line": "TypeFactory tf = ctxt.getTypeFactory();"}}, {"MapLikeType": {"identifier": "(MapLikeType) MapLikeType", "line": "type = ((MapLikeType) type).withKeyValueHandler(kd);"}}, {"findForMap": {"identifier": "(JavaUtilCollectionsDeserializers) findForMap()", "line": "deser = JavaUtilCollectionsDeserializers.findForMap(ctxt, type);"}}, {"getContentType": {"identifier": "(ArrayType) getContentType()", "line": "JavaType elemType = type.getContentType();"}}, {"getValueHandler": {"identifier": "(JavaType) getValueHandler()", "line": "deser = type.getValueHandler();"}}, {"constructType": {"identifier": "(MapperConfig) constructType()", "line": "JavaType type = mapAbstractType(config, config.constructType(rawType));"}}, {"mapAbstractType": {"identifier": "(BasicDeserializerFactory) mapAbstractType()", "line": "JavaType type = mapAbstractType(config, config.constructType(rawType));"}}, {"defaultImpl": {"identifier": "(TypeResolverBuilder) defaultImpl()", "line": "b = b.defaultImpl(defaultType.getRawClass());"}}, {"getConfig": {"identifier": "(DeserializationContext) getConfig()", "line": "JsonCreator.Mode mode = intr.findCreatorAnnotation(ctxt.getConfig(), ann);"}}, {"_mapFallbacks": {"identifier": "(HashMap) _mapFallbacks", "line": "Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());"}}, {"ArrayType": {"identifier": "(ArrayType) ArrayType", "line": "ArrayType type, final BeanDescription beanDesc)"}}, {"getTypeHandler": {"identifier": "(JavaType) getTypeHandler()", "line": "TypeDeserializer contentTypeDeser = contentType.getTypeHandler();"}}, {"KeyDeserializer": {"identifier": "(KeyDeserializer) KeyDeserializer", "line": "KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef);"}}, {"getKeyType": {"identifier": "(MapLikeType) getKeyType()", "line": "JavaType keyType = type.getKeyType();"}}, {"getWrapperName": {"identifier": "(Std) getWrapperName()", "line": "SettableBeanProperty prop = new CreatorProperty(name, type, property.getWrapperName(),"}}, {"getClassInfo": {"identifier": "(BeanDescription) getClassInfo()", "line": "AnnotatedClass ac = beanDesc.getClassInfo();"}}, {"AnnotatedClass": {"identifier": "(AnnotatedClass) AnnotatedClass", "line": "AnnotatedClass ac = beanDesc.getClassInfo();"}}, {"CollectionType": {"identifier": "(CollectionType) CollectionType", "line": "CollectionType ct = tf.constructCollectionType(Collection.class, elemType);"}}, {"MapType": {"identifier": "(MapType) MapType", "line": "protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,"}}, {"isInterface": {"identifier": "(JavaType) isInterface()", "line": "if (type.isInterface() || type.isAbstract()) {"}}, {"isAbstract": {"identifier": "(JavaType) isAbstract()", "line": "if (type.isInterface() || type.isAbstract()) {"}}, {"findProperties": {"identifier": "(BeanDescription) findProperties()", "line": "for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {"}}, {"EnumResolver": {"identifier": "(EnumResolver) EnumResolver", "line": "EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());"}}, {"ClassUtil": {"identifier": "(ClassUtil) ClassUtil", "line": "ClassUtil.checkAndFixAccess(factory.getMember(),"}}, {"getMember": {"identifier": "(AnnotatedMethod) getMember()", "line": "ClassUtil.checkAndFixAccess(factory.getMember(),"}}, {"_factoryConfig": {"identifier": "(DeserializerFactoryConfig) _factoryConfig", "line": "return withConfig(_factoryConfig.withAdditionalDeserializers(additional));"}}, {"withConfig": {"identifier": "(BasicDeserializerFactory) withConfig()", "line": "return withConfig(_factoryConfig.withAdditionalDeserializers(additional));"}}, {"getDeserializer": {"identifier": "(JsonNodeDeserializer) getDeserializer()", "line": "return JsonNodeDeserializer.getDeserializer(nodeClass);"}}, {"isEnumType": {"identifier": "(JavaType) isEnumType()", "line": "if (type.isEnumType()) {"}}, {"constructUnsafe": {"identifier": "(EnumResolver) constructUnsafe()", "line": "return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());"}}, {"CLASS_MAP_ENTRY": {"identifier": "(BasicDeserializerFactory) CLASS_MAP_ENTRY", "line": "private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;"}}, {"isConcrete": {"identifier": "(JavaType) isConcrete()", "line": "if (beanDesc.getType().isConcrete()) {"}}, {"CLASS_STRING": {"identifier": "(BasicDeserializerFactory) CLASS_STRING", "line": "private final static Class<?> CLASS_STRING = String.class;"}}, {"AnnotatedMethod": {"identifier": "(AnnotatedMethod) AnnotatedMethod", "line": "protected AnnotatedMethod _findJsonValueFor(DeserializationConfig config, JavaType enumType)"}}, {"isPrimitive": {"identifier": "(Class) isPrimitive()", "line": "if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {"}}, {"addIntCreator": {"identifier": "(CreatorCollector) addIntCreator()", "line": "creators.addIntCreator(ctor, isCreator);"}}, {"addLongCreator": {"identifier": "(CreatorCollector) addLongCreator()", "line": "creators.addLongCreator(ctor, isCreator);"}}, {"forType": {"identifier": "(PrimitiveArrayDeserializers) forType()", "line": "return PrimitiveArrayDeserializers.forType(raw);"}}, {"createInstance": {"identifier": "(ClassUtil) createInstance()", "line": "return (ValueInstantiator) ClassUtil.createInstance(instClass,"}}, {"CLASS_OBJECT": {"identifier": "(BasicDeserializerFactory) CLASS_OBJECT", "line": "private final static Class<?> CLASS_OBJECT = Object.class;"}}, {"MapDeserializer": {"identifier": "(MapDeserializer) MapDeserializer", "line": "MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);"}}, {"hasRawClass": {"identifier": "(JavaType) hasRawClass()", "line": "return (type == null || type.hasRawClass(rawType)) ? null : type;"}}, {"ReferenceType": {"identifier": "(ReferenceType) ReferenceType", "line": "ReferenceType type, BeanDescription beanDesc)"}}, {"getDefaultImpl": {"identifier": "(TypeResolverBuilder) getDefaultImpl()", "line": "if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {"}}, {"unknownType": {"identifier": "(TypeFactory) unknownType()", "line": "JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];"}}, {"getConstructors": {"identifier": "(BeanDescription) getConstructors()", "line": "for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {"}}, {"isMapLikeType": {"identifier": "(JavaType) isMapLikeType()", "line": "if (type.isMapLikeType()) {"}}, {"resolveType": {"identifier": "(BasicDeserializerFactory) resolveType()", "line": "protected JavaType resolveType(DeserializationContext ctxt,"}}, {"addProperty": {"identifier": "(BasicBeanDescription) addProperty()", "line": "bbd.addProperty(newDef);"}}, {"MapperFeature": {"identifier": "(MapperFeature) MapperFeature", "line": "config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS));"}}, {"isEnabled": {"identifier": "(ACCEPT_CASE_INSENSITIVE_ENUMS) isEnabled()", "line": "config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_ENUMS));"}}, {"isBogusClass": {"identifier": "(ClassUtil) isBogusClass()", "line": "if (ClassUtil.isBogusClass(instClass)) {"}}, {"hasContentType": {"identifier": "(JavaType) hasContentType()", "line": "if (type.hasContentType()) { // that is, is either container- or reference-type"}}, {"hasProperty": {"identifier": "(BasicBeanDescription) hasProperty()", "line": "if (!bbd.hasProperty(pn)) {"}}]}}], "JacksonDatabind-97": [{"context": {"prefix": "    }\n\n    @Override\n    public long asLong(long defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).longValue();\n        }\n        return defaultValue;\n    }\n    \n    @Override\n    public double asDouble(double defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).doubleValue();\n        }\n        return defaultValue;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n", "suffix": "        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to access the POJO this node wraps.\n     */\n    public Object getPojo() { return _value; }\n\n    /*\n    /**********************************************************\n    /* Overridden standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof POJONode) {\n            return _pojoEquals((POJONode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _pojoEquals(POJONode other)\n    {\n", "buggy": "    }\n\n    @Override\n    public long asLong(long defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).longValue();\n        }\n        return defaultValue;\n    }\n    \n    @Override\n    public double asDouble(double defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).doubleValue();\n        }\n        return defaultValue;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            gen.writeObject(_value);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to access the POJO this node wraps.\n     */\n    public Object getPojo() { return _value; }\n\n    /*\n    /**********************************************************\n    /* Overridden standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof POJONode) {\n            return _pojoEquals((POJONode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _pojoEquals(POJONode other)\n    {\n", "fix": "    }\n\n    @Override\n    public long asLong(long defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).longValue();\n        }\n        return defaultValue;\n    }\n    \n    @Override\n    public double asDouble(double defaultValue)\n    {\n        if (_value instanceof Number) {\n            return ((Number) _value).doubleValue();\n        }\n        return defaultValue;\n    }\n    \n    /*\n    /**********************************************************\n    /* Public API, serialization\n    /**********************************************************\n     */\n\n    @Override\n    public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n    {\n        if (_value == null) {\n            ctxt.defaultSerializeNull(gen);\n        } else if (_value instanceof JsonSerializable) {\n            ((JsonSerializable) _value).serialize(gen, ctxt);\n        } else {\n            // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n            //    this to preserve contextual information\n            ctxt.defaultSerializeValue(_value, gen);\n        }\n    }\n\n    /*\n    /**********************************************************\n    /* Extended API\n    /**********************************************************\n     */\n\n    /**\n     * Method that can be used to access the POJO this node wraps.\n     */\n    public Object getPojo() { return _value; }\n\n    /*\n    /**********************************************************\n    /* Overridden standard methods\n    /**********************************************************\n     */\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o == this) return true;\n        if (o == null) return false;\n        if (o instanceof POJONode) {\n            return _pojoEquals((POJONode) o);\n        }\n        return false;\n    }\n\n    /**\n     * @since 2.3\n     */\n    protected boolean _pojoEquals(POJONode other)\n    {\n", "start": 77, "end": 149, "file": "main/java/com/fasterxml/jackson/databind/node/POJONode.java"}, "tokens": {"original": [{"POJONode": {"identifier": "(POJONode) POJONode", "line": "public POJONode(Object v) { _value = v; }"}}, {"getPojo": {"identifier": "(POJONode) getPojo()", "line": "public Object getPojo() { return _value; }"}}, {"intValue": {"identifier": "(Number) intValue()", "line": "return ((Number) _value).intValue();"}}, {"longValue": {"identifier": "(Number) longValue()", "line": "return ((Number) _value).longValue();"}}, {"binaryValue": {"identifier": "(JsonNode) binaryValue()", "line": "return super.binaryValue();"}}, {"doubleValue": {"identifier": "(Number) doubleValue()", "line": "return ((Number) _value).doubleValue();"}}, {"booleanValue": {"identifier": "(Boolean) booleanValue()", "line": "return ((Boolean) _value).booleanValue();"}}, {"hashCode": {"identifier": "(Object) hashCode()", "line": "public int hashCode() { return _value.hashCode(); }"}}, {"asInt": {"identifier": "(POJONode) asInt()", "line": "public int asInt(int defaultValue)"}}, {"ValueNode": {"identifier": "(ValueNode) ValueNode", "line": "extends ValueNode"}}, {"asText": {"identifier": "(POJONode) asText()", "line": "@Override public String asText(String defaultValue) {"}}, {"_pojoEquals": {"identifier": "(POJONode) _pojoEquals()", "line": "return _pojoEquals((POJONode) o);"}}, {"RawValue": {"identifier": "(RawValue) RawValue", "line": "if (_value instanceof RawValue) {"}}, {"asBoolean": {"identifier": "(POJONode) asBoolean()", "line": "public boolean asBoolean(boolean defaultValue)"}}, {"toString": {"identifier": "(Object) toString()", "line": "return (_value == null) ? defaultValue : _value.toString();"}}, {"asDouble": {"identifier": "(POJONode) asDouble()", "line": "public double asDouble(double defaultValue)"}}, {"asLong": {"identifier": "(POJONode) asLong()", "line": "public long asLong(long defaultValue)"}}, {"JsonNodeType": {"identifier": "(JsonNodeType) JsonNodeType", "line": "return JsonNodeType.POJO;"}}, {"getNodeType": {"identifier": "(POJONode) getNodeType()", "line": "public JsonNodeType getNodeType() {"}}, {"asToken": {"identifier": "(POJONode) asToken()", "line": "@Override public JsonToken asToken() { return JsonToken.VALUE_EMBEDDED_OBJECT; }"}}]}}], "JacksonDatabind-99": [{"context": {"prefix": "        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, refdType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withStaticTyping(), _anchorType,\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new ReferenceType(rawType, _bindings,\n                superClass, superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n", "suffix": "        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Narrow/widen\n    /**********************************************************\n     */\n\n    @Override\n    @Deprecated // since 2.7\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        // Should we check that there is a sub-class relationship?\n        return new ReferenceType(subclass, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n        return _referencedType;\n    }\n\n    @Override\n", "buggy": "        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, refdType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withStaticTyping(), _anchorType,\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new ReferenceType(rawType, _bindings,\n                superClass, superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Narrow/widen\n    /**********************************************************\n     */\n\n    @Override\n    @Deprecated // since 2.7\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        // Should we check that there is a sub-class relationship?\n        return new ReferenceType(subclass, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n        return _referencedType;\n    }\n\n    @Override\n", "fix": "        return new ReferenceType(_class, _bindings,\n                _superClass, _superInterfaces, refdType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    public ReferenceType withStaticTyping() {\n        if (_asStatic) {\n            return this;\n        }\n        return new ReferenceType(_class, _bindings, _superClass, _superInterfaces,\n                _referencedType.withStaticTyping(), _anchorType,\n                 _valueHandler, _typeHandler, true);\n    }\n\n    @Override\n    public JavaType refine(Class<?> rawType, TypeBindings bindings,\n            JavaType superClass, JavaType[] superInterfaces) {\n        return new ReferenceType(rawType, _bindings,\n                superClass, superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    @Override\n    protected String buildCanonicalName()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(_class.getName());\n        sb.append('<');\n        sb.append(_referencedType.toCanonical());\n        sb.append('>');\n        return sb.toString();\n    }\n\n    /*\n    /**********************************************************\n    /* Narrow/widen\n    /**********************************************************\n     */\n\n    @Override\n    @Deprecated // since 2.7\n    protected JavaType _narrow(Class<?> subclass)\n    {\n        // Should we check that there is a sub-class relationship?\n        return new ReferenceType(subclass, _bindings,\n                _superClass, _superInterfaces, _referencedType, _anchorType,\n                _valueHandler, _typeHandler, _asStatic);\n    }\n\n    /*\n    /**********************************************************\n    /* Public API overrides\n    /**********************************************************\n     */\n\n    @Override\n    public JavaType getContentType() {\n        return _referencedType;\n    }\n\n    @Override\n", "start": 138, "end": 198, "file": "main/java/com/fasterxml/jackson/databind/type/ReferenceType.java"}, "tokens": {}}], "JacksonDatabind-107": [{"context": {"prefix": "        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n", "suffix": "                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n", "buggy": "        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n", "fix": "        if (deser == null) {\n            /* As per [databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                    if (actual == null) { // what should this be taken to mean?\n                        // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n                        return NullifyingDeserializer.instance;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; cannot change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()) {\n", "start": 149, "end": 179, "file": "main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java"}, "tokens": {"original": [{"_property": {"identifier": "(BeanProperty) _property", "line": "_property = null;"}}, {"_baseType": {"identifier": "(JavaType) _baseType", "line": "return _baseType;"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return sb.toString();"}}, {"_defaultImpl": {"identifier": "(JavaType) _defaultImpl", "line": "return ClassUtil.rawClass(_defaultImpl);"}}, {"ClassUtil": {"identifier": "(ClassUtil) ClassUtil", "line": "return ClassUtil.rawClass(_defaultImpl);"}}, {"typeId": {"identifier": "(Object) typeId", "line": "if (typeId == null) {"}}, {"JavaType": {"identifier": "(JavaType) JavaType", "line": "protected final JavaType _defaultImpl;"}}, {"baseType": {"identifier": "(TypeDeserializerBase) baseType()", "line": "return ctxt.reportInputMismatch(baseType(),"}}, {"_typeIdVisible": {"identifier": "(TypeDeserializerBase) _typeIdVisible", "line": "protected final boolean _typeIdVisible;"}}, {"TypeIdResolver": {"identifier": "(TypeIdResolver) TypeIdResolver", "line": "protected final TypeIdResolver _idResolver;"}}, {"_idResolver": {"identifier": "(TypeDeserializerBase) _idResolver", "line": "protected final TypeIdResolver _idResolver;"}}, {"BeanProperty": {"identifier": "(BeanProperty) BeanProperty", "line": "protected final BeanProperty _property;"}}, {"_deserializers": {"identifier": "(Map) _deserializers", "line": "_deserializers = src._deserializers;"}}, {"getName": {"identifier": "(BeanProperty) getName()", "line": "_property.getName());"}}, {"getRawClass": {"identifier": "(JavaType) getRawClass()", "line": "Class<?> raw = _defaultImpl.getRawClass();"}}, {"getDefaultImpl": {"identifier": "(TypeDeserializerBase) getDefaultImpl()", "line": "public Class<?> getDefaultImpl() {"}}, {"baseTypeName": {"identifier": "(TypeDeserializerBase) baseTypeName()", "line": "public String baseTypeName() { return _baseType.getRawClass().getName(); }"}}, {"getPropertyName": {"identifier": "(TypeDeserializerBase) getPropertyName()", "line": "public final String getPropertyName() { return _typePropertyName; }"}}, {"isBogusClass": {"identifier": "(ClassUtil) isBogusClass()", "line": "if (ClassUtil.isBogusClass(raw)) {"}}, {"getTypeFactory": {"identifier": "(DeserializationContext) getTypeFactory()", "line": "type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());"}}, {"forProperty": {"identifier": "(TypeDeserializerBase) forProperty()", "line": "public abstract TypeDeserializer forProperty(BeanProperty prop);"}}, {"typeFromId": {"identifier": "(TypeIdResolver) typeFromId()", "line": "JavaType type = _idResolver.typeFromId(ctxt, typeId);"}}, {"isEnabled": {"identifier": "(DeserializationContext) isEnabled()", "line": "if (!ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)) {"}}, {"hasGenericTypes": {"identifier": "(JavaType) hasGenericTypes()", "line": "if (!type.hasGenericTypes()) {"}}]}}], "Jsoup-2": [{"context": {"prefix": "            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n", "suffix": "            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }\n\n    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n", "buggy": "            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }\n\n    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n", "fix": "            Attribute attribute = parseAttribute();\n            if (attribute != null)\n                attributes.put(attribute);\n        }\n\n        Tag tag = Tag.valueOf(tagName);\n        Element child = new Element(tag, baseUri, attributes);\n\n        boolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\n        if (tq.matchChomp(\"/>\")) { // close empty element or tag\n            isEmptyElement = true;\n        } else {\n            tq.matchChomp(\">\");\n        }\n        addChildToParent(child, isEmptyElement);\n\n        // pc data only tags (textarea, script): chomp to end tag, add content as text node\n        if (tag.isData()) {\n            String data = tq.chompTo(\"</\" + tagName);\n            tq.chompTo(\">\");\n            popStackToClose(tag);\n            \n            Node dataNode;\n            if (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\n                dataNode = TextNode.createFromEncoded(data, baseUri);\n            else\n                dataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\n            child.appendChild(dataNode);   \n        }\n\n        // <base href>: update the base uri\n        if (child.tagName().equals(\"base\")) {\n            String href = child.absUrl(\"href\");\n            if (href.length() != 0) { // ignore <base target> etc\n                baseUri = href;\n                doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n            }\n        }\n    }\n\n    private Attribute parseAttribute() {\n        tq.consumeWhitespace();\n", "start": 127, "end": 167, "file": "main/java/org/jsoup/parser/Parser.java"}, "tokens": {}}], "Jsoup-15": [{"context": {"prefix": "                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n", "suffix": "                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n", "buggy": "                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n", "fix": "                        tb.framesetOk(false);\n                    }\n                    break;\n                }\n                case Comment: {\n                    tb.insert(t.asComment());\n                    break;\n                }\n                case Doctype: {\n                    tb.error(this);\n                    return false;\n                }\n                case StartTag:\n                    Token.StartTag startTag = t.asStartTag();\n                    String name = startTag.name();\n                    if (name.equals(\"html\")) {\n                        tb.error(this);\n                        // merge attributes onto real html\n                        Element html = tb.getStack().getFirst();\n                        for (Attribute attribute : startTag.getAttributes()) {\n                            if (!html.hasAttr(attribute.getKey()))\n                                html.attributes().put(attribute);\n                        }\n                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n                        return tb.process(t, InHead);\n                    } else if (name.equals(\"body\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else {\n                            tb.framesetOk(false);\n                            Element body = stack.get(1);\n                            for (Attribute attribute : startTag.getAttributes()) {\n                                if (!body.hasAttr(attribute.getKey()))\n                                    body.attributes().put(attribute);\n                            }\n                        }\n                    } else if (name.equals(\"frameset\")) {\n                        tb.error(this);\n                        LinkedList<Element> stack = tb.getStack();\n                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                            // only in fragment case\n                            return false; // ignore\n                        } else if (!tb.framesetOk()) {\n                            return false; // ignore frameset\n", "start": 259, "end": 305, "file": "main/java/org/jsoup/parser/TreeBuilderState.java"}, "tokens": {"original": [{"isEndTag": {"identifier": "(Token) isEndTag()", "line": "} else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {"}}, {"asEndTag": {"identifier": "(Token) asEndTag()", "line": "} else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {"}}, {"isStartTag": {"identifier": "(Token) isStartTag()", "line": "if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {"}}, {"asStartTag": {"identifier": "(Token) asStartTag()", "line": "if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {"}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {"}}, {"currentElement": {"identifier": "(TreeBuilder) currentElement()", "line": "if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {"}}, {"getKey": {"identifier": "(Attribute) getKey()", "line": "if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))"}}, {"isSpecial": {"identifier": "(TreeBuilder) isSpecial()", "line": "if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))"}}, {"inScope": {"identifier": "(TreeBuilder) inScope()", "line": "if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {"}}, {"isDoctype": {"identifier": "(Token) isDoctype()", "line": "} else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {"}}, {"inTableScope": {"identifier": "(TreeBuilder) inTableScope()", "line": "if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {"}}, {"startTag": {"identifier": "(StartTag) startTag", "line": "if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {"}}, {"isComment": {"identifier": "(Token) isComment()", "line": "} else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().name(),"}}, {"TreeBuilder": {"identifier": "(TreeBuilder) TreeBuilder", "line": "private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {"}}, {"StartTag": {"identifier": "(StartTag) StartTag", "line": "private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {"}}, {"getAttributes": {"identifier": "(Tag) getAttributes()", "line": "for (Attribute attribute : startTag.getAttributes()) {"}}, {"framesetOk": {"identifier": "(TreeBuilder) framesetOk()", "line": "} else if (!tb.framesetOk()) {"}}, {"getBaseUri": {"identifier": "(TreeBuilder) getBaseUri()", "line": "Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());"}}, {"onStack": {"identifier": "(TreeBuilder) onStack()", "line": "else if (!tb.onStack(formatEl)) {"}}, {"hasAttr": {"identifier": "(Node) hasAttr()", "line": "if (name.equals(\"base\") && el.hasAttr(\"href\"))"}}, {"aboveOnStack": {"identifier": "(TreeBuilder) aboveOnStack()", "line": "if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))"}}, {"inButtonScope": {"identifier": "(TreeBuilder) inButtonScope()", "line": "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {"}}, {"getDocument": {"identifier": "(TreeBuilder) getDocument()", "line": "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {"}}, {"quirksMode": {"identifier": "(Document) quirksMode()", "line": "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {"}}, {"InRow": {"identifier": "(TreeBuilderState) InRow", "line": "tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag"}}, {"popStackToClose": {"identifier": "(TreeBuilder) popStackToClose()", "line": "tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");"}}, {"hasKey": {"identifier": "(Attributes) hasKey()", "line": "if (startTag.attributes.hasKey(\"action\")) {"}}, {"InTableBody": {"identifier": "(TreeBuilderState) InTableBody", "line": "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))"}}, {"InTable": {"identifier": "(TreeBuilderState) InTable", "line": "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))"}}, {"InCell": {"identifier": "(TreeBuilderState) InCell", "line": "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))"}}, {"InCaption": {"identifier": "(TreeBuilderState) InCaption", "line": "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))"}}, {"TokeniserState": {"identifier": "(TokeniserState) TokeniserState", "line": "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out"}}, {"EndTag": {"identifier": "(EndTag) EndTag", "line": "tb.process(new Token.EndTag(tb.currentElement().nodeName())); // tbody, tfoot, thead"}}, {"inSelectScope": {"identifier": "(TreeBuilder) inSelectScope()", "line": "if (!tb.inSelectScope(name)) {"}}, {"DocumentType": {"identifier": "(DocumentType) DocumentType", "line": "DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());"}}, {"getName": {"identifier": "(Doctype) getName()", "line": "DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());"}}, {"getStack": {"identifier": "(TreeBuilder) getStack()", "line": "DescendableLinkedList<Element> stack = tb.getStack();"}}, {"childNode": {"identifier": "(Node) childNode", "line": "adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod."}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod."}}, {"inListItemScope": {"identifier": "(TreeBuilder) inListItemScope()", "line": "if (!tb.inListItemScope(name)) {"}}, {"childNodes": {"identifier": "(Node) childNodes()", "line": "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);"}}, {"getFormElement": {"identifier": "(TreeBuilder) getFormElement()", "line": "if (tb.getFormElement() != null) {"}}, {"asComment": {"identifier": "(Token) asComment()", "line": "tb.insert(t.asComment()); // into html node"}}, {"InBody": {"identifier": "(TreeBuilderState) InBody", "line": "return InBody.process(t, tb); // does not transition"}}, {"getData": {"identifier": "(Character) getData()", "line": "if (c.getData().equals(nullString)) {"}}, {"isEOF": {"identifier": "(Token) isEOF()", "line": "} else if (t.isEOF()) {"}}, {"asCharacter": {"identifier": "(Token) asCharacter()", "line": "String data = t.asCharacter().getData();"}}, {"getFromStack": {"identifier": "(TreeBuilder) getFromStack()", "line": "Element remainingA = tb.getFromStack(\"a\");"}}, {"insertEmpty": {"identifier": "(TreeBuilder) insertEmpty()", "line": "Element meta = tb.insertEmpty(start);"}}, {"InSelect": {"identifier": "(TreeBuilderState) InSelect", "line": "return tb.process(t, InSelect);"}}, {"originalState": {"identifier": "(TreeBuilder) originalState()", "line": "tb.transition(tb.originalState());"}}, {"ScriptData": {"identifier": "(TokeniserState) ScriptData", "line": "tb.tokeniser.transition(TokeniserState.ScriptData);"}}, {"replaceOnStack": {"identifier": "(TreeBuilder) replaceOnStack()", "line": "tb.replaceOnStack(node, replacement);"}}, {"AfterFrameset": {"identifier": "(TreeBuilderState) AfterFrameset", "line": "tb.transition(AfterFrameset);"}}, {"isCharacter": {"identifier": "(Token) isCharacter()", "line": "if (t.isCharacter()) {"}}, {"InHead": {"identifier": "(TreeBuilderState) InHead", "line": "return tb.process(start, InHead);"}}, {"LinkedList": {"identifier": "(LinkedList) LinkedList", "line": "LinkedList<Element> stack = tb.getStack();"}}, {"getHeadElement": {"identifier": "(TreeBuilder) getHeadElement()", "line": "Element head = tb.getHeadElement();"}}, {"InHeadNoscript": {"identifier": "(TreeBuilderState) InHeadNoscript", "line": "tb.transition(InHeadNoscript);"}}, {"InSelectInTable": {"identifier": "(TreeBuilderState) InSelectInTable", "line": "tb.transition(InSelectInTable);"}}, {"InFrameset": {"identifier": "(TreeBuilderState) InFrameset", "line": "tb.transition(InFrameset);"}}, {"asDoctype": {"identifier": "(Token) asDoctype()", "line": "Token.Doctype d = t.asDoctype();"}}, {"setFormElement": {"identifier": "(TreeBuilder) setFormElement()", "line": "tb.setFormElement(form);"}}, {"BeforeHtml": {"identifier": "(TreeBuilderState) BeforeHtml", "line": "tb.transition(BeforeHtml);"}}, {"InTableText": {"identifier": "(TreeBuilderState) InTableText", "line": "tb.transition(InTableText);"}}, {"isForceQuirks": {"identifier": "(Doctype) isForceQuirks()", "line": "if (d.isForceQuirks())"}}, {"setHeadElement": {"identifier": "(TreeBuilder) setHeadElement()", "line": "tb.setHeadElement(head);"}}, {"BeforeHead": {"identifier": "(TreeBuilderState) BeforeHead", "line": "tb.transition(BeforeHead);"}}, {"removeFromStack": {"identifier": "(TreeBuilder) removeFromStack()", "line": "tb.removeFromStack(formatEl);"}}, {"InColumnGroup": {"identifier": "(TreeBuilderState) InColumnGroup", "line": "tb.transition(InColumnGroup);"}}, {"AfterAfterBody": {"identifier": "(TreeBuilderState) AfterAfterBody", "line": "tb.transition(AfterAfterBody);"}}, {"AfterHead": {"identifier": "(TreeBuilderState) AfterHead", "line": "tb.transition(AfterHead);"}}, {"AfterBody": {"identifier": "(TreeBuilderState) AfterBody", "line": "tb.transition(AfterBody);"}}, {"ForeignContent": {"identifier": "(TreeBuilderState) ForeignContent", "line": "ForeignContent {"}}, {"setBaseUri": {"identifier": "(TreeBuilder) setBaseUri()", "line": "tb.setBaseUri(el);"}}]}}], "Jsoup-24": [{"context": {"prefix": "                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n", "suffix": "                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                        break;\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n        \n", "buggy": "                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                r.advance();\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                        break;\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n        \n", "fix": "                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                char c = r.consume();\n                switch (c) {\n                    case '\\t':\n                    case '\\n':\n                    case '\\f':\n                    case ' ':\n                        t.transition(BeforeAttributeName);\n                        break;\n                    case '/':\n                        t.transition(SelfClosingStartTag);\n                        break;\n                    case '>':\n                        t.emitTagPending();\n                        t.transition(Data);\n                        break;\n                    default:\n                        t.dataBuffer.append(c);\n                        anythingElse(t, r);\n                        break;\n                }\n            } else {\n                anythingElse(t, r);\n            }\n        }\n        \n", "start": 528, "end": 586, "file": "main/java/org/jsoup/parser/TokeniserState.java"}, "tokens": {"original": [{"TagOpen": {"identifier": "(TokeniserState) TagOpen", "line": "t.advanceTransition(TagOpen);"}}, {"EndTagOpen": {"identifier": "(TokeniserState) EndTagOpen", "line": "t.advanceTransition(EndTagOpen);"}}, {"BogusComment": {"identifier": "(TokeniserState) BogusComment", "line": "t.advanceTransition(BogusComment);"}}, {"BogusDoctype": {"identifier": "(TokeniserState) BogusDoctype", "line": "t.advanceTransition(BogusDoctype);"}}, {"matchConsume": {"identifier": "(CharacterReader) matchConsume()", "line": "r.matchConsume(\"]]>\");"}}, {"CommentEndDash": {"identifier": "(TokeniserState) CommentEndDash", "line": "t.advanceTransition(CommentEndDash);"}}, {"emitTagPending": {"identifier": "(Tokeniser) emitTagPending()", "line": "t.emitTagPending();"}}, {"dataBuffer": {"identifier": "(StringBuilder) dataBuffer", "line": "t.dataBuffer.append(name);"}}, {"tagPending": {"identifier": "(Tag) tagPending", "line": "t.tagPending.newAttribute();"}}, {"newAttribute": {"identifier": "(Tag) newAttribute()", "line": "t.tagPending.newAttribute();"}}, {"matchesLetter": {"identifier": "(CharacterReader) matchesLetter()", "line": "if (r.matchesLetter()) {"}}, {"appendTagName": {"identifier": "(Tag) appendTagName()", "line": "t.tagPending.appendTagName(tagName);"}}, {"tagName": {"identifier": "(String) tagName", "line": "t.tagPending.appendTagName(tagName);"}}, {"DoctypeName": {"identifier": "(TokeniserState) DoctypeName", "line": "t.transition(DoctypeName);"}}, {"consumeTo": {"identifier": "(CharacterReader) consumeTo()", "line": "comment.data.append(r.consumeTo('>'));"}}, {"CdataSection": {"identifier": "(TokeniserState) CdataSection", "line": "t.transition(CdataSection);"}}, {"TagName": {"identifier": "(TokeniserState) TagName", "line": "t.transition(TagName);"}}, {"eofError": {"identifier": "(Tokeniser) eofError()", "line": "t.eofError(this);"}}, {"CommentEndBang": {"identifier": "(TokeniserState) CommentEndBang", "line": "t.transition(CommentEndBang);"}}, {"replacementChar": {"identifier": "(char) replacementChar", "line": "t.emit(replacementChar);"}}, {"ScriptData": {"identifier": "(TokeniserState) ScriptData", "line": "t.transition(ScriptData);"}}, {"CommentEnd": {"identifier": "(TokeniserState) CommentEnd", "line": "t.transition(CommentEnd);"}}, {"commentPending": {"identifier": "(Comment) commentPending", "line": "t.commentPending.data.append(c);"}}, {"doctypePending": {"identifier": "(Doctype) doctypePending", "line": "t.doctypePending.name.append(c);"}}, {"CommentStart": {"identifier": "(TokeniserState) CommentStart", "line": "t.transition(CommentStart);"}}, {"AttributeName": {"identifier": "(TokeniserState) AttributeName", "line": "t.transition(AttributeName);"}}, {"consumeToAny": {"identifier": "(CharacterReader) consumeToAny()", "line": "String data = r.consumeToAny('<', nullChar);"}}, {"CharacterReader": {"identifier": "(CharacterReader) CharacterReader", "line": "abstract void read(Tokeniser t, CharacterReader r);"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "t.emit(\"</\" + t.dataBuffer.toString());"}}, {"selfClosing": {"identifier": "(boolean) selfClosing", "line": "t.tagPending.selfClosing = true;"}}, {"matchesAny": {"identifier": "(CharacterReader) matchesAny()", "line": "if (r.matchesAny('\\t', '\\n', '\\f', ' '))"}}, {"isEmpty": {"identifier": "(CharacterReader) isEmpty()", "line": "if (r.isEmpty()) {"}}, {"TokeniserState": {"identifier": "(TokeniserState) TokeniserState", "line": "enum TokeniserState {"}}, {"valueOf": {"identifier": "(String) valueOf()", "line": "private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);"}}]}}], "Jsoup-26": [{"context": {"prefix": " */\npublic class Cleaner {\n    private Whitelist whitelist;\n\n    /**\n     Create a new cleaner, that sanitizes documents using the supplied whitelist.\n     @param whitelist white-list to clean with\n     */\n    public Cleaner(Whitelist whitelist) {\n        Validate.notNull(whitelist);\n        this.whitelist = whitelist;\n    }\n\n    /**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n", "suffix": "            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n\n    /**\n     Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n     in the input HTML are allowed by the whitelist.\n     <p/>\n     This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n     to ensure enforced attributes are set correctly, and that the output is tidied.\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */\n    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0;\n    }\n\n    /**\n", "buggy": " */\npublic class Cleaner {\n    private Whitelist whitelist;\n\n    /**\n     Create a new cleaner, that sanitizes documents using the supplied whitelist.\n     @param whitelist white-list to clean with\n     */\n    public Cleaner(Whitelist whitelist) {\n        Validate.notNull(whitelist);\n        this.whitelist = whitelist;\n    }\n\n    /**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n\n    /**\n     Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n     in the input HTML are allowed by the whitelist.\n     <p/>\n     This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n     to ensure enforced attributes are set correctly, and that the output is tidied.\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */\n    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0;\n    }\n\n    /**\n", "fix": " */\npublic class Cleaner {\n    private Whitelist whitelist;\n\n    /**\n     Create a new cleaner, that sanitizes documents using the supplied whitelist.\n     @param whitelist white-list to clean with\n     */\n    public Cleaner(Whitelist whitelist) {\n        Validate.notNull(whitelist);\n        this.whitelist = whitelist;\n    }\n\n    /**\n     Creates a new, clean document, from the original dirty document, containing only elements allowed by the whitelist.\n     The original document is not modified. Only elements from the dirt document's <code>body</code> are used.\n     @param dirtyDocument Untrusted base document to clean.\n     @return cleaned document.\n     */\n    public Document clean(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body.\n            copySafeNodes(dirtyDocument.body(), clean.body());\n\n        return clean;\n    }\n\n    /**\n     Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n     in the input HTML are allowed by the whitelist.\n     <p/>\n     This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n     using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n     to ensure enforced attributes are set correctly, and that the output is tidied.\n     @param dirtyDocument document to test\n     @return true if no tags or attributes need to be removed; false if they do\n     */\n    public boolean isValid(Document dirtyDocument) {\n        Validate.notNull(dirtyDocument);\n\n        Document clean = Document.createShell(dirtyDocument.baseUri());\n        int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n        return numDiscarded == 0;\n    }\n\n    /**\n", "start": 19, "end": 65, "file": "main/java/org/jsoup/safety/Cleaner.java"}, "tokens": {}}], "Jsoup-32": [{"context": {"prefix": "            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        // todo: fixup, not very useful\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n", "suffix": "        return clone;\n    }\n}\n", "buggy": "            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        // todo: fixup, not very useful\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames();\n        return clone;\n    }\n}\n", "fix": "            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum); \n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        // todo: fixup, not very useful\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        Element clone = (Element) super.clone();\n        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n        return clone;\n    }\n}\n", "start": 1081, "end": 1193, "file": "main/java/org/jsoup/nodes/Element.java"}, "tokens": {"original": [{"className": {"identifier": "(String) className", "line": "classes.add(className);"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(classNames);"}}, {"notEmpty": {"identifier": "(Validate) notEmpty()", "line": "Validate.notEmpty(className);"}}, {"childNodes": {"identifier": "(List) childNodes", "line": "childNodes.clear();"}}, {"tagName": {"identifier": "(Element) tagName()", "line": "* {@code el.tagName(\"div\");}."}}, {"getName": {"identifier": "(Tag) getName()", "line": "return tag.getName();"}}, {"removeClass": {"identifier": "(Element) removeClass()", "line": "public Element removeClass(String className) {"}}, {"toggleClass": {"identifier": "(Element) toggleClass()", "line": "public Element toggleClass(String className) {"}}, {"hasClass": {"identifier": "(Element) hasClass()", "line": "public boolean hasClass(String className) {"}}, {"addClass": {"identifier": "(Element) addClass()", "line": "public Element addClass(String className) {"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "attributes.put(\"class\", StringUtil.join(classNames, \" \"));"}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "public String nodeName() {"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "tag = Tag.valueOf(tagName);"}}, {"outerHtml": {"identifier": "(Node) outerHtml()", "line": "node.outerHtml(accum);"}}, {"hasText": {"identifier": "(Element) hasText()", "line": "if (el.hasText())"}}, {"ownText": {"identifier": "(Element) ownText()", "line": "ownText(sb);"}}, {"childNodeSize": {"identifier": "(Node) childNodeSize()", "line": "int currentSize = childNodeSize();"}}, {"getAllElements": {"identifier": "(Element) getAllElements()", "line": "public Elements getAllElements() {"}}, {"baseUri": {"identifier": "(Node) baseUri()", "line": "Element child = new Element(Tag.valueOf(tagName), baseUri());"}}, {"siblingElements": {"identifier": "(Element) siblingElements()", "line": "public Elements siblingElements() {"}}, {"hashCode": {"identifier": "(Node) hashCode()", "line": "int result = super.hashCode();"}}, {"TextNode": {"identifier": "(TextNode) TextNode", "line": "if (TextNode.lastCharIsWhitespace(accum))"}}, {"asList": {"identifier": "(Arrays) asList()", "line": "classNames = new LinkedHashSet<String>(Arrays.asList(names));"}}, {"appendElement": {"identifier": "(Element) appendElement()", "line": "public Element appendElement(String tagName) {"}}, {"textNodes": {"identifier": "(List) textNodes", "line": "return Collections.unmodifiableList(textNodes);"}}, {"dataNodes": {"identifier": "(Element) dataNodes()", "line": "public List<DataNode> dataNodes() {"}}, {"DataNode": {"identifier": "(DataNode) DataNode", "line": "public List<DataNode> dataNodes() {"}}, {"prependElement": {"identifier": "(Element) prependElement()", "line": "public Element prependElement(String tagName) {"}}, {"isSelfClosing": {"identifier": "(Tag) isSelfClosing()", "line": "if (childNodes.isEmpty() && tag.isSelfClosing())"}}, {"isEmpty": {"identifier": "(List) isEmpty()", "line": "if (childNodes.isEmpty() && tag.isSelfClosing())"}}, {"childNode": {"identifier": "(Node) childNode", "line": "if (childNode instanceof DataNode) {"}}, {"isBlank": {"identifier": "(TextNode) isBlank()", "line": "if (!textNode.isBlank())"}}, {"getWholeData": {"identifier": "(DataNode) getWholeData()", "line": "sb.append(data.getWholeData());"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return accum.toString().trim();"}}, {"parseFragment": {"identifier": "(Parser) parseFragment()", "line": "List<Node> nodes = Parser.parseFragment(html, this, baseUri());"}}, {"addChildren": {"identifier": "(Node) addChildren()", "line": "addChildren(child);"}}, {"toArray": {"identifier": "(List) toArray()", "line": "addChildren(nodes.toArray(new Node[nodes.size()]));"}}, {"isBlock": {"identifier": "(Element) isBlock()", "line": "public boolean isBlock() {"}}, {"getElementById": {"identifier": "(Element) getElementById()", "line": "public Element getElementById(String id) {"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "appendChild(textNode);"}}, {"getWholeText": {"identifier": "(TextNode) getWholeText()", "line": "String text = textNode.getWholeText();"}}, {"indexInList": {"identifier": "(Element) indexInList()", "line": "return indexInList(this, parent().children());"}}, {"prependChild": {"identifier": "(Element) prependChild()", "line": "public Element prependChild(Node child) {"}}, {"parentNode": {"identifier": "(Node) parentNode", "line": "return (Element) parentNode;"}}, {"formatAsBlock": {"identifier": "(Tag) formatAsBlock()", "line": "if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())"}}, {"prettyPrint": {"identifier": "(OutputSettings) prettyPrint()", "line": "if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())"}}, {"appendText": {"identifier": "(Element) appendText()", "line": "public Element appendText(String text) {"}}, {"prependText": {"identifier": "(Element) prependText()", "line": "public Element prependText(String text) {"}}, {"insertChildren": {"identifier": "(Element) insertChildren()", "line": "public Element insertChildren(int index, Collection<? extends Node> children) {"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"outerHtmlHead": {"identifier": "(Element) outerHtmlHead()", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"outerHtmlTail": {"identifier": "(Element) outerHtmlTail()", "line": "void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"isTrue": {"identifier": "(Validate) isTrue()", "line": "Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");"}}]}}], "Jsoup-33": [{"context": {"prefix": "        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n", "suffix": "            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n\n    Element insert(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n", "buggy": "        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n\n    Element insert(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n", "fix": "        String href = base.absUrl(\"href\");\n        if (href.length() != 0) { // ignore <base target> etc\n            baseUri = href;\n            baseUriSetFromDoc = true;\n            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n        }\n    }\n\n    boolean isFragmentParsing() {\n        return fragmentParsing;\n    }\n\n    void error(HtmlTreeBuilderState state) {\n        if (errors.canAddError())\n            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n    }\n\n    Element insert(Token.StartTag startTag) {\n        // handle empty unknown tags\n        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n        if (startTag.isSelfClosing()) {\n            Element el = insertEmpty(startTag);\n            stack.add(el);\n            tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n            return el;\n        }\n        \n        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n        insert(el);\n        return el;\n    }\n\n    Element insert(String startTagName) {\n        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n        insert(el);\n        return el;\n    }\n\n    void insert(Element el) {\n        insertNode(el);\n        stack.add(el);\n    }\n\n    Element insertEmpty(Token.StartTag startTag) {\n        Tag tag = Tag.valueOf(startTag.name());\n        Element el = new Element(tag, baseUri, startTag.attributes);\n        insertNode(el);\n", "start": 138, "end": 184, "file": "main/java/org/jsoup/parser/HtmlTreeBuilder.java"}, "tokens": {}}], "Jsoup-34": [{"context": {"prefix": "     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n", "suffix": "                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n", "buggy": "     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n", "fix": "     */\n    int nextIndexOf(char c) {\n        // doesn't handle scanning for surrogates\n        for (int i = pos; i < length; i++) {\n            if (c == input[i])\n                return i - pos;\n        }\n        return -1;\n    }\n\n    /**\n     * Returns the number of characters between the current position and the next instance of the input sequence\n     *\n     * @param seq scan target\n     * @return offset between current position and next instance of target. -1 if not found.\n     */\n    int nextIndexOf(CharSequence seq) {\n        // doesn't handle scanning for surrogates\n        char startChar = seq.charAt(0);\n        for (int offset = pos; offset < length; offset++) {\n            // scan to first instance of startchar:\n            if (startChar != input[offset])\n                while(++offset < length && startChar != input[offset]);\n            int i = offset + 1;\n            int last = i + seq.length()-1;\n            if (offset < length && last <= length) {\n                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                if (i == last) // found full sequence\n                    return offset - pos;\n            }\n        }\n        return -1;\n    }\n\n    String consumeTo(char c) {\n        int offset = nextIndexOf(c);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n        } else {\n            return consumeToEnd();\n        }\n    }\n\n    String consumeTo(String seq) {\n        int offset = nextIndexOf(seq);\n        if (offset != -1) {\n            String consumed = new String(input, pos, offset);\n            pos += offset;\n            return consumed;\n", "start": 65, "end": 115, "file": "main/java/org/jsoup/parser/CharacterReader.java"}, "tokens": {"original": [{"nextIndexOf": {"identifier": "(CharacterReader) nextIndexOf()", "line": "int offset = nextIndexOf(c);"}}, {"startChar": {"identifier": "(char) startChar", "line": "while(++offset < length && startChar != input[offset]);"}}, {"consumeAsString": {"identifier": "(CharacterReader) consumeAsString()", "line": "String consumeAsString() {"}}, {"consumeTo": {"identifier": "(CharacterReader) consumeTo()", "line": "String consumeTo(String seq) {"}}, {"consumeToEnd": {"identifier": "(CharacterReader) consumeToEnd()", "line": "String consumeToEnd() {"}}, {"matchesDigit": {"identifier": "(CharacterReader) matchesDigit()", "line": "boolean matchesDigit() {"}}, {"isEmpty": {"identifier": "(CharacterReader) isEmpty()", "line": "boolean isEmpty() {"}}, {"matchesLetter": {"identifier": "(CharacterReader) matchesLetter()", "line": "boolean matchesLetter() {"}}, {"toString": {"identifier": "(CharacterReader) toString()", "line": "public String toString() {"}}, {"matchConsume": {"identifier": "(CharacterReader) matchConsume()", "line": "boolean matchConsume(String seq) {"}}, {"consumeToAny": {"identifier": "(CharacterReader) consumeToAny()", "line": "String consumeToAny(final char... chars) {"}}, {"matchesAny": {"identifier": "(CharacterReader) matchesAny()", "line": "boolean matchesAny(char... seq) {"}}, {"rewindToMark": {"identifier": "(CharacterReader) rewindToMark()", "line": "void rewindToMark() {"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(input);"}}, {"CharacterReader": {"identifier": "(CharacterReader) CharacterReader", "line": "CharacterReader(String input) {"}}]}}], "Jsoup-35": [{"context": {"prefix": "                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "suffix": "                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n", "buggy": "                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n", "fix": "                                }\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                node.appendChild(lastNode);\n\n                                lastNode = node;\n                            }\n\n                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                tb.insertInFosterParent(lastNode);\n                            } else {\n                                if (lastNode.parent() != null)\n                                    lastNode.remove();\n                                commonAncestor.appendChild(lastNode);\n                            }\n\n                            Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n                            adopter.attributes().addAll(formatEl.attributes());\n                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                            for (Node childNode : childNodes) {\n                                adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                            }\n                            furthestBlock.appendChild(adopter);\n                            tb.removeFromActiveFormattingElements(formatEl);\n                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n                            tb.removeFromStack(formatEl);\n                            tb.insertOnStackAfter(furthestBlock, adopter);\n                        }\n                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n                        if (!tb.inScope(\"name\")) {\n                            if (!tb.inScope(name)) {\n                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n", "start": 706, "end": 744, "file": "main/java/org/jsoup/parser/HtmlTreeBuilderState.java"}, "tokens": {}}], "Jsoup-37": [{"context": {"prefix": "            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n", "suffix": "    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n", "buggy": "            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return accum.toString().trim();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n", "fix": "            accum.append(\" />\");\n        else\n            accum.append(\">\");\n    }\n\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n        if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n            )))\n                indent(accum, depth, out);\n            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n", "start": 1075, "end": 1125, "file": "main/java/org/jsoup/nodes/Element.java"}, "tokens": {"original": [{"outerHtml": {"identifier": "(Node) outerHtml()", "line": "return outerHtml();"}}, {"getName": {"identifier": "(Tag) getName()", "line": "return tag.getName();"}}, {"isBlock": {"identifier": "(Tag) isBlock()", "line": "return tag.isBlock();"}}, {"tagName": {"identifier": "(String) tagName", "line": "tagName = tagName.toLowerCase().trim();"}}, {"indexInList": {"identifier": "(Element) indexInList()", "line": "return indexInList(this, parent().children());"}}, {"parentNode": {"identifier": "(Node) parentNode", "line": "return (Element) parentNode;"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "import org.jsoup.helper.StringUtil;"}}, {"baseUri": {"identifier": "(String) baseUri", "line": "super(baseUri, attributes);"}}, {"textNodes": {"identifier": "(List) textNodes", "line": "return Collections.unmodifiableList(textNodes);"}}, {"dataNodes": {"identifier": "(List) dataNodes", "line": "return Collections.unmodifiableList(dataNodes);"}}, {"classNames": {"identifier": "(Set) classNames", "line": "return classNames;"}}, {"className": {"identifier": "(String) className", "line": "return Collector.collect(new Evaluator.Class(className), this);"}}, {"ownText": {"identifier": "(Element) ownText()", "line": "public String ownText() {"}}, {"appendElement": {"identifier": "(Element) appendElement()", "line": "public Element appendElement(String tagName) {"}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "public String nodeName() {"}}, {"prependElement": {"identifier": "(Element) prependElement()", "line": "public Element prependElement(String tagName) {"}}, {"asList": {"identifier": "(Arrays) asList()", "line": "classNames = new LinkedHashSet<String>(Arrays.asList(names));"}}, {"childNodeSize": {"identifier": "(Node) childNodeSize()", "line": "int currentSize = childNodeSize();"}}, {"appendText": {"identifier": "(Element) appendText()", "line": "public Element appendText(String text) {"}}, {"prettyPrint": {"identifier": "(OutputSettings) prettyPrint()", "line": "if (out.prettyPrint() && (!childNodes.isEmpty() && ("}}, {"isEmpty": {"identifier": "(List) isEmpty()", "line": "if (out.prettyPrint() && (!childNodes.isEmpty() && ("}}, {"childNodes": {"identifier": "(List) childNodes", "line": "if (out.prettyPrint() && (!childNodes.isEmpty() && ("}}, {"prependText": {"identifier": "(Element) prependText()", "line": "public Element prependText(String text) {"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"outerHtmlHead": {"identifier": "(Element) outerHtmlHead()", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"getElementById": {"identifier": "(Element) getElementById()", "line": "public Element getElementById(String id) {"}}, {"getWholeData": {"identifier": "(DataNode) getWholeData()", "line": "sb.append(data.getWholeData());"}}, {"outerHtmlTail": {"identifier": "(Element) outerHtmlTail()", "line": "void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"TextNode": {"identifier": "(TextNode) TextNode", "line": "TextNode node = new TextNode(text, baseUri());"}}, {"removeClass": {"identifier": "(Element) removeClass()", "line": "public Element removeClass(String className) {"}}, {"toggleClass": {"identifier": "(Element) toggleClass()", "line": "public Element toggleClass(String className) {"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(html);"}}, {"addChildren": {"identifier": "(Node) addChildren()", "line": "addChildren(0, nodes.toArray(new Node[nodes.size()]));"}}, {"toArray": {"identifier": "(List) toArray()", "line": "addChildren(0, nodes.toArray(new Node[nodes.size()]));"}}, {"hashCode": {"identifier": "(Node) hashCode()", "line": "int result = super.hashCode();"}}, {"hasClass": {"identifier": "(Element) hasClass()", "line": "public boolean hasClass(String className) {"}}, {"addClass": {"identifier": "(Element) addClass()", "line": "public Element addClass(String className) {"}}, {"NodeTraversor": {"identifier": "(NodeTraversor) NodeTraversor", "line": "new NodeTraversor(new NodeVisitor() {"}}, {"getWholeText": {"identifier": "(TextNode) getWholeText()", "line": "String text = textNode.getWholeText();"}}, {"prependChild": {"identifier": "(Element) prependChild()", "line": "prependChild(child);"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "tag = Tag.valueOf(tagName);"}}, {"notEmpty": {"identifier": "(Validate) notEmpty()", "line": "Validate.notEmpty(tagName);"}}, {"isSelfClosing": {"identifier": "(Tag) isSelfClosing()", "line": "if (childNodes.isEmpty() && tag.isSelfClosing())"}}, {"siblingElements": {"identifier": "(Element) siblingElements()", "line": "public Elements siblingElements() {"}}, {"parseFragment": {"identifier": "(Parser) parseFragment()", "line": "List<Node> nodes = Parser.parseFragment(html, this, baseUri());"}}, {"isBlank": {"identifier": "(TextNode) isBlank()", "line": "if (!textNode.isBlank())"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "appendChild(child);"}}, {"getAllElements": {"identifier": "(Element) getAllElements()", "line": "public Elements getAllElements() {"}}, {"DataNode": {"identifier": "(DataNode) DataNode", "line": "if (node instanceof DataNode)"}}, {"childNode": {"identifier": "(Node) childNode", "line": "DataNode data = (DataNode) childNode;"}}, {"formatAsBlock": {"identifier": "(Tag) formatAsBlock()", "line": "if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )"}}, {"hasText": {"identifier": "(Element) hasText()", "line": "if (el.hasText())"}}, {"isTrue": {"identifier": "(Validate) isTrue()", "line": "Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");"}}, {"insertChildren": {"identifier": "(Element) insertChildren()", "line": "public Element insertChildren(int index, Collection<? extends Node> children) {"}}]}}], "Jsoup-39": [{"context": {"prefix": "                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n", "suffix": "        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n    /**\n     * Read the input stream into a byte buffer.\n     * @param inStream the input stream to read from\n     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n     * @return the filled byte buffer\n     * @throws IOException if an exception occurs whilst reading from the input stream.\n     */\n    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean capped = maxSize > 0;\n", "buggy": "                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n    /**\n     * Read the input stream into a byte buffer.\n     * @param inStream the input stream to read from\n     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n     * @return the filled byte buffer\n     * @throws IOException if an exception occurs whilst reading from the input stream.\n     */\n    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean capped = maxSize > 0;\n", "fix": "                    foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                    charsetName = foundCharset;\n                    byteData.rewind();\n                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                    doc = null;\n                }\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n            docData = Charset.forName(charsetName).decode(byteData).toString();\n        }\n        // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n            byteData.rewind();\n            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n            docData = docData.substring(1);\n            charsetName = defaultCharset;\n            doc = null;\n        }\n        if (doc == null) {\n            doc = parser.parseInput(docData, baseUri);\n            doc.outputSettings().charset(charsetName);\n        }\n        return doc;\n    }\n\n    /**\n     * Read the input stream into a byte buffer.\n     * @param inStream the input stream to read from\n     * @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n     * @return the filled byte buffer\n     * @throws IOException if an exception occurs whilst reading from the input stream.\n     */\n    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n        Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n        final boolean capped = maxSize > 0;\n", "start": 101, "end": 135, "file": "main/java/org/jsoup/helper/DataUtil.java"}, "tokens": {}}], "Jsoup-40": [{"context": {"prefix": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n/**\n * A {@code <!DOCTYPE>} node.\n */\npublic class DocumentType extends Node {\n    // todo: quirk mode from publicId and systemId\n\n    /**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */\n    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n", "suffix": "        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n\n    @Override\n    public String nodeName() {\n        return \"#doctype\";\n    }\n\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE\");\n        if (!StringUtil.isBlank(attr(\"name\")))\n            accum.append(\" \").append(attr(\"name\"));\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append('\"');\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append('\"');\n        accum.append('>');\n    }\n\n    @Override\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n    }\n}\n", "buggy": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n/**\n * A {@code <!DOCTYPE>} node.\n */\npublic class DocumentType extends Node {\n    // todo: quirk mode from publicId and systemId\n\n    /**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */\n    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        Validate.notEmpty(name);\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n\n    @Override\n    public String nodeName() {\n        return \"#doctype\";\n    }\n\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE\");\n        if (!StringUtil.isBlank(attr(\"name\")))\n            accum.append(\" \").append(attr(\"name\"));\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append('\"');\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append('\"');\n        accum.append('>');\n    }\n\n    @Override\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n    }\n}\n", "fix": "package org.jsoup.nodes;\n\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.helper.Validate;\n\n/**\n * A {@code <!DOCTYPE>} node.\n */\npublic class DocumentType extends Node {\n    // todo: quirk mode from publicId and systemId\n\n    /**\n     * Create a new doctype element.\n     * @param name the doctype's name\n     * @param publicId the doctype's public ID\n     * @param systemId the doctype's system ID\n     * @param baseUri the doctype's base URI\n     */\n    public DocumentType(String name, String publicId, String systemId, String baseUri) {\n        super(baseUri);\n\n        attr(\"name\", name);\n        attr(\"publicId\", publicId);\n        attr(\"systemId\", systemId);\n    }\n\n    @Override\n    public String nodeName() {\n        return \"#doctype\";\n    }\n\n    @Override\n    void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n        accum.append(\"<!DOCTYPE\");\n        if (!StringUtil.isBlank(attr(\"name\")))\n            accum.append(\" \").append(attr(\"name\"));\n        if (!StringUtil.isBlank(attr(\"publicId\")))\n            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append('\"');\n        if (!StringUtil.isBlank(attr(\"systemId\")))\n            accum.append(\" \\\"\").append(attr(\"systemId\")).append('\"');\n        accum.append('>');\n    }\n\n    @Override\n    void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n    }\n}\n", "start": -5, "end": 47, "file": "main/java/org/jsoup/nodes/DocumentType.java"}, "tokens": {"original": [{"isBlank": {"identifier": "(StringUtil) isBlank()", "line": "if (!StringUtil.isBlank(attr(\"name\")))"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "if (!StringUtil.isBlank(attr(\"name\")))"}}, {"nodeName": {"identifier": "(DocumentType) nodeName()", "line": "public String nodeName() {"}}, {"systemId": {"identifier": "(String) systemId", "line": "attr(\"systemId\", systemId);"}}, {"DocumentType": {"identifier": "(DocumentType) DocumentType", "line": "public class DocumentType extends Node {"}}, {"baseUri": {"identifier": "(String) baseUri", "line": "super(baseUri);"}}, {"publicId": {"identifier": "(String) publicId", "line": "attr(\"publicId\", publicId);"}}, {"outerHtmlTail": {"identifier": "(DocumentType) outerHtmlTail()", "line": "void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"outerHtmlHead": {"identifier": "(DocumentType) outerHtmlHead()", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}]}}], "Jsoup-41": [{"context": {"prefix": "            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n", "suffix": "    }\n\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n}\n", "buggy": "            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return this == o;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n}\n", "fix": "            accum.append(\"</\").append(tagName()).append(\">\");\n        }\n    }\n\n    /**\n     * Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code <p>}, would return\n     * {@code <p></p>}. (Whereas {@link #outerHtml()} would return {@code <div><p></p></div>}.)\n     * \n     * @return String of HTML.\n     * @see #outerHtml()\n     */\n    public String html() {\n        StringBuilder accum = new StringBuilder();\n        html(accum);\n        return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n    }\n\n    private void html(StringBuilder accum) {\n        for (Node node : childNodes)\n            node.outerHtml(accum);\n    }\n    \n    /**\n     * Set this element's inner HTML. Clears the existing HTML first.\n     * @param html HTML to parse and set into this element\n     * @return this element\n     * @see #append(String)\n     */\n    public Element html(String html) {\n        empty();\n        append(html);\n        return this;\n    }\n\n    public String toString() {\n        return outerHtml();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        Element element = (Element) o;\n\n        return tag.equals(element.tag);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n        return result;\n    }\n\n    @Override\n    public Element clone() {\n        return (Element) super.clone();\n    }\n}\n", "start": 1128, "end": 1220, "file": "main/java/org/jsoup/nodes/Element.java"}, "tokens": {"original": [{"isBlock": {"identifier": "(Tag) isBlock()", "line": "return tag.isBlock();"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return sb.toString();"}}, {"classNames": {"identifier": "(Set) classNames", "line": "return classNames;"}}, {"outerHtml": {"identifier": "(Node) outerHtml()", "line": "return outerHtml();"}}, {"parentNode": {"identifier": "(Node) parentNode", "line": "return (Element) parentNode;"}}, {"getName": {"identifier": "(Tag) getName()", "line": "return tag.getName();"}}, {"childNodeSize": {"identifier": "(Node) childNodeSize()", "line": "int currentSize = childNodeSize();"}}, {"reparentChild": {"identifier": "(Node) reparentChild()", "line": "reparentChild(child);"}}, {"indexInList": {"identifier": "(Element) indexInList()", "line": "return indexInList(this, parent().children());"}}, {"prependChild": {"identifier": "(Element) prependChild()", "line": "prependChild(node);"}}, {"hashCode": {"identifier": "(Node) hashCode()", "line": "int result = super.hashCode();"}}, {"cssSelector": {"identifier": "(Element) cssSelector()", "line": "return parent().cssSelector() + selector.toString();"}}, {"textNodes": {"identifier": "(List) textNodes", "line": "return Collections.unmodifiableList(textNodes);"}}, {"dataNodes": {"identifier": "(List) dataNodes", "line": "return Collections.unmodifiableList(dataNodes);"}}, {"baseUri": {"identifier": "(String) baseUri", "line": "super(baseUri, attributes);"}}, {"getWholeText": {"identifier": "(TextNode) getWholeText()", "line": "String text = textNode.getWholeText();"}}, {"addChildren": {"identifier": "(Node) addChildren()", "line": "addChildren(0, child);"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "appendChild(node);"}}, {"childNodes": {"identifier": "(List) childNodes", "line": "for (Node node : childNodes) {"}}, {"TextNode": {"identifier": "(TextNode) TextNode", "line": "TextNode textNode = (TextNode) node;"}}, {"childNode": {"identifier": "(Node) childNode", "line": "Element element = (Element) childNode;"}}, {"prettyPrint": {"identifier": "(OutputSettings) prettyPrint()", "line": "if (out.prettyPrint() && (!childNodes.isEmpty() && ("}}, {"isEmpty": {"identifier": "(List) isEmpty()", "line": "if (out.prettyPrint() && (!childNodes.isEmpty() && ("}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(elements);"}}, {"tagName": {"identifier": "(Element) tagName()", "line": "* @param tagName new tag name for this element"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "import org.jsoup.helper.StringUtil;"}}, {"className": {"identifier": "(Element) className()", "line": "* @param className the name of the class to search for."}}, {"NodeTraversor": {"identifier": "(NodeTraversor) NodeTraversor", "line": "new NodeTraversor(new NodeVisitor() {"}}, {"DataNode": {"identifier": "(DataNode) DataNode", "line": "DataNode data = (DataNode) childNode;"}}, {"setSiblingIndex": {"identifier": "(Node) setSiblingIndex()", "line": "child.setSiblingIndex(childNodes.size() - 1);"}}, {"ArrayList": {"identifier": "(ArrayList) ArrayList", "line": "List<TextNode> textNodes = new ArrayList<TextNode>();"}}, {"ownText": {"identifier": "(Element) ownText()", "line": "public String ownText() {"}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "public String nodeName() {"}}, {"hasText": {"identifier": "(Element) hasText()", "line": "public boolean hasText() {"}}, {"prependText": {"identifier": "(Element) prependText()", "line": "public Element prependText(String text) {"}}, {"parseFragment": {"identifier": "(Parser) parseFragment()", "line": "List<Node> nodes = Parser.parseFragment(html, this, baseUri());"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"outerHtmlHead": {"identifier": "(Element) outerHtmlHead()", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"notEmpty": {"identifier": "(Validate) notEmpty()", "line": "Validate.notEmpty(id);"}}, {"removeClass": {"identifier": "(Element) removeClass()", "line": "public Element removeClass(String className) {"}}, {"prependElement": {"identifier": "(Element) prependElement()", "line": "public Element prependElement(String tagName) {"}}, {"getWholeData": {"identifier": "(DataNode) getWholeData()", "line": "sb.append(data.getWholeData());"}}, {"appendText": {"identifier": "(Element) appendText()", "line": "public Element appendText(String text) {"}}, {"outerHtmlTail": {"identifier": "(Element) outerHtmlTail()", "line": "void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"getElementById": {"identifier": "(Element) getElementById()", "line": "public Element getElementById(String id) {"}}, {"getAllElements": {"identifier": "(Element) getAllElements()", "line": "public Elements getAllElements() {"}}, {"hasClass": {"identifier": "(Element) hasClass()", "line": "public boolean hasClass(String className) {"}}, {"addClass": {"identifier": "(Element) addClass()", "line": "public Element addClass(String className) {"}}, {"isTrue": {"identifier": "(Validate) isTrue()", "line": "Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "Element child = new Element(Tag.valueOf(tagName), baseUri());"}}, {"siblingElements": {"identifier": "(Element) siblingElements()", "line": "public Elements siblingElements() {"}}, {"appendElement": {"identifier": "(Element) appendElement()", "line": "public Element appendElement(String tagName) {"}}, {"asList": {"identifier": "(Arrays) asList()", "line": "Set<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));"}}, {"toggleClass": {"identifier": "(Element) toggleClass()", "line": "public Element toggleClass(String className) {"}}, {"isSelfClosing": {"identifier": "(Tag) isSelfClosing()", "line": "if (childNodes.isEmpty() && tag.isSelfClosing()) {"}}, {"insertChildren": {"identifier": "(Element) insertChildren()", "line": "public Element insertChildren(int index, Collection<? extends Node> children) {"}}, {"isBlank": {"identifier": "(TextNode) isBlank()", "line": "if (!textNode.isBlank())"}}, {"formatAsBlock": {"identifier": "(Tag) formatAsBlock()", "line": "tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))"}}]}}], "Jsoup-43": [{"context": {"prefix": "     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n", "suffix": "                return i;\n        }\n        return null;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n", "buggy": "     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element.equals(search))\n                return i;\n        }\n        return null;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n", "fix": "     * sibling, returns 0.\n     * @return position in element sibling list\n     */\n    public Integer elementSiblingIndex() {\n       if (parent() == null) return 0;\n       return indexInList(this, parent().children()); \n    }\n\n    /**\n     * Gets the last element sibling of this element\n     * @return the last sibling that is an element (aka the parent's last element child) \n     */\n    public Element lastElementSibling() {\n        List<Element> siblings = parent().children();\n        return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n    }\n    \n    private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n        Validate.notNull(search);\n        Validate.notNull(elements);\n\n        for (int i = 0; i < elements.size(); i++) {\n            E element = elements.get(i);\n            if (element == search)\n                return i;\n        }\n        return null;\n    }\n\n    // DOM type methods\n\n    /**\n     * Finds elements, including and recursively under this element, with the specified tag name.\n     * @param tagName The tag name to search for (case insensitively).\n     * @return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.\n     */\n    public Elements getElementsByTag(String tagName) {\n        Validate.notEmpty(tagName);\n        tagName = tagName.toLowerCase().trim();\n\n        return Collector.collect(new Evaluator.Tag(tagName), this);\n    }\n\n    /**\n     * Find an element by ID, including or under this element.\n     * <p>\n     * Note that this finds the first matching ID, starting with this element. If you search down from a different\n", "start": 550, "end": 596, "file": "main/java/org/jsoup/nodes/Element.java"}, "tokens": {"original": [{"tagName": {"identifier": "(Element) tagName()", "line": "if (tagName().equals(\"textarea\"))"}}, {"className": {"identifier": "(String) className", "line": "if (className.equalsIgnoreCase(name))"}}, {"hasText": {"identifier": "(Element) hasText()", "line": "if (el.hasText())"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(search);"}}, {"TextNode": {"identifier": "(TextNode) TextNode", "line": "if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))"}}, {"getName": {"identifier": "(Tag) getName()", "line": "if (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))"}}, {"isBlock": {"identifier": "(Element) isBlock()", "line": "(element.isBlock() || element.tag.getName().equals(\"br\")) &&"}}, {"parentNode": {"identifier": "(Node) parentNode", "line": "if (preserveWhitespace(textNode.parentNode))"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "public Element appendChild(Node child) {"}}, {"prependChild": {"identifier": "(Element) prependChild()", "line": "public Element prependChild(Node child) {"}}, {"isBlank": {"identifier": "(TextNode) isBlank()", "line": "if (!textNode.isBlank())"}}, {"addClass": {"identifier": "(Element) addClass()", "line": "public Element addClass(String className) {"}}, {"getAllElements": {"identifier": "(Element) getAllElements()", "line": "public Elements getAllElements() {"}}, {"removeClass": {"identifier": "(Element) removeClass()", "line": "public Element removeClass(String className) {"}}, {"toggleClass": {"identifier": "(Element) toggleClass()", "line": "public Element toggleClass(String className) {"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "Element child = new Element(Tag.valueOf(tagName), baseUri());"}}, {"baseUri": {"identifier": "(Node) baseUri()", "line": "Element child = new Element(Tag.valueOf(tagName), baseUri());"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "if (parent().select(selector.toString()).size() > 1)"}}, {"DataNode": {"identifier": "(DataNode) DataNode", "line": "if (node instanceof DataNode)"}}, {"childNodes": {"identifier": "(List) childNodes", "line": "childNodes.clear();"}}, {"isSelfClosing": {"identifier": "(Tag) isSelfClosing()", "line": "if (childNodes.isEmpty() && tag.isSelfClosing()) {"}}, {"isEmpty": {"identifier": "(List) isEmpty()", "line": "if (childNodes.isEmpty() && tag.isSelfClosing()) {"}}, {"siblingElements": {"identifier": "(Element) siblingElements()", "line": "public Elements siblingElements() {"}}, {"hashCode": {"identifier": "(Node) hashCode()", "line": "int result = super.hashCode();"}}, {"classNames": {"identifier": "(Element) classNames()", "line": "public Element classNames(Set<String> classNames) {"}}, {"childNode": {"identifier": "(Node) childNode", "line": "if (childNode instanceof DataNode) {"}}, {"getElementById": {"identifier": "(Element) getElementById()", "line": "public Element getElementById(String id) {"}}, {"reparentChild": {"identifier": "(Node) reparentChild()", "line": "reparentChild(child);"}}, {"ArrayList": {"identifier": "(ArrayList) ArrayList", "line": "List<Element> elements = new ArrayList<Element>(childNodes.size());"}}, {"appendText": {"identifier": "(Element) appendText()", "line": "public Element appendText(String text) {"}}, {"appendElement": {"identifier": "(Element) appendElement()", "line": "public Element appendElement(String tagName) {"}}, {"prependText": {"identifier": "(Element) prependText()", "line": "public Element prependText(String text) {"}}, {"prependElement": {"identifier": "(Element) prependElement()", "line": "public Element prependElement(String tagName) {"}}, {"getWholeData": {"identifier": "(DataNode) getWholeData()", "line": "sb.append(data.getWholeData());"}}, {"hasClass": {"identifier": "(Element) hasClass()", "line": "public boolean hasClass(String className) {"}}, {"parseFragment": {"identifier": "(Parser) parseFragment()", "line": "List<Node> nodes = Parser.parseFragment(html, this, baseUri());"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "String classes = StringUtil.join(classNames(), \".\");"}}, {"indexInList": {"identifier": "(Element) indexInList()", "line": "return indexInList(this, parent().children());"}}, {"addChildren": {"identifier": "(Node) addChildren()", "line": "addChildren(0, child);"}}, {"outerHtml": {"identifier": "(Node) outerHtml()", "line": "node.outerHtml(accum);"}}, {"textNodes": {"identifier": "(List) textNodes", "line": "return Collections.unmodifiableList(textNodes);"}}, {"dataNodes": {"identifier": "(List) dataNodes", "line": "return Collections.unmodifiableList(dataNodes);"}}, {"classSplit": {"identifier": "(Pattern) classSplit", "line": "String[] names = classSplit.split(className());"}}, {"notEmpty": {"identifier": "(Validate) notEmpty()", "line": "Validate.notEmpty(className);"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())"}}, {"getWholeText": {"identifier": "(TextNode) getWholeText()", "line": "String text = textNode.getWholeText();"}}, {"setSiblingIndex": {"identifier": "(Node) setSiblingIndex()", "line": "child.setSiblingIndex(childNodes.size() - 1);"}}, {"cssSelector": {"identifier": "(Element) cssSelector()", "line": "return parent().cssSelector() + selector.toString();"}}, {"insertChildren": {"identifier": "(Element) insertChildren()", "line": "public Element insertChildren(int index, Collection<? extends Node> children) {"}}, {"childNodeSize": {"identifier": "(Node) childNodeSize()", "line": "int currentSize = childNodeSize();"}}, {"ownText": {"identifier": "(Element) ownText()", "line": "private void ownText(StringBuilder accum) {"}}, {"asList": {"identifier": "(Arrays) asList()", "line": "Set<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));"}}, {"prettyPrint": {"identifier": "(OutputSettings) prettyPrint()", "line": "if (out.prettyPrint() && (!childNodes.isEmpty() && ("}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "public String nodeName() {"}}, {"NodeTraversor": {"identifier": "(NodeTraversor) NodeTraversor", "line": "new NodeTraversor(new NodeVisitor() {"}}, {"outerHtmlHead": {"identifier": "(Element) outerHtmlHead()", "line": "void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"outerHtmlTail": {"identifier": "(Element) outerHtmlTail()", "line": "void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {"}}, {"formatAsBlock": {"identifier": "(Tag) formatAsBlock()", "line": "if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )"}}, {"isTrue": {"identifier": "(Validate) isTrue()", "line": "Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");"}}]}}], "Jsoup-45": [{"context": {"prefix": "    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n", "suffix": "                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n", "buggy": "    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n", "fix": "    }\n\n    void replaceOnStack(Element out, Element in) {\n        replaceInQueue(stack, out, in);\n    }\n\n    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n        int i = queue.lastIndexOf(out);\n        Validate.isTrue(i != -1);\n        queue.set(i, in);\n    }\n\n    void resetInsertionMode() {\n        boolean last = false;\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element node = stack.get(pos);\n            if (pos == 0) {\n                last = true;\n                node = contextElement;\n            }\n            String name = node.nodeName();\n            if (\"select\".equals(name)) {\n                transition(HtmlTreeBuilderState.InSelect);\n                break; // frag\n            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                transition(HtmlTreeBuilderState.InCell);\n                break;\n            } else if (\"tr\".equals(name)) {\n                transition(HtmlTreeBuilderState.InRow);\n                break;\n            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTableBody);\n                break;\n            } else if (\"caption\".equals(name)) {\n                transition(HtmlTreeBuilderState.InCaption);\n                break;\n            } else if (\"colgroup\".equals(name)) {\n                transition(HtmlTreeBuilderState.InColumnGroup);\n                break; // frag\n            } else if (\"table\".equals(name)) {\n                transition(HtmlTreeBuilderState.InTable);\n                break;\n            } else if (\"head\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break; // frag\n            } else if (\"body\".equals(name)) {\n                transition(HtmlTreeBuilderState.InBody);\n                break;\n            } else if (\"frameset\".equals(name)) {\n", "start": 369, "end": 417, "file": "main/java/org/jsoup/parser/HtmlTreeBuilder.java"}, "tokens": {"original": [{"nodeName": {"identifier": "(Element) nodeName()", "line": "else if (next.nodeName().equals(nodeName))"}}, {"tagName": {"identifier": "(String) tagName", "line": "if (tagName.equals(\"script\") || tagName.equals(\"style\"))"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))"}}, {"onStack": {"identifier": "(HtmlTreeBuilder) onStack()", "line": "if (last == null || onStack(last))"}}, {"currentElement": {"identifier": "(TreeBuilder) currentElement()", "line": "while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&"}}, {"isFosterInserts": {"identifier": "(HtmlTreeBuilder) isFosterInserts()", "line": "else if (isFosterInserts())"}}, {"setHeadElement": {"identifier": "(HtmlTreeBuilder) setHeadElement()", "line": "void setHeadElement(Element headElement) {"}}, {"headElement": {"identifier": "(HtmlTreeBuilder) headElement", "line": "void setHeadElement(Element headElement) {"}}, {"isFormListed": {"identifier": "(Tag) isFormListed()", "line": "if (node instanceof Element && ((Element) node).tag().isFormListed()) {"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "Element el = new Element(Tag.valueOf(startTagName), baseUri);"}}, {"baseUri": {"identifier": "(String) baseUri", "line": "Element el = new Element(Tag.valueOf(startTagName), baseUri);"}}, {"popStackToClose": {"identifier": "(HtmlTreeBuilder) popStackToClose()", "line": "void popStackToClose(String... elNames) {"}}, {"ownerDocument": {"identifier": "(Node) ownerDocument()", "line": "if (context.ownerDocument() != null) // quirks setup:"}}, {"inScope": {"identifier": "(HtmlTreeBuilder) inScope()", "line": "boolean inScope(String targetName, String[] extras) {"}}, {"FormElement": {"identifier": "(FormElement) FormElement", "line": "if (parent instanceof FormElement) {"}}, {"ArrayList": {"identifier": "(ArrayList) ArrayList", "line": "private boolean isElementInQueue(ArrayList<Element> queue, Element element) {"}}, {"isSelfClosing": {"identifier": "(Tag) isSelfClosing()", "line": "if (startTag.isSelfClosing()) {"}}, {"isSpecial": {"identifier": "(HtmlTreeBuilder) isSpecial()", "line": "boolean isSpecial(Element el) {"}}, {"framesetOk": {"identifier": "(HtmlTreeBuilder) framesetOk()", "line": "void framesetOk(boolean framesetOk) {"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(entry); // should not occur, as we break at last element"}}, {"getHeadElement": {"identifier": "(HtmlTreeBuilder) getHeadElement()", "line": "Element getHeadElement() {"}}, {"isEmpty": {"identifier": "(ArrayList) isEmpty()", "line": "while (!formattingElements.isEmpty()) {"}}, {"replaceOnStack": {"identifier": "(HtmlTreeBuilder) replaceOnStack()", "line": "void replaceOnStack(Element out, Element in) {"}}, {"addAll": {"identifier": "(Attributes) addAll()", "line": "newEl.attributes().addAll(entry.attributes());"}}, {"aboveOnStack": {"identifier": "(HtmlTreeBuilder) aboveOnStack()", "line": "Element aboveOnStack(Element el) {"}}, {"inTableScope": {"identifier": "(HtmlTreeBuilder) inTableScope()", "line": "boolean inTableScope(String targetName) {"}}, {"isKnownTag": {"identifier": "(Tag) isKnownTag()", "line": "if (tag.isKnownTag()) {"}}, {"inButtonScope": {"identifier": "(HtmlTreeBuilder) inButtonScope()", "line": "boolean inButtonScope(String targetName) {"}}, {"inSelectScope": {"identifier": "(HtmlTreeBuilder) inSelectScope()", "line": "boolean inSelectScope(String targetName) {"}}, {"fragmentParsing": {"identifier": "(HtmlTreeBuilder) fragmentParsing", "line": "private boolean fragmentParsing = false; // if parsing a fragment of html"}}, {"maybeSetBaseUri": {"identifier": "(HtmlTreeBuilder) maybeSetBaseUri()", "line": "void maybeSetBaseUri(Element base) {"}}, {"replaceInQueue": {"identifier": "(HtmlTreeBuilder) replaceInQueue()", "line": "private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {"}}, {"setBaseUri": {"identifier": "(Node) setBaseUri()", "line": "doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants"}}, {"getFromStack": {"identifier": "(HtmlTreeBuilder) getFromStack()", "line": "Element getFromStack(String elName) {"}}, {"removeFromStack": {"identifier": "(HtmlTreeBuilder) removeFromStack()", "line": "boolean removeFromStack(Element el) {"}}, {"TreeBuilder": {"identifier": "(TreeBuilder) TreeBuilder", "line": "public class HtmlTreeBuilder extends TreeBuilder {"}}, {"HtmlTreeBuilder": {"identifier": "(HtmlTreeBuilder) HtmlTreeBuilder", "line": "public class HtmlTreeBuilder extends TreeBuilder {"}}, {"InFrameset": {"identifier": "(HtmlTreeBuilderState) InFrameset", "line": "transition(HtmlTreeBuilderState.InFrameset);"}}, {"inListItemScope": {"identifier": "(HtmlTreeBuilder) inListItemScope()", "line": "boolean inListItemScope(String targetName) {"}}, {"originalState": {"identifier": "(HtmlTreeBuilder) originalState()", "line": "HtmlTreeBuilderState originalState() {"}}, {"insertStartTag": {"identifier": "(HtmlTreeBuilder) insertStartTag()", "line": "Element insertStartTag(String startTagName) {"}}, {"fosterInserts": {"identifier": "(HtmlTreeBuilder) fosterInserts", "line": "void setFosterInserts(boolean fosterInserts) {"}}, {"setFormElement": {"identifier": "(HtmlTreeBuilder) setFormElement()", "line": "void setFormElement(FormElement formElement) {"}}, {"formElement": {"identifier": "(HtmlTreeBuilder) formElement", "line": "void setFormElement(FormElement formElement) {"}}, {"quirksMode": {"identifier": "(Document) quirksMode()", "line": "doc.quirksMode(context.ownerDocument().quirksMode());"}}, {"TokeniserState": {"identifier": "(TokeniserState) TokeniserState", "line": "tokeniser.transition(TokeniserState.Data); // default"}}, {"contextElement": {"identifier": "(HtmlTreeBuilder) contextElement", "line": "private Element contextElement; // fragment parse context -- could be null even if fragment parsing"}}, {"StartTag": {"identifier": "(StartTag) StartTag", "line": "Element insert(Token.StartTag startTag) {"}}, {"inSpecificScope": {"identifier": "(HtmlTreeBuilder) inSpecificScope()", "line": "private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {"}}, {"initialiseParse": {"identifier": "(TreeBuilder) initialiseParse()", "line": "initialiseParse(inputFragment, baseUri, errors);"}}, {"getData": {"identifier": "(Character) getData()", "line": "node = new DataNode(characterToken.getData(), baseUri);"}}, {"TagSearchList": {"identifier": "(String) TagSearchList", "line": "return inScope(targetName, TagSearchList);"}}, {"insertNode": {"identifier": "(HtmlTreeBuilder) insertNode()", "line": "private void insertNode(Node node) {"}}, {"ParseErrorList": {"identifier": "(ParseErrorList) ParseErrorList", "line": "List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {"}}, {"parseFragment": {"identifier": "(HtmlTreeBuilder) parseFragment()", "line": "List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {"}}, {"tokenType": {"identifier": "(Token) tokenType()", "line": "errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));"}}, {"currentToken": {"identifier": "(Token) currentToken", "line": "errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));"}}, {"insertForm": {"identifier": "(HtmlTreeBuilder) insertForm()", "line": "FormElement insertForm(Token.StartTag startTag, boolean onStack) {"}}, {"emptyEnd": {"identifier": "(EndTag) emptyEnd", "line": "tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing"}}, {"addElement": {"identifier": "(FormElement) addElement()", "line": "formElement.addElement((Element) node);"}}, {"insertEmpty": {"identifier": "(HtmlTreeBuilder) insertEmpty()", "line": "Element insertEmpty(Token.StartTag startTag) {"}}, {"InSelect": {"identifier": "(HtmlTreeBuilderState) InSelect", "line": "transition(HtmlTreeBuilderState.InSelect);"}}, {"TagSearchButton": {"identifier": "(String) TagSearchButton", "line": "return inScope(targetName, TagSearchButton);"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack."}}, {"getFormElement": {"identifier": "(HtmlTreeBuilder) getFormElement()", "line": "FormElement getFormElement() {"}}, {"getDocument": {"identifier": "(HtmlTreeBuilder) getDocument()", "line": "Document getDocument() {"}}, {"InCell": {"identifier": "(HtmlTreeBuilderState) InCell", "line": "transition(HtmlTreeBuilderState.InCell);"}}, {"ScriptData": {"identifier": "(TokeniserState) ScriptData", "line": "tokeniser.transition(TokeniserState.ScriptData);"}}, {"InTable": {"identifier": "(HtmlTreeBuilderState) InTable", "line": "transition(HtmlTreeBuilderState.InTable);"}}, {"absUrl": {"identifier": "(Node) absUrl()", "line": "String href = base.absUrl(\"href\");"}}, {"InCaption": {"identifier": "(HtmlTreeBuilderState) InCaption", "line": "transition(HtmlTreeBuilderState.InCaption);"}}, {"BeforeHead": {"identifier": "(HtmlTreeBuilderState) BeforeHead", "line": "transition(HtmlTreeBuilderState.BeforeHead);"}}, {"EndTag": {"identifier": "(EndTag) EndTag", "line": "private Token.EndTag emptyEnd = new Token.EndTag(); // reused empty end tag"}}, {"InTableBody": {"identifier": "(HtmlTreeBuilderState) InTableBody", "line": "transition(HtmlTreeBuilderState.InTableBody);"}}, {"getStack": {"identifier": "(HtmlTreeBuilder) getStack()", "line": "ArrayList<Element> getStack() {"}}, {"InRow": {"identifier": "(HtmlTreeBuilderState) InRow", "line": "transition(HtmlTreeBuilderState.InRow);"}}, {"childNodes": {"identifier": "(Node) childNodes()", "line": "return doc.childNodes();"}}, {"InBody": {"identifier": "(HtmlTreeBuilderState) InBody", "line": "transition(HtmlTreeBuilderState.InBody);"}}, {"canAddError": {"identifier": "(ParseErrorList) canAddError()", "line": "if (errors.canAddError())"}}, {"isTrue": {"identifier": "(Validate) isTrue()", "line": "Validate.isTrue(i != -1);"}}, {"toString": {"identifier": "(HtmlTreeBuilder) toString()", "line": "public String toString() {"}}, {"getBaseUri": {"identifier": "(HtmlTreeBuilder) getBaseUri()", "line": "String getBaseUri() {"}}, {"setSelfClosing": {"identifier": "(Tag) setSelfClosing()", "line": "tag.setSelfClosing();"}}, {"TagsScriptStyle": {"identifier": "(HtmlTreeBuilder) TagsScriptStyle", "line": "private static final String[] TagsScriptStyle = new String[]{\"script\", \"style\"};"}}, {"InColumnGroup": {"identifier": "(HtmlTreeBuilderState) InColumnGroup", "line": "transition(HtmlTreeBuilderState.InColumnGroup);"}}, {"runParser": {"identifier": "(TreeBuilder) runParser()", "line": "runParser();"}}]}}], "Jsoup-46": [{"context": {"prefix": "        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n", "suffix": "                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n", "buggy": "        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n", "fix": "        for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n            codePoint = string.codePointAt(offset);\n\n            if (normaliseWhite) {\n                if (StringUtil.isWhitespace(codePoint)) {\n                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n", "start": 90, "end": 144, "file": "main/java/org/jsoup/nodes/Entities.java"}, "tokens": {"original": [{"toString": {"identifier": "(StringBuilder) toString()", "line": "return accum.toString();"}}, {"escapeMode": {"identifier": "(OutputSettings) escapeMode()", "line": "final EscapeMode escapeMode = out.escapeMode();"}}, {"EscapeMode": {"identifier": "(EscapeMode) EscapeMode", "line": "final EscapeMode escapeMode = out.escapeMode();"}}, {"codePoint": {"identifier": "(int) codePoint", "line": "accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');"}}, {"fullByVal": {"identifier": "(Map) fullByVal", "line": "extended(fullByVal);"}}, {"getMap": {"identifier": "(EscapeMode) getMap()", "line": "final Map<Character, String> map = escapeMode.getMap();"}}, {"canEncode": {"identifier": "(Entities) canEncode()", "line": "if (canEncode(coreCharset, c, encoder))"}}, {"coreCharset": {"identifier": "(CoreCharset) coreCharset", "line": "if (canEncode(coreCharset, c, encoder))"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "import org.jsoup.helper.StringUtil;"}}, {"xhtmlByVal": {"identifier": "(Map) xhtmlByVal", "line": "xhtmlByVal = new HashMap<Character, String>();"}}, {"reachedNonWhite": {"identifier": "(boolean) reachedNonWhite", "line": "reachedNonWhite = true;"}}, {"baseByVal": {"identifier": "(Map) baseByVal", "line": "base(baseByVal),"}}, {"toCharacterKey": {"identifier": "(Entities) toCharacterKey()", "line": "baseByVal = toCharacterKey(base);"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "static String escape(String string, Document.OutputSettings out) {"}}, {"lastWasWhite": {"identifier": "(boolean) lastWasWhite", "line": "lastWasWhite = true;"}}, {"normaliseWhite": {"identifier": "(boolean) normaliseWhite", "line": "if (normaliseWhite) {"}}, {"isNamedEntity": {"identifier": "(Entities) isNamedEntity()", "line": "public static boolean isNamedEntity(String name) {"}}, {"isWhitespace": {"identifier": "(StringUtil) isWhitespace()", "line": "if (StringUtil.isWhitespace(codePoint)) {"}}, {"loadEntities": {"identifier": "(Entities) loadEntities()", "line": "private static Map<String, Character> loadEntities(String filename) {"}}, {"inAttribute": {"identifier": "(boolean) inAttribute", "line": "if (inAttribute)"}}, {"xhtmlArray": {"identifier": "(Entities) xhtmlArray", "line": "private static final Object[][] xhtmlArray = {"}}]}}], "Jsoup-47": [{"context": {"prefix": "                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n", "suffix": "                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n", "buggy": "                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n", "fix": "                    if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                        continue;\n                    accum.append(' ');\n                    lastWasWhite = true;\n                    continue;\n                } else {\n                    lastWasWhite = false;\n                    reachedNonWhite = true;\n                }\n            }\n            // surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\n            if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n                final char c = (char) codePoint;\n                // html specific and required escapes:\n                switch (c) {\n                    case '&':\n                        accum.append(\"&amp;\");\n                        break;\n                    case 0xA0:\n                        if (escapeMode != EscapeMode.xhtml)\n                            accum.append(\"&nbsp;\");\n                        else\n                            accum.append(\"&#xa0;\");\n                        break;\n                    case '<':\n                        // escape when in character data or when in a xml attribue val; not needed in html attr val\n                        if (!inAttribute || escapeMode == EscapeMode.xhtml)\n                            accum.append(\"&lt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '>':\n                        if (!inAttribute)\n                            accum.append(\"&gt;\");\n                        else\n                            accum.append(c);\n                        break;\n                    case '\"':\n                        if (inAttribute)\n                            accum.append(\"&quot;\");\n                        else\n                            accum.append(c);\n                        break;\n                    default:\n                        if (canEncode(coreCharset, c, encoder))\n                            accum.append(c);\n                        else if (map.containsKey(c))\n                            accum.append('&').append(map.get(c)).append(';');\n                        else\n                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n                }\n            } else {\n                final String c = new String(Character.toChars(codePoint));\n", "start": 95, "end": 147, "file": "main/java/org/jsoup/nodes/Entities.java"}, "tokens": {"original": [{"normaliseWhite": {"identifier": "(boolean) normaliseWhite", "line": "if (normaliseWhite) {"}}, {"codePoint": {"identifier": "(int) codePoint", "line": "if (StringUtil.isWhitespace(codePoint)) {"}}, {"isWhitespace": {"identifier": "(StringUtil) isWhitespace()", "line": "if (StringUtil.isWhitespace(codePoint)) {"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "if (StringUtil.isWhitespace(codePoint)) {"}}, {"lastWasWhite": {"identifier": "(boolean) lastWasWhite", "line": "lastWasWhite = true;"}}, {"canEncode": {"identifier": "(Entities) canEncode()", "line": "if (canEncode(coreCharset, c, encoder))"}}, {"coreCharset": {"identifier": "(CoreCharset) coreCharset", "line": "if (canEncode(coreCharset, c, encoder))"}}, {"reachedNonWhite": {"identifier": "(boolean) reachedNonWhite", "line": "if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)"}}, {"xhtmlArray": {"identifier": "(Object) xhtmlArray", "line": "for (Object[] entity : xhtmlArray) {"}}, {"isNamedEntity": {"identifier": "(Entities) isNamedEntity()", "line": "public static boolean isNamedEntity(String name) {"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return accum.toString();"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "static String escape(String string, Document.OutputSettings out) {"}}, {"baseByVal": {"identifier": "(Entities) baseByVal", "line": "private static final Map<Character, String> baseByVal;"}}, {"getMap": {"identifier": "(EscapeMode) getMap()", "line": "public Map<Character, String> getMap() {"}}, {"xhtmlByVal": {"identifier": "(Map) xhtmlByVal", "line": "xhtmlByVal.put(c, ((String) entity[0]));"}}, {"toCharacterKey": {"identifier": "(Entities) toCharacterKey()", "line": "baseByVal = toCharacterKey(base);"}}, {"fullByVal": {"identifier": "(Map) fullByVal", "line": "fullByVal = toCharacterKey(full);"}}, {"escapeMode": {"identifier": "(EscapeMode) escapeMode", "line": "if (escapeMode != EscapeMode.xhtml)"}}, {"EscapeMode": {"identifier": "(EscapeMode) EscapeMode", "line": "if (escapeMode != EscapeMode.xhtml)"}}, {"loadEntities": {"identifier": "(Entities) loadEntities()", "line": "full = loadEntities(\"entities-full.properties\"); // extended and overblown."}}]}}], "Jsoup-51": [{"context": {"prefix": "            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n", "suffix": "    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n", "buggy": "            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n", "fix": "            return false;\n\n        for (int offset = 0; offset < scanLength; offset++) {\n            char upScan = Character.toUpperCase(seq.charAt(offset));\n            char upTarget = Character.toUpperCase(input[pos + offset]);\n            if (upScan != upTarget)\n                return false;\n        }\n        return true;\n    }\n\n    boolean matchesAny(char... seq) {\n        if (isEmpty())\n            return false;\n\n        char c = input[pos];\n        for (char seek : seq) {\n            if (seek == c)\n                return true;\n        }\n        return false;\n    }\n\n    boolean matchesAnySorted(char[] seq) {\n        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n    }\n\n    boolean matchesLetter() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n    }\n\n    boolean matchesDigit() {\n        if (isEmpty())\n            return false;\n        char c = input[pos];\n        return (c >= '0' && c <= '9');\n    }\n\n    boolean matchConsume(String seq) {\n        if (matches(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean matchConsumeIgnoreCase(String seq) {\n        if (matchesIgnoreCase(seq)) {\n            pos += seq.length();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    boolean containsIgnoreCase(String seq) {\n        // used to check presence of </title>, </style>. only finds consistent case.\n        String loScan = seq.toLowerCase(Locale.ENGLISH);\n        String hiScan = seq.toUpperCase(Locale.ENGLISH);\n", "start": 268, "end": 330, "file": "main/java/org/jsoup/parser/CharacterReader.java"}, "tokens": {"original": [{"nullChar": {"identifier": "(char) nullChar", "line": "if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)"}}, {"TokeniserState": {"identifier": "(TokeniserState) TokeniserState", "line": "if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)"}}, {"nextIndexOf": {"identifier": "(CharacterReader) nextIndexOf()", "line": "return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);"}}, {"isEmpty": {"identifier": "(CharacterReader) isEmpty()", "line": "return !isEmpty() && input[pos] == c;"}}, {"cacheString": {"identifier": "(CharacterReader) cacheString()", "line": "return pos > start ? cacheString(start, pos-start) : \"\";"}}, {"consumeToEnd": {"identifier": "(CharacterReader) consumeToEnd()", "line": "return consumeToEnd();"}}, {"consumeTo": {"identifier": "(CharacterReader) consumeTo()", "line": "String consumeTo(char c) {"}}, {"maxCacheLen": {"identifier": "(CharacterReader) maxCacheLen", "line": "private static final int maxCacheLen = 12;"}}, {"stringCache": {"identifier": "(String) stringCache", "line": "final String[] cache = stringCache;"}}, {"rangeEquals": {"identifier": "(CharacterReader) rangeEquals()", "line": "boolean rangeEquals(final int start, int count, final String cached) {"}}, {"consumeToAny": {"identifier": "(CharacterReader) consumeToAny()", "line": "String consumeToAny(final char... chars) {"}}, {"CharacterReader": {"identifier": "(CharacterReader) CharacterReader", "line": "CharacterReader consumes tokens off a string. To replace the old TokenQueue."}}, {"matchesAny": {"identifier": "(CharacterReader) matchesAny()", "line": "boolean matchesAny(char... seq) {"}}, {"consumeAsString": {"identifier": "(CharacterReader) consumeAsString()", "line": "String consumeAsString() {"}}, {"consumeData": {"identifier": "(CharacterReader) consumeData()", "line": "String consumeData() {"}}, {"matchConsume": {"identifier": "(CharacterReader) matchConsume()", "line": "boolean matchConsume(String seq) {"}}, {"consumeTagName": {"identifier": "(CharacterReader) consumeTagName()", "line": "String consumeTagName() {"}}, {"toString": {"identifier": "(CharacterReader) toString()", "line": "public String toString() {"}}, {"rewindToMark": {"identifier": "(CharacterReader) rewindToMark()", "line": "void rewindToMark() {"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(input);"}}, {"matchesDigit": {"identifier": "(CharacterReader) matchesDigit()", "line": "boolean matchesDigit() {"}}, {"matchesLetter": {"identifier": "(CharacterReader) matchesLetter()", "line": "boolean matchesLetter() {"}}]}}], "Jsoup-54": [{"context": {"prefix": "                dest.appendChild(comment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                dest.appendChild(node);\n            } else {\n                // unhandled\n            }\n        }\n\n        public void tail(org.jsoup.nodes.Node source, int depth) {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = (Element) dest.getParentNode(); // undescend. cromulent.\n            }\n        }\n\n        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n", "suffix": "                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n\n        /**\n         * Finds any namespaces defined in this element. Returns any tag prefix.\n         */\n        private String updateNamespaces(org.jsoup.nodes.Element el) {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n", "buggy": "                dest.appendChild(comment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                dest.appendChild(node);\n            } else {\n                // unhandled\n            }\n        }\n\n        public void tail(org.jsoup.nodes.Node source, int depth) {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = (Element) dest.getParentNode(); // undescend. cromulent.\n            }\n        }\n\n        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n\n        /**\n         * Finds any namespaces defined in this element. Returns any tag prefix.\n         */\n        private String updateNamespaces(org.jsoup.nodes.Element el) {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n", "fix": "                dest.appendChild(comment);\n            } else if (source instanceof org.jsoup.nodes.DataNode) {\n                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n                Text node = doc.createTextNode(sourceData.getWholeData());\n                dest.appendChild(node);\n            } else {\n                // unhandled\n            }\n        }\n\n        public void tail(org.jsoup.nodes.Node source, int depth) {\n            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n                dest = (Element) dest.getParentNode(); // undescend. cromulent.\n            }\n        }\n\n        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n            for (Attribute attribute : source.attributes()) {\n                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n                if (key.matches(\"[azAZ_:]{1}[azAZ09_:.]*\"))\n                    el.setAttribute(key, attribute.getValue());\n            }\n        }\n\n        /**\n         * Finds any namespaces defined in this element. Returns any tag prefix.\n         */\n        private String updateNamespaces(org.jsoup.nodes.Element el) {\n            // scan the element for namespace declarations\n            // like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n            Attributes attributes = el.attributes();\n            for (Attribute attr : attributes) {\n                String key = attr.getKey();\n                String prefix;\n                if (key.equals(xmlnsKey)) {\n                    prefix = \"\";\n                } else if (key.startsWith(xmlnsPrefix)) {\n                    prefix = key.substring(xmlnsPrefix.length());\n                } else {\n                    continue;\n                }\n", "start": 105, "end": 145, "file": "main/java/org/jsoup/helper/W3CDom.java"}, "tokens": {}}], "Jsoup-55": [{"context": {"prefix": "                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n", "suffix": "                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n                // is implemented properly, keep handling as cdata\n", "buggy": "                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n                // is implemented properly, keep handling as cdata\n", "fix": "                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            // todo: handle bogus comment starting from eof. when does that trigger?\n            // rewind to capture character that lead us here\n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            // todo: replace nullChar with replaceChar\n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                // todo: should actually check current namepspace, and only non-html allows cdata. until namespace\n                // is implemented properly, keep handling as cdata\n", "start": 856, "end": 908, "file": "main/java/org/jsoup/parser/TokeniserState.java"}, "tokens": {}}], "Jsoup-57": [{"context": {"prefix": "     @param attribute attribute\n     */\n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n", "suffix": "        }\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n", "buggy": "     @param attribute attribute\n     */\n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                attributes.remove(attrKey);\n        }\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n", "fix": "     @param attribute attribute\n     */\n    public void put(Attribute attribute) {\n        Validate.notNull(attribute);\n        if (attributes == null)\n             attributes = new LinkedHashMap<String, Attribute>(2);\n        attributes.put(attribute.getKey(), attribute);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case sensitive.</b>\n     @param key attribute key to remove\n     */\n    public void remove(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        attributes.remove(key);\n    }\n\n    /**\n     Remove an attribute by key. <b>Case insensitive.</b>\n     @param key attribute key to remove\n     */\n    public void removeIgnoreCase(String key) {\n        Validate.notEmpty(key);\n        if (attributes == null)\n            return;\n        for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n            String attrKey = it.next();\n            if (attrKey.equalsIgnoreCase(key))\n                it.remove();\n        }\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key case-sensitive key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKey(String key) {\n        return attributes != null && attributes.containsKey(key);\n    }\n\n    /**\n     Tests if these attributes contain an attribute with this key.\n     @param key key to check for\n     @return true if key exists, false otherwise\n     */\n    public boolean hasKeyIgnoreCase(String key) {\n        if (attributes == null)\n            return false;\n        for (String attrKey : attributes.keySet()) {\n            if (attrKey.equalsIgnoreCase(key))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     Get the number of attributes in this set.\n     @return size\n     */\n", "start": 93, "end": 155, "file": "main/java/org/jsoup/nodes/Attributes.java"}, "tokens": {"original": [{"getKey": {"identifier": "(Attribute) getKey()", "line": "attributes.remove(attr.getKey());"}}, {"dataKey": {"identifier": "(String) dataKey", "line": "attributes.put(dataKey, attr);"}}, {"getValue": {"identifier": "(Attribute) getValue()", "line": "return attributes.get(attrKey).getValue();"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(attribute);"}}, {"notEmpty": {"identifier": "(Validate) notEmpty()", "line": "Validate.notEmpty(key);"}}, {"isDataAttribute": {"identifier": "(Attribute) isDataAttribute()", "line": "if (attr.isDataAttribute()) return true;"}}, {"hashCode": {"identifier": "(AbstractMap) hashCode()", "line": "return attributes != null ? attributes.hashCode() : 0;"}}, {"getIgnoreCase": {"identifier": "(Attributes) getIgnoreCase()", "line": "public String getIgnoreCase(String key) {"}}, {"hasKey": {"identifier": "(Attributes) hasKey()", "line": "String oldValue = hasKey(dataKey) ? attributes.get(dataKey).getValue() : null;"}}, {"asList": {"identifier": "(Attributes) asList()", "line": "public List<Attribute> asList() {"}}, {"entrySet": {"identifier": "(LinkedHashMap) entrySet()", "line": "for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {"}}, {"dataPrefix": {"identifier": "(String) dataPrefix", "line": "return new Attribute(attr.getKey().substring(dataPrefix.length()), attr.getValue());"}}, {"addAll": {"identifier": "(Attributes) addAll()", "line": "public void addAll(Attributes incoming) {"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "return accum.toString();"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "void html(Appendable accum, Document.OutputSettings out) throws IOException {"}}, {"outputSettings": {"identifier": "(Document) outputSettings()", "line": "html(accum, (new Document(\"\")).outputSettings()); // output settings a bit funky, but this html() seldom used"}}]}}], "Jsoup-61": [{"context": {"prefix": "    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }\n\n    /**\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     */\n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    /**\n     * Tests if this element has a class. Case insensitive.\n     * @param className name of class to check for\n     * @return true if it does, false if not\n     */\n    // performance sensitive\n    public boolean hasClass(String className) {\n", "suffix": "        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n", "buggy": "    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }\n\n    /**\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     */\n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    /**\n     * Tests if this element has a class. Case insensitive.\n     * @param className name of class to check for\n     * @return true if it does, false if not\n     */\n    // performance sensitive\n    public boolean hasClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n", "fix": "    \tString[] names = classSplit.split(className());\n    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n\n        return classNames;\n    }\n\n    /**\n     Set the element's {@code class} attribute to the supplied class names.\n     @param classNames set of classes\n     @return this element, for chaining\n     */\n    public Element classNames(Set<String> classNames) {\n        Validate.notNull(classNames);\n        attributes.put(\"class\", StringUtil.join(classNames, \" \"));\n        return this;\n    }\n\n    /**\n     * Tests if this element has a class. Case insensitive.\n     * @param className name of class to check for\n     * @return true if it does, false if not\n     */\n    // performance sensitive\n    public boolean hasClass(String className) {\n        final String classAttr = attributes.getIgnoreCase(\"class\");\n        final int len = classAttr.length();\n        final int wantLen = className.length();\n\n        if (len == 0 || len < wantLen) {\n            return false;\n        }\n\n        // if both lengths are equal, only need compare the className with the attribute\n        if (len == wantLen) {\n            return className.equalsIgnoreCase(classAttr);\n        }\n\n        // otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n        boolean inClass = false;\n        int start = 0;\n        for (int i = 0; i < len; i++) {\n            if (Character.isWhitespace(classAttr.charAt(i))) {\n                if (inClass) {\n                    // white space ends a class name, compare it with the requested one, ignore case\n                    if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n                        return true;\n                    }\n                    inClass = false;\n                }\n            } else {\n", "start": 1066, "end": 1116, "file": "main/java/org/jsoup/nodes/Element.java"}, "tokens": {"original": [{"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "String classes = StringUtil.join(classNames(), \".\");"}}, {"classNames": {"identifier": "(Element) classNames()", "line": "String classes = StringUtil.join(classNames(), \".\");"}}, {"classSplit": {"identifier": "(Element) classSplit", "line": "private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");"}}, {"getIgnoreCase": {"identifier": "(Attributes) getIgnoreCase()", "line": "return attributes.getIgnoreCase(\"id\");"}}, {"className": {"identifier": "(Element) className()", "line": "String[] names = classSplit.split(className());"}}, {"getWholeText": {"identifier": "(TextNode) getWholeText()", "line": "String text = textNode.getWholeText();"}}, {"baseUri": {"identifier": "(String) baseUri", "line": "this(tag, baseUri, new Attributes());"}}, {"asList": {"identifier": "(Arrays) asList()", "line": "Set<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));"}}, {"cssSelector": {"identifier": "(Element) cssSelector()", "line": "public String cssSelector() {"}}, {"tagName": {"identifier": "(String) tagName", "line": "StringBuilder selector = new StringBuilder(tagName);"}}, {"toString": {"identifier": "(Element) toString()", "line": "public String toString() {"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "this(Tag.valueOf(tag), \"\", new Attributes());"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(className);"}}, {"hasClass": {"identifier": "(Element) hasClass()", "line": "public boolean hasClass(String className) {"}}, {"addClass": {"identifier": "(Element) addClass()", "line": "public Element addClass(String className) {"}}, {"notEmpty": {"identifier": "(Validate) notEmpty()", "line": "Validate.notEmpty(className);"}}, {"toggleClass": {"identifier": "(Element) toggleClass()", "line": "public Element toggleClass(String className) {"}}, {"QueryParser": {"identifier": "(QueryParser) QueryParser", "line": "return is(QueryParser.parse(cssQuery));"}}, {"isWhitespace": {"identifier": "(Character) isWhitespace()", "line": "if (Character.isWhitespace(classAttr.charAt(i))) {"}}, {"childNodes": {"identifier": "(List) childNodes", "line": "List<Element> elements = new ArrayList<Element>(childNodes.size());"}}, {"ArrayList": {"identifier": "(ArrayList) ArrayList", "line": "List<Element> elements = new ArrayList<Element>(childNodes.size());"}}, {"removeClass": {"identifier": "(Element) removeClass()", "line": "public Element removeClass(String className) {"}}, {"getName": {"identifier": "(Tag) getName()", "line": "return tag.getName();"}}, {"indexInList": {"identifier": "(Element) indexInList()", "line": "Integer index = indexInList(this, siblings);"}}, {"TextNode": {"identifier": "(TextNode) TextNode", "line": "StringUtil.appendNormalisedWhitespace(accum, text, TextNode.lastCharIsWhitespace(accum));"}}, {"childNodeSize": {"identifier": "(Node) childNodeSize()", "line": "int currentSize = childNodeSize();"}}, {"parseFragment": {"identifier": "(Parser) parseFragment()", "line": "List<Node> nodes = Parser.parseFragment(html, this, baseUri());"}}, {"prettyPrint": {"identifier": "(OutputSettings) prettyPrint()", "line": "return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();"}}, {"ownText": {"identifier": "(Element) ownText()", "line": "public String ownText() {"}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "public String nodeName() {"}}, {"appendElement": {"identifier": "(Element) appendElement()", "line": "*  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}"}}, {"appendText": {"identifier": "(Element) appendText()", "line": "public Element appendText(String text) {"}}, {"prependElement": {"identifier": "(Element) prependElement()", "line": "*  {@code parent.prependElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}"}}, {"dataNodes": {"identifier": "(List) dataNodes", "line": "return Collections.unmodifiableList(dataNodes);"}}, {"preserveCase": {"identifier": "(ParseSettings) preserveCase", "line": "tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case"}}, {"ParseSettings": {"identifier": "(ParseSettings) ParseSettings", "line": "tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case"}}, {"isEmpty": {"identifier": "(Tag) isEmpty()", "line": "if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "if (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())"}}, {"childNode": {"identifier": "(Node) childNode", "line": "DataNode data = (DataNode) childNode;"}}, {"DataNode": {"identifier": "(DataNode) DataNode", "line": "DataNode data = (DataNode) childNode;"}}, {"getWholeData": {"identifier": "(DataNode) getWholeData()", "line": "sb.append(data.getWholeData());"}}, {"outerHtml": {"identifier": "(Node) outerHtml()", "line": "return outerHtml();"}}, {"isSelfClosing": {"identifier": "(Tag) isSelfClosing()", "line": "if (childNodes.isEmpty() && tag.isSelfClosing()) {"}}, {"hasText": {"identifier": "(Element) hasText()", "line": "public boolean hasText() {"}}, {"setSiblingIndex": {"identifier": "(Node) setSiblingIndex()", "line": "child.setSiblingIndex(childNodes.size() - 1);"}}, {"isBlock": {"identifier": "(Tag) isBlock()", "line": "return tag.isBlock();"}}, {"textNodes": {"identifier": "(Element) textNodes()", "line": "List<TextNode> textNodes = new ArrayList<TextNode>();"}}, {"parentNode": {"identifier": "(Node) parentNode", "line": "return (Element) parentNode;"}}, {"isTrue": {"identifier": "(Validate) isTrue()", "line": "Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");"}}, {"prependText": {"identifier": "(Element) prependText()", "line": "public Element prependText(String text) {"}}, {"addChildren": {"identifier": "(Node) addChildren()", "line": "addChildren(0, nodes.toArray(new Node[nodes.size()]));"}}, {"siblingElements": {"identifier": "(Element) siblingElements()", "line": "public Elements siblingElements() {"}}, {"insertChildren": {"identifier": "(Element) insertChildren()", "line": "public Element insertChildren(int index, Collection<? extends Node> children) {"}}, {"getAllElements": {"identifier": "(Element) getAllElements()", "line": "public Elements getAllElements() {"}}, {"prependChild": {"identifier": "(Element) prependChild()", "line": "public Element prependChild(Node child) {"}}, {"reparentChild": {"identifier": "(Node) reparentChild()", "line": "reparentChild(child);"}}, {"getData": {"identifier": "(Comment) getData()", "line": "sb.append(comment.getData());"}}, {"NodeTraversor": {"identifier": "(NodeTraversor) NodeTraversor", "line": "new NodeTraversor(new NodeVisitor() {"}}, {"formatAsBlock": {"identifier": "(Tag) formatAsBlock()", "line": "tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "public Element appendChild(Node child) {"}}, {"getElementById": {"identifier": "(Element) getElementById()", "line": "public Element getElementById(String id) {"}}, {"outerHtmlHead": {"identifier": "(Element) outerHtmlHead()", "line": "void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {"}}, {"outerHtmlTail": {"identifier": "(Element) outerHtmlTail()", "line": "void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {"}}, {"isBlank": {"identifier": "(TextNode) isBlank()", "line": "if (!textNode.isBlank())"}}]}}], "Jsoup-62": [{"context": {"prefix": "                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n", "suffix": "            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        // in script, style etc. normally treated as data tags\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                // if current node is script: already started\n", "buggy": "                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().normalName();\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        // in script, style etc. normally treated as data tags\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                // if current node is script: already started\n", "fix": "                                tb.error(this);\n                                return false;\n                            }\n                            tb.generateImpliedEndTags();\n                            if (!tb.currentElement().nodeName().equals(name))\n                                tb.error(this);\n                            tb.popStackToClose(name);\n                            tb.clearFormattingElementsToLastMarker();\n                        }\n                    } else if (name.equals(\"br\")) {\n                        tb.error(this);\n                        tb.processStartTag(\"br\");\n                        return false;\n                    } else {\n                        return anyOtherEndTag(t, tb);\n                    }\n\n                    break;\n                case EOF:\n                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n                    // stop parsing\n                    break;\n            }\n            return true;\n        }\n\n        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n            String name = t.asEndTag().name(); // matches with case sensitivity if enabled\n            ArrayList<Element> stack = tb.getStack();\n            for (int pos = stack.size() -1; pos >= 0; pos--) {\n                Element node = stack.get(pos);\n                if (node.nodeName().equals(name)) {\n                    tb.generateImpliedEndTags(name);\n                    if (!name.equals(tb.currentElement().nodeName()))\n                        tb.error(this);\n                    tb.popStackToClose(name);\n                    break;\n                } else {\n                    if (tb.isSpecial(node)) {\n                        tb.error(this);\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    Text {\n        // in script, style etc. normally treated as data tags\n        boolean process(Token t, HtmlTreeBuilder tb) {\n            if (t.isCharacter()) {\n                tb.insert(t.asCharacter());\n            } else if (t.isEOF()) {\n                tb.error(this);\n                // if current node is script: already started\n", "start": 736, "end": 790, "file": "main/java/org/jsoup/parser/HtmlTreeBuilderState.java"}, "tokens": {"original": [{"asStartTag": {"identifier": "(Token) asStartTag()", "line": "StringUtil.in(t.asStartTag().normalName(),"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "StringUtil.in(t.asStartTag().normalName(),"}}, {"inTableScope": {"identifier": "(HtmlTreeBuilder) inTableScope()", "line": "if (tb.inTableScope(t.asEndTag().normalName())) {"}}, {"isEndTag": {"identifier": "(Token) isEndTag()", "line": "t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))"}}, {"asCharacter": {"identifier": "(Token) asCharacter()", "line": "String data = t.asCharacter().getData();"}}, {"getData": {"identifier": "(Character) getData()", "line": "String data = t.asCharacter().getData();"}}, {"processEndTag": {"identifier": "(TreeBuilder) processEndTag()", "line": "tb.processEndTag(el.nodeName());"}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "tb.processEndTag(el.nodeName());"}}, {"isStartTag": {"identifier": "(Token) isStartTag()", "line": "t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),"}}, {"EndTag": {"identifier": "(EndTag) EndTag", "line": "Token.EndTag endTag = t.asEndTag();"}}, {"currentElement": {"identifier": "(TreeBuilder) currentElement()", "line": "if (!name.equals(tb.currentElement().nodeName()))"}}, {"StartTag": {"identifier": "(StartTag) StartTag", "line": "Token.StartTag start = t.asStartTag();"}}, {"getFormElement": {"identifier": "(HtmlTreeBuilder) getFormElement()", "line": "Element form = tb.getFormElement();"}}, {"hasKey": {"identifier": "(Attributes) hasKey()", "line": "String prompt = startTag.attributes.hasKey(\"prompt\") ?"}}, {"aboveOnStack": {"identifier": "(HtmlTreeBuilder) aboveOnStack()", "line": "node = tb.aboveOnStack(node);"}}, {"asComment": {"identifier": "(Token) asComment()", "line": "tb.insert(t.asComment());"}}, {"inScope": {"identifier": "(HtmlTreeBuilder) inScope()", "line": "} else if (!tb.inScope(formatEl.nodeName())) {"}}, {"inSorted": {"identifier": "(StringUtil) inSorted()", "line": "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {"}}, {"originalState": {"identifier": "(HtmlTreeBuilder) originalState()", "line": "tb.transition(tb.originalState());"}}, {"getHeadElement": {"identifier": "(HtmlTreeBuilder) getHeadElement()", "line": "Element head = tb.getHeadElement();"}}, {"popStackToClose": {"identifier": "(HtmlTreeBuilder) popStackToClose()", "line": "tb.popStackToClose(formatEl.nodeName());"}}, {"insertStartTag": {"identifier": "(HtmlTreeBuilder) insertStartTag()", "line": "tb.insertStartTag(\"html\");"}}, {"getStack": {"identifier": "(HtmlTreeBuilder) getStack()", "line": "Element html = tb.getStack().get(0);"}}, {"valueOf": {"identifier": "(String) valueOf()", "line": "private static String nullString = String.valueOf('\\u0000');"}}, {"processStartTag": {"identifier": "(TreeBuilder) processStartTag()", "line": "tb.processStartTag(\"form\");"}}, {"replaceOnStack": {"identifier": "(HtmlTreeBuilder) replaceOnStack()", "line": "tb.replaceOnStack(node, replacement);"}}, {"getFromStack": {"identifier": "(HtmlTreeBuilder) getFromStack()", "line": "Element remainingA = tb.getFromStack(\"a\");"}}, {"removeFromStack": {"identifier": "(HtmlTreeBuilder) removeFromStack()", "line": "tb.removeFromStack(formatEl);"}}, {"InTable": {"identifier": "(HtmlTreeBuilderState) InTable", "line": "return tb.process(t, InTable);"}}, {"addAll": {"identifier": "(Attributes) addAll()", "line": "adopter.attributes().addAll(formatEl.attributes());"}}, {"InSelectInTable": {"identifier": "(HtmlTreeBuilderState) InSelectInTable", "line": "tb.transition(InSelectInTable);"}}, {"insertForm": {"identifier": "(HtmlTreeBuilder) insertForm()", "line": "tb.insertForm(startTag, false);"}}, {"InFrameset": {"identifier": "(HtmlTreeBuilderState) InFrameset", "line": "tb.transition(InFrameset);"}}, {"framesetOk": {"identifier": "(HtmlTreeBuilder) framesetOk()", "line": "tb.framesetOk(false);"}}, {"isComment": {"identifier": "(Token) isComment()", "line": "} else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),"}}, {"isWhitespace": {"identifier": "(HtmlTreeBuilderState) isWhitespace()", "line": "} else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),"}}, {"insertEmpty": {"identifier": "(HtmlTreeBuilder) insertEmpty()", "line": "Element meta = tb.insertEmpty(start);"}}, {"asDoctype": {"identifier": "(Token) asDoctype()", "line": "Token.Doctype d = t.asDoctype();"}}, {"getBaseUri": {"identifier": "(HtmlTreeBuilder) getBaseUri()", "line": "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());"}}, {"onStack": {"identifier": "(HtmlTreeBuilder) onStack()", "line": "else if (!tb.onStack(formatEl)) {"}}, {"getAttributes": {"identifier": "(Tag) getAttributes()", "line": "for (Attribute attribute : startTag.getAttributes()) {"}}, {"isDoctype": {"identifier": "(Token) isDoctype()", "line": "} else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {"}}, {"setFormElement": {"identifier": "(HtmlTreeBuilder) setFormElement()", "line": "tb.setFormElement(null);"}}, {"toString": {"identifier": "(Object) toString()", "line": "tb.insert(new Token.Character().data(t.toString()));"}}, {"InSelect": {"identifier": "(HtmlTreeBuilderState) InSelect", "line": "return tb.process(t, InSelect);"}}, {"BeforeHtml": {"identifier": "(HtmlTreeBuilderState) BeforeHtml", "line": "tb.transition(BeforeHtml);"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "commonAncestor.appendChild(lastNode);"}}, {"getDocument": {"identifier": "(HtmlTreeBuilder) getDocument()", "line": "tb.getDocument().appendChild(doctype);"}}, {"InTableText": {"identifier": "(HtmlTreeBuilderState) InTableText", "line": "tb.transition(InTableText);"}}, {"InTableBody": {"identifier": "(HtmlTreeBuilderState) InTableBody", "line": "tb.transition(InTableBody);"}}, {"isCharacter": {"identifier": "(Token) isCharacter()", "line": "if (t.isCharacter()) {"}}, {"InBody": {"identifier": "(HtmlTreeBuilderState) InBody", "line": "processed = tb.process(t, InBody);"}}, {"isEOF": {"identifier": "(Token) isEOF()", "line": "} else if (t.isEOF()) {"}}, {"hasAttr": {"identifier": "(Node) hasAttr()", "line": "if (name.equals(\"base\") && el.hasAttr(\"href\"))"}}, {"InHead": {"identifier": "(HtmlTreeBuilderState) InHead", "line": "return tb.process(t, InHead);"}}, {"InColumnGroup": {"identifier": "(HtmlTreeBuilderState) InColumnGroup", "line": "tb.transition(InColumnGroup);"}}, {"AfterFrameset": {"identifier": "(HtmlTreeBuilderState) AfterFrameset", "line": "tb.transition(AfterFrameset);"}}, {"HtmlTreeBuilder": {"identifier": "(HtmlTreeBuilder) HtmlTreeBuilder", "line": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {"}}, {"setHeadElement": {"identifier": "(HtmlTreeBuilder) setHeadElement()", "line": "tb.setHeadElement(head);"}}, {"InHeadNoscript": {"identifier": "(HtmlTreeBuilderState) InHeadNoscript", "line": "tb.transition(InHeadNoscript);"}}, {"TokeniserState": {"identifier": "(TokeniserState) TokeniserState", "line": "tb.tokeniser.transition(TokeniserState.Rawtext);"}}, {"isSpecial": {"identifier": "(HtmlTreeBuilder) isSpecial()", "line": "if (tb.isSpecial(node)) {"}}, {"BeforeHead": {"identifier": "(HtmlTreeBuilderState) BeforeHead", "line": "tb.transition(BeforeHead);"}}, {"getKey": {"identifier": "(Attribute) getKey()", "line": "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))"}}, {"ScriptData": {"identifier": "(TokeniserState) ScriptData", "line": "tb.tokeniser.transition(TokeniserState.ScriptData);"}}, {"InRow": {"identifier": "(HtmlTreeBuilderState) InRow", "line": "tb.transition(InRow);"}}, {"TreeBuilder": {"identifier": "(TreeBuilder) TreeBuilder", "line": "private boolean handleMissingTr(Token t, TreeBuilder tb) {"}}, {"InCell": {"identifier": "(HtmlTreeBuilderState) InCell", "line": "tb.transition(InCell);"}}, {"preserveCase": {"identifier": "(ParseSettings) preserveCase", "line": "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());"}}, {"ParseSettings": {"identifier": "(ParseSettings) ParseSettings", "line": "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());"}}, {"maybeSetBaseUri": {"identifier": "(HtmlTreeBuilder) maybeSetBaseUri()", "line": "tb.maybeSetBaseUri(el);"}}, {"inButtonScope": {"identifier": "(HtmlTreeBuilder) inButtonScope()", "line": "if (!tb.inButtonScope(name)) {"}}, {"inSelectScope": {"identifier": "(HtmlTreeBuilder) inSelectScope()", "line": "if (!tb.inSelectScope(name)) {"}}, {"AfterHead": {"identifier": "(HtmlTreeBuilderState) AfterHead", "line": "tb.transition(AfterHead);"}}, {"InCaption": {"identifier": "(HtmlTreeBuilderState) InCaption", "line": "tb.transition(InCaption);"}}, {"inListItemScope": {"identifier": "(HtmlTreeBuilder) inListItemScope()", "line": "if (!tb.inListItemScope(name)) {"}}, {"childNodes": {"identifier": "(Node) childNodes()", "line": "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);"}}, {"childNodeSize": {"identifier": "(Node) childNodeSize()", "line": "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);"}}, {"quirksMode": {"identifier": "(Document) quirksMode()", "line": "tb.getDocument().quirksMode(Document.QuirksMode.quirks);"}}, {"isForceQuirks": {"identifier": "(Doctype) isForceQuirks()", "line": "if (d.isForceQuirks())"}}, {"AfterAfterBody": {"identifier": "(HtmlTreeBuilderState) AfterAfterBody", "line": "tb.transition(AfterAfterBody);"}}, {"normalizeTag": {"identifier": "(ParseSettings) normalizeTag()", "line": "tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());"}}, {"getPubSysKey": {"identifier": "(Doctype) getPubSysKey()", "line": "tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());"}}, {"getName": {"identifier": "(Doctype) getName()", "line": "tb.settings.normalizeTag(d.getName()), d.getPubSysKey(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());"}}, {"AfterBody": {"identifier": "(HtmlTreeBuilderState) AfterBody", "line": "tb.transition(AfterBody);"}}, {"DocumentType": {"identifier": "(DocumentType) DocumentType", "line": "DocumentType doctype = new DocumentType("}}, {"childNode": {"identifier": "(Node) childNode", "line": "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod."}}, {"ForeignContent": {"identifier": "(HtmlTreeBuilderState) ForeignContent", "line": "ForeignContent {"}}]}}], "Jsoup-76": [{"context": {"prefix": "                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n", "suffix": "                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n", "buggy": "                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n", "fix": "                                second.remove();\n                            // pop up to html element\n                            while (stack.size() > 1)\n                                stack.remove(stack.size()-1);\n                            tb.insert(startTag);\n                            tb.transition(InFrameset);\n                        }\n                    } else if (StringUtil.inSorted(name, Constants.Headings)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n                            tb.error(this);\n                            tb.pop();\n                        }\n                        tb.insert(startTag);\n                    } else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insert(startTag);\n                        tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n                        tb.framesetOk(false);\n                    } else if (name.equals(\"form\")) {\n                        if (tb.getFormElement() != null) {\n                            tb.error(this);\n                            return false;\n                        }\n                        if (tb.inButtonScope(\"p\")) {\n                            tb.processEndTag(\"p\");\n                        }\n                        tb.insertForm(startTag, true);\n                    } else if (StringUtil.inSorted(name, Constants.DdDt)) {\n                        tb.framesetOk(false);\n                        ArrayList<Element> stack = tb.getStack();\n                        for (int i = stack.size() - 1; i > 0; i--) {\n                            Element el = stack.get(i);\n                            if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n                                tb.processEndTag(el.nodeName());\n                                break;\n                            }\n                            if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                break;\n                        }\n", "start": 360, "end": 402, "file": "main/java/org/jsoup/parser/HtmlTreeBuilderState.java"}, "tokens": {}}], "Jsoup-77": [{"context": {"prefix": "                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n", "suffix": "        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n", "buggy": "                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.name();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n", "fix": "                insert.attributes().addAll(el.attributes());\n            }\n        }\n        insertNode(insert);\n    }\n\n    void insert(Token.Character token) {\n        final String data = token.getData();\n        insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n    }\n\n    void insert(Token.Doctype d) {\n        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\n        doctypeNode.setPubSysKey(d.getPubSysKey());\n        insertNode(doctypeNode);\n    }\n\n    /**\n     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n     * found, skips.\n     *\n     * @param endTag tag to close\n     */\n    private void popStackToClose(Token.EndTag endTag) {\n        String elName = endTag.normalName();\n        Element firstFound = null;\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            if (next.nodeName().equals(elName)) {\n                firstFound = next;\n                break;\n            }\n        }\n        if (firstFound == null)\n            return; // not found, skip\n\n        for (int pos = stack.size() -1; pos >= 0; pos--) {\n            Element next = stack.get(pos);\n            stack.remove(pos);\n            if (next == firstFound)\n                break;\n        }\n    }\n\n    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n        runParser();\n        return doc.childNodes();\n", "start": 92, "end": 140, "file": "main/java/org/jsoup/parser/XmlTreeBuilder.java"}, "tokens": {"original": [{"getData": {"identifier": "(Comment) getData()", "line": "String data = comment.getData();"}}, {"valueOf": {"identifier": "(Tag) valueOf()", "line": "Tag tag = Tag.valueOf(startTag.name(), settings);"}}, {"asComment": {"identifier": "(Token) asComment()", "line": "insert(token.asComment());"}}, {"defaultSettings": {"identifier": "(XmlTreeBuilder) defaultSettings()", "line": "ParseSettings defaultSettings() {"}}, {"ParseSettings": {"identifier": "(ParseSettings) ParseSettings", "line": "ParseSettings defaultSettings() {"}}, {"childNodes": {"identifier": "(Node) childNodes()", "line": "return doc.childNodes();"}}, {"preserveCase": {"identifier": "(ParseSettings) preserveCase", "line": "return ParseSettings.preserveCase;"}}, {"popStackToClose": {"identifier": "(XmlTreeBuilder) popStackToClose()", "line": "popStackToClose(token.asEndTag());"}}, {"asEndTag": {"identifier": "(Token) asEndTag()", "line": "popStackToClose(token.asEndTag());"}}, {"insertNode": {"identifier": "(XmlTreeBuilder) insertNode()", "line": "insertNode(el);"}}, {"asDoctype": {"identifier": "(Token) asDoctype()", "line": "insert(token.asDoctype());"}}, {"nodeName": {"identifier": "(Element) nodeName()", "line": "if (next.nodeName().equals(elName)) {"}}, {"asStartTag": {"identifier": "(Token) asStartTag()", "line": "insert(token.asStartTag());"}}, {"EndTag": {"identifier": "(TokenType) EndTag", "line": "case EndTag:"}}, {"asCharacter": {"identifier": "(Token) asCharacter()", "line": "insert(token.asCharacter());"}}, {"currentElement": {"identifier": "(TreeBuilder) currentElement()", "line": "currentElement().appendChild(node);"}}, {"appendChild": {"identifier": "(Element) appendChild()", "line": "currentElement().appendChild(node);"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);"}}, {"outputSettings": {"identifier": "(Document) outputSettings()", "line": "doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);"}}, {"setSelfClosing": {"identifier": "(Tag) setSelfClosing()", "line": "tag.setSelfClosing();"}}, {"runParser": {"identifier": "(TreeBuilder) runParser()", "line": "runParser();"}}, {"isSelfClosing": {"identifier": "(Tag) isSelfClosing()", "line": "if (startTag.isSelfClosing()) {"}}, {"initialiseParse": {"identifier": "(TreeBuilder) initialiseParse()", "line": "super.initialiseParse(input, baseUri, errors, settings);"}}, {"baseUri": {"identifier": "(String) baseUri", "line": "super.initialiseParse(input, baseUri, errors, settings);"}}, {"normalizeTag": {"identifier": "(ParseSettings) normalizeTag()", "line": "insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));"}}, {"tagName": {"identifier": "(Element) tagName()", "line": "insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));"}}, {"addAll": {"identifier": "(Attributes) addAll()", "line": "insert.attributes().addAll(el.attributes());"}}, {"noTracking": {"identifier": "(ParseErrorList) noTracking()", "line": "return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);"}}, {"ParseErrorList": {"identifier": "(ParseErrorList) ParseErrorList", "line": "return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);"}}, {"StartTag": {"identifier": "(StartTag) StartTag", "line": "Element insert(Token.StartTag startTag) {"}}, {"XmlTreeBuilder": {"identifier": "(XmlTreeBuilder) XmlTreeBuilder", "line": "public class XmlTreeBuilder extends TreeBuilder {"}}, {"TreeBuilder": {"identifier": "(TreeBuilder) TreeBuilder", "line": "public class XmlTreeBuilder extends TreeBuilder {"}}, {"setPubSysKey": {"identifier": "(DocumentType) setPubSysKey()", "line": "doctypeNode.setPubSysKey(d.getPubSysKey());"}}, {"getPubSysKey": {"identifier": "(Doctype) getPubSysKey()", "line": "doctypeNode.setPubSysKey(d.getPubSysKey());"}}, {"isCData": {"identifier": "(Token) isCData()", "line": "insertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));"}}, {"xmlParser": {"identifier": "(Parser) xmlParser()", "line": "Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());"}}, {"isKnownTag": {"identifier": "(Tag) isKnownTag()", "line": "if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above."}}, {"DocumentType": {"identifier": "(DocumentType) DocumentType", "line": "DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());"}}, {"getName": {"identifier": "(Doctype) getName()", "line": "DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());"}}, {"parseFragment": {"identifier": "(XmlTreeBuilder) parseFragment()", "line": "List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {"}}]}}], "Jsoup-86": [{"context": {"prefix": "     */\n    public Comment(String data, String baseUri) {\n        this(data);\n    }\n\n    public String nodeName() {\n        return \"#comment\";\n    }\n\n    /**\n     Get the contents of the comment.\n     @return comment content\n     */\n    public String getData() {\n        return coreValue();\n    }\n\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint())\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     */\n    public boolean isXmlDeclaration() {\n        String data = getData();\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }\n\n    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n", "suffix": "            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n}\n", "buggy": "     */\n    public Comment(String data, String baseUri) {\n        this(data);\n    }\n\n    public String nodeName() {\n        return \"#comment\";\n    }\n\n    /**\n     Get the contents of the comment.\n     @return comment content\n     */\n    public String getData() {\n        return coreValue();\n    }\n\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint())\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     */\n    public boolean isXmlDeclaration() {\n        String data = getData();\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }\n\n    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.childNodeSize() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n}\n", "fix": "     */\n    public Comment(String data, String baseUri) {\n        this(data);\n    }\n\n    public String nodeName() {\n        return \"#comment\";\n    }\n\n    /**\n     Get the contents of the comment.\n     @return comment content\n     */\n    public String getData() {\n        return coreValue();\n    }\n\n\tvoid outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n        if (out.prettyPrint())\n            indent(accum, depth, out);\n        accum\n                .append(\"<!--\")\n                .append(getData())\n                .append(\"-->\");\n    }\n\n\tvoid outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}\n\n    @Override\n    public String toString() {\n        return outerHtml();\n    }\n\n    /**\n     * Check if this comment looks like an XML Declaration.\n     * @return true if it looks like, maybe, it's an XML Declaration.\n     */\n    public boolean isXmlDeclaration() {\n        String data = getData();\n        return (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\")));\n    }\n\n    /**\n     * Attempt to cast this comment to an XML Declaration note.\n     * @return an XML declaration if it could be parsed as one, null otherwise.\n     */\n    public XmlDeclaration asXmlDeclaration() {\n        String data = getData();\n        Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n        XmlDeclaration decl = null;\n        if (doc.children().size() > 0) {\n            Element el = doc.child(0);\n            decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n            decl.attributes().addAll(el.attributes());\n        }\n        return decl;\n    }\n}\n", "start": 27, "end": 127, "file": "main/java/org/jsoup/nodes/Comment.java"}, "tokens": {"original": [{"prettyPrint": {"identifier": "(OutputSettings) prettyPrint()", "line": "if (out.prettyPrint())"}}, {"nodeName": {"identifier": "(Comment) nodeName()", "line": "public String nodeName() {"}}, {"toString": {"identifier": "(Comment) toString()", "line": "public String toString() {"}}, {"addAll": {"identifier": "(Attributes) addAll()", "line": "decl.attributes().addAll(el.attributes());"}}, {"getData": {"identifier": "(Comment) getData()", "line": "public String getData() {"}}, {"LeafNode": {"identifier": "(LeafNode) LeafNode", "line": "public class Comment extends LeafNode {"}}, {"XmlDeclaration": {"identifier": "(XmlDeclaration) XmlDeclaration", "line": "public XmlDeclaration asXmlDeclaration() {"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}"}}, {"outerHtmlTail": {"identifier": "(Comment) outerHtmlTail()", "line": "void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {}"}}, {"coreValue": {"identifier": "(LeafNode) coreValue()", "line": "return coreValue();"}}, {"outerHtmlHead": {"identifier": "(Comment) outerHtmlHead()", "line": "void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {"}}, {"COMMENT_KEY": {"identifier": "(Comment) COMMENT_KEY", "line": "private static final String COMMENT_KEY = \"comment\";"}}, {"xmlParser": {"identifier": "(Parser) xmlParser()", "line": "Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());"}}, {"baseUri": {"identifier": "(LeafNode) baseUri()", "line": "Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());"}}, {"normalizeTag": {"identifier": "(ParseSettings) normalizeTag()", "line": "decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));"}}, {"NodeUtils": {"identifier": "(NodeUtils) NodeUtils", "line": "decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));"}}, {"tagName": {"identifier": "(Element) tagName()", "line": "decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));"}}, {"outerHtml": {"identifier": "(Node) outerHtml()", "line": "return outerHtml();"}}]}}], "Jsoup-88": [{"context": {"prefix": "        this.parent = parent;\n    }\n\n    /**\n     Get the attribute key.\n     @return the attribute key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n\n    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n", "suffix": "    }\n\n    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return oldVal;\n    }\n\n    /**\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n", "buggy": "        this.parent = parent;\n    }\n\n    /**\n     Get the attribute key.\n     @return the attribute key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n\n    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n        return val;\n    }\n\n    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return oldVal;\n    }\n\n    /**\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n", "fix": "        this.parent = parent;\n    }\n\n    /**\n     Get the attribute key.\n     @return the attribute key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     Set the attribute key; case is preserved.\n     @param key the new key; must not be null\n     */\n    public void setKey(String key) {\n        Validate.notNull(key);\n        key = key.trim();\n        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.keys[i] = key;\n        }\n        this.key = key;\n    }\n\n    /**\n     Get the attribute value.\n     @return the attribute value\n     */\n    public String getValue() {\n        return Attributes.checkNotNull(val);\n    }\n\n    /**\n     Set the attribute value.\n     @param val the new attribute value; must not be null\n     */\n    public String setValue(String val) {\n        String oldVal = parent.get(this.key);\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return oldVal;\n    }\n\n    /**\n     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n     @return HTML\n     */\n    public String html() {\n        StringBuilder sb = StringUtil.borrowBuilder();\n        \n        try {\n        \thtml(sb, (new Document(\"\")).outputSettings());\n        } catch(IOException exception) {\n        \tthrow new SerializationException(exception);\n        }\n        return StringUtil.releaseBuilder(sb);\n    }\n\n", "start": 47, "end": 111, "file": "main/java/org/jsoup/nodes/Attribute.java"}, "tokens": {"original": [{"isDataAttribute": {"identifier": "(Attribute) isDataAttribute()", "line": "return isDataAttribute(key);"}}, {"setValue": {"identifier": "(Attribute) setValue()", "line": "public String setValue(String val) {"}}, {"releaseBuilder": {"identifier": "(StringUtil) releaseBuilder()", "line": "return StringUtil.releaseBuilder(sb);"}}, {"StringUtil": {"identifier": "(StringUtil) StringUtil", "line": "return StringUtil.releaseBuilder(sb);"}}, {"getValue": {"identifier": "(Attribute) getValue()", "line": "public String getValue() {"}}, {"notNull": {"identifier": "(Validate) notNull()", "line": "Validate.notNull(key);"}}, {"hashCode": {"identifier": "(String) hashCode()", "line": "result = 31 * result + (val != null ? val.hashCode() : 0);"}}, {"toString": {"identifier": "(Attribute) toString()", "line": "public String toString() {"}}, {"NotFound": {"identifier": "(int) NotFound", "line": "if (i != Attributes.NotFound)"}}, {"borrowBuilder": {"identifier": "(StringUtil) borrowBuilder()", "line": "StringBuilder sb = StringUtil.borrowBuilder();"}}, {"setKey": {"identifier": "(Attribute) setKey()", "line": "public void setKey(String key) {"}}, {"getKey": {"identifier": "(Attribute) getKey()", "line": "public String getKey() {"}}, {"indexOfKey": {"identifier": "(Attributes) indexOfKey()", "line": "int i = parent.indexOfKey(this.key);"}}, {"checkNotNull": {"identifier": "(Attributes) checkNotNull()", "line": "Entities.escape(accum, Attributes.checkNotNull(val) , out, true, false, false);"}}, {"dataPrefix": {"identifier": "(String) dataPrefix", "line": "return key.startsWith(Attributes.dataPrefix) && key.length() > Attributes.dataPrefix.length();"}}, {"OutputSettings": {"identifier": "(OutputSettings) OutputSettings", "line": "out.syntax() == Document.OutputSettings.Syntax.html &&"}}, {"outputSettings": {"identifier": "(Document) outputSettings()", "line": "html(sb, (new Document(\"\")).outputSettings());"}}, {"notEmpty": {"identifier": "(Validate) notEmpty()", "line": "Validate.notEmpty(key); // trimming could potentially make empty, so validate here"}}]}}], "Jsoup-93": [{"context": {"prefix": "                .data(formData())\n                .method(method);\n    }\n\n    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n", "suffix": "\n            if (\"select\".equals(el.normalName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n", "buggy": "                .data(formData())\n                .method(method);\n    }\n\n    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n\n            if (\"select\".equals(el.normalName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n", "fix": "                .data(formData())\n                .method(method);\n    }\n\n    /**\n     * Get the data that this form submits. The returned list is a copy of the data, and changes to the contents of the\n     * list will not be reflected in the DOM.\n     * @return a list of key vals\n     */\n    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n            String name = el.attr(\"name\");\n            if (name.length() == 0) continue;\n            String type = el.attr(\"type\");\n\n            if (type.equalsIgnoreCase(\"button\")) continue; // browsers don't submit these\n\n            if (\"select\".equals(el.normalName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n", "start": 68, "end": 108, "file": "main/java/org/jsoup/nodes/FormElement.java"}, "tokens": {}}], "Collections-26": [{"context": {"prefix": "     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n", "suffix": "        calculateHashCode(keys);\n        return this;\n    }\n}\n", "buggy": "     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    private Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n}\n", "fix": "     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object other) {\n        if (other == this) {\n            return true;\n        }\n        if (other instanceof MultiKey) {\n            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n            return Arrays.equals(keys, otherMulti.keys);\n        }\n        return false;\n    }\n\n    /**\n     * Gets the combined hash code that is computed from all the keys.\n     * <p>\n     * This value is computed once and then cached, so elements should not\n     * change their hash codes once created (note that this is the same\n     * constraint that would be used if the individual keys elements were\n     * themselves {@link java.util.Map Map} keys.\n     *\n     * @return the hash code\n     */\n    @Override\n    public int hashCode() {\n        return hashCode;\n    }\n\n    /**\n     * Gets a debugging string version of the key.\n     *\n     * @return a debugging string\n     */\n    @Override\n    public String toString() {\n        return \"MultiKey\" + Arrays.toString(keys);\n    }\n\n    /**\n     * Calculate the hash code of the instance using the provided keys.\n     * @param keys the keys to calculate the hash code for\n     */\n    private void calculateHashCode(final Object[] keys)\n    {\n        int total = 0;\n        for (final Object key : keys) {\n            if (key != null) {\n                total ^= key.hashCode();\n            }\n        }\n        hashCode = total;\n    }\n\n    /**\n     * Recalculate the hash code after deserialization. The hash code of some\n     * keys might have change (hash codes based on the system hash code are\n     * only stable for the same process).\n     * @return the instance with recalculated hash code\n     */\n    protected Object readResolve() {\n        calculateHashCode(keys);\n        return this;\n    }\n}\n", "start": 216, "end": 336, "file": "main/java/org/apache/commons/collections4/keyvalue/MultiKey.java"}, "tokens": {"original": [{"hashCode": {"identifier": "(MultiKey) hashCode()", "line": "private transient int hashCode;"}}, {"getKeys": {"identifier": "(MultiKey) getKeys()", "line": "public K[] getKeys() {"}}, {"MultiKey": {"identifier": "(MultiKey) MultiKey", "line": "if (other instanceof MultiKey) {"}}, {"getKey": {"identifier": "(MultiKey) getKey()", "line": "public K getKey(final int index) {"}}, {"toString": {"identifier": "(MultiKey) toString()", "line": "public String toString() {"}}]}}], "Compress-1": [{"context": {"prefix": "    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.cpioEntry != null) {\n            closeArchiveEntry();\n        }\n        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n        this.cpioEntry.setMode(0);\n        this.cpioEntry.setName(\"TRAILER!!!\");\n        this.cpioEntry.setNumberOfLinks(1);\n        writeHeader(this.cpioEntry);\n        closeArchiveEntry();\n    }\n\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException {\n        if (!this.closed) {\n", "suffix": "            super.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(final long count, final int border) throws IOException {\n        long skip = count % border;\n        if (skip > 0) {\n            byte tmp[] = new byte[(int) (border - skip)];\n            out.write(tmp);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n", "buggy": "    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.cpioEntry != null) {\n            closeArchiveEntry();\n        }\n        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n        this.cpioEntry.setMode(0);\n        this.cpioEntry.setName(\"TRAILER!!!\");\n        this.cpioEntry.setNumberOfLinks(1);\n        writeHeader(this.cpioEntry);\n        closeArchiveEntry();\n    }\n\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException {\n        if (!this.closed) {\n            super.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(final long count, final int border) throws IOException {\n        long skip = count % border;\n        if (skip > 0) {\n            byte tmp[] = new byte[(int) (border - skip)];\n            out.write(tmp);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n", "fix": "    public void finish() throws IOException {\n        ensureOpen();\n\n        if (this.finished) {\n            return;\n        }\n        if (this.cpioEntry != null) {\n            closeArchiveEntry();\n        }\n        this.cpioEntry = new CpioArchiveEntry(this.entryFormat);\n        this.cpioEntry.setMode(0);\n        this.cpioEntry.setName(\"TRAILER!!!\");\n        this.cpioEntry.setNumberOfLinks(1);\n        writeHeader(this.cpioEntry);\n        closeArchiveEntry();\n    }\n\n    /**\n     * Closes the CPIO output stream as well as the stream being filtered.\n     * \n     * @throws IOException\n     *             if an I/O error has occurred or if a CPIO file error has\n     *             occurred\n     */\n    public void close() throws IOException {\n        if (!this.closed) {\n            this.finish();\n            super.close();\n            this.closed = true;\n        }\n    }\n\n    private void pad(final long count, final int border) throws IOException {\n        long skip = count % border;\n        if (skip > 0) {\n            byte tmp[] = new byte[(int) (border - skip)];\n            out.write(tmp);\n        }\n    }\n\n    private void writeBinaryLong(final long number, final int length,\n            final boolean swapHalfWord) throws IOException {\n        byte tmp[] = CpioUtil.long2byteArray(number, length, swapHalfWord);\n        out.write(tmp);\n    }\n\n    private void writeAsciiLong(final long number, final int length,\n            final int radix) throws IOException {\n        StringBuffer tmp = new StringBuffer();\n        String tmpStr;\n        if (radix == 16) {\n            tmp.append(Long.toHexString(number));\n        } else if (radix == 8) {\n            tmp.append(Long.toOctalString(number));\n", "start": 319, "end": 371, "file": "main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java"}, "tokens": {}}], "Compress-19": [{"context": {"prefix": "            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n", "suffix": "                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n", "buggy": "            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length != expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n", "fix": "            diskStart = new ZipLong(buffer, offset + length - WORD);\n        }\n    }\n\n    /**\n     * Parses the raw bytes read from the central directory extra\n     * field with knowledge which fields are expected to be there.\n     *\n     * <p>All four fields inside the zip64 extended information extra\n     * field are optional and must only be present if their corresponding\n     * entry inside the central directory contains the correct magic\n     * value.</p>\n     */\n    public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                            boolean hasCompressedSize,\n                                            boolean hasRelativeHeaderOffset,\n                                            boolean hasDiskStart)\n        throws ZipException {\n        if (rawCentralDirectoryData != null) {\n            int expectedLength = (hasUncompressedSize ? DWORD : 0)\n                + (hasCompressedSize ? DWORD : 0)\n                + (hasRelativeHeaderOffset ? DWORD : 0)\n                + (hasDiskStart ? WORD : 0);\n            if (rawCentralDirectoryData.length < expectedLength) {\n                throw new ZipException(\"central directory zip64 extended\"\n                                       + \" information extra field's length\"\n                                       + \" doesn't match central directory\"\n                                       + \" data.  Expected length \"\n                                       + expectedLength + \" but is \"\n                                       + rawCentralDirectoryData.length);\n            }\n            int offset = 0;\n            if (hasUncompressedSize) {\n                size = new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasCompressedSize) {\n                compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,\n                                                         offset);\n                offset += DWORD;\n            }\n            if (hasRelativeHeaderOffset) {\n                relativeHeaderOffset =\n                    new ZipEightByteInteger(rawCentralDirectoryData, offset);\n                offset += DWORD;\n            }\n            if (hasDiskStart) {\n", "start": 235, "end": 281, "file": "main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java"}, "tokens": {"original": [{"ZipShort": {"identifier": "(ZipShort) ZipShort", "line": "public ZipShort getCentralDirectoryLength() {"}}, {"diskStart": {"identifier": "(ZipLong) diskStart", "line": "diskStart = new ZipLong(rawCentralDirectoryData, offset);"}}, {"ZipLong": {"identifier": "(ZipLong) ZipLong", "line": "diskStart = new ZipLong(rawCentralDirectoryData, offset);"}}, {"getValue": {"identifier": "(ZipShort) getValue()", "line": "byte[] data = new byte[getCentralDirectoryLength().getValue()];"}}, {"compressedSize": {"identifier": "(ZipEightByteInteger) compressedSize", "line": "compressedSize = new ZipEightByteInteger(rawCentralDirectoryData,"}}, {"addSizes": {"identifier": "(Zip64ExtendedInformationExtraField) addSizes()", "line": "private int addSizes(byte[] data) {"}}, {"setSize": {"identifier": "(Zip64ExtendedInformationExtraField) setSize()", "line": "public void setSize(ZipEightByteInteger size) {"}}, {"hasDiskStart": {"identifier": "(boolean) hasDiskStart", "line": "if (hasDiskStart) {"}}, {"getHeaderId": {"identifier": "(Zip64ExtendedInformationExtraField) getHeaderId()", "line": "public ZipShort getHeaderId() {"}}, {"getSize": {"identifier": "(Zip64ExtendedInformationExtraField) getSize()", "line": "public ZipEightByteInteger getSize() {"}}, {"HEADER_ID": {"identifier": "(Zip64ExtendedInformationExtraField) HEADER_ID", "line": "static final ZipShort HEADER_ID = new ZipShort(0x0001);"}}, {"getBytes": {"identifier": "(ZipLong) getBytes()", "line": "System.arraycopy(diskStart.getBytes(), 0, data, off, WORD);"}}]}}], "Compress-23": [{"context": {"prefix": "                byte[] password) throws IOException;\n        OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n", "suffix": "            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorInputStream(in);\n", "buggy": "                byte[] password) throws IOException;\n        OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] << (8 * i));\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorInputStream(in);\n", "fix": "                byte[] password) throws IOException;\n        OutputStream encode(final OutputStream out, final byte[] password)\n            throws IOException {\n            throw new UnsupportedOperationException(\"method doesn't support writing\");\n        }\n    }\n    \n    static class CopyDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            return in; \n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return out;\n        }\n    }\n\n    static class LZMADecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder,\n                byte[] password) throws IOException {\n            byte propsByte = coder.properties[0];\n            long dictSize = coder.properties[1];\n            for (int i = 1; i < 4; i++) {\n                dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i);\n            }\n            if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                throw new IOException(\"Dictionary larger than 4GiB maximum size\");\n            }\n            return new LZMAInputStream(in, -1, propsByte, (int) dictSize);\n        }\n    }\n    \n    static class DeflateDecoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n            throws IOException {\n            return new InflaterInputStream(new DummyByteAddingInputStream(in),\n                                           new Inflater(true));\n        }\n        @Override\n        OutputStream encode(final OutputStream out, final byte[] password) {\n            return new DeflaterOutputStream(out, new Deflater(9, true));\n        }\n    }\n\n    static class BZIP2Decoder extends CoderBase {\n        @Override\n        InputStream decode(final InputStream in, final Coder coder, final byte[] password)\n                throws IOException {\n            return new BZip2CompressorInputStream(in);\n", "start": 85, "end": 137, "file": "main/java/org/apache/commons/compress/archivers/sevenz/Coders.java"}, "tokens": {"original": [{"propsByte": {"identifier": "() propsByte", "line": "byte propsByte = coder.properties[0];"}}, {"CopyDecoder": {"identifier": "(CopyDecoder) CopyDecoder", "line": "static class CopyDecoder extends CoderBase {"}}, {"CoderBase": {"identifier": "(CoderBase) CoderBase", "line": "static class CopyDecoder extends CoderBase {"}}, {"LZMADecoder": {"identifier": "(LZMADecoder) LZMADecoder", "line": "static class LZMADecoder extends CoderBase {"}}, {"CoderId": {"identifier": "(CoderId) CoderId", "line": "static CoderId[] coderTable = new CoderId[] {"}}, {"BZIP2Decoder": {"identifier": "(BZIP2Decoder) BZIP2Decoder", "line": "static class BZIP2Decoder extends CoderBase {"}}, {"DeflateDecoder": {"identifier": "(DeflateDecoder) DeflateDecoder", "line": "static class DeflateDecoder extends CoderBase {"}}, {"getId": {"identifier": "(SevenZMethod) getId()", "line": "if (Arrays.equals(coderId.method.getId(), coder.decompressionMethodId)) {"}}, {"SevenZMethod": {"identifier": "(SevenZMethod) SevenZMethod", "line": "new CoderId(SevenZMethod.COPY, new CopyDecoder()),"}}]}}], "Compress-25": [{"context": {"prefix": "     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n", "suffix": "    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n            return null;\n        }\n\n", "buggy": "     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n            return null;\n        }\n\n", "fix": "     * Extra Fields (if present) to set the file names.\n     */\n    public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    /**\n     * @param encoding the encoding to use for file names, use null\n     * for the platform's default encoding\n     * @param useUnicodeExtraFields whether to use InfoZIP Unicode\n     * Extra Fields (if present) to set the file names.\n     * @param allowStoredEntriesWithDataDescriptor whether the stream\n     * will try to read STORED entries that use a data descriptor\n     * @since 1.1\n     */\n    public ZipArchiveInputStream(InputStream inputStream,\n                                 String encoding,\n                                 boolean useUnicodeExtraFields,\n                                 boolean allowStoredEntriesWithDataDescriptor) {\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        // haven't read anything so far\n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        try {\n            if (firstEntry) {\n                // split archives have a special signature before the\n                // first local file header - look for it and fail with\n                // the appropriate error message if this is a split\n                // archive.\n                readFirstLocalFileHeader(LFH_BUF);\n            } else {\n                readFully(LFH_BUF);\n            }\n        } catch (EOFException e) {\n            return null;\n        }\n\n", "start": 158, "end": 208, "file": "main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java"}, "tokens": {}}], "Compress-38": [{"context": {"prefix": "     *\n     * @since 1.1\n     *\n     */\n    public boolean isPaxHeader(){\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     */\n    public boolean isGlobalPaxHeader(){\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n", "suffix": "            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this is a \"normal file\"\n     *\n     * @since 1.2\n     * @return whether this is a \"normal file\"\n     */\n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    /**\n     * Check if this is a symbolic link entry.\n     *\n     * @since 1.2\n     * @return whether this is a symbolic link\n     */\n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    /**\n     * Check if this is a link entry.\n     *\n", "buggy": "     *\n     * @since 1.1\n     *\n     */\n    public boolean isPaxHeader(){\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     */\n    public boolean isGlobalPaxHeader(){\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this is a \"normal file\"\n     *\n     * @since 1.2\n     * @return whether this is a \"normal file\"\n     */\n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    /**\n     * Check if this is a symbolic link entry.\n     *\n     * @since 1.2\n     * @return whether this is a symbolic link\n     */\n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    /**\n     * Check if this is a link entry.\n     *\n", "fix": "     *\n     * @since 1.1\n     *\n     */\n    public boolean isPaxHeader(){\n        return linkFlag == LF_PAX_EXTENDED_HEADER_LC\n            || linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n    }\n\n    /**\n     * Check if this is a Pax header.\n     *\n     * @return {@code true} if this is a Pax header.\n     *\n     * @since 1.1\n     */\n    public boolean isGlobalPaxHeader(){\n        return linkFlag == LF_PAX_GLOBAL_EXTENDED_HEADER;\n    }\n\n    /**\n     * Return whether or not this entry represents a directory.\n     *\n     * @return True if this entry is a directory.\n     */\n    @Override\n    public boolean isDirectory() {\n        if (file != null) {\n            return file.isDirectory();\n        }\n\n        if (linkFlag == LF_DIR) {\n            return true;\n        }\n\n        if (!isPaxHeader() && !isGlobalPaxHeader() && getName().endsWith(\"/\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if this is a \"normal file\"\n     *\n     * @since 1.2\n     * @return whether this is a \"normal file\"\n     */\n    public boolean isFile() {\n        if (file != null) {\n            return file.isFile();\n        }\n        if (linkFlag == LF_OLDNORM || linkFlag == LF_NORMAL) {\n            return true;\n        }\n        return !getName().endsWith(\"/\");\n    }\n\n    /**\n     * Check if this is a symbolic link entry.\n     *\n     * @since 1.2\n     * @return whether this is a symbolic link\n     */\n    public boolean isSymbolicLink() {\n        return linkFlag == LF_SYMLINK;\n    }\n\n    /**\n     * Check if this is a link entry.\n     *\n", "start": 823, "end": 893, "file": "main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java"}, "tokens": {"original": [{"isDirectory": {"identifier": "(TarArchiveEntry) isDirectory()", "line": "if (isDirectory() && !name.endsWith(\"/\")){"}}, {"hashCode": {"identifier": "(String) hashCode()", "line": "return getName().hashCode();"}}, {"MAX_NAMELEN": {"identifier": "(int) MAX_NAMELEN", "line": "if (user.length() > MAX_NAMELEN) {"}}, {"getLinkName": {"identifier": "(TarArchiveEntry) getLinkName()", "line": "public String getLinkName() {"}}, {"getUserName": {"identifier": "(TarArchiveEntry) getUserName()", "line": "public String getUserName() {"}}, {"getGroupName": {"identifier": "(TarArchiveEntry) getGroupName()", "line": "public String getGroupName() {"}}, {"getUserId": {"identifier": "(TarArchiveEntry) getUserId()", "line": "public int getUserId() {"}}, {"setName": {"identifier": "(TarArchiveEntry) setName()", "line": "public void setName(final String name) {"}}, {"isFile": {"identifier": "(TarArchiveEntry) isFile()", "line": "public boolean isFile() {"}}, {"isLink": {"identifier": "(TarArchiveEntry) isLink()", "line": "public boolean isLink() {"}}, {"getModTime": {"identifier": "(TarArchiveEntry) getModTime()", "line": "public Date getModTime() {"}}, {"getDevMinor": {"identifier": "(TarArchiveEntry) getDevMinor()", "line": "public int getDevMinor() {"}}, {"getRealSize": {"identifier": "(TarArchiveEntry) getRealSize()", "line": "public long getRealSize() {"}}, {"getMode": {"identifier": "(TarArchiveEntry) getMode()", "line": "public int getMode() {"}}, {"setLinkName": {"identifier": "(TarArchiveEntry) setLinkName()", "line": "public void setLinkName(final String link) {"}}, {"getFile": {"identifier": "(TarArchiveEntry) getFile()", "line": "public File getFile() {"}}, {"getSize": {"identifier": "(TarArchiveEntry) getSize()", "line": "public long getSize() {"}}, {"getLongUserId": {"identifier": "(TarArchiveEntry) getLongUserId()", "line": "public long getLongUserId() {"}}, {"isExtended": {"identifier": "(TarArchiveEntry) isExtended", "line": "public boolean isExtended() {"}}, {"getLongGroupId": {"identifier": "(TarArchiveEntry) getLongGroupId()", "line": "public long getLongGroupId() {"}}, {"getGroupId": {"identifier": "(TarArchiveEntry) getGroupId()", "line": "public int getGroupId() {"}}, {"isFIFO": {"identifier": "(TarArchiveEntry) isFIFO()", "line": "public boolean isFIFO() {"}}, {"isCheckSumOK": {"identifier": "(TarArchiveEntry) isCheckSumOK()", "line": "public boolean isCheckSumOK() {"}}, {"isStarSparse": {"identifier": "(TarArchiveEntry) isStarSparse()", "line": "public boolean isStarSparse() {"}}, {"userName": {"identifier": "(TarArchiveEntry) userName", "line": "public void setUserName(final String userName) {"}}, {"setUserName": {"identifier": "(TarArchiveEntry) setUserName()", "line": "public void setUserName(final String userName) {"}}, {"setMode": {"identifier": "(TarArchiveEntry) setMode()", "line": "public void setMode(final int mode) {"}}, {"getDevMajor": {"identifier": "(TarArchiveEntry) getDevMajor()", "line": "public int getDevMajor() {"}}, {"realSize": {"identifier": "(long) realSize", "line": "realSize = Integer.parseInt(headers.get(\"GNU.sparse.size\"));"}}, {"isBlockDevice": {"identifier": "(TarArchiveEntry) isBlockDevice()", "line": "public boolean isBlockDevice() {"}}, {"setSize": {"identifier": "(TarArchiveEntry) setSize()", "line": "public void setSize(final long size) {"}}, {"TarArchiveEntry": {"identifier": "(TarArchiveEntry) TarArchiveEntry", "line": "private TarArchiveEntry() {"}}, {"isSparse": {"identifier": "(TarArchiveEntry) isSparse()", "line": "public boolean isSparse() {"}}, {"setGroupName": {"identifier": "(TarArchiveEntry) setGroupName()", "line": "public void setGroupName(final String groupName) {"}}, {"groupName": {"identifier": "(TarArchiveEntry) groupName", "line": "public void setGroupName(final String groupName) {"}}, {"isOldGNUSparse": {"identifier": "(TarArchiveEntry) isOldGNUSparse()", "line": "public boolean isOldGNUSparse() {"}}, {"isSymbolicLink": {"identifier": "(TarArchiveEntry) isSymbolicLink()", "line": "public boolean isSymbolicLink() {"}}, {"userId": {"identifier": "(TarArchiveEntry) userId", "line": "public void setUserId(final int userId) {"}}, {"setUserId": {"identifier": "(TarArchiveEntry) setUserId()", "line": "public void setUserId(final int userId) {"}}, {"setModTime": {"identifier": "(TarArchiveEntry) setModTime()", "line": "public void setModTime(final long time) {"}}, {"setDevMajor": {"identifier": "(TarArchiveEntry) setDevMajor()", "line": "public void setDevMajor(final int devNo) {"}}, {"setDevMinor": {"identifier": "(TarArchiveEntry) setDevMinor()", "line": "public void setDevMinor(final int devNo) {"}}, {"isGNUSparse": {"identifier": "(TarArchiveEntry) isGNUSparse()", "line": "public boolean isGNUSparse() {"}}, {"setNames": {"identifier": "(TarArchiveEntry) setNames()", "line": "public void setNames(final String userName, final String groupName) {"}}, {"isPaxGNUSparse": {"identifier": "(TarArchiveEntry) isPaxGNUSparse()", "line": "public boolean isPaxGNUSparse() {"}}, {"parseName": {"identifier": "(TarUtils) parseName()", "line": "magic = TarUtils.parseName(header, offset, MAGICLEN);"}}, {"TarUtils": {"identifier": "(TarUtils) TarUtils", "line": "magic = TarUtils.parseName(header, offset, MAGICLEN);"}}, {"evaluateType": {"identifier": "(TarArchiveEntry) evaluateType()", "line": "private int evaluateType(final byte[] header) {"}}, {"linkName": {"identifier": "(TarArchiveEntry) linkName", "line": "private String linkName = \"\";"}}, {"isPaxHeader": {"identifier": "(TarArchiveEntry) isPaxHeader()", "line": "public boolean isPaxHeader(){"}}, {"parseTarHeader": {"identifier": "(TarArchiveEntry) parseTarHeader()", "line": "public void parseTarHeader(final byte[] header) {"}}, {"modTime": {"identifier": "(long) modTime", "line": "this.modTime = new Date().getTime() / MILLIS_PER_SECOND;"}}, {"setGroupId": {"identifier": "(TarArchiveEntry) setGroupId()", "line": "public void setGroupId(final int groupId) {"}}, {"groupId": {"identifier": "(TarArchiveEntry) groupId", "line": "public void setGroupId(final int groupId) {"}}, {"isDescendent": {"identifier": "(TarArchiveEntry) isDescendent()", "line": "public boolean isDescendent(final TarArchiveEntry desc) {"}}, {"linkFlag": {"identifier": "(byte) linkFlag", "line": "if (linkFlag == LF_DIR) {"}}, {"setIds": {"identifier": "(TarArchiveEntry) setIds()", "line": "public void setIds(final int userId, final int groupId) {"}}, {"ArchiveUtils": {"identifier": "(ArchiveUtils) ArchiveUtils", "line": "if (ArchiveUtils.matchAsciiBuffer(MAGIC_GNU, header, MAGIC_OFFSET, MAGICLEN)) {"}}, {"parseBoolean": {"identifier": "(TarUtils) parseBoolean()", "line": "isExtended = TarUtils.parseBoolean(header, offset);"}}, {"formatNameBytes": {"identifier": "(TarUtils) formatNameBytes()", "line": "offset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);"}}, {"devMinor": {"identifier": "(int) devMinor", "line": "offset = writeEntryHeaderField(devMinor, outbuf, offset, DEVLEN,"}}, {"starSparse": {"identifier": "(TarArchiveEntry) starSparse", "line": "private boolean starSparse;"}}, {"ZipEncoding": {"identifier": "(ZipEncoding) ZipEncoding", "line": "import org.apache.commons.compress.archivers.zip.ZipEncoding;"}}, {"devMajor": {"identifier": "(int) devMajor", "line": "offset = writeEntryHeaderField(devMajor, outbuf, offset, DEVLEN,"}}, {"parseOctal": {"identifier": "(TarUtils) parseOctal()", "line": "realSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);"}}, {"computeCheckSum": {"identifier": "(TarUtils) computeCheckSum()", "line": "final long chk = TarUtils.computeCheckSum(outbuf);"}}, {"checkSumOK": {"identifier": "(boolean) checkSumOK", "line": "checkSumOK = TarUtils.verifyCheckSum(header);"}}, {"verifyCheckSum": {"identifier": "(TarUtils) verifyCheckSum()", "line": "checkSumOK = TarUtils.verifyCheckSum(header);"}}, {"paxGNUSparse": {"identifier": "(TarArchiveEntry) paxGNUSparse", "line": "private boolean paxGNUSparse;"}}]}}], "Csv-1": [{"context": {"prefix": " * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n", "suffix": "            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n", "buggy": " * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\n') {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n", "fix": " * A special reader decorator which supports more\n * sophisticated access to the underlying reader object.\n *\n * In particular the reader supports a look-ahead option,\n * which allows you to see the next char returned by\n * next().\n */\nclass ExtendedBufferedReader extends BufferedReader {\n\n    /** The end of stream symbol */\n    static final int END_OF_STREAM = -1;\n\n    /** Undefined state for the lookahead char */\n    static final int UNDEFINED = -2;\n\n    /** The last char returned */\n    private int lastChar = UNDEFINED;\n\n    /** The line counter */\n    private int lineCounter = 0;\n\n    /**\n     * Created extended buffered reader using default buffer-size\n     */\n    ExtendedBufferedReader(Reader r) {\n        super(r);\n    }\n\n    @Override\n    public int read() throws IOException {\n        int current = super.read();\n        if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {\n            lineCounter++;\n        }\n        lastChar = current;\n        return lastChar;\n    }\n\n    /**\n     * Returns the last character that was read as an integer (0 to 65535). This\n     * will be the last character returned by any of the read methods. This will\n     * not include a character read using the {@link #peek()} method. If no\n     * character has been read then this will return {@link #UNDEFINED}. If the\n     * end of the stream was reached on the last read then this will return\n     * {@link #END_OF_STREAM}.\n     * \n     * @return the last character that was read\n     */\n    int readAgain() {\n        return lastChar;\n    }\n\n    @Override\n    public int read(char[] buf, int offset, int length) throws IOException {\n        if (length == 0) {\n            return 0;\n        }\n        \n        int len = super.read(buf, offset, length);\n        \n        if (len > 0) {\n\n            for (int i = offset; i < offset + len; i++) {\n", "start": 26, "end": 88, "file": "main/java/org/apache/commons/csv/ExtendedBufferedReader.java"}, "tokens": {"original": [{"readAgain": {"identifier": "(ExtendedBufferedReader) readAgain()", "line": "int readAgain() {"}}, {"lastChar": {"identifier": "(int) lastChar", "line": "lastChar = current;"}}, {"getLineNumber": {"identifier": "(ExtendedBufferedReader) getLineNumber()", "line": "int getLineNumber() {"}}, {"readLine": {"identifier": "(ExtendedBufferedReader) readLine()", "line": "public String readLine() throws IOException {"}}, {"lineCounter": {"identifier": "(ExtendedBufferedReader) lineCounter", "line": "private int lineCounter = 0;"}}, {"lookAhead": {"identifier": "(ExtendedBufferedReader) lookAhead()", "line": "int lookAhead() throws IOException {"}}]}}], "Csv-4": [{"context": {"prefix": "     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n", "suffix": "    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n", "buggy": "     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n", "fix": "     *             If an I/O error occurs\n     */\n    public void close() throws IOException {\n        if (this.lexer != null) {\n            this.lexer.close();\n        }\n    }\n\n    /**\n     * Returns the current line number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the record number.\n     *\n     * @return current line number\n     */\n    public long getCurrentLineNumber() {\n        return this.lexer.getCurrentLineNumber();\n    }\n\n    /**\n     * Returns a copy of the header map that iterates in column order.\n     * <p>\n     * The map keys are column names. The map values are 0-based indices.\n     * </p>\n     * @return a copy of the header map that iterates in column order.\n     */\n    public Map<String, Integer> getHeaderMap() {\n        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n    }\n\n    /**\n     * Returns the current record number in the input stream.\n     * <p/>\n     * ATTENTION: If your CSV input has multi-line values, the returned number does not correspond to the line number.\n     *\n     * @return current line number\n     */\n    public long getRecordNumber() {\n        return this.recordNumber;\n    }\n\n    /**\n     * Parses the CSV input according to the given format and returns the content as a list of\n     * {@link CSVRecord CSVRecords}.\n     * <p/>\n     * The returned content starts at the current parse-position in the stream.\n     *\n     * @return list of {@link CSVRecord CSVRecords}, may be empty\n     * @throws IOException\n     *             on parse error or input read-failure\n     */\n    public List<CSVRecord> getRecords() throws IOException {\n        final List<CSVRecord> records = new ArrayList<CSVRecord>();\n        CSVRecord rec;\n        while ((rec = this.nextRecord()) != null) {\n", "start": 260, "end": 314, "file": "main/java/org/apache/commons/csv/CSVParser.java"}, "tokens": {"original": [{"getHeaderMap": {"identifier": "(CSVParser) getHeaderMap()", "line": "public Map<String, Integer> getHeaderMap() {"}}, {"CSVParser": {"identifier": "(CSVParser) CSVParser", "line": "return new CSVParser(new StringReader(string), format);"}}, {"getHeader": {"identifier": "(CSVFormat) getHeader()", "line": "final String[] formatHeader = this.format.getHeader();"}}, {"CSVRecord": {"identifier": "(CSVRecord) CSVRecord", "line": "result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,"}}, {"nextRecord": {"identifier": "(CSVParser) nextRecord()", "line": "return CSVParser.this.nextRecord();"}}, {"isClosed": {"identifier": "(Lexer) isClosed()", "line": "return this.lexer.isClosed();"}}, {"getNullString": {"identifier": "(CSVFormat) getNullString()", "line": "final String nullString = this.format.getNullString();"}}, {"recordNumber": {"identifier": "(long) recordNumber", "line": "return this.recordNumber;"}}, {"reusableToken": {"identifier": "(Token) reusableToken", "line": "final String input = this.reusableToken.content.toString();"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "final String input = this.reusableToken.content.toString();"}}, {"nextToken": {"identifier": "(Lexer) nextToken()", "line": "this.lexer.nextToken(this.reusableToken);"}}, {"notNull": {"identifier": "(Assertions) notNull()", "line": "Assertions.notNull(string, \"string\");"}}, {"CSVFormat": {"identifier": "(CSVFormat) CSVFormat", "line": "* CSVParser parser = new CSVParser(in, CSVFormat.EXCEL);"}}, {"getRecords": {"identifier": "(CSVParser) getRecords()", "line": "public List<CSVRecord> getRecords() throws IOException {"}}, {"addRecordValue": {"identifier": "(CSVParser) addRecordValue()", "line": "this.addRecordValue();"}}, {"getRecordNumber": {"identifier": "(CSVParser) getRecordNumber()", "line": "public long getRecordNumber() {"}}, {"isReady": {"identifier": "(boolean) isReady", "line": "if (this.reusableToken.isReady) {"}}]}}], "Csv-11": [{"context": {"prefix": "     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n", "suffix": "                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n", "buggy": "     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n", "fix": "     */\n    private Map<String, Integer> initializeHeader() throws IOException {\n        Map<String, Integer> hdrMap = null;\n        final String[] formatHeader = this.format.getHeader();\n        if (formatHeader != null) {\n            hdrMap = new LinkedHashMap<String, Integer>();\n\n            String[] headerRecord = null;\n            if (formatHeader.length == 0) {\n                // read the header from the first line of the file\n                final CSVRecord nextRecord = this.nextRecord();\n                if (nextRecord != null) {\n                    headerRecord = nextRecord.values();\n                }\n            } else {\n                if (this.format.getSkipHeaderRecord()) {\n                    this.nextRecord();\n                }\n                headerRecord = formatHeader;\n            }\n\n            // build the name to index mappings\n            if (headerRecord != null) {\n                for (int i = 0; i < headerRecord.length; i++) {\n                    final String header = headerRecord[i];\n                    final boolean containsHeader = hdrMap.containsKey(header);\n                    final boolean emptyHeader = header == null || header.trim().isEmpty();\n                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                \"\\\" in \" + Arrays.toString(headerRecord));\n                    }\n                    hdrMap.put(header, Integer.valueOf(i));\n                }\n            }\n        }\n        return hdrMap;\n    }\n\n    public boolean isClosed() {\n        return this.lexer.isClosed();\n    }\n\n    /**\n     * Returns an iterator on the records.\n     *\n     * <p>IOExceptions occurring during the iteration are wrapped in a\n     * RuntimeException.\n     * If the parser is closed a call to {@code next()} will throw a\n     * NoSuchElementException.</p>\n     */\n    public Iterator<CSVRecord> iterator() {\n        return new Iterator<CSVRecord>() {\n            private CSVRecord current;\n", "start": 357, "end": 409, "file": "main/java/org/apache/commons/csv/CSVParser.java"}, "tokens": {"original": [{"hdrMap": {"identifier": "(Map) hdrMap", "line": "final boolean containsHeader = hdrMap.containsKey(header);"}}, {"containsHeader": {"identifier": "() containsHeader", "line": "final boolean containsHeader = hdrMap.containsKey(header);"}}, {"headerRecord": {"identifier": "(String) headerRecord", "line": "final String header = headerRecord[i];"}}, {"getHeader": {"identifier": "(CSVFormat) getHeader()", "line": "final String[] formatHeader = this.format.getHeader();"}}, {"formatHeader": {"identifier": "() formatHeader", "line": "final String[] formatHeader = this.format.getHeader();"}}, {"headerMap": {"identifier": "(CSVParser) headerMap", "line": "private final Map<String, Integer> headerMap;"}}, {"CSVRecord": {"identifier": "(CSVRecord) CSVRecord", "line": "final CSVRecord nextRecord = this.nextRecord();"}}, {"nextRecord": {"identifier": "(CSVParser) nextRecord()", "line": "final CSVRecord nextRecord = this.nextRecord();"}}, {"reusableToken": {"identifier": "(Token) reusableToken", "line": "final String input = this.reusableToken.content.toString();"}}, {"toString": {"identifier": "(StringBuilder) toString()", "line": "final String input = this.reusableToken.content.toString();"}}, {"getNullString": {"identifier": "(CSVFormat) getNullString()", "line": "final String nullString = this.format.getNullString();"}}, {"CSVParser": {"identifier": "(CSVParser) CSVParser", "line": "return new CSVParser(new InputStreamReader(url.openStream(), charset), format);"}}, {"notNull": {"identifier": "(Assertions) notNull()", "line": "Assertions.notNull(reader, \"reader\");"}}, {"getHeaderMap": {"identifier": "(CSVParser) getHeaderMap()", "line": "public Map<String, Integer> getHeaderMap() {"}}, {"CSVFormat": {"identifier": "(CSVFormat) CSVFormat", "line": "public CSVParser(final Reader reader, final CSVFormat format) throws IOException {"}}, {"isClosed": {"identifier": "(CSVParser) isClosed()", "line": "public boolean isClosed() {"}}, {"getRecords": {"identifier": "(CSVParser) getRecords()", "line": "* List&lt;CSVRecord&gt; list = parser.getRecords();"}}, {"getRecordNumber": {"identifier": "(CSVParser) getRecordNumber()", "line": "public long getRecordNumber() {"}}, {"addRecordValue": {"identifier": "(CSVParser) addRecordValue()", "line": "private void addRecordValue() {"}}, {"recordNumber": {"identifier": "(CSVParser) recordNumber", "line": "private long recordNumber;"}}, {"isReady": {"identifier": "(boolean) isReady", "line": "if (this.reusableToken.isReady) {"}}, {"nextToken": {"identifier": "(Lexer) nextToken()", "line": "this.lexer.nextToken(this.reusableToken);"}}]}}], "Csv-14": [{"context": {"prefix": "        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n", "suffix": "                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n", "buggy": "        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n", "fix": "        }\n        switch (quoteModePolicy) {\n        case ALL:\n            quote = true;\n            break;\n        case NON_NUMERIC:\n            quote = !(object instanceof Number);\n            break;\n        case NONE:\n            // Use the existing escaping code\n            printAndEscape(value, offset, len, out);\n            return;\n        case MINIMAL:\n            if (len <= 0) {\n                // always quote an empty token that is the first\n                // on the line, as it may be the only thing on the\n                // line. If it were not quoted in that case,\n                // an empty line has no tokens.\n                if (newRecord) {\n                    quote = true;\n                }\n            } else {\n                char c = value.charAt(pos);\n\n                // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n                    // Some other chars at the start of a value caused the parser to fail, so for now\n                    // encapsulate if we start in anything less than '#'. We are being conservative\n                    // by including the default comment char too.\n                    quote = true;\n                } else {\n                    while (pos < end) {\n                        c = value.charAt(pos);\n                        if (c == LF || c == CR || c == quoteChar || c == delimChar) {\n                            quote = true;\n                            break;\n                        }\n                        pos++;\n                    }\n\n                    if (!quote) {\n                        pos = end - 1;\n                        c = value.charAt(pos);\n                        // Some other chars at the end caused the parser to fail, so for now\n                        // encapsulate if we end in anything less than ' '\n                        if (c <= SP) {\n                            quote = true;\n                        }\n                    }\n", "start": 1013, "end": 1063, "file": "main/java/org/apache/commons/csv/CSVFormat.java"}, "tokens": {"original": [{"quoteChar": {"identifier": "(char) quoteChar", "line": "if (c == LF || c == CR || c == quoteChar || c == delimChar) {"}}, {"delimChar": {"identifier": "(char) delimChar", "line": "if (c == LF || c == CR || c == quoteChar || c == delimChar) {"}}, {"recordSeparator": {"identifier": "(CSVFormat) recordSeparator", "line": "*             if recordSeparator is none of CR, LF or CRLF"}}, {"escapeCharacter": {"identifier": "(Character) escapeCharacter", "line": "\"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");"}}, {"commentMarker": {"identifier": "(Character) commentMarker", "line": "\"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");"}}, {"headerComments": {"identifier": "(CSVFormat) headerComments", "line": "*            the headerComments which will be printed by the Printer before the actual CSV data."}}, {"quoteCharacter": {"identifier": "(Character) quoteCharacter", "line": "\"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");"}}, {"toString": {"identifier": "(Arrays) toString()", "line": "\"The header contains a duplicate entry: '\" + hdr + \"' in \" + Arrays.toString(header));"}}, {"CSVFormat": {"identifier": "(CSVFormat) CSVFormat", "line": "* @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker"}}, {"printRecord": {"identifier": "(CSVFormat) printRecord()", "line": "public void printRecord(final Appendable out, final Object... values) throws IOException {"}}, {"quoteMode": {"identifier": "(QuoteMode) quoteMode", "line": "if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {"}}, {"QuoteMode": {"identifier": "(QuoteMode) QuoteMode", "line": "if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {"}}, {"isLineBreak": {"identifier": "(CSVFormat) isLineBreak()", "line": "if (isLineBreak(escape)) {"}}, {"hashCode": {"identifier": "(Character) hashCode()", "line": "result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());"}}, {"quoteModePolicy": {"identifier": "(QuoteMode) quoteModePolicy", "line": "if (quoteModePolicy == null) {"}}, {"CSVPrinter": {"identifier": "(CSVPrinter) CSVPrinter", "line": "public CSVPrinter print(final File out, Charset charset) throws IOException {"}}, {"nullString": {"identifier": "(CSVFormat) nullString", "line": "* <li><strong>Reading:</strong> Converts strings equal to the given {@code nullString} to {@code null} when reading"}}, {"printAndQuote": {"identifier": "(CSVFormat) printAndQuote()", "line": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,"}}, {"withHeader": {"identifier": "(CSVFormat) withHeader()", "line": "public CSVFormat withHeader(final Class<? extends Enum<?>> headerEnum) {"}}, {"newFormat": {"identifier": "(CSVFormat) newFormat()", "line": "public static CSVFormat newFormat(final char delimiter) {"}}, {"withEscape": {"identifier": "(CSVFormat) withEscape()", "line": "public CSVFormat withEscape(final char escape) {"}}, {"printAndEscape": {"identifier": "(CSVFormat) printAndEscape()", "line": "private void printAndEscape(final CharSequence value, final int offset, final int len, final Appendable out)"}}, {"getTrim": {"identifier": "(CSVFormat) getTrim()", "line": "charSequence = getTrim() ? trim(charSequence) : charSequence;"}}, {"isNullStringSet": {"identifier": "(CSVFormat) isNullStringSet()", "line": "if (isNullStringSet()) {"}}, {"withQuote": {"identifier": "(CSVFormat) withQuote()", "line": "public CSVFormat withQuote(final char quoteChar) {"}}, {"valueOf": {"identifier": "(CSVFormat) valueOf()", "line": "public static CSVFormat valueOf(final String format) {"}}, {"withDelimiter": {"identifier": "(CSVFormat) withDelimiter()", "line": "public CSVFormat withDelimiter(final char delimiter) {"}}, {"withQuoteMode": {"identifier": "(CSVFormat) withQuoteMode()", "line": "public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {"}}, {"toStringArray": {"identifier": "(CSVFormat) toStringArray()", "line": "private String[] toStringArray(final Object[] values) {"}}, {"withTrim": {"identifier": "(CSVFormat) withTrim()", "line": "public CSVFormat withTrim(final boolean trim) {"}}, {"getHeader": {"identifier": "(CSVFormat) getHeader()", "line": "public String[] getHeader() {"}}, {"withNullString": {"identifier": "(CSVFormat) withNullString()", "line": ".withQuote(null).withRecordSeparator(LF).withNullString(\"\\\\N\");"}}, {"getQuoteMode": {"identifier": "(CSVFormat) getQuoteMode()", "line": "public QuoteMode getQuoteMode() {"}}, {"getDelimiter": {"identifier": "(CSVFormat) getDelimiter()", "line": "public char getDelimiter() {"}}, {"getNullString": {"identifier": "(CSVFormat) getNullString()", "line": "public String getNullString() {"}}, {"INFORMIX_UNLOAD": {"identifier": "(CSVFormat) INFORMIX_UNLOAD", "line": "public static final CSVFormat INFORMIX_UNLOAD = DEFAULT.withDelimiter(PIPE).withEscape(BACKSLASH)"}}, {"NON_NUMERIC": {"identifier": "(QuoteMode) NON_NUMERIC", "line": "case NON_NUMERIC:"}}]}}], "Gson-5": [{"context": {"prefix": "                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n", "suffix": "\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n", "buggy": "                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n", "fix": "                        }\n                    }\n                }\n            }\n\n            // extract timezone\n            if (date.length() <= offset) {\n                throw new IllegalArgumentException(\"No time zone indicator\");\n            }\n\n            TimeZone timezone = null;\n            char timezoneIndicator = date.charAt(offset);\n\n            if (timezoneIndicator == 'Z') {\n                timezone = TIMEZONE_UTC;\n                offset += 1;\n            } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                String timezoneOffset = date.substring(offset);\n\n                // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n                timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";\n\n                offset += timezoneOffset.length();\n                // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\n                if (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\n                    timezone = TIMEZONE_UTC;\n                } else {\n                    // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n                    //    not sure why, but that's the way it looks. Further, Javadocs for\n                    //    `java.util.TimeZone` specifically instruct use of GMT as base for\n                    //    custom timezones... odd.\n                    String timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\n                    timezone = TimeZone.getTimeZone(timezoneId);\n\n                    String act = timezone.getID();\n                    if (!act.equals(timezoneId)) {\n                        /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n                         *    one without. If so, don't sweat.\n                         *   Yes, very inefficient. Hopefully not hit often.\n                         *   If it becomes a perf problem, add 'loose' comparison instead.\n", "start": 193, "end": 233, "file": "src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java"}, "tokens": {}}], "Gson-11": [{"context": {"prefix": "    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n", "suffix": "        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n", "buggy": "    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n", "fix": "    }\n  };\n\n  public static final TypeAdapter<Number> DOUBLE = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapter<Number> NUMBER = new TypeAdapter<Number>() {\n    @Override\n    public Number read(JsonReader in) throws IOException {\n      JsonToken jsonToken = in.peek();\n      switch (jsonToken) {\n      case NULL:\n        in.nextNull();\n        return null;\n      case NUMBER:\n      case STRING:\n        return new LazilyParsedNumber(in.nextString());\n      default:\n        throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n      }\n    }\n    @Override\n    public void write(JsonWriter out, Number value) throws IOException {\n      out.value(value);\n    }\n  };\n\n  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n\n  public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n    @Override\n    public Character read(JsonReader in) throws IOException {\n      if (in.peek() == JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      String str = in.nextString();\n      if (str.length() != 1) {\n        throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n      }\n      return str.charAt(0);\n    }\n    @Override\n    public void write(JsonWriter out, Character value) throws IOException {\n", "start": 343, "end": 397, "file": "src/main/java/com/google/gson/internal/bind/TypeAdapters.java"}, "tokens": {}}], "Gson-13": [{"context": {"prefix": "          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n", "suffix": "      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n", "buggy": "          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n", "fix": "          }\n          return PEEKED_NONE;\n        }\n        if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n          value = -(c - '0');\n          last = NUMBER_CHAR_DIGIT;\n        } else if (last == NUMBER_CHAR_DIGIT) {\n          if (value == 0) {\n            return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n          }\n          long newValue = value * 10 - (c - '0');\n          fitsInLong &= value > MIN_INCOMPLETE_INTEGER\n              || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n          value = newValue;\n        } else if (last == NUMBER_CHAR_DECIMAL) {\n          last = NUMBER_CHAR_FRACTION_DIGIT;\n        } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n          last = NUMBER_CHAR_EXP_DIGIT;\n        }\n      }\n    }\n\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {\n      peekedLong = negative ? value : -value;\n      pos += i;\n      return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n        || last == NUMBER_CHAR_EXP_DIGIT) {\n      peekedNumberLength = i;\n      return peeked = PEEKED_NUMBER;\n    } else {\n      return PEEKED_NONE;\n    }\n  }\n\n  private boolean isLiteral(char c) throws IOException {\n    switch (c) {\n    case '/':\n    case '\\\\':\n    case ';':\n    case '#':\n    case '=':\n      checkLenient(); // fall-through\n    case '{':\n    case '}':\n    case '[':\n", "start": 707, "end": 753, "file": "src/main/java/com/google/gson/stream/JsonReader.java"}, "tokens": {"original": [{"fillBuffer": {"identifier": "(JsonReader) fillBuffer()", "line": "if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {"}}, {"lineStart": {"identifier": "(int) lineStart", "line": "if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {"}}, {"lineNumber": {"identifier": "(int) lineNumber", "line": "if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {"}}, {"NONEMPTY_ARRAY": {"identifier": "(int) NONEMPTY_ARRAY", "line": "if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {"}}, {"EMPTY_ARRAY": {"identifier": "(int) EMPTY_ARRAY", "line": "if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {"}}, {"JsonScope": {"identifier": "(JsonScope) JsonScope", "line": "if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {"}}, {"NONEMPTY_OBJECT": {"identifier": "(int) NONEMPTY_OBJECT", "line": "} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {"}}, {"EMPTY_OBJECT": {"identifier": "(int) EMPTY_OBJECT", "line": "} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {"}}, {"stackSize": {"identifier": "(int) stackSize", "line": "if (stackSize == stack.length) {"}}, {"PEEKED_UNQUOTED": {"identifier": "(int) PEEKED_UNQUOTED", "line": "} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {"}}, {"isLiteral": {"identifier": "(JsonReader) isLiteral()", "line": "&& isLiteral(buffer[pos + length])) {"}}, {"DANGLING_NAME": {"identifier": "(int) DANGLING_NAME", "line": "} else if (peekStack == JsonScope.DANGLING_NAME) {"}}, {"JsonToken": {"identifier": "(JsonToken) JsonToken", "line": "*       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {"}}, {"nextName": {"identifier": "(JsonReader) nextName()", "line": "*       String name = reader.nextName();"}}, {"peekedString": {"identifier": "(String) peekedString", "line": "long result = Long.parseLong(peekedString);"}}, {"EMPTY_DOCUMENT": {"identifier": "(int) EMPTY_DOCUMENT", "line": "} else if (peekStack == JsonScope.EMPTY_DOCUMENT) {"}}, {"PEEKED_NUMBER": {"identifier": "(int) PEEKED_NUMBER", "line": "if (p == PEEKED_NUMBER) {"}}, {"hasNext": {"identifier": "(JsonReader) hasNext()", "line": "*     while (reader.hasNext()) {"}}, {"JsonTreeReader": {"identifier": "(JsonTreeReader) JsonTreeReader", "line": "if (reader instanceof JsonTreeReader) {"}}, {"peekedLong": {"identifier": "(long) peekedLong", "line": "if (peekedLong != result) { // Make sure no precision was lost casting to 'int'."}}, {"pathNames": {"identifier": "(String) pathNames", "line": "if (pathNames[i] != null) {"}}, {"syntaxError": {"identifier": "(JsonReader) syntaxError()", "line": "private IOException syntaxError(String message) throws IOException {"}}, {"nextQuotedValue": {"identifier": "(JsonReader) nextQuotedValue()", "line": "private String nextQuotedValue(char quote) throws IOException {"}}, {"nextLong": {"identifier": "(JsonReader) nextLong()", "line": "public long nextLong() throws IOException {"}}, {"getPath": {"identifier": "(JsonReader) getPath()", "line": "return \" at line \" + line + \" column \" + column + \" path \" + getPath();"}}, {"PEEKED_TRUE": {"identifier": "(int) PEEKED_TRUE", "line": "if (p == PEEKED_TRUE) {"}}, {"PEEKED_FALSE": {"identifier": "(int) PEEKED_FALSE", "line": "} else if (p == PEEKED_FALSE) {"}}, {"pathIndices": {"identifier": "(JsonReader) pathIndices", "line": "* (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in"}}, {"JsonReader": {"identifier": "(JsonReader) JsonReader", "line": "public class JsonReader implements Closeable {"}}, {"skipQuotedValue": {"identifier": "(JsonReader) skipQuotedValue()", "line": "private void skipQuotedValue(char quote) throws IOException {"}}, {"setLenient": {"identifier": "(JsonReader) setLenient()", "line": "public final void setLenient(boolean lenient) {"}}, {"nextString": {"identifier": "(JsonReader) nextString()", "line": "*         username = reader.nextString();"}}, {"isLenient": {"identifier": "(JsonReader) isLenient()", "line": "public final boolean isLenient() {"}}, {"PEEKED_BUFFERED": {"identifier": "(int) PEEKED_BUFFERED", "line": "} else if (p != PEEKED_BUFFERED) {"}}, {"locationString": {"identifier": "(JsonReader) locationString()", "line": "throw new NumberFormatException(\"Expected an int but was \" + peekedLong + locationString());"}}, {"PEEKED_NONE": {"identifier": "(int) PEEKED_NONE", "line": "if (result != PEEKED_NONE) {"}}, {"skipToEndOfLine": {"identifier": "(JsonReader) skipToEndOfLine()", "line": "private void skipToEndOfLine() throws IOException {"}}, {"nextInt": {"identifier": "(JsonReader) nextInt()", "line": "*         followersCount = reader.nextInt();"}}, {"peekNumber": {"identifier": "(JsonReader) peekNumber()", "line": "private int peekNumber() throws IOException {"}}, {"PEEKED_NULL": {"identifier": "(int) PEEKED_NULL", "line": "if (p == PEEKED_NULL) {"}}, {"PEEKED_LONG": {"identifier": "(int) PEEKED_LONG", "line": "if (p == PEEKED_LONG) {"}}, {"nextDouble": {"identifier": "(JsonReader) nextDouble()", "line": "*       doubles.add(reader.nextDouble());"}}, {"nextBoolean": {"identifier": "(JsonReader) nextBoolean()", "line": "public boolean nextBoolean() throws IOException {"}}, {"toString": {"identifier": "(Long) toString()", "line": "result = Long.toString(peekedLong);"}}, {"skipTo": {"identifier": "(JsonReader) skipTo()", "line": "private boolean skipTo(String toFind) throws IOException {"}}, {"skipValue": {"identifier": "(JsonReader) skipValue()", "line": "public void skipValue() throws IOException {"}}, {"peekKeyword": {"identifier": "(JsonReader) peekKeyword()", "line": "private int peekKeyword() throws IOException {"}}, {"checkLenient": {"identifier": "(JsonReader) checkLenient()", "line": "private void checkLenient() throws IOException {"}}, {"PEEKED_EOF": {"identifier": "(JsonReader) PEEKED_EOF", "line": "private static final int PEEKED_EOF = 17;"}}, {"doPeek": {"identifier": "(JsonReader) doPeek()", "line": "int doPeek() throws IOException {"}}, {"endArray": {"identifier": "(JsonReader) endArray()", "line": "public void endArray() throws IOException {"}}, {"nextNull": {"identifier": "(JsonReader) nextNull()", "line": "public void nextNull() throws IOException {"}}, {"beginObject": {"identifier": "(JsonReader) beginObject()", "line": "*     reader.beginObject();"}}, {"beginArray": {"identifier": "(JsonReader) beginArray()", "line": "public void beginArray() throws IOException {"}}, {"endObject": {"identifier": "(JsonReader) endObject()", "line": "*     reader.endObject();"}}, {"BEGIN_ARRAY": {"identifier": "(JsonToken) BEGIN_ARRAY", "line": "return JsonToken.BEGIN_ARRAY;"}}, {"BEGIN_OBJECT": {"identifier": "(JsonToken) BEGIN_OBJECT", "line": "return JsonToken.BEGIN_OBJECT;"}}, {"END_DOCUMENT": {"identifier": "(JsonToken) END_DOCUMENT", "line": "return JsonToken.END_DOCUMENT;"}}, {"END_ARRAY": {"identifier": "(JsonToken) END_ARRAY", "line": "return JsonToken.END_ARRAY;"}}, {"END_OBJECT": {"identifier": "(JsonToken) END_OBJECT", "line": "return JsonToken.END_OBJECT;"}}]}}], "Gson-15": [{"context": {"prefix": "   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n", "suffix": "      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n", "buggy": "   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (Double.isNaN(value) || Double.isInfinite(value)) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n", "fix": "   */\n  public JsonWriter value(boolean value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(Boolean value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n    writeDeferredName();\n    beforeValue();\n    out.write(value ? \"true\" : \"false\");\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(double value) throws IOException {\n    writeDeferredName();\n    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {\n      throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n    }\n    beforeValue();\n    out.append(Double.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @return this writer.\n   */\n  public JsonWriter value(long value) throws IOException {\n    writeDeferredName();\n    beforeValue();\n    out.write(Long.toString(value));\n    return this;\n  }\n\n  /**\n   * Encodes {@code value}.\n   *\n   * @param value a finite value. May not be {@link Double#isNaN() NaNs} or\n   *     {@link Double#isInfinite() infinities}.\n   * @return this writer.\n   */\n  public JsonWriter value(Number value) throws IOException {\n    if (value == null) {\n      return nullValue();\n    }\n\n    writeDeferredName();\n", "start": 462, "end": 526, "file": "src/main/java/com/google/gson/stream/JsonWriter.java"}, "tokens": {"original": [{"isLenient": {"identifier": "(JsonWriter) isLenient()", "line": "public boolean isLenient() {"}}, {"setLenient": {"identifier": "(JsonWriter) setLenient()", "line": "public final void setLenient(boolean lenient) {"}}, {"JsonWriter": {"identifier": "(JsonWriter) JsonWriter", "line": "public JsonWriter value(double value) throws IOException {"}}, {"isHtmlSafe": {"identifier": "(JsonWriter) isHtmlSafe()", "line": "public final boolean isHtmlSafe() {"}}, {"serializeNulls": {"identifier": "(boolean) serializeNulls", "line": "if (serializeNulls) {"}}, {"stackSize": {"identifier": "(int) stackSize", "line": "if (stackSize == stack.length) {"}}, {"deferredName": {"identifier": "(String) deferredName", "line": "if (deferredName != null) {"}}, {"setIndent": {"identifier": "(JsonWriter) setIndent()", "line": "public final void setIndent(String indent) {"}}, {"setHtmlSafe": {"identifier": "(JsonWriter) setHtmlSafe()", "line": "public final void setHtmlSafe(boolean htmlSafe) {"}}, {"htmlSafe": {"identifier": "(JsonWriter) htmlSafe", "line": "public final void setHtmlSafe(boolean htmlSafe) {"}}, {"jsonValue": {"identifier": "(JsonWriter) jsonValue()", "line": "public JsonWriter jsonValue(String value) throws IOException {"}}, {"beforeValue": {"identifier": "(JsonWriter) beforeValue()", "line": "private void beforeValue() throws IOException {"}}, {"nullValue": {"identifier": "(JsonWriter) nullValue()", "line": "public JsonWriter nullValue() throws IOException {"}}, {"beforeName": {"identifier": "(JsonWriter) beforeName()", "line": "private void beforeName() throws IOException {"}}, {"replaceTop": {"identifier": "(JsonWriter) replaceTop()", "line": "private void replaceTop(int topOfStack) {"}}, {"beginArray": {"identifier": "(JsonWriter) beginArray()", "line": "public JsonWriter beginArray() throws IOException {"}}, {"endArray": {"identifier": "(JsonWriter) endArray()", "line": "public JsonWriter endArray() throws IOException {"}}, {"beginObject": {"identifier": "(JsonWriter) beginObject()", "line": "public JsonWriter beginObject() throws IOException {"}}, {"endObject": {"identifier": "(JsonWriter) endObject()", "line": "public JsonWriter endObject() throws IOException {"}}]}}], "JacksonXml-5": [{"context": {"prefix": "    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n", "suffix": "    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n", "buggy": "    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = src._rootNameLookup;\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n", "fix": "    private static final long serialVersionUID = 1L;\n\n    /**\n     * If all we get to serialize is a null, there's no way to figure out\n     * expected root name; so let's just default to something like \"&lt;null>\"...\n     */\n    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\n    protected final XmlRootNameLookup _rootNameLookup;\n\n    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n    {\n        super();\n        _rootNameLookup = rootNames;\n    }\n\n    public XmlSerializerProvider(XmlSerializerProvider src,\n            SerializationConfig config, SerializerFactory f)\n    {\n        super(src, config, f);\n        _rootNameLookup  = src._rootNameLookup;\n    }\n\n    /**\n     * @since 2.8.9\n     */\n    protected XmlSerializerProvider(XmlSerializerProvider src) {\n        super(src);\n        // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n        //    root name lookup as that may link back to diff version, configuration\n        _rootNameLookup = new XmlRootNameLookup();\n    }\n\n    /*\n    /**********************************************************************\n    /* Overridden methods\n    /**********************************************************************\n     */\n\n    @Override\n    public DefaultSerializerProvider copy() {\n        return new XmlSerializerProvider(this);\n    }\n\n    @Override\n    public DefaultSerializerProvider createInstance(SerializationConfig config,\n            SerializerFactory jsf) {\n        return new XmlSerializerProvider(this, config, jsf);\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n    {\n        if (value == null) {\n            _serializeXmlNull(gen);\n            return;\n        }\n        final Class<?> cls = value.getClass();\n        final boolean asArray;\n        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n", "start": 28, "end": 88, "file": "main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java"}, "tokens": {"original": [{"findRootName": {"identifier": "(XmlRootNameLookup) findRootName()", "line": "rootName = _rootNameLookup.findRootName(cls, _config);"}}, {"_startRootArray": {"identifier": "(XmlSerializerProvider) _startRootArray()", "line": "_startRootArray(xgen, rootName);"}}, {"ToXmlGenerator": {"identifier": "(ToXmlGenerator) ToXmlGenerator", "line": "_initWithRootName((ToXmlGenerator) jgen, rootName);"}}, {"setNextName": {"identifier": "(ToXmlGenerator) setNextName()", "line": "xgen.setNextName(rootName);"}}, {"_asXmlGenerator": {"identifier": "(XmlSerializerProvider) _asXmlGenerator()", "line": "final ToXmlGenerator xgen = _asXmlGenerator(gen);"}}, {"isIndexedType": {"identifier": "(TypeUtil) isIndexedType()", "line": "asArray = TypeUtil.isIndexedType(rootType);"}}, {"TypeUtil": {"identifier": "(TypeUtil) TypeUtil", "line": "asArray = TypeUtil.isIndexedType(rootType);"}}, {"getStaxWriter": {"identifier": "(ToXmlGenerator) getStaxWriter()", "line": "xgen.getStaxWriter().setDefaultNamespace(ns);"}}, {"writeFieldName": {"identifier": "(ToXmlGenerator) writeFieldName()", "line": "xgen.writeFieldName(\"item\");"}}, {"_wrapAsIOE": {"identifier": "(XmlSerializerProvider) _wrapAsIOE()", "line": "throw _wrapAsIOE(gen, e);"}}, {"serializeValue": {"identifier": "(DefaultSerializerProvider) serializeValue()", "line": "super.serializeValue(jgen, null);"}}, {"StaxUtil": {"identifier": "(StaxUtil) StaxUtil", "line": "import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;"}}, {"createInstance": {"identifier": "(XmlSerializerProvider) createInstance()", "line": "public DefaultSerializerProvider createInstance(SerializationConfig config,"}}, {"writeEndObject": {"identifier": "(JsonGenerator) writeEndObject()", "line": "gen.writeEndObject();"}}, {"initGenerator": {"identifier": "(ToXmlGenerator) initGenerator()", "line": "xgen.initGenerator();"}}, {"inRoot": {"identifier": "(ToXmlGenerator) inRoot()", "line": "if (xgen.inRoot()) {"}}]}}], "JxPath-10": [{"context": {"prefix": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n", "suffix": "                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n", "buggy": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n", "fix": " * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.jxpath.ri.compiler;\n\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Iterator;\n\nimport org.apache.commons.jxpath.ri.EvalContext;\nimport org.apache.commons.jxpath.ri.InfoSetUtil;\nimport org.apache.commons.jxpath.ri.axes.InitialContext;\nimport org.apache.commons.jxpath.ri.axes.SelfContext;\n\n/**\n * Base implementation of Expression for the operations \"&gt;\", \"&gt;=\", \"&lt;\", \"&lt;=\".\n * @since JXPath 1.3\n *\n * @author Matt Benson\n * @version $Revision$ $Date$\n */\npublic abstract class CoreOperationRelationalExpression extends CoreOperation {\n\n    protected CoreOperationRelationalExpression(Expression[] args) {\n        super(args);\n    }\n\n    public final Object computeValue(EvalContext context) {\n        return compute(args[0].compute(context), args[1].compute(context))\n                ? Boolean.TRUE : Boolean.FALSE;\n    }\n\n    protected final int getPrecedence() {\n        return 3;\n    }\n\n    protected final boolean isSymmetric() {\n        return false;\n    }\n\n    protected abstract boolean evaluateCompare(int compare);\n\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n", "start": 13, "end": 69, "file": "java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java"}, "tokens": {"original": [{"EvalContext": {"identifier": "(EvalContext) EvalContext", "line": "public final Object computeValue(EvalContext context) {"}}, {"containsMatch": {"identifier": "(CoreOperationRelationalExpression) containsMatch()", "line": "return containsMatch((Iterator) right, left);"}}, {"evaluateCompare": {"identifier": "(CoreOperationRelationalExpression) evaluateCompare()", "line": "protected abstract boolean evaluateCompare(int compare);"}}, {"findMatch": {"identifier": "(CoreOperationRelationalExpression) findMatch()", "line": "return findMatch((Iterator) left, (Iterator) right);"}}, {"getPrecedence": {"identifier": "(CoreOperationRelationalExpression) getPrecedence()", "line": "protected final int getPrecedence() {"}}, {"doubleValue": {"identifier": "(InfoSetUtil) doubleValue()", "line": "double ld = InfoSetUtil.doubleValue(left);"}}, {"InfoSetUtil": {"identifier": "(InfoSetUtil) InfoSetUtil", "line": "double ld = InfoSetUtil.doubleValue(left);"}}, {"CoreOperation": {"identifier": "(CoreOperation) CoreOperation", "line": "public abstract class CoreOperationRelationalExpression extends CoreOperation {"}}, {"isSymmetric": {"identifier": "(CoreOperationRelationalExpression) isSymmetric()", "line": "protected final boolean isSymmetric() {"}}, {"hasNext": {"identifier": "(Iterator) hasNext()", "line": "while (lit.hasNext()) {"}}]}}]}